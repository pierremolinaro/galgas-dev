//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'common_semantics.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     january 18th, 2010, at 18h39'37"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "common_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "common_semantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_AC_semanticsEntity'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_semanticsEntity::
cPtr_AC_semanticsEntity (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_semanticsEntity * GGS_AC_semanticsEntity::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_semanticsEntity *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_AC_semanticsEntity *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_semanticsEntity::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@AC_semanticsEntity:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity::
static_string_message_messageTypeEntite (void) {
  return "any entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity::
message_messageTypeEntite (void) const {
  return "any entity" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity::
instanceMessage (void) const {
  return "any entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity::
_static_message (void) {
  return "any entity" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_semanticsEntity (& typeid (cPtr_AC_semanticsEntity), NULL, "any entity") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_AC_semanticsEntity::galgasRTTI (void) const {
  return & gClassInfoFor__AC_semanticsEntity ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_AC_semanticsEntity'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_AC_semanticsEntity ("AC_semanticsEntity", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_AC_semanticsEntity GGS_AC_semanticsEntity::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_semanticsEntity result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_semanticsEntity *> (inPointer) != NULL)
      : (typeid (cPtr_AC_semanticsEntity) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_AC_semanticsEntity (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_semanticsEntity),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_semanticsEntity::
reader_messageTypeEntite (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_semanticsEntity *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_AC_semanticsEntity * p = (cPtr_AC_semanticsEntity *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_semanticsEntity::actualTypeName (void) const {
  return "AC_semanticsEntity" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_AC_semanticsEntity::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__AC_semanticsEntity ("AC_semanticsEntity", & kTypeDescriptor_GGS_AC_semanticsEntity) ;

//---------------------------------------------------------------------------*

GGS_object GGS_AC_semanticsEntity::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_AC_semanticsEntity * p = NULL ;
    macroMyNew (p, GGS_AC_semanticsEntity (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity GGS_AC_semanticsEntity::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_AC_semanticsEntity result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_AC_semanticsEntity * p = dynamic_cast <const GGS_AC_semanticsEntity *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_AC_semanticsEntity, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_AC_semanticsEntity::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_AC_semanticsEntity ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'e_M_semanticsEntitiesForUse'                     *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_semanticsEntitiesForUse::e_M_semanticsEntitiesForUse (void) :
aDefEntite () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map '@M_semanticsEntitiesForUse'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_semanticsEntitiesForUse ("M_semanticsEntitiesForUse", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_semanticsEntitiesForUse::
elementOf_GGS_M_semanticsEntitiesForUse (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_semanticsEntitiesForUse & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_semanticsEntitiesForUse::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aDefEntite.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_semanticsEntitiesForUse::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_semanticsEntitiesForUse * ptr = dynamic_cast <const elementOf_GGS_M_semanticsEntitiesForUse *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.aDefEntite.operator_isEqual (ptr->mInfo.aDefEntite)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_semanticsEntitiesForUse::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_semanticsEntitiesForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_semanticsEntitiesForUse * info = (e_M_semanticsEntitiesForUse *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_semanticsEntitiesForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_semanticsEntitiesForUse * info = (e_M_semanticsEntitiesForUse *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsEntitiesForUse result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_semanticsEntitiesForUse info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_semanticsEntitiesForUse::
operator_isEqual (const GGS_M_semanticsEntitiesForUse & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_semanticsEntitiesForUse::
operator_isNotEqual (const GGS_M_semanticsEntitiesForUse & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_semanticsEntity & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_semanticsEntitiesForUse info  ;
    info.aDefEntite = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_semanticsEntity   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.aDefEntite ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_semanticsEntitiesForUse::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_semanticsEntity   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_semanticsEntitiesForUse::kInsertMessage_insertKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_semanticsEntity & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_semanticsEntitiesForUse & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsEntitiesForUse result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_semanticsEntitiesForUse result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_semanticsEntitiesForUse::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_semanticsEntitiesForUse " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_semanticsEntity  & GGS_M_semanticsEntitiesForUse::cEnumerator::_aDefEntite (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aDefEntite ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_semanticsEntitiesForUse::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_semanticsEntitiesForUse * p = NULL ;
    macroMyNew (p, GGS_M_semanticsEntitiesForUse (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_semanticsEntitiesForUse result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_semanticsEntitiesForUse * p = dynamic_cast <const GGS_M_semanticsEntitiesForUse *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_semanticsEntitiesForUse, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_semanticsEntitiesForUse::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_semanticsEntitiesForUse ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Class for 'EXactualParametersPassingMode' Enumeration            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EXactualParametersPassingMode ("EXactualParametersPassingMode", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_EXactualParametersPassingMode::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXactualParametersPassingMode::
operator_isEqual (const GGS_EXactualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXactualParametersPassingMode::
operator_isNotEqual (const GGS_EXactualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXactualParametersPassingMode::
operator_infOrEqual (const GGS_EXactualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXactualParametersPassingMode::
operator_supOrEqual (const GGS_EXactualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXactualParametersPassingMode::
operator_strictInf (const GGS_EXactualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXactualParametersPassingMode::
operator_strictSup (const GGS_EXactualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXactualParametersPassingMode::
reader_actualArgumentMessage (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [4] = {"",
    "an input (\?) actual parameter",
    "an output (!) actual parameter",
    "an output/input (!\?) actual parameter"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXactualParametersPassingMode::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @EXactualParametersPassingMode" ;
  switch (mValue) {
  case enum_parameterIn:
    s << " parameterIn>" ;
    break ;
  case enum_parameterOut:
    s << " parameterOut>" ;
    break ;
  case enum_parameterOutIn:
    s << " parameterOutIn>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_EXactualParametersPassingMode::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EXactualParametersPassingMode * p = NULL ;
    macroMyNew (p, GGS_EXactualParametersPassingMode (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXactualParametersPassingMode GGS_EXactualParametersPassingMode::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EXactualParametersPassingMode result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EXactualParametersPassingMode * p = dynamic_cast <const GGS_EXactualParametersPassingMode *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EXactualParametersPassingMode, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EXactualParametersPassingMode::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EXactualParametersPassingMode ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstruction::
cPtr_typeInstruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstruction * GGS_typeInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstruction (& typeid (cPtr_typeInstruction), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInstruction ("typeInstruction", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstruction GGS_typeInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstruction::actualTypeName (void) const {
  return "typeInstruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_typeInstruction::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__typeInstruction ("typeInstruction", & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInstruction * p = NULL ;
    macroMyNew (p, GGS_typeInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction GGS_typeInstruction::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInstruction * p = dynamic_cast <const GGS_typeInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeInstructionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeInstructionList::
elementOf_GGS_typeInstructionList (const GGS_typeInstruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeInstructionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeInstructionList * ptr = dynamic_cast <const elementOf_GGS_typeInstructionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeInstructionList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@typeInstructionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInstructionList ("typeInstructionList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
internalAppendValues (const GGS_typeInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
internalPrependValues (const GGS_typeInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
addAssign_operation (const GGS_typeInstruction & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList GGS_typeInstructionList::
operator_concat (const GGS_typeInstructionList & inOperand) const {
  GGS_typeInstructionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
dotAssign_operation (const GGS_typeInstructionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeInstructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeInstruction  p_0 = p->mInstruction ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeInstruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeInstructionList::
constructor_emptyList (void) {
  GGS_typeInstructionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeInstructionList::
constructor_listWithValue (const GGS_typeInstruction & argument_0) {
  GGS_typeInstructionList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
internalSubListWithRange (GGS_typeInstructionList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList GGS_typeInstructionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList GGS_typeInstructionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeInstructionList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
method_first (C_Compiler & inLexique,
              GGS_typeInstruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
method_last (C_Compiler & inLexique,
             GGS_typeInstruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeInstruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeInstruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstruction  GGS_typeInstructionList::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstruction  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstruction  & GGS_typeInstructionList::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeInstructionList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInstructionList * p = NULL ;
    macroMyNew (p, GGS_typeInstructionList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList GGS_typeInstructionList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInstructionList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInstructionList * p = dynamic_cast <const GGS_typeInstructionList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInstructionList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInstructionList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@typeListModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListModel::
elementOf_GGS_typeListModel (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListModel::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListModel * ptr = dynamic_cast <const elementOf_GGS_typeListModel *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@typeListModel'                            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeListModel ("typeListModel", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeListModel::
internalAppendValues (const GGS_lstring & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
internalPrependValues (const GGS_lstring & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListModel GGS_typeListModel::
operator_concat (const GGS_typeListModel & inOperand) const {
  GGS_typeListModel result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
dotAssign_operation (const GGS_typeListModel inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeListModel * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTypeName ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mTypeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_typeListModel::
constructor_emptyList (void) {
  GGS_typeListModel result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_typeListModel::
constructor_listWithValue (const GGS_lstring & argument_0) {
  GGS_typeListModel result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
internalSubListWithRange (GGS_typeListModel & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mTypeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListModel GGS_typeListModel::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListModel result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel GGS_typeListModel::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListModel result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListModel::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeListModel", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeListModel::
reader_mTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
modifier_setMTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeListModel::cEnumerator::_mTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeListModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeListModel * p = NULL ;
    macroMyNew (p, GGS_typeListModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel GGS_typeListModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeListModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeListModel * p = dynamic_cast <const GGS_typeListModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeListModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeListModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeListModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_TypeModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_TypeModel::
cPtr_TypeModel (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_TypeModel * GGS_TypeModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_TypeModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_TypeModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_TypeModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@TypeModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_TypeModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_TypeModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_TypeModel (& typeid (cPtr_TypeModel), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_TypeModel::galgasRTTI (void) const {
  return & gClassInfoFor__TypeModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_TypeModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_TypeModel ("TypeModel", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_TypeModel GGS_TypeModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_TypeModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_TypeModel *> (inPointer) != NULL)
      : (typeid (cPtr_TypeModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_TypeModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_TypeModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_TypeModel::actualTypeName (void) const {
  return "TypeModel" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_TypeModel::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__TypeModel ("TypeModel", & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_TypeModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_TypeModel * p = NULL ;
    macroMyNew (p, GGS_TypeModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_TypeModel GGS_TypeModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_TypeModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_TypeModel * p = dynamic_cast <const GGS_TypeModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_TypeModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_TypeModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_TypeModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_BoolModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_BoolModel::
cPtr_BoolModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_BoolModel * GGS_BoolModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_BoolModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_BoolModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_BoolModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_BoolModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@BoolModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_BoolModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_BoolModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_BoolModel (& typeid (cPtr_BoolModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_BoolModel::galgasRTTI (void) const {
  return & gClassInfoFor__BoolModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_BoolModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_BoolModel ("BoolModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_BoolModel::
GGS_BoolModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_BoolModel::
GGS_BoolModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_BoolModel GGS_BoolModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_BoolModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_BoolModel *> (inPointer) != NULL)
      : (typeid (cPtr_BoolModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_BoolModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_BoolModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_BoolModel * gSingleton_BoolModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_BoolModel (void) {
  macroDetachPointer (gSingleton_BoolModel, cPtr_BoolModel) ;
}

//---------------------------------------------------------------------------*

GGS_BoolModel GGS_BoolModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_BoolModel result ;
  if (NULL == gSingleton_BoolModel) {
    macroMyNew (gSingleton_BoolModel, cPtr_BoolModel (THERE)) ;
    registerReleaseRoutine (cleanUp_BoolModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_BoolModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_BoolModel::actualTypeName (void) const {
  return "BoolModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__BoolModel ("BoolModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_BoolModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_BoolModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_BoolModel * p = NULL ;
    macroMyNew (p, GGS_BoolModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_BoolModel GGS_BoolModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_BoolModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_BoolModel * p = dynamic_cast <const GGS_BoolModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_BoolModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_BoolModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_BoolModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_CharModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_CharModel::
cPtr_CharModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_CharModel * GGS_CharModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_CharModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_CharModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_CharModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_CharModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@CharModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_CharModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_CharModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_CharModel (& typeid (cPtr_CharModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_CharModel::galgasRTTI (void) const {
  return & gClassInfoFor__CharModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_CharModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_CharModel ("CharModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_CharModel::
GGS_CharModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_CharModel::
GGS_CharModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_CharModel GGS_CharModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_CharModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_CharModel *> (inPointer) != NULL)
      : (typeid (cPtr_CharModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_CharModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_CharModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_CharModel * gSingleton_CharModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_CharModel (void) {
  macroDetachPointer (gSingleton_CharModel, cPtr_CharModel) ;
}

//---------------------------------------------------------------------------*

GGS_CharModel GGS_CharModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_CharModel result ;
  if (NULL == gSingleton_CharModel) {
    macroMyNew (gSingleton_CharModel, cPtr_CharModel (THERE)) ;
    registerReleaseRoutine (cleanUp_CharModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_CharModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_CharModel::actualTypeName (void) const {
  return "CharModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__CharModel ("CharModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_CharModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_CharModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_CharModel * p = NULL ;
    macroMyNew (p, GGS_CharModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_CharModel GGS_CharModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_CharModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_CharModel * p = dynamic_cast <const GGS_CharModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_CharModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_CharModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_CharModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_UIntModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_UIntModel::
cPtr_UIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_UIntModel * GGS_UIntModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_UIntModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_UIntModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_UIntModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_UIntModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@UIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_UIntModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_UIntModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_UIntModel (& typeid (cPtr_UIntModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_UIntModel::galgasRTTI (void) const {
  return & gClassInfoFor__UIntModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_UIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_UIntModel ("UIntModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_UIntModel::
GGS_UIntModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_UIntModel::
GGS_UIntModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_UIntModel GGS_UIntModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_UIntModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_UIntModel *> (inPointer) != NULL)
      : (typeid (cPtr_UIntModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_UIntModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_UIntModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_UIntModel * gSingleton_UIntModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_UIntModel (void) {
  macroDetachPointer (gSingleton_UIntModel, cPtr_UIntModel) ;
}

//---------------------------------------------------------------------------*

GGS_UIntModel GGS_UIntModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_UIntModel result ;
  if (NULL == gSingleton_UIntModel) {
    macroMyNew (gSingleton_UIntModel, cPtr_UIntModel (THERE)) ;
    registerReleaseRoutine (cleanUp_UIntModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_UIntModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_UIntModel::actualTypeName (void) const {
  return "UIntModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__UIntModel ("UIntModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_UIntModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_UIntModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_UIntModel * p = NULL ;
    macroMyNew (p, GGS_UIntModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_UIntModel GGS_UIntModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_UIntModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_UIntModel * p = dynamic_cast <const GGS_UIntModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_UIntModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_UIntModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_UIntModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_SIntModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_SIntModel::
cPtr_SIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_SIntModel * GGS_SIntModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_SIntModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_SIntModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_SIntModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_SIntModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@SIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_SIntModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_SIntModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_SIntModel (& typeid (cPtr_SIntModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_SIntModel::galgasRTTI (void) const {
  return & gClassInfoFor__SIntModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_SIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_SIntModel ("SIntModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_SIntModel::
GGS_SIntModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_SIntModel::
GGS_SIntModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_SIntModel GGS_SIntModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_SIntModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_SIntModel *> (inPointer) != NULL)
      : (typeid (cPtr_SIntModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_SIntModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_SIntModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_SIntModel * gSingleton_SIntModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_SIntModel (void) {
  macroDetachPointer (gSingleton_SIntModel, cPtr_SIntModel) ;
}

//---------------------------------------------------------------------------*

GGS_SIntModel GGS_SIntModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_SIntModel result ;
  if (NULL == gSingleton_SIntModel) {
    macroMyNew (gSingleton_SIntModel, cPtr_SIntModel (THERE)) ;
    registerReleaseRoutine (cleanUp_SIntModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_SIntModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_SIntModel::actualTypeName (void) const {
  return "SIntModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__SIntModel ("SIntModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_SIntModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_SIntModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_SIntModel * p = NULL ;
    macroMyNew (p, GGS_SIntModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_SIntModel GGS_SIntModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_SIntModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_SIntModel * p = dynamic_cast <const GGS_SIntModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_SIntModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_SIntModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_SIntModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_UInt64Model'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_UInt64Model::
cPtr_UInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_UInt64Model * GGS_UInt64Model::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_UInt64Model *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_UInt64Model *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_UInt64Model::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_UInt64Model::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@UInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_UInt64Model::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_UInt64Model::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_UInt64Model (& typeid (cPtr_UInt64Model), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_UInt64Model::galgasRTTI (void) const {
  return & gClassInfoFor__UInt64Model ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_UInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_UInt64Model ("UInt64Model", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_UInt64Model::
GGS_UInt64Model (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_UInt64Model::
GGS_UInt64Model (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_UInt64Model GGS_UInt64Model::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_UInt64Model result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_UInt64Model *> (inPointer) != NULL)
      : (typeid (cPtr_UInt64Model) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_UInt64Model (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_UInt64Model),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_UInt64Model * gSingleton_UInt64Model = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_UInt64Model (void) {
  macroDetachPointer (gSingleton_UInt64Model, cPtr_UInt64Model) ;
}

//---------------------------------------------------------------------------*

GGS_UInt64Model GGS_UInt64Model::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_UInt64Model result ;
  if (NULL == gSingleton_UInt64Model) {
    macroMyNew (gSingleton_UInt64Model, cPtr_UInt64Model (THERE)) ;
    registerReleaseRoutine (cleanUp_UInt64Model) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_UInt64Model) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_UInt64Model::actualTypeName (void) const {
  return "UInt64Model" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__UInt64Model ("UInt64Model", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_UInt64Model) ;

//---------------------------------------------------------------------------*

GGS_object GGS_UInt64Model::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_UInt64Model * p = NULL ;
    macroMyNew (p, GGS_UInt64Model (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_UInt64Model GGS_UInt64Model::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_UInt64Model result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_UInt64Model * p = dynamic_cast <const GGS_UInt64Model *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_UInt64Model, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_UInt64Model::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_UInt64Model ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_SInt64Model'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_SInt64Model::
cPtr_SInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_SInt64Model * GGS_SInt64Model::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_SInt64Model *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_SInt64Model *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_SInt64Model::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_SInt64Model::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@SInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_SInt64Model::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_SInt64Model::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_SInt64Model (& typeid (cPtr_SInt64Model), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_SInt64Model::galgasRTTI (void) const {
  return & gClassInfoFor__SInt64Model ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_SInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_SInt64Model ("SInt64Model", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_SInt64Model::
GGS_SInt64Model (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_SInt64Model::
GGS_SInt64Model (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_SInt64Model GGS_SInt64Model::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_SInt64Model result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_SInt64Model *> (inPointer) != NULL)
      : (typeid (cPtr_SInt64Model) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_SInt64Model (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_SInt64Model),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_SInt64Model * gSingleton_SInt64Model = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_SInt64Model (void) {
  macroDetachPointer (gSingleton_SInt64Model, cPtr_SInt64Model) ;
}

//---------------------------------------------------------------------------*

GGS_SInt64Model GGS_SInt64Model::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_SInt64Model result ;
  if (NULL == gSingleton_SInt64Model) {
    macroMyNew (gSingleton_SInt64Model, cPtr_SInt64Model (THERE)) ;
    registerReleaseRoutine (cleanUp_SInt64Model) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_SInt64Model) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_SInt64Model::actualTypeName (void) const {
  return "SInt64Model" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__SInt64Model ("SInt64Model", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_SInt64Model) ;

//---------------------------------------------------------------------------*

GGS_object GGS_SInt64Model::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_SInt64Model * p = NULL ;
    macroMyNew (p, GGS_SInt64Model (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_SInt64Model GGS_SInt64Model::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_SInt64Model result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_SInt64Model * p = dynamic_cast <const GGS_SInt64Model *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_SInt64Model, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_SInt64Model::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_SInt64Model ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_DoubleModel'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_DoubleModel::
cPtr_DoubleModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_DoubleModel * GGS_DoubleModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_DoubleModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_DoubleModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_DoubleModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_DoubleModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@DoubleModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_DoubleModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_DoubleModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_DoubleModel (& typeid (cPtr_DoubleModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_DoubleModel::galgasRTTI (void) const {
  return & gClassInfoFor__DoubleModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_DoubleModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_DoubleModel ("DoubleModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_DoubleModel::
GGS_DoubleModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_DoubleModel::
GGS_DoubleModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_DoubleModel GGS_DoubleModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_DoubleModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_DoubleModel *> (inPointer) != NULL)
      : (typeid (cPtr_DoubleModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_DoubleModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_DoubleModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_DoubleModel * gSingleton_DoubleModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_DoubleModel (void) {
  macroDetachPointer (gSingleton_DoubleModel, cPtr_DoubleModel) ;
}

//---------------------------------------------------------------------------*

GGS_DoubleModel GGS_DoubleModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_DoubleModel result ;
  if (NULL == gSingleton_DoubleModel) {
    macroMyNew (gSingleton_DoubleModel, cPtr_DoubleModel (THERE)) ;
    registerReleaseRoutine (cleanUp_DoubleModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_DoubleModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_DoubleModel::actualTypeName (void) const {
  return "DoubleModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__DoubleModel ("DoubleModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_DoubleModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_DoubleModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_DoubleModel * p = NULL ;
    macroMyNew (p, GGS_DoubleModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_DoubleModel GGS_DoubleModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_DoubleModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_DoubleModel * p = dynamic_cast <const GGS_DoubleModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_DoubleModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_DoubleModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_DoubleModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_StringModel'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_StringModel::
cPtr_StringModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_StringModel * GGS_StringModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_StringModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_StringModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_StringModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_StringModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@StringModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_StringModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_StringModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_StringModel (& typeid (cPtr_StringModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_StringModel::galgasRTTI (void) const {
  return & gClassInfoFor__StringModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_StringModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_StringModel ("StringModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_StringModel::
GGS_StringModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_StringModel::
GGS_StringModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_StringModel GGS_StringModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_StringModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_StringModel *> (inPointer) != NULL)
      : (typeid (cPtr_StringModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_StringModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_StringModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_StringModel * gSingleton_StringModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_StringModel (void) {
  macroDetachPointer (gSingleton_StringModel, cPtr_StringModel) ;
}

//---------------------------------------------------------------------------*

GGS_StringModel GGS_StringModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_StringModel result ;
  if (NULL == gSingleton_StringModel) {
    macroMyNew (gSingleton_StringModel, cPtr_StringModel (THERE)) ;
    registerReleaseRoutine (cleanUp_StringModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_StringModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_StringModel::actualTypeName (void) const {
  return "StringModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__StringModel ("StringModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_StringModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_StringModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_StringModel * p = NULL ;
    macroMyNew (p, GGS_StringModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_StringModel GGS_StringModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_StringModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_StringModel * p = dynamic_cast <const GGS_StringModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_StringModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_StringModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_StringModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_LBoolModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LBoolModel::
cPtr_LBoolModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LBoolModel * GGS_LBoolModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LBoolModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LBoolModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LBoolModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LBoolModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@LBoolModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LBoolModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LBoolModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LBoolModel (& typeid (cPtr_LBoolModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_LBoolModel::galgasRTTI (void) const {
  return & gClassInfoFor__LBoolModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LBoolModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_LBoolModel ("LBoolModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_LBoolModel::
GGS_LBoolModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LBoolModel::
GGS_LBoolModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_LBoolModel GGS_LBoolModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LBoolModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LBoolModel *> (inPointer) != NULL)
      : (typeid (cPtr_LBoolModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_LBoolModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LBoolModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_LBoolModel * gSingleton_LBoolModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LBoolModel (void) {
  macroDetachPointer (gSingleton_LBoolModel, cPtr_LBoolModel) ;
}

//---------------------------------------------------------------------------*

GGS_LBoolModel GGS_LBoolModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LBoolModel result ;
  if (NULL == gSingleton_LBoolModel) {
    macroMyNew (gSingleton_LBoolModel, cPtr_LBoolModel (THERE)) ;
    registerReleaseRoutine (cleanUp_LBoolModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LBoolModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LBoolModel::actualTypeName (void) const {
  return "LBoolModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__LBoolModel ("LBoolModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_LBoolModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_LBoolModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_LBoolModel * p = NULL ;
    macroMyNew (p, GGS_LBoolModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_LBoolModel GGS_LBoolModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_LBoolModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_LBoolModel * p = dynamic_cast <const GGS_LBoolModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_LBoolModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_LBoolModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_LBoolModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_LCharModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LCharModel::
cPtr_LCharModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LCharModel * GGS_LCharModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LCharModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LCharModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LCharModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LCharModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@LCharModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LCharModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LCharModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LCharModel (& typeid (cPtr_LCharModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_LCharModel::galgasRTTI (void) const {
  return & gClassInfoFor__LCharModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LCharModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_LCharModel ("LCharModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_LCharModel::
GGS_LCharModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LCharModel::
GGS_LCharModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_LCharModel GGS_LCharModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LCharModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LCharModel *> (inPointer) != NULL)
      : (typeid (cPtr_LCharModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_LCharModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LCharModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_LCharModel * gSingleton_LCharModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LCharModel (void) {
  macroDetachPointer (gSingleton_LCharModel, cPtr_LCharModel) ;
}

//---------------------------------------------------------------------------*

GGS_LCharModel GGS_LCharModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LCharModel result ;
  if (NULL == gSingleton_LCharModel) {
    macroMyNew (gSingleton_LCharModel, cPtr_LCharModel (THERE)) ;
    registerReleaseRoutine (cleanUp_LCharModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LCharModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LCharModel::actualTypeName (void) const {
  return "LCharModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__LCharModel ("LCharModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_LCharModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_LCharModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_LCharModel * p = NULL ;
    macroMyNew (p, GGS_LCharModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_LCharModel GGS_LCharModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_LCharModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_LCharModel * p = dynamic_cast <const GGS_LCharModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_LCharModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_LCharModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_LCharModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_LUIntModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LUIntModel::
cPtr_LUIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LUIntModel * GGS_LUIntModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LUIntModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LUIntModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LUIntModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LUIntModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@LUIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LUIntModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LUIntModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LUIntModel (& typeid (cPtr_LUIntModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_LUIntModel::galgasRTTI (void) const {
  return & gClassInfoFor__LUIntModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LUIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_LUIntModel ("LUIntModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_LUIntModel::
GGS_LUIntModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LUIntModel::
GGS_LUIntModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_LUIntModel GGS_LUIntModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LUIntModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LUIntModel *> (inPointer) != NULL)
      : (typeid (cPtr_LUIntModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_LUIntModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LUIntModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_LUIntModel * gSingleton_LUIntModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LUIntModel (void) {
  macroDetachPointer (gSingleton_LUIntModel, cPtr_LUIntModel) ;
}

//---------------------------------------------------------------------------*

GGS_LUIntModel GGS_LUIntModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LUIntModel result ;
  if (NULL == gSingleton_LUIntModel) {
    macroMyNew (gSingleton_LUIntModel, cPtr_LUIntModel (THERE)) ;
    registerReleaseRoutine (cleanUp_LUIntModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LUIntModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LUIntModel::actualTypeName (void) const {
  return "LUIntModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__LUIntModel ("LUIntModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_LUIntModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_LUIntModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_LUIntModel * p = NULL ;
    macroMyNew (p, GGS_LUIntModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_LUIntModel GGS_LUIntModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_LUIntModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_LUIntModel * p = dynamic_cast <const GGS_LUIntModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_LUIntModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_LUIntModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_LUIntModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_LSIntModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LSIntModel::
cPtr_LSIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LSIntModel * GGS_LSIntModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LSIntModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LSIntModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LSIntModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LSIntModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@LSIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LSIntModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LSIntModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LSIntModel (& typeid (cPtr_LSIntModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_LSIntModel::galgasRTTI (void) const {
  return & gClassInfoFor__LSIntModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LSIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_LSIntModel ("LSIntModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_LSIntModel::
GGS_LSIntModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LSIntModel::
GGS_LSIntModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_LSIntModel GGS_LSIntModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LSIntModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LSIntModel *> (inPointer) != NULL)
      : (typeid (cPtr_LSIntModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_LSIntModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LSIntModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_LSIntModel * gSingleton_LSIntModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LSIntModel (void) {
  macroDetachPointer (gSingleton_LSIntModel, cPtr_LSIntModel) ;
}

//---------------------------------------------------------------------------*

GGS_LSIntModel GGS_LSIntModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LSIntModel result ;
  if (NULL == gSingleton_LSIntModel) {
    macroMyNew (gSingleton_LSIntModel, cPtr_LSIntModel (THERE)) ;
    registerReleaseRoutine (cleanUp_LSIntModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LSIntModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LSIntModel::actualTypeName (void) const {
  return "LSIntModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__LSIntModel ("LSIntModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_LSIntModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_LSIntModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_LSIntModel * p = NULL ;
    macroMyNew (p, GGS_LSIntModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_LSIntModel GGS_LSIntModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_LSIntModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_LSIntModel * p = dynamic_cast <const GGS_LSIntModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_LSIntModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_LSIntModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_LSIntModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_LUInt64Model'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LUInt64Model::
cPtr_LUInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LUInt64Model * GGS_LUInt64Model::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LUInt64Model *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LUInt64Model *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LUInt64Model::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LUInt64Model::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@LUInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LUInt64Model::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LUInt64Model::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LUInt64Model (& typeid (cPtr_LUInt64Model), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_LUInt64Model::galgasRTTI (void) const {
  return & gClassInfoFor__LUInt64Model ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LUInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_LUInt64Model ("LUInt64Model", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_LUInt64Model::
GGS_LUInt64Model (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LUInt64Model::
GGS_LUInt64Model (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_LUInt64Model GGS_LUInt64Model::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LUInt64Model result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LUInt64Model *> (inPointer) != NULL)
      : (typeid (cPtr_LUInt64Model) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_LUInt64Model (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LUInt64Model),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_LUInt64Model * gSingleton_LUInt64Model = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LUInt64Model (void) {
  macroDetachPointer (gSingleton_LUInt64Model, cPtr_LUInt64Model) ;
}

//---------------------------------------------------------------------------*

GGS_LUInt64Model GGS_LUInt64Model::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LUInt64Model result ;
  if (NULL == gSingleton_LUInt64Model) {
    macroMyNew (gSingleton_LUInt64Model, cPtr_LUInt64Model (THERE)) ;
    registerReleaseRoutine (cleanUp_LUInt64Model) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LUInt64Model) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LUInt64Model::actualTypeName (void) const {
  return "LUInt64Model" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__LUInt64Model ("LUInt64Model", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_LUInt64Model) ;

//---------------------------------------------------------------------------*

GGS_object GGS_LUInt64Model::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_LUInt64Model * p = NULL ;
    macroMyNew (p, GGS_LUInt64Model (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_LUInt64Model GGS_LUInt64Model::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_LUInt64Model result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_LUInt64Model * p = dynamic_cast <const GGS_LUInt64Model *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_LUInt64Model, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_LUInt64Model::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_LUInt64Model ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_LSInt64Model'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LSInt64Model::
cPtr_LSInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LSInt64Model * GGS_LSInt64Model::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LSInt64Model *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LSInt64Model *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LSInt64Model::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LSInt64Model::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@LSInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LSInt64Model::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LSInt64Model::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LSInt64Model (& typeid (cPtr_LSInt64Model), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_LSInt64Model::galgasRTTI (void) const {
  return & gClassInfoFor__LSInt64Model ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LSInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_LSInt64Model ("LSInt64Model", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_LSInt64Model::
GGS_LSInt64Model (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LSInt64Model::
GGS_LSInt64Model (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_LSInt64Model GGS_LSInt64Model::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LSInt64Model result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LSInt64Model *> (inPointer) != NULL)
      : (typeid (cPtr_LSInt64Model) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_LSInt64Model (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LSInt64Model),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_LSInt64Model * gSingleton_LSInt64Model = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LSInt64Model (void) {
  macroDetachPointer (gSingleton_LSInt64Model, cPtr_LSInt64Model) ;
}

//---------------------------------------------------------------------------*

GGS_LSInt64Model GGS_LSInt64Model::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LSInt64Model result ;
  if (NULL == gSingleton_LSInt64Model) {
    macroMyNew (gSingleton_LSInt64Model, cPtr_LSInt64Model (THERE)) ;
    registerReleaseRoutine (cleanUp_LSInt64Model) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LSInt64Model) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LSInt64Model::actualTypeName (void) const {
  return "LSInt64Model" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__LSInt64Model ("LSInt64Model", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_LSInt64Model) ;

//---------------------------------------------------------------------------*

GGS_object GGS_LSInt64Model::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_LSInt64Model * p = NULL ;
    macroMyNew (p, GGS_LSInt64Model (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_LSInt64Model GGS_LSInt64Model::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_LSInt64Model result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_LSInt64Model * p = dynamic_cast <const GGS_LSInt64Model *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_LSInt64Model, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_LSInt64Model::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_LSInt64Model ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_LDoubleModel'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LDoubleModel::
cPtr_LDoubleModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LDoubleModel * GGS_LDoubleModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LDoubleModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LDoubleModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LDoubleModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LDoubleModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@LDoubleModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LDoubleModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LDoubleModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LDoubleModel (& typeid (cPtr_LDoubleModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_LDoubleModel::galgasRTTI (void) const {
  return & gClassInfoFor__LDoubleModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LDoubleModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_LDoubleModel ("LDoubleModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_LDoubleModel::
GGS_LDoubleModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LDoubleModel::
GGS_LDoubleModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_LDoubleModel GGS_LDoubleModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LDoubleModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LDoubleModel *> (inPointer) != NULL)
      : (typeid (cPtr_LDoubleModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_LDoubleModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LDoubleModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_LDoubleModel * gSingleton_LDoubleModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LDoubleModel (void) {
  macroDetachPointer (gSingleton_LDoubleModel, cPtr_LDoubleModel) ;
}

//---------------------------------------------------------------------------*

GGS_LDoubleModel GGS_LDoubleModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LDoubleModel result ;
  if (NULL == gSingleton_LDoubleModel) {
    macroMyNew (gSingleton_LDoubleModel, cPtr_LDoubleModel (THERE)) ;
    registerReleaseRoutine (cleanUp_LDoubleModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LDoubleModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LDoubleModel::actualTypeName (void) const {
  return "LDoubleModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__LDoubleModel ("LDoubleModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_LDoubleModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_LDoubleModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_LDoubleModel * p = NULL ;
    macroMyNew (p, GGS_LDoubleModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_LDoubleModel GGS_LDoubleModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_LDoubleModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_LDoubleModel * p = dynamic_cast <const GGS_LDoubleModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_LDoubleModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_LDoubleModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_LDoubleModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_LStringModel'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LStringModel::
cPtr_LStringModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LStringModel * GGS_LStringModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LStringModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LStringModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LStringModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LStringModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@LStringModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LStringModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LStringModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LStringModel (& typeid (cPtr_LStringModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_LStringModel::galgasRTTI (void) const {
  return & gClassInfoFor__LStringModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LStringModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_LStringModel ("LStringModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_LStringModel::
GGS_LStringModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LStringModel::
GGS_LStringModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_LStringModel GGS_LStringModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LStringModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LStringModel *> (inPointer) != NULL)
      : (typeid (cPtr_LStringModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_LStringModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LStringModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_LStringModel * gSingleton_LStringModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LStringModel (void) {
  macroDetachPointer (gSingleton_LStringModel, cPtr_LStringModel) ;
}

//---------------------------------------------------------------------------*

GGS_LStringModel GGS_LStringModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LStringModel result ;
  if (NULL == gSingleton_LStringModel) {
    macroMyNew (gSingleton_LStringModel, cPtr_LStringModel (THERE)) ;
    registerReleaseRoutine (cleanUp_LStringModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LStringModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LStringModel::actualTypeName (void) const {
  return "LStringModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__LStringModel ("LStringModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_LStringModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_LStringModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_LStringModel * p = NULL ;
    macroMyNew (p, GGS_LStringModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_LStringModel GGS_LStringModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_LStringModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_LStringModel * p = dynamic_cast <const GGS_LStringModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_LStringModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_LStringModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_LStringModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_StringsetModel'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_StringsetModel::
cPtr_StringsetModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_StringsetModel * GGS_StringsetModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_StringsetModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_StringsetModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_StringsetModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_StringsetModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@StringsetModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_StringsetModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_StringsetModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_StringsetModel (& typeid (cPtr_StringsetModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_StringsetModel::galgasRTTI (void) const {
  return & gClassInfoFor__StringsetModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_StringsetModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_StringsetModel ("StringsetModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_StringsetModel::
GGS_StringsetModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_StringsetModel::
GGS_StringsetModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_StringsetModel GGS_StringsetModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_StringsetModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_StringsetModel *> (inPointer) != NULL)
      : (typeid (cPtr_StringsetModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_StringsetModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_StringsetModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_StringsetModel * gSingleton_StringsetModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_StringsetModel (void) {
  macroDetachPointer (gSingleton_StringsetModel, cPtr_StringsetModel) ;
}

//---------------------------------------------------------------------------*

GGS_StringsetModel GGS_StringsetModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_StringsetModel result ;
  if (NULL == gSingleton_StringsetModel) {
    macroMyNew (gSingleton_StringsetModel, cPtr_StringsetModel (THERE)) ;
    registerReleaseRoutine (cleanUp_StringsetModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_StringsetModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_StringsetModel::actualTypeName (void) const {
  return "StringsetModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__StringsetModel ("StringsetModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_StringsetModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_StringsetModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_StringsetModel * p = NULL ;
    macroMyNew (p, GGS_StringsetModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_StringsetModel GGS_StringsetModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_StringsetModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_StringsetModel * p = dynamic_cast <const GGS_StringsetModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_StringsetModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_StringsetModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_StringsetModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_LocationModel'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LocationModel::
cPtr_LocationModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LocationModel * GGS_LocationModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LocationModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LocationModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LocationModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LocationModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@LocationModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LocationModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LocationModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LocationModel (& typeid (cPtr_LocationModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_LocationModel::galgasRTTI (void) const {
  return & gClassInfoFor__LocationModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LocationModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_LocationModel ("LocationModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_LocationModel::
GGS_LocationModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LocationModel::
GGS_LocationModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_LocationModel GGS_LocationModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LocationModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LocationModel *> (inPointer) != NULL)
      : (typeid (cPtr_LocationModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_LocationModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LocationModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_LocationModel * gSingleton_LocationModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LocationModel (void) {
  macroDetachPointer (gSingleton_LocationModel, cPtr_LocationModel) ;
}

//---------------------------------------------------------------------------*

GGS_LocationModel GGS_LocationModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LocationModel result ;
  if (NULL == gSingleton_LocationModel) {
    macroMyNew (gSingleton_LocationModel, cPtr_LocationModel (THERE)) ;
    registerReleaseRoutine (cleanUp_LocationModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LocationModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LocationModel::actualTypeName (void) const {
  return "LocationModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__LocationModel ("LocationModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_LocationModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_LocationModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_LocationModel * p = NULL ;
    macroMyNew (p, GGS_LocationModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_LocationModel GGS_LocationModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_LocationModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_LocationModel * p = dynamic_cast <const GGS_LocationModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_LocationModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_LocationModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_LocationModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_ListModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ListModel::
cPtr_ListModel (const GGS_typeListModel & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mAttributeList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ListModel * GGS_ListModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ListModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ListModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ListModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ListModel * ptr = dynamic_cast <const cPtr_ListModel *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ListModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ListModel:"
           << mAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ListModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ListModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ListModel (& typeid (cPtr_ListModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ListModel::galgasRTTI (void) const {
  return & gClassInfoFor__ListModel ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ListModel::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ListModel (mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_ListModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ListModel ("ListModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_ListModel::
GGS_ListModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ListModel::
GGS_ListModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ListModel GGS_ListModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ListModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ListModel *> (inPointer) != NULL)
      : (typeid (cPtr_ListModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ListModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ListModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ListModel GGS_ListModel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeListModel & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ListModel result ;
  macroMyNew (result.mPointer, cPtr_ListModel (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ListModel::actualTypeName (void) const {
  return "ListModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ListModel ("ListModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_ListModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ListModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ListModel * p = NULL ;
    macroMyNew (p, GGS_ListModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ListModel GGS_ListModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ListModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ListModel * p = dynamic_cast <const GGS_ListModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ListModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ListModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ListModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_MapModel'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_MapModel::
cPtr_MapModel (const GGS_typeListModel & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mAttributeList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_MapModel * GGS_MapModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_MapModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_MapModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_MapModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_MapModel * ptr = dynamic_cast <const cPtr_MapModel *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_MapModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@MapModel:"
           << mAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_MapModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_MapModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_MapModel (& typeid (cPtr_MapModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_MapModel::galgasRTTI (void) const {
  return & gClassInfoFor__MapModel ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_MapModel::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_MapModel (mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_MapModel'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_MapModel ("MapModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_MapModel::
GGS_MapModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_MapModel::
GGS_MapModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_MapModel GGS_MapModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_MapModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_MapModel *> (inPointer) != NULL)
      : (typeid (cPtr_MapModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_MapModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_MapModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_MapModel GGS_MapModel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeListModel & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_MapModel result ;
  macroMyNew (result.mPointer, cPtr_MapModel (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_MapModel::actualTypeName (void) const {
  return "MapModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__MapModel ("MapModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_MapModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_MapModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_MapModel * p = NULL ;
    macroMyNew (p, GGS_MapModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_MapModel GGS_MapModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_MapModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_MapModel * p = dynamic_cast <const GGS_MapModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_MapModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_MapModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_MapModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_enumConstantMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_enumConstantMap::e_enumConstantMap (void) :
mConstantIndex (),
mHasConstructor () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@enumConstantMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumConstantMap ("enumConstantMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_enumConstantMap::
elementOf_GGS_enumConstantMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_enumConstantMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumConstantMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mConstantIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasConstructor.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumConstantMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_enumConstantMap * ptr = dynamic_cast <const elementOf_GGS_enumConstantMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mConstantIndex.operator_isEqual (ptr->mInfo.mConstantIndex)).boolValue ()
           && (mInfo.mHasConstructor.operator_isEqual (ptr->mInfo.mHasConstructor)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumConstantMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumConstantMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumConstantMap * info = (e_enumConstantMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_enumConstantMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_enumConstantMap * info = (e_enumConstantMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap GGS_enumConstantMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumConstantMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_enumConstantMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumConstantMap::
operator_isEqual (const GGS_enumConstantMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumConstantMap::
operator_isNotEqual (const GGS_enumConstantMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                const GGS_bool& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_enumConstantMap info  ;
    info.mConstantIndex = inParameter0 ;
    info.mHasConstructor = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mConstantIndex ;
    outParameter1 = node->mInfo.mHasConstructor ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumConstantMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumConstantMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap GGS_enumConstantMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_enumConstantMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumConstantMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap GGS_enumConstantMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumConstantMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumConstantMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @enumConstantMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_enumConstantMap::cEnumerator::_mConstantIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mConstantIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_enumConstantMap::cEnumerator::_mHasConstructor (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasConstructor ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumConstantMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumConstantMap * p = NULL ;
    macroMyNew (p, GGS_enumConstantMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap GGS_enumConstantMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumConstantMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumConstantMap * p = dynamic_cast <const GGS_enumConstantMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumConstantMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumConstantMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumConstantMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@enumUsedConstantMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumUsedConstantMap ("enumUsedConstantMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_enumUsedConstantMap::
elementOf_GGS_enumUsedConstantMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_enumUsedConstantMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumUsedConstantMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumUsedConstantMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumUsedConstantMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumUsedConstantMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumUsedConstantMap * info = (e_enumUsedConstantMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_enumUsedConstantMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_enumUsedConstantMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_enumUsedConstantMap * info = (e_enumUsedConstantMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_enumUsedConstantMap GGS_enumUsedConstantMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumUsedConstantMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumUsedConstantMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_enumUsedConstantMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumUsedConstantMap::
operator_isEqual (const GGS_enumUsedConstantMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumUsedConstantMap::
operator_isNotEqual (const GGS_enumUsedConstantMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumUsedConstantMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumUsedConstantMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_enumUsedConstantMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumUsedConstantMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumUsedConstantMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('u'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumUsedConstantMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumUsedConstantMap GGS_enumUsedConstantMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_enumUsedConstantMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumUsedConstantMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumUsedConstantMap GGS_enumUsedConstantMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumUsedConstantMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumUsedConstantMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @enumUsedConstantMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumUsedConstantMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumUsedConstantMap * p = NULL ;
    macroMyNew (p, GGS_enumUsedConstantMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumUsedConstantMap GGS_enumUsedConstantMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumUsedConstantMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumUsedConstantMap * p = dynamic_cast <const GGS_enumUsedConstantMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumUsedConstantMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumUsedConstantMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumUsedConstantMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@EXenumMessageMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EXenumMessageMap ("EXenumMessageMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_EXenumMessageMap::
elementOf_GGS_EXenumMessageMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_EXenumMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_EXenumMessageMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_EXenumMessageMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_EXenumMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_EXenumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_EXenumMessageMap * info = (e_EXenumMessageMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_EXenumMessageMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_EXenumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_EXenumMessageMap * info = (e_EXenumMessageMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_EXenumMessageMap GGS_EXenumMessageMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXenumMessageMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXenumMessageMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_EXenumMessageMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXenumMessageMap::
operator_isEqual (const GGS_EXenumMessageMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXenumMessageMap::
operator_isNotEqual (const GGS_EXenumMessageMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_EXenumMessageMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_EXenumMessageMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_EXenumMessageMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXenumMessageMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXenumMessageMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXenumMessageMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXenumMessageMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXenumMessageMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_EXenumMessageMap GGS_EXenumMessageMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_EXenumMessageMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXenumMessageMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXenumMessageMap GGS_EXenumMessageMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_EXenumMessageMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXenumMessageMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @EXenumMessageMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_EXenumMessageMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EXenumMessageMap * p = NULL ;
    macroMyNew (p, GGS_EXenumMessageMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXenumMessageMap GGS_EXenumMessageMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EXenumMessageMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EXenumMessageMap * p = dynamic_cast <const GGS_EXenumMessageMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EXenumMessageMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EXenumMessageMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EXenumMessageMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_EnumModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_EnumModel::
cPtr_EnumModel (const GGS_enumConstantMap & argument_0,
                                const GGS_EXenumMessageMap & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mEnumConstantesMap (argument_0),
mMessagesMap (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_EnumModel * GGS_EnumModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_EnumModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_EnumModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_EnumModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_EnumModel * ptr = dynamic_cast <const cPtr_EnumModel *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumConstantesMap.operator_isEqual (ptr->mEnumConstantesMap).boolValue ()
         && mMessagesMap.operator_isEqual (ptr->mMessagesMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_EnumModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@EnumModel:"
           << mEnumConstantesMap.reader_description (inIndentation + 1)
           << mMessagesMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_EnumModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_EnumModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_EnumModel (& typeid (cPtr_EnumModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_EnumModel::galgasRTTI (void) const {
  return & gClassInfoFor__EnumModel ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_EnumModel::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_EnumModel (mEnumConstantesMap, mMessagesMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_EnumModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EnumModel ("EnumModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_EnumModel::
GGS_EnumModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_EnumModel::
GGS_EnumModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_EnumModel GGS_EnumModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_EnumModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_EnumModel *> (inPointer) != NULL)
      : (typeid (cPtr_EnumModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_EnumModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_EnumModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EnumModel GGS_EnumModel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_enumConstantMap & argument_0,
                 const GGS_EXenumMessageMap & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_EnumModel result ;
  macroMyNew (result.mPointer, cPtr_EnumModel (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_EnumModel::actualTypeName (void) const {
  return "EnumModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__EnumModel ("EnumModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_EnumModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_EnumModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EnumModel * p = NULL ;
    macroMyNew (p, GGS_EnumModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EnumModel GGS_EnumModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EnumModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EnumModel * p = dynamic_cast <const GGS_EnumModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EnumModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EnumModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EnumModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'e_externTypeConstructorMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

e_externTypeConstructorMap::e_externTypeConstructorMap (void) :
mFormalInputArgumentList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map '@externTypeConstructorMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_externTypeConstructorMap ("externTypeConstructorMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_externTypeConstructorMap::
elementOf_GGS_externTypeConstructorMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_externTypeConstructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_externTypeConstructorMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFormalInputArgumentList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_externTypeConstructorMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_externTypeConstructorMap * ptr = dynamic_cast <const elementOf_GGS_externTypeConstructorMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFormalInputArgumentList.operator_isEqual (ptr->mInfo.mFormalInputArgumentList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_externTypeConstructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_externTypeConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_externTypeConstructorMap * info = (e_externTypeConstructorMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_externTypeConstructorMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_externTypeConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_externTypeConstructorMap * info = (e_externTypeConstructorMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_externTypeConstructorMap GGS_externTypeConstructorMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_externTypeConstructorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externTypeConstructorMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_externTypeConstructorMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_externTypeConstructorMap::
operator_isEqual (const GGS_externTypeConstructorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_externTypeConstructorMap::
operator_isNotEqual (const GGS_externTypeConstructorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_externTypeConstructorMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_externTypeConstructorMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeListModel & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_externTypeConstructorMap info  ;
    info.mFormalInputArgumentList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externTypeConstructorMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListModel   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalInputArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_externTypeConstructorMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_externTypeConstructorMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListModel   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_externTypeConstructorMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_externTypeConstructorMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListModel & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_externTypeConstructorMap GGS_externTypeConstructorMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_externTypeConstructorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_externTypeConstructorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externTypeConstructorMap GGS_externTypeConstructorMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_externTypeConstructorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_externTypeConstructorMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @externTypeConstructorMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListModel  & GGS_externTypeConstructorMap::cEnumerator::_mFormalInputArgumentList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFormalInputArgumentList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_externTypeConstructorMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_externTypeConstructorMap * p = NULL ;
    macroMyNew (p, GGS_externTypeConstructorMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externTypeConstructorMap GGS_externTypeConstructorMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_externTypeConstructorMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_externTypeConstructorMap * p = dynamic_cast <const GGS_externTypeConstructorMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_externTypeConstructorMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_externTypeConstructorMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_externTypeConstructorMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_externTypeReaderMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_externTypeReaderMap::e_externTypeReaderMap (void) :
mReaderFormalArgumentList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@externTypeReaderMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_externTypeReaderMap ("externTypeReaderMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_externTypeReaderMap::
elementOf_GGS_externTypeReaderMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_externTypeReaderMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_externTypeReaderMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReaderFormalArgumentList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_externTypeReaderMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_externTypeReaderMap * ptr = dynamic_cast <const elementOf_GGS_externTypeReaderMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mReaderFormalArgumentList.operator_isEqual (ptr->mInfo.mReaderFormalArgumentList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_externTypeReaderMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_externTypeReaderMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_externTypeReaderMap * info = (e_externTypeReaderMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_externTypeReaderMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_externTypeReaderMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_externTypeReaderMap * info = (e_externTypeReaderMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_externTypeReaderMap GGS_externTypeReaderMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_externTypeReaderMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externTypeReaderMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_externTypeReaderMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_externTypeReaderMap::
operator_isEqual (const GGS_externTypeReaderMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_externTypeReaderMap::
operator_isNotEqual (const GGS_externTypeReaderMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_externTypeReaderMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_externTypeReaderMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_signatureForGrammarAnalysis & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_externTypeReaderMap info  ;
    info.mReaderFormalArgumentList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externTypeReaderMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_signatureForGrammarAnalysis   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mReaderFormalArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_externTypeReaderMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_externTypeReaderMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_signatureForGrammarAnalysis   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_externTypeReaderMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_externTypeReaderMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_signatureForGrammarAnalysis & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_externTypeReaderMap GGS_externTypeReaderMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_externTypeReaderMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_externTypeReaderMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externTypeReaderMap GGS_externTypeReaderMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_externTypeReaderMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_externTypeReaderMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @externTypeReaderMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_signatureForGrammarAnalysis  & GGS_externTypeReaderMap::cEnumerator::_mReaderFormalArgumentList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReaderFormalArgumentList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_externTypeReaderMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_externTypeReaderMap * p = NULL ;
    macroMyNew (p, GGS_externTypeReaderMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externTypeReaderMap GGS_externTypeReaderMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_externTypeReaderMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_externTypeReaderMap * p = dynamic_cast <const GGS_externTypeReaderMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_externTypeReaderMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_externTypeReaderMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_externTypeReaderMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_externTypeModifierMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_externTypeModifierMap::e_externTypeModifierMap (void) :
mModifierFormalArgumentList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@externTypeModifierMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_externTypeModifierMap ("externTypeModifierMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_externTypeModifierMap::
elementOf_GGS_externTypeModifierMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_externTypeModifierMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_externTypeModifierMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mModifierFormalArgumentList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_externTypeModifierMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_externTypeModifierMap * ptr = dynamic_cast <const elementOf_GGS_externTypeModifierMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mModifierFormalArgumentList.operator_isEqual (ptr->mInfo.mModifierFormalArgumentList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_externTypeModifierMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_externTypeModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_externTypeModifierMap * info = (e_externTypeModifierMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_externTypeModifierMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_externTypeModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_externTypeModifierMap * info = (e_externTypeModifierMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_externTypeModifierMap GGS_externTypeModifierMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_externTypeModifierMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_externTypeModifierMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_externTypeModifierMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_externTypeModifierMap::
operator_isEqual (const GGS_externTypeModifierMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_externTypeModifierMap::
operator_isNotEqual (const GGS_externTypeModifierMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_externTypeModifierMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_externTypeModifierMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_signatureForGrammarAnalysis & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_externTypeModifierMap info  ;
    info.mModifierFormalArgumentList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_externTypeModifierMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_signatureForGrammarAnalysis   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mModifierFormalArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_externTypeModifierMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_externTypeModifierMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_signatureForGrammarAnalysis   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_externTypeModifierMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_externTypeModifierMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_signatureForGrammarAnalysis & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_externTypeModifierMap GGS_externTypeModifierMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_externTypeModifierMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_externTypeModifierMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externTypeModifierMap GGS_externTypeModifierMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_externTypeModifierMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_externTypeModifierMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @externTypeModifierMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_signatureForGrammarAnalysis  & GGS_externTypeModifierMap::cEnumerator::_mModifierFormalArgumentList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mModifierFormalArgumentList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_externTypeModifierMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_externTypeModifierMap * p = NULL ;
    macroMyNew (p, GGS_externTypeModifierMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externTypeModifierMap GGS_externTypeModifierMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_externTypeModifierMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_externTypeModifierMap * p = dynamic_cast <const GGS_externTypeModifierMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_externTypeModifierMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_externTypeModifierMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_externTypeModifierMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_ExternTypeModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ExternTypeModel::
cPtr_ExternTypeModel (const GGS_externTypeConstructorMap & argument_0,
                                const GGS_externTypeReaderMap & argument_1,
                                const GGS_externTypeModifierMap & argument_2,
                                const GGS_typeListModel & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mExternTypeConstructorMap (argument_0),
mReaderMap (argument_1),
mModifierMap (argument_2),
mAddAssignFormalInputArgumentList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ExternTypeModel * GGS_ExternTypeModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ExternTypeModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ExternTypeModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ExternTypeModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ExternTypeModel * ptr = dynamic_cast <const cPtr_ExternTypeModel *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExternTypeConstructorMap.operator_isEqual (ptr->mExternTypeConstructorMap).boolValue ()
         && mReaderMap.operator_isEqual (ptr->mReaderMap).boolValue ()
         && mModifierMap.operator_isEqual (ptr->mModifierMap).boolValue ()
         && mAddAssignFormalInputArgumentList.operator_isEqual (ptr->mAddAssignFormalInputArgumentList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ExternTypeModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ExternTypeModel:"
           << mExternTypeConstructorMap.reader_description (inIndentation + 1)
           << mReaderMap.reader_description (inIndentation + 1)
           << mModifierMap.reader_description (inIndentation + 1)
           << mAddAssignFormalInputArgumentList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ExternTypeModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ExternTypeModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ExternTypeModel (& typeid (cPtr_ExternTypeModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ExternTypeModel::galgasRTTI (void) const {
  return & gClassInfoFor__ExternTypeModel ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ExternTypeModel::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ExternTypeModel (mExternTypeConstructorMap, mReaderMap, mModifierMap, mAddAssignFormalInputArgumentList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_ExternTypeModel'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ExternTypeModel ("ExternTypeModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_ExternTypeModel::
GGS_ExternTypeModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ExternTypeModel::
GGS_ExternTypeModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ExternTypeModel GGS_ExternTypeModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ExternTypeModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ExternTypeModel *> (inPointer) != NULL)
      : (typeid (cPtr_ExternTypeModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ExternTypeModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ExternTypeModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ExternTypeModel GGS_ExternTypeModel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_externTypeConstructorMap & argument_0,
                 const GGS_externTypeReaderMap & argument_1,
                 const GGS_externTypeModifierMap & argument_2,
                 const GGS_typeListModel & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ExternTypeModel result ;
  macroMyNew (result.mPointer, cPtr_ExternTypeModel (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ExternTypeModel::actualTypeName (void) const {
  return "ExternTypeModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ExternTypeModel ("ExternTypeModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_ExternTypeModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ExternTypeModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ExternTypeModel * p = NULL ;
    macroMyNew (p, GGS_ExternTypeModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ExternTypeModel GGS_ExternTypeModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ExternTypeModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ExternTypeModel * p = dynamic_cast <const GGS_ExternTypeModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ExternTypeModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ExternTypeModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ExternTypeModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@classMessageMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classMessageMap ("classMessageMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_classMessageMap::
elementOf_GGS_classMessageMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_classMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classMessageMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_classMessageMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_classMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_classMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_classMessageMap * info = (e_classMessageMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_classMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_classMessageMap * info = (e_classMessageMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap GGS_classMessageMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMessageMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_classMessageMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMessageMap::
operator_isEqual (const GGS_classMessageMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMessageMap::
operator_isNotEqual (const GGS_classMessageMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_classMessageMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_classMessageMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_classMessageMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap GGS_classMessageMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_classMessageMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMessageMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap GGS_classMessageMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classMessageMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classMessageMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @classMessageMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_classMessageMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classMessageMap * p = NULL ;
    macroMyNew (p, GGS_classMessageMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap GGS_classMessageMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classMessageMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classMessageMap * p = dynamic_cast <const GGS_classMessageMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classMessageMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classMessageMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classMessageMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_ClassModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ClassModel::
cPtr_ClassModel (const GGS_bool& argument_0,
                                const GGS_stringset & argument_1,
                                const GGS_typeListModel & argument_2,
                                const GGS_classMessageMap & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mIsAbstract (argument_0),
mSuperClasses (argument_1),
mAttributeList (argument_2),
mMessageMap (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ClassModel * GGS_ClassModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ClassModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ClassModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ClassModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ClassModel * ptr = dynamic_cast <const cPtr_ClassModel *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAbstract.operator_isEqual (ptr->mIsAbstract).boolValue ()
         && mSuperClasses.operator_isEqual (ptr->mSuperClasses).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mMessageMap.operator_isEqual (ptr->mMessageMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ClassModel::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ClassModel:"
           << mIsAbstract.reader_description (inIndentation + 1)
           << mSuperClasses.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mMessageMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ClassModel::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ClassModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ClassModel (& typeid (cPtr_ClassModel), & typeid (cPtr_TypeModel), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ClassModel::galgasRTTI (void) const {
  return & gClassInfoFor__ClassModel ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ClassModel::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ClassModel (mIsAbstract, mSuperClasses, mAttributeList, mMessageMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_ClassModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ClassModel ("ClassModel", true, & kTypeDescriptor_GGS_TypeModel) ;

//---------------------------------------------------------------------------*

GGS_ClassModel::
GGS_ClassModel (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ClassModel::
GGS_ClassModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ClassModel GGS_ClassModel::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ClassModel result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ClassModel *> (inPointer) != NULL)
      : (typeid (cPtr_ClassModel) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ClassModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ClassModel),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ClassModel GGS_ClassModel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_stringset & argument_1,
                 const GGS_typeListModel & argument_2,
                 const GGS_classMessageMap & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ClassModel result ;
  macroMyNew (result.mPointer, cPtr_ClassModel (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset  GGS_ClassModel::
reader_mSuperClasses (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringset   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ClassModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ClassModel *) mPointer)->mSuperClasses ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_ClassModel::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListModel   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ClassModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ClassModel *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap  GGS_ClassModel::
reader_mMessageMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classMessageMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ClassModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ClassModel *) mPointer)->mMessageMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ClassModel::actualTypeName (void) const {
  return "ClassModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ClassModel ("ClassModel", gClassInfoFor__TypeModel, & kTypeDescriptor_GGS_ClassModel) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ClassModel::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ClassModel * p = NULL ;
    macroMyNew (p, GGS_ClassModel (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ClassModel GGS_ClassModel::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ClassModel result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ClassModel * p = dynamic_cast <const GGS_ClassModel *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ClassModel, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ClassModel::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ClassModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'e_ModelMap'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_ModelMap::e_ModelMap (void) :
mType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@ModelMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ModelMap ("ModelMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_ModelMap::
elementOf_GGS_ModelMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_ModelMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ModelMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ModelMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_ModelMap * ptr = dynamic_cast <const elementOf_GGS_ModelMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mType.operator_isEqual (ptr->mInfo.mType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ModelMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_ModelMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ModelMap * info = (e_ModelMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_ModelMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_ModelMap * info = (e_ModelMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ModelMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_ModelMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ModelMap::
operator_isEqual (const GGS_ModelMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ModelMap::
operator_isNotEqual (const GGS_ModelMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_TypeModel & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_ModelMap info  ;
    info.mType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_TypeModel   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_ModelMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_ModelMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_TypeModel   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_ModelMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_ModelMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_TypeModel & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_ModelMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ModelMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ModelMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ModelMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @ModelMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_TypeModel  & GGS_ModelMap::cEnumerator::_mType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_ModelMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ModelMap * p = NULL ;
    macroMyNew (p, GGS_ModelMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ModelMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ModelMap * p = dynamic_cast <const GGS_ModelMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ModelMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ModelMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ModelMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_ActionMap'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_ActionMap::e_ActionMap (void) :
mSignature (),
mIsExtern () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@ActionMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ActionMap ("ActionMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_ActionMap::
elementOf_GGS_ActionMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_ActionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ActionMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIsExtern.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ActionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_ActionMap * ptr = dynamic_cast <const elementOf_GGS_ActionMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mSignature.operator_isEqual (ptr->mInfo.mSignature)).boolValue ()
           && (mInfo.mIsExtern.operator_isEqual (ptr->mInfo.mIsExtern)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ActionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_ActionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ActionMap * info = (e_ActionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_ActionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_ActionMap * info = (e_ActionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_ActionMap GGS_ActionMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ActionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_ActionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ActionMap::
operator_isEqual (const GGS_ActionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ActionMap::
operator_isNotEqual (const GGS_ActionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_signatureForGrammarAnalysis & inParameter0,
                const GGS_bool& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_ActionMap info  ;
    info.mSignature = inParameter0 ;
    info.mIsExtern = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_signatureForGrammarAnalysis   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mSignature ;
    outParameter1 = node->mInfo.mIsExtern ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_ActionMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_ActionMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_signatureForGrammarAnalysis   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_ActionMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_ActionMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_signatureForGrammarAnalysis & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_ActionMap GGS_ActionMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_ActionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ActionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ActionMap GGS_ActionMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ActionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ActionMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @ActionMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_signatureForGrammarAnalysis  & GGS_ActionMap::cEnumerator::_mSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_ActionMap::cEnumerator::_mIsExtern (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIsExtern ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_ActionMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ActionMap * p = NULL ;
    macroMyNew (p, GGS_ActionMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ActionMap GGS_ActionMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ActionMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ActionMap * p = dynamic_cast <const GGS_ActionMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ActionMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ActionMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ActionMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Class for 'localConstantBuildStyleEnum' Enumeration             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localConstantBuildStyleEnum ("localConstantBuildStyleEnum", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_localConstantBuildStyleEnum::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator_isEqual (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator_isNotEqual (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator_infOrEqual (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator_supOrEqual (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator_strictInf (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator_strictSup (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localConstantBuildStyleEnum::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @localConstantBuildStyleEnum" ;
  switch (mValue) {
  case enum_firstIsKeyOtherMapStyle:
    s << " firstIsKeyOtherMapStyle>" ;
    break ;
  case enum_listStyle:
    s << " listStyle>" ;
    break ;
  case enum_mapStyle:
    s << " mapStyle>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_localConstantBuildStyleEnum::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localConstantBuildStyleEnum * p = NULL ;
    macroMyNew (p, GGS_localConstantBuildStyleEnum (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localConstantBuildStyleEnum GGS_localConstantBuildStyleEnum::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localConstantBuildStyleEnum result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localConstantBuildStyleEnum * p = dynamic_cast <const GGS_localConstantBuildStyleEnum *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localConstantBuildStyleEnum, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localConstantBuildStyleEnum::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localConstantBuildStyleEnum ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_AC_galgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_galgasType::
cPtr_AC_galgasType (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_galgasType * GGS_AC_galgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_galgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_AC_galgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this attribute cannot be used for sorting") COMMA_SOURCE_FILE_AT_LINE (434)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_check_with_InstructionAccess (C_Compiler & inLexique,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_lstring  /* var_cas_searchMethodName */,
                                GGS_AC_galgasType  /* var_cas_inKeyExpressionType */,
                                GGS_string& var_cas_outMapTypeName,
                                GGS_string& var_cas_outErrorMessage,
                                GGS_typeListeAttributsSemantiques & var_cas_outAttributeList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only a map object can be accessed by the 'with' instruction") COMMA_SOURCE_FILE_AT_LINE (448)) ;
  var_cas_outAttributeList.drop () ;
  var_cas_outMapTypeName.drop () ;
  var_cas_outErrorMessage.drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_acceptAssignmentFromHere (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("assignment from 'here' is not allowed for variables of this type") COMMA_SOURCE_FILE_AT_LINE (454)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_acceptForeachInstruction (C_Compiler & inLexique,
                                GGS_M_semanticsEntitiesForUse  /* var_cas_inSemanticsEntitiesForUse */,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle,
                                GGS_bool& var_cas_outNewStyle COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type cannot be enumerated by in 'foreach' instruction") COMMA_SOURCE_FILE_AT_LINE (468)) ;
  var_cas_outForeachList.drop () ;
  var_cas_outStyle.drop () ;
  var_cas_outNewStyle.drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (477)) ;
  var_cas_outModifierSignature.drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleMethodInstructionCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outMethodSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support method call instruction") COMMA_SOURCE_FILE_AT_LINE (489)) ;
  var_cas_outMethodSignature.drop () ;
  var_cas_outCategoryMethodClassBaseName.drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_AC_galgasType (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (503)) ;
  var_cas_outAccessorTypesList.drop () ;
  var_cas_outHasLexiqueAndLocationArguments.drop () ;
  var_cas_outReturnedType.drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleClassMethodCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inTypeMethodName,
                                GGS_L_EXsignature & var_cas_outTypeMethodSignature COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inTypeMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This type method is not defined") COMMA_SOURCE_FILE_AT_LINE (511)) ;
  var_cas_outTypeMethodSignature.drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleMinusAssignOperatorCall (C_Compiler & inLexique,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support call of '-=' operator") COMMA_SOURCE_FILE_AT_LINE (521)) ;
  var_cas_outParametersList.drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleAddAssignOperatorCall (C_Compiler & inLexique,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support call of '+=' operator") COMMA_SOURCE_FILE_AT_LINE (532)) ;
  var_cas_outParametersList.drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleIncrementOperatorCall (C_Compiler & inLexique,
                                GGS_location  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support call of '++' operator") COMMA_SOURCE_FILE_AT_LINE (540)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleDecrementOperatorCall (C_Compiler & inLexique,
                                GGS_location  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support call of '--' operator") COMMA_SOURCE_FILE_AT_LINE (548)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type cannot be silently converted to @location value") COMMA_SOURCE_FILE_AT_LINE (554)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@AC_galgasType:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType::
static_string_message_messageGalgasType (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType::
message_messageGalgasType (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType::
instanceMessage (void) const {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType::
_static_message (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_galgasType (& typeid (cPtr_AC_galgasType), NULL, "any type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_AC_galgasType::galgasRTTI (void) const {
  return & gClassInfoFor__AC_galgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_galgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_AC_galgasType ("AC_galgasType", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_AC_galgasType GGS_AC_galgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_galgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_galgasType *> (inPointer) != NULL)
      : (typeid (cPtr_AC_galgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_AC_galgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_galgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_galgasType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_galgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_AC_galgasType * p = (cPtr_AC_galgasType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_galgasType::actualTypeName (void) const {
  return "AC_galgasType" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_AC_galgasType::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__AC_galgasType ("AC_galgasType", & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_AC_galgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_AC_galgasType * p = NULL ;
    macroMyNew (p, GGS_AC_galgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType GGS_AC_galgasType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_AC_galgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_AC_galgasType * p = dynamic_cast <const GGS_AC_galgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_AC_galgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_AC_galgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_AC_galgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeEntiteType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteType::
cPtr_typeEntiteType (const GGS_AC_galgasType & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aDefType (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteType * GGS_typeEntiteType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteType * ptr = dynamic_cast <const cPtr_typeEntiteType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aDefType.operator_isEqual (ptr->aDefType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeEntiteType:"
           << aDefType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteType::
static_string_message_messageTypeEntite (void) {
  return "a type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteType::
message_messageTypeEntite (void) const {
  return "a type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteType::
instanceMessage (void) const {
  return "a type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteType::
_static_message (void) {
  return "a type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntiteType (& typeid (cPtr_typeEntiteType), & typeid (cPtr_AC_semanticsEntity), "a type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeEntiteType::galgasRTTI (void) const {
  return & gClassInfoFor__typeEntiteType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeEntiteType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeEntiteType (aDefType COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeEntiteType ("typeEntiteType", true, & kTypeDescriptor_GGS_AC_semanticsEntity) ;

//---------------------------------------------------------------------------*

GGS_typeEntiteType::
GGS_typeEntiteType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteType::
GGS_typeEntiteType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEntiteType GGS_typeEntiteType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntiteType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntiteType *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntiteType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEntiteType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntiteType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteType GGS_typeEntiteType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_galgasType & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteType result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteType::
reader_messageTypeEntite (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeEntiteType * p = (cPtr_typeEntiteType *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeEntiteType::
reader_aDefType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteType *) mPointer)->aDefType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntiteType::actualTypeName (void) const {
  return "typeEntiteType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeEntiteType ("typeEntiteType", gClassInfoFor__AC_semanticsEntity, & kTypeDescriptor_GGS_typeEntiteType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeEntiteType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeEntiteType * p = NULL ;
    macroMyNew (p, GGS_typeEntiteType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteType GGS_typeEntiteType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeEntiteType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeEntiteType * p = dynamic_cast <const GGS_typeEntiteType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeEntiteType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeEntiteType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeEntiteType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeCplusPlusName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCplusPlusName::
cPtr_typeCplusPlusName (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mVariableLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCplusPlusName * GGS_typeCplusPlusName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCplusPlusName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCplusPlusName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeCplusPlusName::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeCplusPlusName:"
           << mVariableLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCplusPlusName::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCplusPlusName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCplusPlusName (& typeid (cPtr_typeCplusPlusName), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeCplusPlusName::galgasRTTI (void) const {
  return & gClassInfoFor__typeCplusPlusName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCplusPlusName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeCplusPlusName ("typeCplusPlusName", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCplusPlusName GGS_typeCplusPlusName::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCplusPlusName result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCplusPlusName *> (inPointer) != NULL)
      : (typeid (cPtr_typeCplusPlusName) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCplusPlusName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCplusPlusName),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeCplusPlusName::
reader_mVariableLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCplusPlusName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCplusPlusName *) mPointer)->mVariableLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCplusPlusName::actualTypeName (void) const {
  return "typeCplusPlusName" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_typeCplusPlusName::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__typeCplusPlusName ("typeCplusPlusName", & kTypeDescriptor_GGS_typeCplusPlusName) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeCplusPlusName::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeCplusPlusName * p = NULL ;
    macroMyNew (p, GGS_typeCplusPlusName (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName GGS_typeCplusPlusName::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeCplusPlusName result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeCplusPlusName * p = dynamic_cast <const GGS_typeCplusPlusName *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeCplusPlusName, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeCplusPlusName::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeCplusPlusName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeDirectName'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectName::
cPtr_typeDirectName (const GGS_location & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectName * GGS_typeDirectName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDirectName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDirectName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDirectName * ptr = dynamic_cast <const cPtr_typeDirectName *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableLocation.operator_isEqual (ptr->mVariableLocation).boolValue ()
         && mName.operator_isEqual (ptr->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectName::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeDirectName:"
           << mVariableLocation.reader_description (inIndentation + 1)
           << mName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDirectName::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDirectName (& typeid (cPtr_typeDirectName), & typeid (cPtr_typeCplusPlusName), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeDirectName::galgasRTTI (void) const {
  return & gClassInfoFor__typeDirectName ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDirectName::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDirectName (mVariableLocation, mName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeDirectName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeDirectName ("typeDirectName", true, & kTypeDescriptor_GGS_typeCplusPlusName) ;

//---------------------------------------------------------------------------*

GGS_typeDirectName::
GGS_typeDirectName (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectName::
GGS_typeDirectName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDirectName GGS_typeDirectName::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDirectName result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDirectName *> (inPointer) != NULL)
      : (typeid (cPtr_typeDirectName) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDirectName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDirectName),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectName GGS_typeDirectName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeDirectName result ;
  macroMyNew (result.mPointer, cPtr_typeDirectName (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDirectName::actualTypeName (void) const {
  return "typeDirectName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeDirectName ("typeDirectName", gClassInfoFor__typeCplusPlusName, & kTypeDescriptor_GGS_typeDirectName) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeDirectName::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeDirectName * p = NULL ;
    macroMyNew (p, GGS_typeDirectName (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectName GGS_typeDirectName::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeDirectName result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeDirectName * p = dynamic_cast <const GGS_typeDirectName *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeDirectName, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeDirectName::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeDirectName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeCurrentObjectName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCurrentObjectName::
cPtr_typeCurrentObjectName (const GGS_location & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCurrentObjectName * GGS_typeCurrentObjectName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCurrentObjectName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCurrentObjectName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCurrentObjectName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCurrentObjectName * ptr = dynamic_cast <const cPtr_typeCurrentObjectName *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableLocation.operator_isEqual (ptr->mVariableLocation).boolValue ()
         && mName.operator_isEqual (ptr->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCurrentObjectName::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeCurrentObjectName:"
           << mVariableLocation.reader_description (inIndentation + 1)
           << mName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCurrentObjectName::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCurrentObjectName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCurrentObjectName (& typeid (cPtr_typeCurrentObjectName), & typeid (cPtr_typeCplusPlusName), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeCurrentObjectName::galgasRTTI (void) const {
  return & gClassInfoFor__typeCurrentObjectName ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeCurrentObjectName::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeCurrentObjectName (mVariableLocation, mName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCurrentObjectName'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeCurrentObjectName ("typeCurrentObjectName", true, & kTypeDescriptor_GGS_typeCplusPlusName) ;

//---------------------------------------------------------------------------*

GGS_typeCurrentObjectName::
GGS_typeCurrentObjectName (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCurrentObjectName::
GGS_typeCurrentObjectName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCurrentObjectName GGS_typeCurrentObjectName::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCurrentObjectName result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCurrentObjectName *> (inPointer) != NULL)
      : (typeid (cPtr_typeCurrentObjectName) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCurrentObjectName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCurrentObjectName),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCurrentObjectName GGS_typeCurrentObjectName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeCurrentObjectName result ;
  macroMyNew (result.mPointer, cPtr_typeCurrentObjectName (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCurrentObjectName::actualTypeName (void) const {
  return "typeCurrentObjectName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeCurrentObjectName ("typeCurrentObjectName", gClassInfoFor__typeCplusPlusName, & kTypeDescriptor_GGS_typeCurrentObjectName) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeCurrentObjectName::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeCurrentObjectName * p = NULL ;
    macroMyNew (p, GGS_typeCurrentObjectName (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCurrentObjectName GGS_typeCurrentObjectName::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeCurrentObjectName result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeCurrentObjectName * p = dynamic_cast <const GGS_typeCurrentObjectName *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeCurrentObjectName, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeCurrentObjectName::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeCurrentObjectName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeCppStarThisName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCppStarThisName::
cPtr_typeCppStarThisName (const GGS_location & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE),
mGalgasTypeName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCppStarThisName * GGS_typeCppStarThisName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCppStarThisName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCppStarThisName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCppStarThisName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCppStarThisName * ptr = dynamic_cast <const cPtr_typeCppStarThisName *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableLocation.operator_isEqual (ptr->mVariableLocation).boolValue ()
         && mGalgasTypeName.operator_isEqual (ptr->mGalgasTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCppStarThisName::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeCppStarThisName:"
           << mVariableLocation.reader_description (inIndentation + 1)
           << mGalgasTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCppStarThisName::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCppStarThisName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCppStarThisName (& typeid (cPtr_typeCppStarThisName), & typeid (cPtr_typeCplusPlusName), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeCppStarThisName::galgasRTTI (void) const {
  return & gClassInfoFor__typeCppStarThisName ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeCppStarThisName::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeCppStarThisName (mVariableLocation, mGalgasTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeCppStarThisName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeCppStarThisName ("typeCppStarThisName", true, & kTypeDescriptor_GGS_typeCplusPlusName) ;

//---------------------------------------------------------------------------*

GGS_typeCppStarThisName::
GGS_typeCppStarThisName (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCppStarThisName::
GGS_typeCppStarThisName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCppStarThisName GGS_typeCppStarThisName::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCppStarThisName result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCppStarThisName *> (inPointer) != NULL)
      : (typeid (cPtr_typeCppStarThisName) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCppStarThisName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCppStarThisName),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCppStarThisName GGS_typeCppStarThisName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeCppStarThisName result ;
  macroMyNew (result.mPointer, cPtr_typeCppStarThisName (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCppStarThisName::
reader_mGalgasTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCppStarThisName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCppStarThisName *) mPointer)->mGalgasTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCppStarThisName::actualTypeName (void) const {
  return "typeCppStarThisName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeCppStarThisName ("typeCppStarThisName", gClassInfoFor__typeCplusPlusName, & kTypeDescriptor_GGS_typeCppStarThisName) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeCppStarThisName::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeCppStarThisName * p = NULL ;
    macroMyNew (p, GGS_typeCppStarThisName (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCppStarThisName GGS_typeCppStarThisName::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeCppStarThisName result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeCppStarThisName * p = dynamic_cast <const GGS_typeCppStarThisName *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeCppStarThisName, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeCppStarThisName::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeCppStarThisName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeCppThisInCategoryName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCppThisInCategoryName::
cPtr_typeCppThisInCategoryName (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCppThisInCategoryName * GGS_typeCppThisInCategoryName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCppThisInCategoryName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCppThisInCategoryName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCppThisInCategoryName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCppThisInCategoryName * ptr = dynamic_cast <const cPtr_typeCppThisInCategoryName *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableLocation.operator_isEqual (ptr->mVariableLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCppThisInCategoryName::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeCppThisInCategoryName:"
           << mVariableLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCppThisInCategoryName::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCppThisInCategoryName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCppThisInCategoryName (& typeid (cPtr_typeCppThisInCategoryName), & typeid (cPtr_typeCplusPlusName), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeCppThisInCategoryName::galgasRTTI (void) const {
  return & gClassInfoFor__typeCppThisInCategoryName ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeCppThisInCategoryName::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeCppThisInCategoryName (mVariableLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeCppThisInCategoryName'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeCppThisInCategoryName ("typeCppThisInCategoryName", true, & kTypeDescriptor_GGS_typeCplusPlusName) ;

//---------------------------------------------------------------------------*

GGS_typeCppThisInCategoryName::
GGS_typeCppThisInCategoryName (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCppThisInCategoryName::
GGS_typeCppThisInCategoryName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCppThisInCategoryName GGS_typeCppThisInCategoryName::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCppThisInCategoryName result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCppThisInCategoryName *> (inPointer) != NULL)
      : (typeid (cPtr_typeCppThisInCategoryName) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCppThisInCategoryName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCppThisInCategoryName),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCppThisInCategoryName GGS_typeCppThisInCategoryName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeCppThisInCategoryName result ;
  macroMyNew (result.mPointer, cPtr_typeCppThisInCategoryName (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCppThisInCategoryName::actualTypeName (void) const {
  return "typeCppThisInCategoryName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeCppThisInCategoryName ("typeCppThisInCategoryName", gClassInfoFor__typeCplusPlusName, & kTypeDescriptor_GGS_typeCppThisInCategoryName) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeCppThisInCategoryName::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeCppThisInCategoryName * p = NULL ;
    macroMyNew (p, GGS_typeCppThisInCategoryName (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCppThisInCategoryName GGS_typeCppThisInCategoryName::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeCppThisInCategoryName result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeCppThisInCategoryName * p = dynamic_cast <const GGS_typeCppThisInCategoryName *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeCppThisInCategoryName, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeCppThisInCategoryName::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeCppThisInCategoryName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeCppInheritedName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCppInheritedName::
cPtr_typeCppInheritedName (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCppInheritedName * GGS_typeCppInheritedName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCppInheritedName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCppInheritedName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCppInheritedName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCppInheritedName * ptr = dynamic_cast <const cPtr_typeCppInheritedName *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableLocation.operator_isEqual (ptr->mVariableLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCppInheritedName::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeCppInheritedName:"
           << mVariableLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCppInheritedName::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCppInheritedName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCppInheritedName (& typeid (cPtr_typeCppInheritedName), & typeid (cPtr_typeCplusPlusName), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeCppInheritedName::galgasRTTI (void) const {
  return & gClassInfoFor__typeCppInheritedName ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeCppInheritedName::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeCppInheritedName (mVariableLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCppInheritedName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeCppInheritedName ("typeCppInheritedName", true, & kTypeDescriptor_GGS_typeCplusPlusName) ;

//---------------------------------------------------------------------------*

GGS_typeCppInheritedName::
GGS_typeCppInheritedName (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCppInheritedName::
GGS_typeCppInheritedName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCppInheritedName GGS_typeCppInheritedName::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCppInheritedName result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCppInheritedName *> (inPointer) != NULL)
      : (typeid (cPtr_typeCppInheritedName) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCppInheritedName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCppInheritedName),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCppInheritedName GGS_typeCppInheritedName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeCppInheritedName result ;
  macroMyNew (result.mPointer, cPtr_typeCppInheritedName (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCppInheritedName::actualTypeName (void) const {
  return "typeCppInheritedName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeCppInheritedName ("typeCppInheritedName", gClassInfoFor__typeCplusPlusName, & kTypeDescriptor_GGS_typeCppInheritedName) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeCppInheritedName::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeCppInheritedName * p = NULL ;
    macroMyNew (p, GGS_typeCppInheritedName (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCppInheritedName GGS_typeCppInheritedName::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeCppInheritedName result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeCppInheritedName * p = dynamic_cast <const GGS_typeCppInheritedName *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeCppInheritedName, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeCppInheritedName::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeCppInheritedName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeAutomaticName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAutomaticName::
cPtr_typeAutomaticName (const GGS_location & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAutomaticName * GGS_typeAutomaticName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAutomaticName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAutomaticName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAutomaticName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAutomaticName * ptr = dynamic_cast <const cPtr_typeAutomaticName *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableLocation.operator_isEqual (ptr->mVariableLocation).boolValue ()
         && mName.operator_isEqual (ptr->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAutomaticName::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeAutomaticName:"
           << mVariableLocation.reader_description (inIndentation + 1)
           << mName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeAutomaticName::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeAutomaticName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeAutomaticName (& typeid (cPtr_typeAutomaticName), & typeid (cPtr_typeCplusPlusName), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeAutomaticName::galgasRTTI (void) const {
  return & gClassInfoFor__typeAutomaticName ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeAutomaticName::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeAutomaticName (mVariableLocation, mName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAutomaticName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeAutomaticName ("typeAutomaticName", true, & kTypeDescriptor_GGS_typeCplusPlusName) ;

//---------------------------------------------------------------------------*

GGS_typeAutomaticName::
GGS_typeAutomaticName (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAutomaticName::
GGS_typeAutomaticName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeAutomaticName GGS_typeAutomaticName::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeAutomaticName result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeAutomaticName *> (inPointer) != NULL)
      : (typeid (cPtr_typeAutomaticName) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeAutomaticName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeAutomaticName),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAutomaticName GGS_typeAutomaticName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeAutomaticName result ;
  macroMyNew (result.mPointer, cPtr_typeAutomaticName (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeAutomaticName::
reader_mName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAutomaticName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAutomaticName *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeAutomaticName::actualTypeName (void) const {
  return "typeAutomaticName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeAutomaticName ("typeAutomaticName", gClassInfoFor__typeCplusPlusName, & kTypeDescriptor_GGS_typeAutomaticName) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeAutomaticName::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeAutomaticName * p = NULL ;
    macroMyNew (p, GGS_typeAutomaticName (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAutomaticName GGS_typeAutomaticName::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeAutomaticName result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeAutomaticName * p = dynamic_cast <const GGS_typeAutomaticName *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeAutomaticName, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeAutomaticName::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeAutomaticName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeLocationAutomaticName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLocationAutomaticName::
cPtr_typeLocationAutomaticName (const GGS_location & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE),
mSequenceNumber (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLocationAutomaticName * GGS_typeLocationAutomaticName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLocationAutomaticName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLocationAutomaticName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLocationAutomaticName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLocationAutomaticName * ptr = dynamic_cast <const cPtr_typeLocationAutomaticName *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableLocation.operator_isEqual (ptr->mVariableLocation).boolValue ()
         && mSequenceNumber.operator_isEqual (ptr->mSequenceNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLocationAutomaticName::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeLocationAutomaticName:"
           << mVariableLocation.reader_description (inIndentation + 1)
           << mSequenceNumber.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLocationAutomaticName::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLocationAutomaticName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLocationAutomaticName (& typeid (cPtr_typeLocationAutomaticName), & typeid (cPtr_typeCplusPlusName), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLocationAutomaticName::galgasRTTI (void) const {
  return & gClassInfoFor__typeLocationAutomaticName ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLocationAutomaticName::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLocationAutomaticName (mVariableLocation, mSequenceNumber COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLocationAutomaticName'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLocationAutomaticName ("typeLocationAutomaticName", true, & kTypeDescriptor_GGS_typeCplusPlusName) ;

//---------------------------------------------------------------------------*

GGS_typeLocationAutomaticName::
GGS_typeLocationAutomaticName (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLocationAutomaticName::
GGS_typeLocationAutomaticName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLocationAutomaticName GGS_typeLocationAutomaticName::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLocationAutomaticName result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLocationAutomaticName *> (inPointer) != NULL)
      : (typeid (cPtr_typeLocationAutomaticName) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLocationAutomaticName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLocationAutomaticName),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLocationAutomaticName GGS_typeLocationAutomaticName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeLocationAutomaticName result ;
  macroMyNew (result.mPointer, cPtr_typeLocationAutomaticName (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLocationAutomaticName::actualTypeName (void) const {
  return "typeLocationAutomaticName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLocationAutomaticName ("typeLocationAutomaticName", gClassInfoFor__typeCplusPlusName, & kTypeDescriptor_GGS_typeLocationAutomaticName) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLocationAutomaticName::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLocationAutomaticName * p = NULL ;
    macroMyNew (p, GGS_typeLocationAutomaticName (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLocationAutomaticName GGS_typeLocationAutomaticName::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLocationAutomaticName result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLocationAutomaticName * p = dynamic_cast <const GGS_typeLocationAutomaticName *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLocationAutomaticName, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLocationAutomaticName::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLocationAutomaticName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeOperandName'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOperandName::
cPtr_typeOperandName (const GGS_location & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE),
mName (argument_1),
mFieldKind (argument_2),
mIteratorNewStyle (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOperandName * GGS_typeOperandName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOperandName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeOperandName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeOperandName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeOperandName * ptr = dynamic_cast <const cPtr_typeOperandName *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableLocation.operator_isEqual (ptr->mVariableLocation).boolValue ()
         && mName.operator_isEqual (ptr->mName).boolValue ()
         && mFieldKind.operator_isEqual (ptr->mFieldKind).boolValue ()
         && mIteratorNewStyle.operator_isEqual (ptr->mIteratorNewStyle).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeOperandName::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeOperandName:"
           << mVariableLocation.reader_description (inIndentation + 1)
           << mName.reader_description (inIndentation + 1)
           << mFieldKind.reader_description (inIndentation + 1)
           << mIteratorNewStyle.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeOperandName::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeOperandName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeOperandName (& typeid (cPtr_typeOperandName), & typeid (cPtr_typeCplusPlusName), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeOperandName::galgasRTTI (void) const {
  return & gClassInfoFor__typeOperandName ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeOperandName::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeOperandName (mVariableLocation, mName, mFieldKind, mIteratorNewStyle COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOperandName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeOperandName ("typeOperandName", true, & kTypeDescriptor_GGS_typeCplusPlusName) ;

//---------------------------------------------------------------------------*

GGS_typeOperandName::
GGS_typeOperandName (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeOperandName::
GGS_typeOperandName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeOperandName GGS_typeOperandName::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeOperandName result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeOperandName *> (inPointer) != NULL)
      : (typeid (cPtr_typeOperandName) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeOperandName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeOperandName),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeOperandName GGS_typeOperandName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1,
                 const GGS_bool& argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeOperandName result ;
  macroMyNew (result.mPointer, cPtr_typeOperandName (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeOperandName::actualTypeName (void) const {
  return "typeOperandName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeOperandName ("typeOperandName", gClassInfoFor__typeCplusPlusName, & kTypeDescriptor_GGS_typeOperandName) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeOperandName::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeOperandName * p = NULL ;
    macroMyNew (p, GGS_typeOperandName (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeOperandName GGS_typeOperandName::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeOperandName result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeOperandName * p = dynamic_cast <const GGS_typeOperandName *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeOperandName, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeOperandName::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeOperandName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_typeKeyName'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeKeyName::
cPtr_typeKeyName (const GGS_location & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE),
mIteratorNewStyle (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeKeyName * GGS_typeKeyName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeKeyName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeKeyName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeKeyName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeKeyName * ptr = dynamic_cast <const cPtr_typeKeyName *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableLocation.operator_isEqual (ptr->mVariableLocation).boolValue ()
         && mIteratorNewStyle.operator_isEqual (ptr->mIteratorNewStyle).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeKeyName::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeKeyName:"
           << mVariableLocation.reader_description (inIndentation + 1)
           << mIteratorNewStyle.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeKeyName::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeKeyName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeKeyName (& typeid (cPtr_typeKeyName), & typeid (cPtr_typeCplusPlusName), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeKeyName::galgasRTTI (void) const {
  return & gClassInfoFor__typeKeyName ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeKeyName::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeKeyName (mVariableLocation, mIteratorNewStyle COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeKeyName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeKeyName ("typeKeyName", true, & kTypeDescriptor_GGS_typeCplusPlusName) ;

//---------------------------------------------------------------------------*

GGS_typeKeyName::
GGS_typeKeyName (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeKeyName::
GGS_typeKeyName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeKeyName GGS_typeKeyName::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeKeyName result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeKeyName *> (inPointer) != NULL)
      : (typeid (cPtr_typeKeyName) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeKeyName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeKeyName),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeKeyName GGS_typeKeyName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeKeyName result ;
  macroMyNew (result.mPointer, cPtr_typeKeyName (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeKeyName::actualTypeName (void) const {
  return "typeKeyName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeKeyName ("typeKeyName", gClassInfoFor__typeCplusPlusName, & kTypeDescriptor_GGS_typeKeyName) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeKeyName::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeKeyName * p = NULL ;
    macroMyNew (p, GGS_typeKeyName (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeKeyName GGS_typeKeyName::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeKeyName result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeKeyName * p = dynamic_cast <const GGS_typeKeyName *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeKeyName, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeKeyName::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeKeyName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_typeNullName'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNullName::
cPtr_typeNullName (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNullName * GGS_typeNullName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNullName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeNullName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeNullName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeNullName * ptr = dynamic_cast <const cPtr_typeNullName *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableLocation.operator_isEqual (ptr->mVariableLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeNullName::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeNullName:"
           << mVariableLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeNullName::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeNullName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeNullName (& typeid (cPtr_typeNullName), & typeid (cPtr_typeCplusPlusName), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeNullName::galgasRTTI (void) const {
  return & gClassInfoFor__typeNullName ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeNullName::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeNullName (mVariableLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeNullName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeNullName ("typeNullName", true, & kTypeDescriptor_GGS_typeCplusPlusName) ;

//---------------------------------------------------------------------------*

GGS_typeNullName::
GGS_typeNullName (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeNullName::
GGS_typeNullName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeNullName GGS_typeNullName::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeNullName result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeNullName *> (inPointer) != NULL)
      : (typeid (cPtr_typeNullName) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeNullName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeNullName),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeNullName GGS_typeNullName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeNullName result ;
  macroMyNew (result.mPointer, cPtr_typeNullName (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeNullName::actualTypeName (void) const {
  return "typeNullName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeNullName ("typeNullName", gClassInfoFor__typeCplusPlusName, & kTypeDescriptor_GGS_typeNullName) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeNullName::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeNullName * p = NULL ;
    macroMyNew (p, GGS_typeNullName (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeNullName GGS_typeNullName::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeNullName result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeNullName * p = dynamic_cast <const GGS_typeNullName *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeNullName, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeNullName::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeNullName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeListeTypesEtNomsArgMethode'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeTypesEtNomsArgMethode::
elementOf_GGS_typeListeTypesEtNomsArgMethode (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mFormalArgumentPassingMode (argument_1),
mCppName (argument_2),
mModeIn (argument_3),
mParameterName (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeTypesEtNomsArgMethode::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeTypesEtNomsArgMethode * ptr = dynamic_cast <const elementOf_GGS_typeListeTypesEtNomsArgMethode *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mFormalArgumentPassingMode.operator_isEqual (ptr->mFormalArgumentPassingMode).boolValue ()
         && mCppName.operator_isEqual (ptr->mCppName).boolValue ()
         && mModeIn.operator_isEqual (ptr->mModeIn).boolValue ()
         && mParameterName.operator_isEqual (ptr->mParameterName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeTypesEtNomsArgMethode::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mModeIn.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mParameterName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeTypesEtNomsArgMethode'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeListeTypesEtNomsArgMethode ("typeListeTypesEtNomsArgMethode", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_formalArgumentPassingMode& argument_1,
                    const GGS_typeCplusPlusName & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_lstring & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_formalArgumentPassingMode& argument_1,
                    const GGS_typeCplusPlusName & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_lstring & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode GGS_typeListeTypesEtNomsArgMethode::
operator_concat (const GGS_typeListeTypesEtNomsArgMethode & inOperand) const {
  GGS_typeListeTypesEtNomsArgMethode result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
dotAssign_operation (const GGS_typeListeTypesEtNomsArgMethode inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeListeTypesEtNomsArgMethode * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_formalArgumentPassingMode p_1 = p->mFormalArgumentPassingMode ;
          GGS_typeCplusPlusName  p_2 = p->mCppName ;
          GGS_bool p_3 = p->mModeIn ;
          GGS_lstring  p_4 = p->mParameterName ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_formalArgumentPassingMode& argument_1,
                     const GGS_typeCplusPlusName & argument_2,
                     const GGS_bool& argument_3,
                     const GGS_lstring & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mType,
                                ptr->mFormalArgumentPassingMode,
                                ptr->mCppName,
                                ptr->mModeIn,
                                ptr->mParameterName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_typeListeTypesEtNomsArgMethode::
constructor_emptyList (void) {
  GGS_typeListeTypesEtNomsArgMethode result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_typeListeTypesEtNomsArgMethode::
constructor_listWithValue (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4) {
  GGS_typeListeTypesEtNomsArgMethode result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
internalSubListWithRange (GGS_typeListeTypesEtNomsArgMethode & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mType, ptr->mFormalArgumentPassingMode, ptr->mCppName, ptr->mModeIn, ptr->mParameterName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode GGS_typeListeTypesEtNomsArgMethode::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeTypesEtNomsArgMethode result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode GGS_typeListeTypesEtNomsArgMethode::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeTypesEtNomsArgMethode result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeTypesEtNomsArgMethode::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeListeTypesEtNomsArgMethode", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
method_first (C_Compiler & inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_formalArgumentPassingMode& _out_1,
              GGS_typeCplusPlusName & _out_2,
              GGS_bool& _out_3,
              GGS_lstring & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
    _out_2 = ptr->mCppName ;
    _out_3 = ptr->mModeIn ;
    _out_4 = ptr->mParameterName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
method_last (C_Compiler & inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_formalArgumentPassingMode& _out_1,
             GGS_typeCplusPlusName & _out_2,
             GGS_bool& _out_3,
             GGS_lstring & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
    _out_2 = ptr->mCppName ;
    _out_3 = ptr->mModeIn ;
    _out_4 = ptr->mParameterName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_formalArgumentPassingMode& _out_1,
                 GGS_typeCplusPlusName & _out_2,
                 GGS_bool& _out_3,
                 GGS_lstring & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
    _out_2 = ptr->mCppName ;
    _out_3 = ptr->mModeIn ;
    _out_4 = ptr->mParameterName ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_popLast (C_Compiler & inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_formalArgumentPassingMode& _out_1,
                GGS_typeCplusPlusName & _out_2,
                GGS_bool& _out_3,
                GGS_lstring & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
    _out_2 = ptr->mCppName ;
    _out_3 = ptr->mModeIn ;
    _out_4 = ptr->mParameterName ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeListeTypesEtNomsArgMethode::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_galgasType  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingMode GGS_typeListeTypesEtNomsArgMethode::
reader_mFormalArgumentPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalArgumentPassingMode result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeListeTypesEtNomsArgMethode::
reader_mCppNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusName  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCppName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeTypesEtNomsArgMethode::
reader_mModeInAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mModeIn ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeListeTypesEtNomsArgMethode::
reader_mParameterNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mParameterName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_AC_galgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_setMFormalArgumentPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_formalArgumentPassingMode & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_setMCppNameAtIndex (C_Compiler & inLexique,
                              const GGS_typeCplusPlusName  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCppName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_setMModeInAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mModeIn = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_setMParameterNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mParameterName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeListeTypesEtNomsArgMethode::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalArgumentPassingMode & GGS_typeListeTypesEtNomsArgMethode::cEnumerator::_mFormalArgumentPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentPassingMode ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCplusPlusName  & GGS_typeListeTypesEtNomsArgMethode::cEnumerator::_mCppName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCppName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_typeListeTypesEtNomsArgMethode::cEnumerator::_mModeIn (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mModeIn ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeListeTypesEtNomsArgMethode::cEnumerator::_mParameterName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mParameterName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeListeTypesEtNomsArgMethode::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeListeTypesEtNomsArgMethode * p = NULL ;
    macroMyNew (p, GGS_typeListeTypesEtNomsArgMethode (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode GGS_typeListeTypesEtNomsArgMethode::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeListeTypesEtNomsArgMethode result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeListeTypesEtNomsArgMethode * p = dynamic_cast <const GGS_typeListeTypesEtNomsArgMethode *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeListeTypesEtNomsArgMethode, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeListeTypesEtNomsArgMethode::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeListeTypesEtNomsArgMethode ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@typeSuperClassesMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeSuperClassesMap ("typeSuperClassesMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeSuperClassesMap::
elementOf_GGS_typeSuperClassesMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeSuperClassesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSuperClassesMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeSuperClassesMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeSuperClassesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeSuperClassesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeSuperClassesMap * info = (e_typeSuperClassesMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeSuperClassesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeSuperClassesMap * info = (e_typeSuperClassesMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSuperClassesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeSuperClassesMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSuperClassesMap::
operator_isEqual (const GGS_typeSuperClassesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSuperClassesMap::
operator_isNotEqual (const GGS_typeSuperClassesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeSuperClassesMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeSuperClassesMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('f'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('u'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeSuperClassesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSuperClassesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSuperClassesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSuperClassesMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeSuperClassesMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeSuperClassesMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeSuperClassesMap * p = NULL ;
    macroMyNew (p, GGS_typeSuperClassesMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeSuperClassesMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeSuperClassesMap * p = dynamic_cast <const GGS_typeSuperClassesMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeSuperClassesMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeSuperClassesMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeSuperClassesMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeAttributsSemantiques'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeAttributsSemantiques::
elementOf_GGS_typeListeAttributsSemantiques (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributType (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeAttributsSemantiques::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeAttributsSemantiques * ptr = dynamic_cast <const elementOf_GGS_typeListeAttributsSemantiques *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributType.operator_isEqual (ptr->mAttributType).boolValue ()
         && mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeAttributsSemantiques::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeAttributsSemantiques'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeListeAttributsSemantiques ("typeListeAttributsSemantiques", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques GGS_typeListeAttributsSemantiques::
operator_concat (const GGS_typeListeAttributsSemantiques & inOperand) const {
  GGS_typeListeAttributsSemantiques result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
dotAssign_operation (const GGS_typeListeAttributsSemantiques inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeListeAttributsSemantiques * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mAttributType ;
          GGS_lstring  p_1 = p->mAttributeName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAttributType,
                                ptr->mAttributeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeListeAttributsSemantiques::
constructor_emptyList (void) {
  GGS_typeListeAttributsSemantiques result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeListeAttributsSemantiques::
constructor_listWithValue (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_typeListeAttributsSemantiques result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
internalSubListWithRange (GGS_typeListeAttributsSemantiques & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributType, ptr->mAttributeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques GGS_typeListeAttributsSemantiques::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques GGS_typeListeAttributsSemantiques::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeAttributsSemantiques::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeListeAttributsSemantiques", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
method_first (C_Compiler & inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributType ;
    _out_1 = ptr->mAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
method_last (C_Compiler & inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributType ;
    _out_1 = ptr->mAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributType ;
    _out_1 = ptr->mAttributeName ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
modifier_popLast (C_Compiler & inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributType ;
    _out_1 = ptr->mAttributeName ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeListeAttributsSemantiques::
reader_mAttributTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_galgasType  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeListeAttributsSemantiques::
reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
modifier_setMAttributTypeAtIndex (C_Compiler & inLexique,
                              const GGS_AC_galgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeListeAttributsSemantiques::cEnumerator::_mAttributType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeListeAttributsSemantiques::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeListeAttributsSemantiques::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeListeAttributsSemantiques * p = NULL ;
    macroMyNew (p, GGS_typeListeAttributsSemantiques (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques GGS_typeListeAttributsSemantiques::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeListeAttributsSemantiques result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeListeAttributsSemantiques * p = dynamic_cast <const GGS_typeListeAttributsSemantiques *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeListeAttributsSemantiques, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeListeAttributsSemantiques::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeListeAttributsSemantiques ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@typeTypesList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTypesList::
elementOf_GGS_typeTypesList (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mEndOfExpressionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTypesList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeTypesList * ptr = dynamic_cast <const elementOf_GGS_typeTypesList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mEndOfExpressionLocation.operator_isEqual (ptr->mEndOfExpressionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTypesList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfExpressionLocation.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@typeTypesList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTypesList ("typeTypesList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeTypesList GGS_typeTypesList::
operator_concat (const GGS_typeTypesList & inOperand) const {
  GGS_typeTypesList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
dotAssign_operation (const GGS_typeTypesList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeTypesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_location  p_1 = p->mEndOfExpressionLocation ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mType,
                                ptr->mEndOfExpressionLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeTypesList  GGS_typeTypesList::
constructor_emptyList (void) {
  GGS_typeTypesList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTypesList  GGS_typeTypesList::
constructor_listWithValue (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  GGS_typeTypesList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
internalSubListWithRange (GGS_typeTypesList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mType, ptr->mEndOfExpressionLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeTypesList GGS_typeTypesList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeTypesList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTypesList GGS_typeTypesList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeTypesList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTypesList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeTypesList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
method_first (C_Compiler & inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_location & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mEndOfExpressionLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
method_last (C_Compiler & inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_location & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mEndOfExpressionLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_location & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mEndOfExpressionLocation ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
modifier_popLast (C_Compiler & inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_location & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mEndOfExpressionLocation ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeTypesList::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_galgasType  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeTypesList::
reader_mEndOfExpressionLocationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfExpressionLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_AC_galgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
modifier_setMEndOfExpressionLocationAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfExpressionLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeTypesList::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_typeTypesList::cEnumerator::_mEndOfExpressionLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndOfExpressionLocation ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeTypesList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTypesList * p = NULL ;
    macroMyNew (p, GGS_typeTypesList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTypesList GGS_typeTypesList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTypesList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTypesList * p = dynamic_cast <const GGS_typeTypesList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTypesList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTypesList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTypesList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_EXsignature'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_EXsignature::
elementOf_GGS_L_EXsignature (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mFormalArgumentPassingMode (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_EXsignature::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_EXsignature * ptr = dynamic_cast <const elementOf_GGS_L_EXsignature *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mFormalArgumentPassingMode.operator_isEqual (ptr->mFormalArgumentPassingMode).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_EXsignature::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_EXsignature'                            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_EXsignature ("L_EXsignature", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_formalArgumentPassingMode& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_formalArgumentPassingMode& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature GGS_L_EXsignature::
operator_concat (const GGS_L_EXsignature & inOperand) const {
  GGS_L_EXsignature result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
dotAssign_operation (const GGS_L_EXsignature inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_EXsignature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_formalArgumentPassingMode p_1 = p->mFormalArgumentPassingMode ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_formalArgumentPassingMode& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mType,
                                ptr->mFormalArgumentPassingMode
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_L_EXsignature::
constructor_emptyList (void) {
  GGS_L_EXsignature result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_L_EXsignature::
constructor_listWithValue (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) {
  GGS_L_EXsignature result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
internalSubListWithRange (GGS_L_EXsignature & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mType, ptr->mFormalArgumentPassingMode) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature GGS_L_EXsignature::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_EXsignature result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature GGS_L_EXsignature::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_EXsignature result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_EXsignature::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_EXsignature", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
method_first (C_Compiler & inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_formalArgumentPassingMode& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
method_last (C_Compiler & inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_formalArgumentPassingMode& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_formalArgumentPassingMode& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
modifier_popLast (C_Compiler & inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_formalArgumentPassingMode& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_L_EXsignature::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_galgasType  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingMode GGS_L_EXsignature::
reader_mFormalArgumentPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalArgumentPassingMode result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_AC_galgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
modifier_setMFormalArgumentPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_formalArgumentPassingMode & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_L_EXsignature::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalArgumentPassingMode & GGS_L_EXsignature::cEnumerator::_mFormalArgumentPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentPassingMode ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_EXsignature::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_EXsignature * p = NULL ;
    macroMyNew (p, GGS_L_EXsignature (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature GGS_L_EXsignature::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_EXsignature result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_EXsignature * p = dynamic_cast <const GGS_L_EXsignature *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_EXsignature, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_EXsignature::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_EXsignature ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Class for 'categoryMethodKind' Enumeration                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_categoryMethodKind ("categoryMethodKind", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_categoryMethodKind::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodKind::
operator_isEqual (const GGS_categoryMethodKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodKind::
operator_isNotEqual (const GGS_categoryMethodKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodKind::
operator_infOrEqual (const GGS_categoryMethodKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodKind::
operator_supOrEqual (const GGS_categoryMethodKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodKind::
operator_strictInf (const GGS_categoryMethodKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodKind::
operator_strictSup (const GGS_categoryMethodKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryMethodKind::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @categoryMethodKind" ;
  switch (mValue) {
  case enum_abstractMethod:
    s << " abstractMethod>" ;
    break ;
  case enum_baseMethod:
    s << " baseMethod>" ;
    break ;
  case enum_overridingMethod:
    s << " overridingMethod>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_categoryMethodKind::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_categoryMethodKind * p = NULL ;
    macroMyNew (p, GGS_categoryMethodKind (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodKind GGS_categoryMethodKind::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_categoryMethodKind result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_categoryMethodKind * p = dynamic_cast <const GGS_categoryMethodKind *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_categoryMethodKind, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_categoryMethodKind::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_categoryMethodKind ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_EXcategoryMethodMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_EXcategoryMethodMap::e_EXcategoryMethodMap (void) :
mCategoryMethodKind (),
aListeArgumentsFormels () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@EXcategoryMethodMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EXcategoryMethodMap ("EXcategoryMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_EXcategoryMethodMap::
elementOf_GGS_EXcategoryMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_EXcategoryMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_EXcategoryMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mCategoryMethodKind.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aListeArgumentsFormels.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_EXcategoryMethodMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_EXcategoryMethodMap * ptr = dynamic_cast <const elementOf_GGS_EXcategoryMethodMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mCategoryMethodKind.operator_isEqual (ptr->mInfo.mCategoryMethodKind)).boolValue ()
           && (mInfo.aListeArgumentsFormels.operator_isEqual (ptr->mInfo.aListeArgumentsFormels)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_EXcategoryMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_EXcategoryMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_EXcategoryMethodMap * info = (e_EXcategoryMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_EXcategoryMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_EXcategoryMethodMap * info = (e_EXcategoryMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryMethodMap GGS_EXcategoryMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXcategoryMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_EXcategoryMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXcategoryMethodMap::
operator_isEqual (const GGS_EXcategoryMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXcategoryMethodMap::
operator_isNotEqual (const GGS_EXcategoryMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_categoryMethodKind& inParameter0,
                const GGS_L_EXsignature & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_EXcategoryMethodMap info  ;
    info.mCategoryMethodKind = inParameter0 ;
    info.aListeArgumentsFormels = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_categoryMethodKind  & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mCategoryMethodKind ;
    outParameter1 = node->mInfo.aListeArgumentsFormels ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXcategoryMethodMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('g'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_categoryMethodKind  & outParameter0,
                                GGS_L_EXsignature   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXcategoryMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('g'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_categoryMethodKind& inParameter0,
                                const GGS_L_EXsignature & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryMethodMap GGS_EXcategoryMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_EXcategoryMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXcategoryMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryMethodMap GGS_EXcategoryMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_EXcategoryMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXcategoryMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @EXcategoryMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_categoryMethodKind & GGS_EXcategoryMethodMap::cEnumerator::_mCategoryMethodKind (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mCategoryMethodKind ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_EXcategoryMethodMap::cEnumerator::_aListeArgumentsFormels (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aListeArgumentsFormels ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_EXcategoryMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EXcategoryMethodMap * p = NULL ;
    macroMyNew (p, GGS_EXcategoryMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryMethodMap GGS_EXcategoryMethodMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EXcategoryMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EXcategoryMethodMap * p = dynamic_cast <const GGS_EXcategoryMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EXcategoryMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EXcategoryMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EXcategoryMethodMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_EXcategoryReaderMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_EXcategoryReaderMap::e_EXcategoryReaderMap (void) :
mCategoryMethodKind (),
aListeArgumentsFormels (),
mReturnedType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@EXcategoryReaderMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EXcategoryReaderMap ("EXcategoryReaderMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_EXcategoryReaderMap::
elementOf_GGS_EXcategoryReaderMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_EXcategoryReaderMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_EXcategoryReaderMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mCategoryMethodKind.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aListeArgumentsFormels.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReturnedType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_EXcategoryReaderMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_EXcategoryReaderMap * ptr = dynamic_cast <const elementOf_GGS_EXcategoryReaderMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mCategoryMethodKind.operator_isEqual (ptr->mInfo.mCategoryMethodKind)).boolValue ()
           && (mInfo.aListeArgumentsFormels.operator_isEqual (ptr->mInfo.aListeArgumentsFormels)).boolValue ()
           && (mInfo.mReturnedType.operator_isEqual (ptr->mInfo.mReturnedType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_EXcategoryReaderMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_EXcategoryReaderMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_EXcategoryReaderMap * info = (e_EXcategoryReaderMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryReaderMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_EXcategoryReaderMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_EXcategoryReaderMap * info = (e_EXcategoryReaderMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryReaderMap GGS_EXcategoryReaderMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXcategoryReaderMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryReaderMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_EXcategoryReaderMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXcategoryReaderMap::
operator_isEqual (const GGS_EXcategoryReaderMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXcategoryReaderMap::
operator_isNotEqual (const GGS_EXcategoryReaderMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryReaderMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryReaderMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_categoryMethodKind& inParameter0,
                const GGS_L_EXsignature & inParameter1,
                const GGS_AC_galgasType & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_EXcategoryReaderMap info  ;
    info.mCategoryMethodKind = inParameter0 ;
    info.aListeArgumentsFormels = inParameter1 ;
    info.mReturnedType = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryReaderMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_categoryMethodKind  & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_AC_galgasType   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mCategoryMethodKind ;
    outParameter1 = node->mInfo.aListeArgumentsFormels ;
    outParameter2 = node->mInfo.mReturnedType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXcategoryReaderMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('g'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXcategoryReaderMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_categoryMethodKind  & outParameter0,
                                GGS_L_EXsignature   & outParameter1,
                                GGS_AC_galgasType   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXcategoryReaderMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('g'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXcategoryReaderMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_categoryMethodKind& inParameter0,
                                const GGS_L_EXsignature & inParameter1,
                                const GGS_AC_galgasType & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryReaderMap GGS_EXcategoryReaderMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_EXcategoryReaderMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXcategoryReaderMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryReaderMap GGS_EXcategoryReaderMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_EXcategoryReaderMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXcategoryReaderMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @EXcategoryReaderMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_categoryMethodKind & GGS_EXcategoryReaderMap::cEnumerator::_mCategoryMethodKind (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mCategoryMethodKind ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_EXcategoryReaderMap::cEnumerator::_aListeArgumentsFormels (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aListeArgumentsFormels ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_EXcategoryReaderMap::cEnumerator::_mReturnedType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReturnedType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_EXcategoryReaderMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EXcategoryReaderMap * p = NULL ;
    macroMyNew (p, GGS_EXcategoryReaderMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryReaderMap GGS_EXcategoryReaderMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EXcategoryReaderMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EXcategoryReaderMap * p = dynamic_cast <const GGS_EXcategoryReaderMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EXcategoryReaderMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EXcategoryReaderMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EXcategoryReaderMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_EXcategoryTemplateMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_EXcategoryTemplateMap::e_EXcategoryTemplateMap (void) :
mCategoryMethodKind (),
aListeArgumentsFormels () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@EXcategoryTemplateMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EXcategoryTemplateMap ("EXcategoryTemplateMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_EXcategoryTemplateMap::
elementOf_GGS_EXcategoryTemplateMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_EXcategoryTemplateMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_EXcategoryTemplateMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mCategoryMethodKind.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aListeArgumentsFormels.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_EXcategoryTemplateMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_EXcategoryTemplateMap * ptr = dynamic_cast <const elementOf_GGS_EXcategoryTemplateMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mCategoryMethodKind.operator_isEqual (ptr->mInfo.mCategoryMethodKind)).boolValue ()
           && (mInfo.aListeArgumentsFormels.operator_isEqual (ptr->mInfo.aListeArgumentsFormels)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_EXcategoryTemplateMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_EXcategoryTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_EXcategoryTemplateMap * info = (e_EXcategoryTemplateMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryTemplateMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_EXcategoryTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_EXcategoryTemplateMap * info = (e_EXcategoryTemplateMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryTemplateMap GGS_EXcategoryTemplateMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXcategoryTemplateMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryTemplateMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_EXcategoryTemplateMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXcategoryTemplateMap::
operator_isEqual (const GGS_EXcategoryTemplateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXcategoryTemplateMap::
operator_isNotEqual (const GGS_EXcategoryTemplateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryTemplateMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryTemplateMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_categoryMethodKind& inParameter0,
                const GGS_L_EXsignature & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_EXcategoryTemplateMap info  ;
    info.mCategoryMethodKind = inParameter0 ;
    info.aListeArgumentsFormels = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryTemplateMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_categoryMethodKind  & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mCategoryMethodKind ;
    outParameter1 = node->mInfo.aListeArgumentsFormels ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXcategoryTemplateMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('g'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXcategoryTemplateMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_categoryMethodKind  & outParameter0,
                                GGS_L_EXsignature   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXcategoryTemplateMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('g'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXcategoryTemplateMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_categoryMethodKind& inParameter0,
                                const GGS_L_EXsignature & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryTemplateMap GGS_EXcategoryTemplateMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_EXcategoryTemplateMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXcategoryTemplateMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryTemplateMap GGS_EXcategoryTemplateMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_EXcategoryTemplateMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXcategoryTemplateMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @EXcategoryTemplateMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_categoryMethodKind & GGS_EXcategoryTemplateMap::cEnumerator::_mCategoryMethodKind (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mCategoryMethodKind ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_EXcategoryTemplateMap::cEnumerator::_aListeArgumentsFormels (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aListeArgumentsFormels ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_EXcategoryTemplateMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EXcategoryTemplateMap * p = NULL ;
    macroMyNew (p, GGS_EXcategoryTemplateMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryTemplateMap GGS_EXcategoryTemplateMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EXcategoryTemplateMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EXcategoryTemplateMap * p = dynamic_cast <const GGS_EXcategoryTemplateMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EXcategoryTemplateMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EXcategoryTemplateMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EXcategoryTemplateMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_actualParametersSignature'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_actualParametersSignature::
elementOf_GGS_L_actualParametersSignature (const GGS_AC_galgasType & argument_0,
                                const GGS_EXactualParametersPassingMode& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mFormalArgumentPassingMode (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_actualParametersSignature::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_actualParametersSignature * ptr = dynamic_cast <const elementOf_GGS_L_actualParametersSignature *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mFormalArgumentPassingMode.operator_isEqual (ptr->mFormalArgumentPassingMode).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_actualParametersSignature::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@L_actualParametersSignature'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_actualParametersSignature ("L_actualParametersSignature", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_EXactualParametersPassingMode& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_EXactualParametersPassingMode& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_EXactualParametersPassingMode& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature GGS_L_actualParametersSignature::
operator_concat (const GGS_L_actualParametersSignature & inOperand) const {
  GGS_L_actualParametersSignature result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
dotAssign_operation (const GGS_L_actualParametersSignature inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_actualParametersSignature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_EXactualParametersPassingMode p_1 = p->mFormalArgumentPassingMode ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_EXactualParametersPassingMode& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mType,
                                ptr->mFormalArgumentPassingMode
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature  GGS_L_actualParametersSignature::
constructor_emptyList (void) {
  GGS_L_actualParametersSignature result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature  GGS_L_actualParametersSignature::
constructor_listWithValue (const GGS_AC_galgasType & argument_0,
                                const GGS_EXactualParametersPassingMode& argument_1) {
  GGS_L_actualParametersSignature result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
internalSubListWithRange (GGS_L_actualParametersSignature & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mType, ptr->mFormalArgumentPassingMode) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature GGS_L_actualParametersSignature::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_actualParametersSignature result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature GGS_L_actualParametersSignature::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_actualParametersSignature result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_actualParametersSignature::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_actualParametersSignature", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
method_first (C_Compiler & inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_EXactualParametersPassingMode& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
method_last (C_Compiler & inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_EXactualParametersPassingMode& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_EXactualParametersPassingMode& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
modifier_popLast (C_Compiler & inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_EXactualParametersPassingMode& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_L_actualParametersSignature::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_galgasType  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXactualParametersPassingMode GGS_L_actualParametersSignature::
reader_mFormalArgumentPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_EXactualParametersPassingMode result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_AC_galgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
modifier_setMFormalArgumentPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_EXactualParametersPassingMode & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_L_actualParametersSignature::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_EXactualParametersPassingMode & GGS_L_actualParametersSignature::cEnumerator::_mFormalArgumentPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentPassingMode ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_actualParametersSignature::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_actualParametersSignature * p = NULL ;
    macroMyNew (p, GGS_L_actualParametersSignature (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature GGS_L_actualParametersSignature::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_actualParametersSignature result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_actualParametersSignature * p = dynamic_cast <const GGS_L_actualParametersSignature *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_actualParametersSignature, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_actualParametersSignature::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_actualParametersSignature ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_M_accessors_map'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_accessors_map::e_M_accessors_map (void) :
mAccessorSignature (),
mReturnedType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@M_accessors_map'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_accessors_map ("M_accessors_map", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_accessors_map::
elementOf_GGS_M_accessors_map (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_accessors_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_accessors_map::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAccessorSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReturnedType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_accessors_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_accessors_map * ptr = dynamic_cast <const elementOf_GGS_M_accessors_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mAccessorSignature.operator_isEqual (ptr->mInfo.mAccessorSignature)).boolValue ()
           && (mInfo.mReturnedType.operator_isEqual (ptr->mInfo.mReturnedType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_accessors_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_accessors_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_accessors_map * info = (e_M_accessors_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_accessors_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_accessors_map * info = (e_M_accessors_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_accessors_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_accessors_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_accessors_map::
operator_isEqual (const GGS_M_accessors_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_accessors_map::
operator_isNotEqual (const GGS_M_accessors_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                const GGS_AC_galgasType & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_accessors_map info  ;
    info.mAccessorSignature = inParameter0 ;
    info.mReturnedType = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mAccessorSignature ;
    outParameter1 = node->mInfo.mReturnedType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_accessors_map::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_AC_galgasType   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_accessors_map::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_AC_galgasType & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_accessors_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_accessors_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_accessors_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_accessors_map::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_accessors_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_M_accessors_map::cEnumerator::_mAccessorSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAccessorSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_M_accessors_map::cEnumerator::_mReturnedType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReturnedType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_accessors_map::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_accessors_map * p = NULL ;
    macroMyNew (p, GGS_M_accessors_map (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_accessors_map result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_accessors_map * p = dynamic_cast <const GGS_M_accessors_map *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_accessors_map, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_accessors_map::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_accessors_map ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeGalgas_jokerInParameterList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_jokerInParameterList::
cPtr_typeGalgas_jokerInParameterList (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_jokerInParameterList * GGS_typeGalgas_jokerInParameterList::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_jokerInParameterList *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_jokerInParameterList::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_jokerInParameterList::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_jokerInParameterList::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_jokerInParameterList:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_jokerInParameterList::
static_string_message_messageGalgasType (void) {
  return "\?\?" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_jokerInParameterList::
message_messageGalgasType (void) const {
  return "\?\?" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_jokerInParameterList::
instanceMessage (void) const {
  return "a joker" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_jokerInParameterList::
_static_message (void) {
  return "a joker" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_jokerInParameterList (& typeid (cPtr_typeGalgas_jokerInParameterList), & typeid (cPtr_AC_galgasType), "a joker") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_jokerInParameterList::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_jokerInParameterList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeGalgas_jokerInParameterList'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_jokerInParameterList ("typeGalgas_jokerInParameterList", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_jokerInParameterList::
GGS_typeGalgas_jokerInParameterList (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_jokerInParameterList::
GGS_typeGalgas_jokerInParameterList (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_jokerInParameterList GGS_typeGalgas_jokerInParameterList::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_jokerInParameterList result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_jokerInParameterList) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_jokerInParameterList (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_jokerInParameterList),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_jokerInParameterList * gSingleton_typeGalgas_jokerInParameterList = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_jokerInParameterList (void) {
  macroDetachPointer (gSingleton_typeGalgas_jokerInParameterList, cPtr_typeGalgas_jokerInParameterList) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_jokerInParameterList GGS_typeGalgas_jokerInParameterList::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_jokerInParameterList result ;
  if (NULL == gSingleton_typeGalgas_jokerInParameterList) {
    macroMyNew (gSingleton_typeGalgas_jokerInParameterList, cPtr_typeGalgas_jokerInParameterList (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_jokerInParameterList) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_jokerInParameterList) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_jokerInParameterList::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_jokerInParameterList * p = (cPtr_typeGalgas_jokerInParameterList *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_jokerInParameterList::actualTypeName (void) const {
  return "typeGalgas_jokerInParameterList" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_jokerInParameterList ("typeGalgas_jokerInParameterList", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_jokerInParameterList) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_jokerInParameterList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_jokerInParameterList * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_jokerInParameterList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_jokerInParameterList GGS_typeGalgas_jokerInParameterList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_jokerInParameterList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_jokerInParameterList * p = dynamic_cast <const GGS_typeGalgas_jokerInParameterList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_jokerInParameterList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_jokerInParameterList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_jokerInParameterList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeGalgas_bool'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_bool::
cPtr_typeGalgas_bool (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_bool * GGS_typeGalgas_bool::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_bool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_bool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_bool::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("bool") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_bool:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_bool::
static_string_message_messageGalgasType (void) {
  return "a '@bool' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_bool::
message_messageGalgasType (void) const {
  return "a '@bool' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_bool::
instanceMessage (void) const {
  return "a '@bool' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_bool::
_static_message (void) {
  return "a '@bool' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_bool (& typeid (cPtr_typeGalgas_bool), & typeid (cPtr_AC_galgasType), "a '@bool' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_bool::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_bool ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_bool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_bool ("typeGalgas_bool", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_bool::
GGS_typeGalgas_bool (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_bool::
GGS_typeGalgas_bool (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_bool GGS_typeGalgas_bool::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_bool result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_bool *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_bool) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_bool (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_bool),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_bool * gSingleton_typeGalgas_bool = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_bool (void) {
  macroDetachPointer (gSingleton_typeGalgas_bool, cPtr_typeGalgas_bool) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_bool GGS_typeGalgas_bool::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_bool result ;
  if (NULL == gSingleton_typeGalgas_bool) {
    macroMyNew (gSingleton_typeGalgas_bool, cPtr_typeGalgas_bool (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_bool) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_bool) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_bool::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_bool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_bool * p = (cPtr_typeGalgas_bool *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_bool::actualTypeName (void) const {
  return "typeGalgas_bool" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_bool ("typeGalgas_bool", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_bool) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_bool::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_bool * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_bool (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_bool GGS_typeGalgas_bool::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_bool result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_bool * p = dynamic_cast <const GGS_typeGalgas_bool *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_bool, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_bool::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_bool ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeGalgas_uint'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_uint::
cPtr_typeGalgas_uint (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_uint * GGS_typeGalgas_uint::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_uint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_uint *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_uint::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("uint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_handleIncrementOperatorCall (C_Compiler & /* inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_handleDecrementOperatorCall (C_Compiler & /* inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_uint (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_35540 = (((var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (837))).operator_isEqual (GGS_string ("max"))).operator_or ((var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (838))).operator_isEqual (GGS_string ("errorCount")))).operator_or ((var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (839))).operator_isEqual (GGS_string ("warningCount"))) ;
  if (cond_35540.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (cond_35540.isBuiltAndFalse ()) {
    const GGS_bool cond_35839 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (841))).operator_isEqual (GGS_string ("valueWithMask")) ;
    if (cond_35839.isBuiltAndTrue ()) {
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
    }else if (cond_35839.isBuiltAndFalse ()) {
      var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (847)) ;
      var_cas_outAccessorTypesList.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_uint:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint::
static_string_message_messageGalgasType (void) {
  return "a '@uint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint::
message_messageGalgasType (void) const {
  return "a '@uint' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint::
instanceMessage (void) const {
  return "a '@uint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint::
_static_message (void) {
  return "a '@uint' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_uint (& typeid (cPtr_typeGalgas_uint), & typeid (cPtr_AC_galgasType), "a '@uint' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_uint::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_uint ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_uint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_uint ("typeGalgas_uint", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint::
GGS_typeGalgas_uint (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint::
GGS_typeGalgas_uint (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_uint GGS_typeGalgas_uint::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_uint result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_uint *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_uint) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_uint (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_uint),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_uint * gSingleton_typeGalgas_uint = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_uint (void) {
  macroDetachPointer (gSingleton_typeGalgas_uint, cPtr_typeGalgas_uint) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint GGS_typeGalgas_uint::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_uint result ;
  if (NULL == gSingleton_typeGalgas_uint) {
    macroMyNew (gSingleton_typeGalgas_uint, cPtr_typeGalgas_uint (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_uint) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_uint) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_uint::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_uint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_uint * p = (cPtr_typeGalgas_uint *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_uint::actualTypeName (void) const {
  return "typeGalgas_uint" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_uint ("typeGalgas_uint", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_uint) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_uint::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_uint * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_uint (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint GGS_typeGalgas_uint::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_uint result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_uint * p = dynamic_cast <const GGS_typeGalgas_uint *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_uint, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_uint::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_uint ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeGalgas_char'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_char::
cPtr_typeGalgas_char (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_char * GGS_typeGalgas_char::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_char *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_char *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_char::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("char") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_char (this) ;
  const GGS_bool cond_36962 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (876))).operator_isEqual (GGS_string ("replacementCharacter")) ;
  if (cond_36962.isBuiltAndTrue ()) {
    var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (cond_36962.isBuiltAndFalse ()) {
    const GGS_bool cond_37244 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (879))).operator_isEqual (GGS_string ("unicodeCharacterWithUnsigned")) ;
    if (cond_37244.isBuiltAndTrue ()) {
      var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
    }else if (cond_37244.isBuiltAndFalse ()) {
      var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (885)) ;
      var_cas_outAccessorTypesList.drop () ;
      var_cas_outHasLexiqueAndLocationArguments.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_char:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_char::
static_string_message_messageGalgasType (void) {
  return "a '@char' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_char::
message_messageGalgasType (void) const {
  return "a '@char' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_char::
instanceMessage (void) const {
  return "a '@char' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_char::
_static_message (void) {
  return "a '@char' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_char (& typeid (cPtr_typeGalgas_char), & typeid (cPtr_AC_galgasType), "a '@char' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_char::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_char ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_char'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_char ("typeGalgas_char", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_char::
GGS_typeGalgas_char (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_char::
GGS_typeGalgas_char (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_char GGS_typeGalgas_char::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_char result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_char *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_char) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_char (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_char),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_char * gSingleton_typeGalgas_char = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_char (void) {
  macroDetachPointer (gSingleton_typeGalgas_char, cPtr_typeGalgas_char) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_char GGS_typeGalgas_char::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_char result ;
  if (NULL == gSingleton_typeGalgas_char) {
    macroMyNew (gSingleton_typeGalgas_char, cPtr_typeGalgas_char (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_char) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_char) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_char::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_char *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_char * p = (cPtr_typeGalgas_char *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_char::actualTypeName (void) const {
  return "typeGalgas_char" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_char ("typeGalgas_char", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_char) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_char::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_char * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_char (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_char GGS_typeGalgas_char::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_char result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_char * p = dynamic_cast <const GGS_typeGalgas_char *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_char, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_char::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_char ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_string'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_string::
cPtr_typeGalgas_string (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_string * GGS_typeGalgas_string::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_string *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_string *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_string::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("string") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_handleMethodInstructionCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outReaderSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string ("") ;
  const GGS_bool cond_38511 = (var_cas_inMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (917))).operator_isEqual (GGS_string ("writeToFile")) ;
  if (cond_38511.isBuiltAndTrue ()) {
    var_cas_outReaderSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outReaderSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
  }else if (cond_38511.isBuiltAndFalse ()) {
    const GGS_bool cond_38835 = (var_cas_inMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (920))).operator_isEqual (GGS_string ("writeToFileWhenDifferentContents")) ;
    if (cond_38835.isBuiltAndTrue ()) {
      var_cas_outReaderSignature = GGS_L_EXsignature ::constructor_emptyList () ;
      var_cas_outReaderSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
      var_cas_outReaderSignature.addAssign_operation (GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    }else if (cond_38835.isBuiltAndFalse ()) {
      const GGS_bool cond_39053 = (var_cas_inMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (924))).operator_isEqual (GGS_string ("writeToExecutableFile")) ;
      if (cond_39053.isBuiltAndTrue ()) {
        var_cas_outReaderSignature = GGS_L_EXsignature ::constructor_emptyList () ;
        var_cas_outReaderSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
      }else if (cond_39053.isBuiltAndFalse ()) {
        const GGS_bool cond_39277 = (var_cas_inMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (927))).operator_isEqual (GGS_string ("makeDirectoryAndWriteToFile")) ;
        if (cond_39277.isBuiltAndTrue ()) {
          var_cas_outReaderSignature = GGS_L_EXsignature ::constructor_emptyList () ;
          var_cas_outReaderSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
        }else if (cond_39277.isBuiltAndFalse ()) {
          const GGS_bool cond_39389 = (var_cas_inMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (930))).operator_isEqual (GGS_string ("makeDirectory")) ;
          if (cond_39389.isBuiltAndTrue ()) {
            var_cas_outReaderSignature = GGS_L_EXsignature ::constructor_emptyList () ;
          }else if (cond_39389.isBuiltAndFalse ()) {
            var_cas_inMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("this method is not defined (writeToFile, makeDirectoryAndWriteToFile")).operator_concat (GGS_string (" and makeDirectory methods are defined on @string objects) ")) COMMA_SOURCE_FILE_AT_LINE (935)) ;
            var_cas_outReaderSignature.drop () ;
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_string (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_40094 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (947))).operator_isEqual (GGS_string ("stringWithVersionString")) ;
  if (cond_40094.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (cond_40094.isBuiltAndFalse ()) {
    const GGS_bool cond_40241 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (949))).operator_isEqual (GGS_string ("stringWithSourceFilePath")) ;
    if (cond_40241.isBuiltAndTrue ()) {
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    }else if (cond_40241.isBuiltAndFalse ()) {
      const GGS_bool cond_40390 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (951))).operator_isEqual (GGS_string ("stringWithCurrentDirectory")) ;
      if (cond_40390.isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
      }else if (cond_40390.isBuiltAndFalse ()) {
        const GGS_bool cond_40707 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (953))).operator_isEqual (GGS_string ("stringWithSequenceOfCharacters")) ;
        if (cond_40707.isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
          var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_char ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
        }else if (cond_40707.isBuiltAndFalse ()) {
          const GGS_bool cond_40857 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (957))).operator_isEqual (GGS_string ("stringWithMainFirstArgument")) ;
          if (cond_40857.isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          }else if (cond_40857.isBuiltAndFalse ()) {
            const GGS_bool cond_41088 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (959))).operator_isEqual (GGS_string ("stringWithContentsOfFile")) ;
            if (cond_41088.isBuiltAndTrue ()) {
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
            }else if (cond_41088.isBuiltAndFalse ()) {
              const GGS_bool cond_41236 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (962))).operator_isEqual (GGS_string ("stringWithCurrentDateTime")) ;
              if (cond_41236.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              }else if (cond_41236.isBuiltAndFalse ()) {
                const GGS_bool cond_41472 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (964))).operator_isEqual (GGS_string ("stringWithEnvironmentVariable")) ;
                if (cond_41472.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                }else if (cond_41472.isBuiltAndFalse ()) {
                  const GGS_bool cond_41715 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (967))).operator_isEqual (GGS_string ("stringWithEnvironmentVariableOrEmpty")) ;
                  if (cond_41715.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                  }else if (cond_41715.isBuiltAndFalse ()) {
                    const GGS_bool cond_41852 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (970))).operator_isEqual (GGS_string ("CppLineComment")) ;
                    if (cond_41852.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    }else if (cond_41852.isBuiltAndFalse ()) {
                      const GGS_bool cond_42074 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (972))).operator_isEqual (GGS_string ("CppTitleComment")) ;
                      if (cond_42074.isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                      }else if (cond_42074.isBuiltAndFalse ()) {
                        const GGS_bool cond_42286 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (975))).operator_isEqual (GGS_string ("CppChar")) ;
                        if (cond_42286.isBuiltAndTrue ()) {
                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                          var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_char ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                        }else if (cond_42286.isBuiltAndFalse ()) {
                          const GGS_bool cond_42502 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (978))).operator_isEqual (GGS_string ("CppString")) ;
                          if (cond_42502.isBuiltAndTrue ()) {
                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                            var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                          }else if (cond_42502.isBuiltAndFalse ()) {
                            const GGS_bool cond_42819 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (981))).operator_isEqual (GGS_string ("componentsJoinedByString")) ;
                            if (cond_42819.isBuiltAndTrue ()) {
                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                              var_cas_outAccessorTypesList.addAssign_operation (function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (983)), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                              var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                            }else if (cond_42819.isBuiltAndFalse ()) {
                              var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (987)) ;
                              var_cas_outAccessorTypesList.drop () ;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_43307 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (996))).operator_isEqual (GGS_string ("setCapacity")) ;
  if (cond_43307.isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
  }else if (cond_43307.isBuiltAndFalse ()) {
    const GGS_bool cond_43522 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (999))).operator_isEqual (GGS_string ("incIndentation")) ;
    if (cond_43522.isBuiltAndTrue ()) {
      var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
      var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
    }else if (cond_43522.isBuiltAndFalse ()) {
      const GGS_bool cond_43737 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1002))).operator_isEqual (GGS_string ("decIndentation")) ;
      if (cond_43737.isBuiltAndTrue ()) {
        var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
        var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
      }else if (cond_43737.isBuiltAndFalse ()) {
        const GGS_bool cond_44053 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1005))).operator_isEqual (GGS_string ("setCharacterAtIndex")) ;
        if (cond_44053.isBuiltAndTrue ()) {
          var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
          var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_char ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
          var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
        }else if (cond_44053.isBuiltAndFalse ()) {
          var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this modifier is not defined") COMMA_SOURCE_FILE_AT_LINE (1012)) ;
          var_cas_outModifierSignature.drop () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_handleClassMethodCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inTypeMethodName,
                                GGS_L_EXsignature & var_cas_outTypeMethodSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_44579 = (var_cas_inTypeMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1021))).operator_isEqual (GGS_string ("deleteFile")) ;
  if (cond_44579.isBuiltAndTrue ()) {
    var_cas_outTypeMethodSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outTypeMethodSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
  }else if (cond_44579.isBuiltAndFalse ()) {
    const GGS_bool cond_44806 = (var_cas_inTypeMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1024))).operator_isEqual (GGS_string ("deleteFileIfExists")) ;
    if (cond_44806.isBuiltAndTrue ()) {
      var_cas_outTypeMethodSignature = GGS_L_EXsignature ::constructor_emptyList () ;
      var_cas_outTypeMethodSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
    }else if (cond_44806.isBuiltAndFalse ()) {
      const GGS_bool cond_45035 = (var_cas_inTypeMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1027))).operator_isEqual (GGS_string ("removeEmptyDirectory")) ;
      if (cond_45035.isBuiltAndTrue ()) {
        var_cas_outTypeMethodSignature = GGS_L_EXsignature ::constructor_emptyList () ;
        var_cas_outTypeMethodSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
      }else if (cond_45035.isBuiltAndFalse ()) {
        const GGS_bool cond_45270 = (var_cas_inTypeMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1030))).operator_isEqual (GGS_string ("removeDirectoryRecursively")) ;
        if (cond_45270.isBuiltAndTrue ()) {
          var_cas_outTypeMethodSignature = GGS_L_EXsignature ::constructor_emptyList () ;
          var_cas_outTypeMethodSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
        }else if (cond_45270.isBuiltAndFalse ()) {
          const GGS_bool cond_46096 = (var_cas_inTypeMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1033))).operator_isEqual (GGS_string ("generateFile")) ;
          if (cond_46096.isBuiltAndTrue ()) {
            var_cas_outTypeMethodSignature = GGS_L_EXsignature ::constructor_emptyList () ;
            var_cas_outTypeMethodSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
            var_cas_outTypeMethodSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
            var_cas_outTypeMethodSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
            var_cas_outTypeMethodSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
            var_cas_outTypeMethodSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
            var_cas_outTypeMethodSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
            var_cas_outTypeMethodSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
          }else if (cond_46096.isBuiltAndFalse ()) {
            var_cas_inTypeMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This type method is not defined") COMMA_SOURCE_FILE_AT_LINE (1044)) ;
            var_cas_outTypeMethodSignature.drop () ;
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_string:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_string::
static_string_message_messageGalgasType (void) {
  return "a '@string' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_string::
message_messageGalgasType (void) const {
  return "a '@string' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_string::
instanceMessage (void) const {
  return "a '@string' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_string::
_static_message (void) {
  return "a '@string' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_string (& typeid (cPtr_typeGalgas_string), & typeid (cPtr_AC_galgasType), "a '@string' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_string::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_string ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_string'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_string ("typeGalgas_string", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_string::
GGS_typeGalgas_string (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_string::
GGS_typeGalgas_string (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_string GGS_typeGalgas_string::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_string result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_string *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_string) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_string (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_string),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_string * gSingleton_typeGalgas_string = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_string (void) {
  macroDetachPointer (gSingleton_typeGalgas_string, cPtr_typeGalgas_string) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_string GGS_typeGalgas_string::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_string result ;
  if (NULL == gSingleton_typeGalgas_string) {
    macroMyNew (gSingleton_typeGalgas_string, cPtr_typeGalgas_string (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_string) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_string) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_string::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_string *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_string * p = (cPtr_typeGalgas_string *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_string::actualTypeName (void) const {
  return "typeGalgas_string" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_string ("typeGalgas_string", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_string) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_string::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_string * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_string (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_string GGS_typeGalgas_string::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_string result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_string * p = dynamic_cast <const GGS_typeGalgas_string *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_string, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_string::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_string ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeGalgas_sint'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_sint::
cPtr_typeGalgas_sint (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_sint * GGS_typeGalgas_sint::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_sint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_sint *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_sint::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("sint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_handleIncrementOperatorCall (C_Compiler & /* inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_handleDecrementOperatorCall (C_Compiler & /* inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_sint (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
  const GGS_bool cond_47502 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1086))).operator_isEqual (GGS_string ("min")) ;
  if (cond_47502.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (cond_47502.isBuiltAndFalse ()) {
    const GGS_bool cond_47627 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1088))).operator_isEqual (GGS_string ("max")) ;
    if (cond_47627.isBuiltAndTrue ()) {
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    }else if (cond_47627.isBuiltAndFalse ()) {
      var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1092)) ;
      var_cas_outAccessorTypesList.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_sint:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint::
static_string_message_messageGalgasType (void) {
  return "a '@sint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint::
message_messageGalgasType (void) const {
  return "a '@sint' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint::
instanceMessage (void) const {
  return "a '@sint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint::
_static_message (void) {
  return "a '@sint' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_sint (& typeid (cPtr_typeGalgas_sint), & typeid (cPtr_AC_galgasType), "a '@sint' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_sint::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_sint ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_sint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_sint ("typeGalgas_sint", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint::
GGS_typeGalgas_sint (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint::
GGS_typeGalgas_sint (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_sint GGS_typeGalgas_sint::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_sint result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_sint *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_sint) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_sint (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_sint),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_sint * gSingleton_typeGalgas_sint = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_sint (void) {
  macroDetachPointer (gSingleton_typeGalgas_sint, cPtr_typeGalgas_sint) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint GGS_typeGalgas_sint::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_sint result ;
  if (NULL == gSingleton_typeGalgas_sint) {
    macroMyNew (gSingleton_typeGalgas_sint, cPtr_typeGalgas_sint (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_sint) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_sint) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_sint::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_sint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_sint * p = (cPtr_typeGalgas_sint *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_sint::actualTypeName (void) const {
  return "typeGalgas_sint" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_sint ("typeGalgas_sint", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_sint) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_sint::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_sint * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_sint (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint GGS_typeGalgas_sint::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_sint result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_sint * p = dynamic_cast <const GGS_typeGalgas_sint *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_sint, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_sint::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_sint ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_sint64'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_sint64::
cPtr_typeGalgas_sint64 (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_sint64 * GGS_typeGalgas_sint64::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_sint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_sint64 *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_sint64::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("sint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_handleIncrementOperatorCall (C_Compiler & /* inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_handleDecrementOperatorCall (C_Compiler & /* inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_sint64 (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
  const GGS_bool cond_49032 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1134))).operator_isEqual (GGS_string ("min")) ;
  if (cond_49032.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (cond_49032.isBuiltAndFalse ()) {
    const GGS_bool cond_49157 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1136))).operator_isEqual (GGS_string ("max")) ;
    if (cond_49157.isBuiltAndTrue ()) {
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    }else if (cond_49157.isBuiltAndFalse ()) {
      var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1140)) ;
      var_cas_outAccessorTypesList.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_sint64:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint64::
static_string_message_messageGalgasType (void) {
  return "a '@sint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint64::
message_messageGalgasType (void) const {
  return "a '@sint64' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint64::
instanceMessage (void) const {
  return "a '@sint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint64::
_static_message (void) {
  return "a '@sint64' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_sint64 (& typeid (cPtr_typeGalgas_sint64), & typeid (cPtr_AC_galgasType), "a '@sint64' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_sint64::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_sint64 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_sint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_sint64 ("typeGalgas_sint64", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint64::
GGS_typeGalgas_sint64 (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint64::
GGS_typeGalgas_sint64 (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_sint64 GGS_typeGalgas_sint64::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_sint64 result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_sint64 *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_sint64) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_sint64 (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_sint64),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_sint64 * gSingleton_typeGalgas_sint64 = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_sint64 (void) {
  macroDetachPointer (gSingleton_typeGalgas_sint64, cPtr_typeGalgas_sint64) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint64 GGS_typeGalgas_sint64::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_sint64 result ;
  if (NULL == gSingleton_typeGalgas_sint64) {
    macroMyNew (gSingleton_typeGalgas_sint64, cPtr_typeGalgas_sint64 (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_sint64) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_sint64) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_sint64::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_sint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_sint64 * p = (cPtr_typeGalgas_sint64 *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_sint64::actualTypeName (void) const {
  return "typeGalgas_sint64" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_sint64 ("typeGalgas_sint64", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_sint64) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_sint64::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_sint64 * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_sint64 (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint64 GGS_typeGalgas_sint64::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_sint64 result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_sint64 * p = dynamic_cast <const GGS_typeGalgas_sint64 *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_sint64, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_sint64::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_sint64 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_uint64'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_uint64::
cPtr_typeGalgas_uint64 (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_uint64 * GGS_typeGalgas_uint64::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_uint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_uint64 *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_uint64::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("uint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_handleIncrementOperatorCall (C_Compiler & /* inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_handleDecrementOperatorCall (C_Compiler & /* inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_uint64 (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_50554 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1182))).operator_isEqual (GGS_string ("max")) ;
  if (cond_50554.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (cond_50554.isBuiltAndFalse ()) {
    const GGS_bool cond_50794 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1184))).operator_isEqual (GGS_string ("uint64MaskWithCompressedBitString")) ;
    if (cond_50794.isBuiltAndTrue ()) {
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
    }else if (cond_50794.isBuiltAndFalse ()) {
      const GGS_bool cond_51039 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1187))).operator_isEqual (GGS_string ("uint64BaseValueWithCompressedBitString")) ;
      if (cond_51039.isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
      }else if (cond_51039.isBuiltAndFalse ()) {
        const GGS_bool cond_51264 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1190))).operator_isEqual (GGS_string ("uint64WithBitString")) ;
        if (cond_51264.isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
        }else if (cond_51264.isBuiltAndFalse ()) {
          var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1195)) ;
          var_cas_outAccessorTypesList.drop () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_uint64:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint64::
static_string_message_messageGalgasType (void) {
  return "a '@uint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint64::
message_messageGalgasType (void) const {
  return "a '@uint64' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint64::
instanceMessage (void) const {
  return "a '@uint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint64::
_static_message (void) {
  return "a '@uint64' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_uint64 (& typeid (cPtr_typeGalgas_uint64), & typeid (cPtr_AC_galgasType), "a '@uint64' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_uint64::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_uint64 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_uint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_uint64 ("typeGalgas_uint64", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint64::
GGS_typeGalgas_uint64 (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint64::
GGS_typeGalgas_uint64 (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_uint64 GGS_typeGalgas_uint64::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_uint64 result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_uint64 *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_uint64) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_uint64 (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_uint64),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_uint64 * gSingleton_typeGalgas_uint64 = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_uint64 (void) {
  macroDetachPointer (gSingleton_typeGalgas_uint64, cPtr_typeGalgas_uint64) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint64 GGS_typeGalgas_uint64::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_uint64 result ;
  if (NULL == gSingleton_typeGalgas_uint64) {
    macroMyNew (gSingleton_typeGalgas_uint64, cPtr_typeGalgas_uint64 (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_uint64) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_uint64) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_uint64::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_uint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_uint64 * p = (cPtr_typeGalgas_uint64 *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_uint64::actualTypeName (void) const {
  return "typeGalgas_uint64" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_uint64 ("typeGalgas_uint64", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_uint64) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_uint64::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_uint64 * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_uint64 (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint64 GGS_typeGalgas_uint64::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_uint64 result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_uint64 * p = dynamic_cast <const GGS_typeGalgas_uint64 *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_uint64, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_uint64::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_uint64 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_double'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_double::
cPtr_typeGalgas_double (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_double * GGS_typeGalgas_double::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_double *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_double *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_double::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_double::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("double") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_double::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_double::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_double:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_double::
static_string_message_messageGalgasType (void) {
  return "a '@double' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_double::
message_messageGalgasType (void) const {
  return "a '@double' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_double::
instanceMessage (void) const {
  return "a '@double' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_double::
_static_message (void) {
  return "a '@double' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_double (& typeid (cPtr_typeGalgas_double), & typeid (cPtr_AC_galgasType), "a '@double' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_double::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_double ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_double'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_double ("typeGalgas_double", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_double::
GGS_typeGalgas_double (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_double::
GGS_typeGalgas_double (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_double GGS_typeGalgas_double::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_double result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_double *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_double) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_double (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_double),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_double * gSingleton_typeGalgas_double = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_double (void) {
  macroDetachPointer (gSingleton_typeGalgas_double, cPtr_typeGalgas_double) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_double GGS_typeGalgas_double::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_double result ;
  if (NULL == gSingleton_typeGalgas_double) {
    macroMyNew (gSingleton_typeGalgas_double, cPtr_typeGalgas_double (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_double) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_double) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_double::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_double *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_double * p = (cPtr_typeGalgas_double *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_double::actualTypeName (void) const {
  return "typeGalgas_double" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_double ("typeGalgas_double", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_double) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_double::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_double * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_double (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_double GGS_typeGalgas_double::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_double result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_double * p = dynamic_cast <const GGS_typeGalgas_double *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_double, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_double::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_double ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeGalgas_binaryset'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_binaryset::
cPtr_typeGalgas_binaryset (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_binaryset * GGS_typeGalgas_binaryset::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_binaryset *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_binaryset *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_binaryset::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_binaryset::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("binaryset") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_binaryset::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_binaryset (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_53135 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1242))).operator_isEqual (GGS_string ("binarySetWithBit")) ;
  if (cond_53135.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  }else if (cond_53135.isBuiltAndFalse ()) {
    const GGS_bool cond_53272 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1245))).operator_isEqual (GGS_string ("emptyBinarySet")) ;
    if (cond_53272.isBuiltAndTrue ()) {
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    }else if (cond_53272.isBuiltAndFalse ()) {
      const GGS_bool cond_53408 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1247))).operator_isEqual (GGS_string ("fullBinarySet")) ;
      if (cond_53408.isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
      }else if (cond_53408.isBuiltAndFalse ()) {
        const GGS_bool cond_53643 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1249))).operator_isEqual (GGS_string ("binarySetWithPredicateString")) ;
        if (cond_53643.isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
        }else if (cond_53643.isBuiltAndFalse ()) {
          const GGS_bool cond_54040 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1252))).operator_isEqual (GGS_string ("binarySetWithEqualComparison")) ;
          if (cond_54040.isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
          }else if (cond_54040.isBuiltAndFalse ()) {
            const GGS_bool cond_54440 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1257))).operator_isEqual (GGS_string ("binarySetWithNotEqualComparison")) ;
            if (cond_54440.isBuiltAndTrue ()) {
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
              var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
              var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
            }else if (cond_54440.isBuiltAndFalse ()) {
              const GGS_bool cond_54843 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1262))).operator_isEqual (GGS_string ("binarySetWithStrictLowerComparison")) ;
              if (cond_54843.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
              }else if (cond_54843.isBuiltAndFalse ()) {
                const GGS_bool cond_55248 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1267))).operator_isEqual (GGS_string ("binarySetWithStrictGreaterComparison")) ;
                if (cond_55248.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                  var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                  var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                }else if (cond_55248.isBuiltAndFalse ()) {
                  const GGS_bool cond_55652 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1272))).operator_isEqual (GGS_string ("binarySetWithLowerOrEqualComparison")) ;
                  if (cond_55652.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                  }else if (cond_55652.isBuiltAndFalse ()) {
                    const GGS_bool cond_56058 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1277))).operator_isEqual (GGS_string ("binarySetWithGreaterOrEqualComparison")) ;
                    if (cond_56058.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                    }else if (cond_56058.isBuiltAndFalse ()) {
                      const GGS_bool cond_56457 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1282))).operator_isEqual (GGS_string ("binarySetWithEqualToConstant")) ;
                      if (cond_56457.isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                      }else if (cond_56457.isBuiltAndFalse ()) {
                        const GGS_bool cond_56859 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1287))).operator_isEqual (GGS_string ("binarySetWithNotEqualToConstant")) ;
                        if (cond_56859.isBuiltAndTrue ()) {
                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                          var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                          var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                          var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                        }else if (cond_56859.isBuiltAndFalse ()) {
                          const GGS_bool cond_57266 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1292))).operator_isEqual (GGS_string ("binarySetWithStrictLowerThanConstant")) ;
                          if (cond_57266.isBuiltAndTrue ()) {
                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                            var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                            var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                            var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                          }else if (cond_57266.isBuiltAndFalse ()) {
                            const GGS_bool cond_57675 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1297))).operator_isEqual (GGS_string ("binarySetWithStrictGreaterThanConstant")) ;
                            if (cond_57675.isBuiltAndTrue ()) {
                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                              var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                              var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                              var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                            }else if (cond_57675.isBuiltAndFalse ()) {
                              const GGS_bool cond_58081 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1302))).operator_isEqual (GGS_string ("binarySetWithLowerOrEqualToConstant")) ;
                              if (cond_58081.isBuiltAndTrue ()) {
                                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                              }else if (cond_58081.isBuiltAndFalse ()) {
                                const GGS_bool cond_58489 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1307))).operator_isEqual (GGS_string ("binarySetWithGreaterOrEqualToConstant")) ;
                                if (cond_58489.isBuiltAndTrue ()) {
                                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                  var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                  var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                  var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                }else if (cond_58489.isBuiltAndFalse ()) {
                                  const GGS_bool cond_58888 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1312))).operator_isEqual (GGS_string ("binarySetWithITE")) ;
                                  if (cond_58888.isBuiltAndTrue ()) {
                                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_binaryset ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_binaryset ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_binaryset ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                  }else if (cond_58888.isBuiltAndFalse ()) {
                                    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1319)) ;
                                    var_cas_outAccessorTypesList.drop () ;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_binaryset::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_binaryset:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_binaryset::
static_string_message_messageGalgasType (void) {
  return "a '@binaryset' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_binaryset::
message_messageGalgasType (void) const {
  return "a '@binaryset' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_binaryset::
instanceMessage (void) const {
  return "a '@binaryset' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_binaryset::
_static_message (void) {
  return "a '@binaryset' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_binaryset (& typeid (cPtr_typeGalgas_binaryset), & typeid (cPtr_AC_galgasType), "a '@binaryset' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_binaryset::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_binaryset ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgas_binaryset'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_binaryset ("typeGalgas_binaryset", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_binaryset::
GGS_typeGalgas_binaryset (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_binaryset::
GGS_typeGalgas_binaryset (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_binaryset GGS_typeGalgas_binaryset::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_binaryset result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_binaryset *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_binaryset) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_binaryset (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_binaryset),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_binaryset * gSingleton_typeGalgas_binaryset = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_binaryset (void) {
  macroDetachPointer (gSingleton_typeGalgas_binaryset, cPtr_typeGalgas_binaryset) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_binaryset GGS_typeGalgas_binaryset::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_binaryset result ;
  if (NULL == gSingleton_typeGalgas_binaryset) {
    macroMyNew (gSingleton_typeGalgas_binaryset, cPtr_typeGalgas_binaryset (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_binaryset) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_binaryset) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_binaryset::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_binaryset *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_binaryset * p = (cPtr_typeGalgas_binaryset *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_binaryset::actualTypeName (void) const {
  return "typeGalgas_binaryset" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_binaryset ("typeGalgas_binaryset", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_binaryset) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_binaryset::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_binaryset * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_binaryset (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_binaryset GGS_typeGalgas_binaryset::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_binaryset result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_binaryset * p = dynamic_cast <const GGS_typeGalgas_binaryset *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_binaryset, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_binaryset::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_binaryset ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_galgasPrimitiveType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_galgasPrimitiveType::
cPtr_C_galgasPrimitiveType (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_galgasPrimitiveType * GGS_C_galgasPrimitiveType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_galgasPrimitiveType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_galgasPrimitiveType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_C_galgasPrimitiveType::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@C_galgasPrimitiveType:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType::
static_string_message_messageGalgasType (void) {
  return "any primitive type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType::
message_messageGalgasType (void) const {
  return "any primitive type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType::
instanceMessage (void) const {
  return "any primitive type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType::
_static_message (void) {
  return "any primitive type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_galgasPrimitiveType (& typeid (cPtr_C_galgasPrimitiveType), & typeid (cPtr_AC_galgasType), "any primitive type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_galgasPrimitiveType::galgasRTTI (void) const {
  return & gClassInfoFor__C_galgasPrimitiveType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_galgasPrimitiveType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_galgasPrimitiveType ("C_galgasPrimitiveType", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_galgasPrimitiveType GGS_C_galgasPrimitiveType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_galgasPrimitiveType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_galgasPrimitiveType *> (inPointer) != NULL)
      : (typeid (cPtr_C_galgasPrimitiveType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_galgasPrimitiveType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_galgasPrimitiveType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_galgasPrimitiveType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_galgasPrimitiveType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_C_galgasPrimitiveType * p = (cPtr_C_galgasPrimitiveType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_galgasPrimitiveType::actualTypeName (void) const {
  return "C_galgasPrimitiveType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_galgasPrimitiveType ("C_galgasPrimitiveType", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_galgasPrimitiveType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_galgasPrimitiveType * p = NULL ;
    macroMyNew (p, GGS_C_galgasPrimitiveType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType GGS_C_galgasPrimitiveType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_galgasPrimitiveType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_galgasPrimitiveType * p = dynamic_cast <const GGS_C_galgasPrimitiveType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_galgasPrimitiveType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_galgasPrimitiveType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_galgasPrimitiveType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgas_location'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_location::
cPtr_typeGalgas_location (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_location * GGS_typeGalgas_location::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_location *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_location *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_location::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("location") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
method_acceptAssignmentFromHere (C_Compiler & /* inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_location:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_location::
static_string_message_messageGalgasType (void) {
  return "a '@location' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_location::
message_messageGalgasType (void) const {
  return "a '@location' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_location::
instanceMessage (void) const {
  return "a '@location' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_location::
_static_message (void) {
  return "a '@location' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_location (& typeid (cPtr_typeGalgas_location), & typeid (cPtr_C_galgasPrimitiveType), "a '@location' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_location::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_location ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_location'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_location ("typeGalgas_location", true, & kTypeDescriptor_GGS_C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_location::
GGS_typeGalgas_location (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_location::
GGS_typeGalgas_location (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_location GGS_typeGalgas_location::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_location result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_location *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_location) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_location (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_location),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_location * gSingleton_typeGalgas_location = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_location (void) {
  macroDetachPointer (gSingleton_typeGalgas_location, cPtr_typeGalgas_location) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_location GGS_typeGalgas_location::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_location result ;
  if (NULL == gSingleton_typeGalgas_location) {
    macroMyNew (gSingleton_typeGalgas_location, cPtr_typeGalgas_location (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_location) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_location) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_location::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_location *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_location * p = (cPtr_typeGalgas_location *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_location::actualTypeName (void) const {
  return "typeGalgas_location" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_location ("typeGalgas_location", gClassInfoFor__C_galgasPrimitiveType, & kTypeDescriptor_GGS_typeGalgas_location) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_location::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_location * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_location (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_location GGS_typeGalgas_location::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_location result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_location * p = dynamic_cast <const GGS_typeGalgas_location *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_location, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_location::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_location ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgas_lstring'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lstring::
cPtr_typeGalgas_lstring (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lstring * GGS_typeGalgas_lstring::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lstring *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lstring *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lstring::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("lstring") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_lstring (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_61515 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1379))).operator_isEqual (GGS_string ("new")) ;
  if (cond_61515.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  }else if (cond_61515.isBuiltAndFalse ()) {
    const GGS_bool cond_61667 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1383))).operator_isEqual (GGS_string ("retrieveAndResetTemplateString")) ;
    if (cond_61667.isBuiltAndTrue ()) {
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    }else if (cond_61667.isBuiltAndFalse ()) {
      var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1387)) ;
      var_cas_outAccessorTypesList.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_62136 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1396))).operator_isEqual (GGS_string ("setString")) ;
  if (cond_62136.isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
  }else if (cond_62136.isBuiltAndFalse ()) {
    const GGS_bool cond_62351 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1399))).operator_isEqual (GGS_string ("setLocation")) ;
    if (cond_62351.isBuiltAndTrue ()) {
      var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
      var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
    }else if (cond_62351.isBuiltAndFalse ()) {
      var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1405)) ;
      var_cas_outModifierSignature.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_lstring:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lstring::
static_string_message_messageGalgasType (void) {
  return "a '@lstring' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lstring::
message_messageGalgasType (void) const {
  return "a '@lstring' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lstring::
instanceMessage (void) const {
  return "a '@lstring' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lstring::
_static_message (void) {
  return "a '@lstring' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_lstring (& typeid (cPtr_typeGalgas_lstring), & typeid (cPtr_C_galgasPrimitiveType), "a '@lstring' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_lstring::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_lstring ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_lstring'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_lstring ("typeGalgas_lstring", true, & kTypeDescriptor_GGS_C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_lstring::
GGS_typeGalgas_lstring (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lstring::
GGS_typeGalgas_lstring (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_lstring GGS_typeGalgas_lstring::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lstring result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_lstring *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_lstring) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_lstring (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_lstring),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_lstring * gSingleton_typeGalgas_lstring = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_lstring (void) {
  macroDetachPointer (gSingleton_typeGalgas_lstring, cPtr_typeGalgas_lstring) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lstring GGS_typeGalgas_lstring::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lstring result ;
  if (NULL == gSingleton_typeGalgas_lstring) {
    macroMyNew (gSingleton_typeGalgas_lstring, cPtr_typeGalgas_lstring (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_lstring) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_lstring) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lstring::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lstring *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_lstring * p = (cPtr_typeGalgas_lstring *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_lstring::actualTypeName (void) const {
  return "typeGalgas_lstring" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_lstring ("typeGalgas_lstring", gClassInfoFor__C_galgasPrimitiveType, & kTypeDescriptor_GGS_typeGalgas_lstring) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_lstring::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_lstring * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_lstring (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lstring GGS_typeGalgas_lstring::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lstring result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_lstring * p = dynamic_cast <const GGS_typeGalgas_lstring *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_lstring, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_lstring::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_lstring ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_lchar'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lchar::
cPtr_typeGalgas_lchar (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lchar * GGS_typeGalgas_lchar::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lchar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lchar *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lchar::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("lchar") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_lchar (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_63658 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1433))).operator_isEqual (GGS_string ("new")) ;
  if (cond_63658.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t = GGS_typeGalgas_char ::constructor_new (inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  }else if (cond_63658.isBuiltAndFalse ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1441)) ;
    var_cas_outAccessorTypesList.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_64123 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1450))).operator_isEqual (GGS_string ("setChar")) ;
  if (cond_64123.isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_char ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
  }else if (cond_64123.isBuiltAndFalse ()) {
    const GGS_bool cond_64338 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1453))).operator_isEqual (GGS_string ("setLocation")) ;
    if (cond_64338.isBuiltAndTrue ()) {
      var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
      var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
    }else if (cond_64338.isBuiltAndFalse ()) {
      var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1459)) ;
      var_cas_outModifierSignature.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_lchar:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lchar::
static_string_message_messageGalgasType (void) {
  return "a '@lchar' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lchar::
message_messageGalgasType (void) const {
  return "a '@lchar' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lchar::
instanceMessage (void) const {
  return "a '@lchar' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lchar::
_static_message (void) {
  return "a '@lchar' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_lchar (& typeid (cPtr_typeGalgas_lchar), & typeid (cPtr_C_galgasPrimitiveType), "a '@lchar' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_lchar::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_lchar ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lchar'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_lchar ("typeGalgas_lchar", true, & kTypeDescriptor_GGS_C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_lchar::
GGS_typeGalgas_lchar (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lchar::
GGS_typeGalgas_lchar (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_lchar GGS_typeGalgas_lchar::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lchar result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_lchar *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_lchar) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_lchar (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_lchar),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_lchar * gSingleton_typeGalgas_lchar = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_lchar (void) {
  macroDetachPointer (gSingleton_typeGalgas_lchar, cPtr_typeGalgas_lchar) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lchar GGS_typeGalgas_lchar::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lchar result ;
  if (NULL == gSingleton_typeGalgas_lchar) {
    macroMyNew (gSingleton_typeGalgas_lchar, cPtr_typeGalgas_lchar (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_lchar) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_lchar) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lchar::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lchar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_lchar * p = (cPtr_typeGalgas_lchar *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_lchar::actualTypeName (void) const {
  return "typeGalgas_lchar" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_lchar ("typeGalgas_lchar", gClassInfoFor__C_galgasPrimitiveType, & kTypeDescriptor_GGS_typeGalgas_lchar) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_lchar::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_lchar * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_lchar (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lchar GGS_typeGalgas_lchar::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lchar result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_lchar * p = dynamic_cast <const GGS_typeGalgas_lchar *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_lchar, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_lchar::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_lchar ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_lbool'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lbool::
cPtr_typeGalgas_lbool (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lbool * GGS_typeGalgas_lbool::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lbool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lbool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lbool::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("lbool") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_lbool (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_65641 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1487))).operator_isEqual (GGS_string ("new")) ;
  if (cond_65641.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  }else if (cond_65641.isBuiltAndFalse ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1495)) ;
    var_cas_outAccessorTypesList.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_66106 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1504))).operator_isEqual (GGS_string ("setBool")) ;
  if (cond_66106.isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
  }else if (cond_66106.isBuiltAndFalse ()) {
    const GGS_bool cond_66321 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1507))).operator_isEqual (GGS_string ("setLocation")) ;
    if (cond_66321.isBuiltAndTrue ()) {
      var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
      var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
    }else if (cond_66321.isBuiltAndFalse ()) {
      var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1513)) ;
      var_cas_outModifierSignature.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_lbool:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lbool::
static_string_message_messageGalgasType (void) {
  return "a '@lbool' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lbool::
message_messageGalgasType (void) const {
  return "a '@lbool' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lbool::
instanceMessage (void) const {
  return "a '@lbool' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lbool::
_static_message (void) {
  return "a '@lbool' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_lbool (& typeid (cPtr_typeGalgas_lbool), & typeid (cPtr_C_galgasPrimitiveType), "a '@lbool' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_lbool::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_lbool ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lbool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_lbool ("typeGalgas_lbool", true, & kTypeDescriptor_GGS_C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_lbool::
GGS_typeGalgas_lbool (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lbool::
GGS_typeGalgas_lbool (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_lbool GGS_typeGalgas_lbool::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lbool result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_lbool *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_lbool) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_lbool (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_lbool),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_lbool * gSingleton_typeGalgas_lbool = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_lbool (void) {
  macroDetachPointer (gSingleton_typeGalgas_lbool, cPtr_typeGalgas_lbool) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lbool GGS_typeGalgas_lbool::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lbool result ;
  if (NULL == gSingleton_typeGalgas_lbool) {
    macroMyNew (gSingleton_typeGalgas_lbool, cPtr_typeGalgas_lbool (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_lbool) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_lbool) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lbool::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lbool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_lbool * p = (cPtr_typeGalgas_lbool *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_lbool::actualTypeName (void) const {
  return "typeGalgas_lbool" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_lbool ("typeGalgas_lbool", gClassInfoFor__C_galgasPrimitiveType, & kTypeDescriptor_GGS_typeGalgas_lbool) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_lbool::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_lbool * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_lbool (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lbool GGS_typeGalgas_lbool::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lbool result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_lbool * p = dynamic_cast <const GGS_typeGalgas_lbool *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_lbool, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_lbool::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_lbool ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_luint'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_luint::
cPtr_typeGalgas_luint (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_luint * GGS_typeGalgas_luint::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_luint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_luint *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_luint::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("luint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_luint (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_67623 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1540))).operator_isEqual (GGS_string ("new")) ;
  if (cond_67623.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  }else if (cond_67623.isBuiltAndFalse ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1548)) ;
    var_cas_outAccessorTypesList.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_68088 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1557))).operator_isEqual (GGS_string ("setUint")) ;
  if (cond_68088.isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
  }else if (cond_68088.isBuiltAndFalse ()) {
    const GGS_bool cond_68303 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1560))).operator_isEqual (GGS_string ("setLocation")) ;
    if (cond_68303.isBuiltAndTrue ()) {
      var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
      var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
    }else if (cond_68303.isBuiltAndFalse ()) {
      var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1566)) ;
      var_cas_outModifierSignature.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_luint:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint::
static_string_message_messageGalgasType (void) {
  return "a '@luint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint::
message_messageGalgasType (void) const {
  return "a '@luint' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint::
instanceMessage (void) const {
  return "a '@luint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint::
_static_message (void) {
  return "a '@luint' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_luint (& typeid (cPtr_typeGalgas_luint), & typeid (cPtr_C_galgasPrimitiveType), "a '@luint' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_luint::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_luint ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_luint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_luint ("typeGalgas_luint", true, & kTypeDescriptor_GGS_C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint::
GGS_typeGalgas_luint (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint::
GGS_typeGalgas_luint (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_luint GGS_typeGalgas_luint::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_luint result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_luint *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_luint) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_luint (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_luint),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_luint * gSingleton_typeGalgas_luint = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_luint (void) {
  macroDetachPointer (gSingleton_typeGalgas_luint, cPtr_typeGalgas_luint) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint GGS_typeGalgas_luint::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_luint result ;
  if (NULL == gSingleton_typeGalgas_luint) {
    macroMyNew (gSingleton_typeGalgas_luint, cPtr_typeGalgas_luint (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_luint) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_luint) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_luint::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_luint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_luint * p = (cPtr_typeGalgas_luint *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_luint::actualTypeName (void) const {
  return "typeGalgas_luint" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_luint ("typeGalgas_luint", gClassInfoFor__C_galgasPrimitiveType, & kTypeDescriptor_GGS_typeGalgas_luint) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_luint::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_luint * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_luint (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint GGS_typeGalgas_luint::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_luint result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_luint * p = dynamic_cast <const GGS_typeGalgas_luint *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_luint, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_luint::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_luint ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgas_luint64'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_luint64::
cPtr_typeGalgas_luint64 (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_luint64 * GGS_typeGalgas_luint64::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_luint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_luint64 *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_luint64::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("luint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_luint64 (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_69611 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1593))).operator_isEqual (GGS_string ("new")) ;
  if (cond_69611.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t = GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  }else if (cond_69611.isBuiltAndFalse ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1601)) ;
    var_cas_outAccessorTypesList.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_70080 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1610))).operator_isEqual (GGS_string ("setUint64")) ;
  if (cond_70080.isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
  }else if (cond_70080.isBuiltAndFalse ()) {
    const GGS_bool cond_70295 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1613))).operator_isEqual (GGS_string ("setLocation")) ;
    if (cond_70295.isBuiltAndTrue ()) {
      var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
      var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
    }else if (cond_70295.isBuiltAndFalse ()) {
      var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1619)) ;
      var_cas_outModifierSignature.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_luint64:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint64::
static_string_message_messageGalgasType (void) {
  return "a '@luint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint64::
message_messageGalgasType (void) const {
  return "a '@luint64' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint64::
instanceMessage (void) const {
  return "a '@luint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint64::
_static_message (void) {
  return "a '@luint64' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_luint64 (& typeid (cPtr_typeGalgas_luint64), & typeid (cPtr_C_galgasPrimitiveType), "a '@luint64' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_luint64::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_luint64 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_luint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_luint64 ("typeGalgas_luint64", true, & kTypeDescriptor_GGS_C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint64::
GGS_typeGalgas_luint64 (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint64::
GGS_typeGalgas_luint64 (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_luint64 GGS_typeGalgas_luint64::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_luint64 result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_luint64 *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_luint64) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_luint64 (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_luint64),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_luint64 * gSingleton_typeGalgas_luint64 = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_luint64 (void) {
  macroDetachPointer (gSingleton_typeGalgas_luint64, cPtr_typeGalgas_luint64) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint64 GGS_typeGalgas_luint64::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_luint64 result ;
  if (NULL == gSingleton_typeGalgas_luint64) {
    macroMyNew (gSingleton_typeGalgas_luint64, cPtr_typeGalgas_luint64 (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_luint64) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_luint64) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_luint64::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_luint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_luint64 * p = (cPtr_typeGalgas_luint64 *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_luint64::actualTypeName (void) const {
  return "typeGalgas_luint64" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_luint64 ("typeGalgas_luint64", gClassInfoFor__C_galgasPrimitiveType, & kTypeDescriptor_GGS_typeGalgas_luint64) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_luint64::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_luint64 * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_luint64 (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint64 GGS_typeGalgas_luint64::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_luint64 result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_luint64 * p = dynamic_cast <const GGS_typeGalgas_luint64 *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_luint64, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_luint64::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_luint64 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_lsint'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lsint::
cPtr_typeGalgas_lsint (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lsint * GGS_typeGalgas_lsint::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lsint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lsint *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lsint::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("lsint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_lsint (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_71601 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1646))).operator_isEqual (GGS_string ("new")) ;
  if (cond_71601.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t = GGS_typeGalgas_sint ::constructor_new (inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  }else if (cond_71601.isBuiltAndFalse ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1654)) ;
    var_cas_outAccessorTypesList.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_72066 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1663))).operator_isEqual (GGS_string ("setSint")) ;
  if (cond_72066.isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_sint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
  }else if (cond_72066.isBuiltAndFalse ()) {
    const GGS_bool cond_72281 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1666))).operator_isEqual (GGS_string ("setLocation")) ;
    if (cond_72281.isBuiltAndTrue ()) {
      var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
      var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
    }else if (cond_72281.isBuiltAndFalse ()) {
      var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1672)) ;
      var_cas_outModifierSignature.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_lsint:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint::
static_string_message_messageGalgasType (void) {
  return "a '@lsint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint::
message_messageGalgasType (void) const {
  return "a '@lsint' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint::
instanceMessage (void) const {
  return "a '@lsint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint::
_static_message (void) {
  return "a '@lsint' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_lsint (& typeid (cPtr_typeGalgas_lsint), & typeid (cPtr_C_galgasPrimitiveType), "a '@lsint' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_lsint::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_lsint ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lsint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_lsint ("typeGalgas_lsint", true, & kTypeDescriptor_GGS_C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint::
GGS_typeGalgas_lsint (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint::
GGS_typeGalgas_lsint (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_lsint GGS_typeGalgas_lsint::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lsint result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_lsint *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_lsint) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_lsint (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_lsint),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_lsint * gSingleton_typeGalgas_lsint = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_lsint (void) {
  macroDetachPointer (gSingleton_typeGalgas_lsint, cPtr_typeGalgas_lsint) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint GGS_typeGalgas_lsint::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lsint result ;
  if (NULL == gSingleton_typeGalgas_lsint) {
    macroMyNew (gSingleton_typeGalgas_lsint, cPtr_typeGalgas_lsint (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_lsint) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_lsint) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lsint::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lsint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_lsint * p = (cPtr_typeGalgas_lsint *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_lsint::actualTypeName (void) const {
  return "typeGalgas_lsint" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_lsint ("typeGalgas_lsint", gClassInfoFor__C_galgasPrimitiveType, & kTypeDescriptor_GGS_typeGalgas_lsint) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_lsint::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_lsint * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_lsint (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint GGS_typeGalgas_lsint::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lsint result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_lsint * p = dynamic_cast <const GGS_typeGalgas_lsint *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_lsint, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_lsint::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_lsint ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgas_lsint64'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lsint64::
cPtr_typeGalgas_lsint64 (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lsint64 * GGS_typeGalgas_lsint64::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lsint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lsint64 *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lsint64::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("lsint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_lsint64 (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_73589 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1699))).operator_isEqual (GGS_string ("new")) ;
  if (cond_73589.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t = GGS_typeGalgas_sint64 ::constructor_new (inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  }else if (cond_73589.isBuiltAndFalse ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1707)) ;
    var_cas_outAccessorTypesList.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_74058 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1716))).operator_isEqual (GGS_string ("setSint64")) ;
  if (cond_74058.isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_sint64 ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
  }else if (cond_74058.isBuiltAndFalse ()) {
    const GGS_bool cond_74273 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1719))).operator_isEqual (GGS_string ("setLocation")) ;
    if (cond_74273.isBuiltAndTrue ()) {
      var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
      var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
    }else if (cond_74273.isBuiltAndFalse ()) {
      var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1725)) ;
      var_cas_outModifierSignature.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_lsint64:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint64::
static_string_message_messageGalgasType (void) {
  return "a '@lsint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint64::
message_messageGalgasType (void) const {
  return "a '@lsint64' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint64::
instanceMessage (void) const {
  return "a '@lsint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint64::
_static_message (void) {
  return "a '@lsint64' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_lsint64 (& typeid (cPtr_typeGalgas_lsint64), & typeid (cPtr_C_galgasPrimitiveType), "a '@lsint64' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_lsint64::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_lsint64 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_lsint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_lsint64 ("typeGalgas_lsint64", true, & kTypeDescriptor_GGS_C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint64::
GGS_typeGalgas_lsint64 (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint64::
GGS_typeGalgas_lsint64 (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_lsint64 GGS_typeGalgas_lsint64::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lsint64 result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_lsint64 *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_lsint64) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_lsint64 (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_lsint64),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_lsint64 * gSingleton_typeGalgas_lsint64 = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_lsint64 (void) {
  macroDetachPointer (gSingleton_typeGalgas_lsint64, cPtr_typeGalgas_lsint64) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint64 GGS_typeGalgas_lsint64::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lsint64 result ;
  if (NULL == gSingleton_typeGalgas_lsint64) {
    macroMyNew (gSingleton_typeGalgas_lsint64, cPtr_typeGalgas_lsint64 (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_lsint64) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_lsint64) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lsint64::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lsint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_lsint64 * p = (cPtr_typeGalgas_lsint64 *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_lsint64::actualTypeName (void) const {
  return "typeGalgas_lsint64" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_lsint64 ("typeGalgas_lsint64", gClassInfoFor__C_galgasPrimitiveType, & kTypeDescriptor_GGS_typeGalgas_lsint64) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_lsint64::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_lsint64 * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_lsint64 (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint64 GGS_typeGalgas_lsint64::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lsint64 result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_lsint64 * p = dynamic_cast <const GGS_typeGalgas_lsint64 *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_lsint64, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_lsint64::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_lsint64 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgas_ldouble'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_ldouble::
cPtr_typeGalgas_ldouble (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_ldouble * GGS_typeGalgas_ldouble::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_ldouble *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_ldouble *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_ldouble::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("ldouble") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_ldouble (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_75585 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1752))).operator_isEqual (GGS_string ("new")) ;
  if (cond_75585.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t = GGS_typeGalgas_double ::constructor_new (inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  }else if (cond_75585.isBuiltAndFalse ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1760)) ;
    var_cas_outAccessorTypesList.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_76054 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1769))).operator_isEqual (GGS_string ("setDouble")) ;
  if (cond_76054.isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_double ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
  }else if (cond_76054.isBuiltAndFalse ()) {
    const GGS_bool cond_76269 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1772))).operator_isEqual (GGS_string ("setLocation")) ;
    if (cond_76269.isBuiltAndTrue ()) {
      var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
      var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
    }else if (cond_76269.isBuiltAndFalse ()) {
      var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1778)) ;
      var_cas_outModifierSignature.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_ldouble:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_ldouble::
static_string_message_messageGalgasType (void) {
  return "a '@ldouble' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_ldouble::
message_messageGalgasType (void) const {
  return "a '@ldouble' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_ldouble::
instanceMessage (void) const {
  return "a '@ldouble' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_ldouble::
_static_message (void) {
  return "a '@ldouble' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_ldouble (& typeid (cPtr_typeGalgas_ldouble), & typeid (cPtr_C_galgasPrimitiveType), "a '@ldouble' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_ldouble::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_ldouble ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_ldouble'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_ldouble ("typeGalgas_ldouble", true, & kTypeDescriptor_GGS_C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_ldouble::
GGS_typeGalgas_ldouble (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_ldouble::
GGS_typeGalgas_ldouble (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_ldouble GGS_typeGalgas_ldouble::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_ldouble result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_ldouble *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_ldouble) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_ldouble (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_ldouble),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_ldouble * gSingleton_typeGalgas_ldouble = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_ldouble (void) {
  macroDetachPointer (gSingleton_typeGalgas_ldouble, cPtr_typeGalgas_ldouble) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_ldouble GGS_typeGalgas_ldouble::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_ldouble result ;
  if (NULL == gSingleton_typeGalgas_ldouble) {
    macroMyNew (gSingleton_typeGalgas_ldouble, cPtr_typeGalgas_ldouble (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_ldouble) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_ldouble) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_ldouble::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_ldouble *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_ldouble * p = (cPtr_typeGalgas_ldouble *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_ldouble::actualTypeName (void) const {
  return "typeGalgas_ldouble" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_ldouble ("typeGalgas_ldouble", gClassInfoFor__C_galgasPrimitiveType, & kTypeDescriptor_GGS_typeGalgas_ldouble) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_ldouble::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_ldouble * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_ldouble (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_ldouble GGS_typeGalgas_ldouble::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_ldouble result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_ldouble * p = dynamic_cast <const GGS_typeGalgas_ldouble *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_ldouble, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_ldouble::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_ldouble ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeGalgas_stringset'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_stringset::
cPtr_typeGalgas_stringset (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_stringset * GGS_typeGalgas_stringset::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_stringset *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_stringset *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_stringset::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("stringset") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_stringset (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
  const GGS_bool cond_77689 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1809))).operator_isEqual (GGS_string ("emptySet")) ;
  if (cond_77689.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (cond_77689.isBuiltAndFalse ()) {
    const GGS_bool cond_77938 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1811))).operator_isEqual (GGS_string ("setWithString")) ;
    if (cond_77938.isBuiltAndTrue ()) {
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
      GGS_AC_galgasType  var_cas_t = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
      var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
    }else if (cond_77938.isBuiltAndFalse ()) {
      var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1817)) ;
      var_cas_outAccessorTypesList.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_handleAddAssignOperatorCall (C_Compiler & inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outParametersList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_outParametersList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_handleMinusAssignOperatorCall (C_Compiler & inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outParametersList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  GGS_AC_galgasType  var_cas_t = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
  var_cas_outParametersList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_acceptForeachInstruction (C_Compiler & inLexique,
                                GGS_M_semanticsEntitiesForUse  /* var_cas_inSemanticsEntitiesForUse */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle,
                                GGS_bool& var_cas_outNewStyle COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outNewStyle = GGS_bool (true) ;
  var_cas_outForeachList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_outForeachList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("key"), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_stringset:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_stringset::
static_string_message_messageGalgasType (void) {
  return "a '@stringset' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_stringset::
message_messageGalgasType (void) const {
  return "a '@stringset' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_stringset::
instanceMessage (void) const {
  return "a '@stringset' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_stringset::
_static_message (void) {
  return "a '@stringset' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_stringset (& typeid (cPtr_typeGalgas_stringset), & typeid (cPtr_AC_galgasType), "a '@stringset' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_stringset::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_stringset ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgas_stringset'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_stringset ("typeGalgas_stringset", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_stringset::
GGS_typeGalgas_stringset (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_stringset::
GGS_typeGalgas_stringset (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_stringset GGS_typeGalgas_stringset::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_stringset result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_stringset *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_stringset) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_stringset (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_stringset),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_stringset * gSingleton_typeGalgas_stringset = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_stringset (void) {
  macroDetachPointer (gSingleton_typeGalgas_stringset, cPtr_typeGalgas_stringset) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_stringset GGS_typeGalgas_stringset::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_stringset result ;
  if (NULL == gSingleton_typeGalgas_stringset) {
    macroMyNew (gSingleton_typeGalgas_stringset, cPtr_typeGalgas_stringset (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_stringset) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_stringset) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_stringset::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_stringset *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_stringset * p = (cPtr_typeGalgas_stringset *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_stringset::actualTypeName (void) const {
  return "typeGalgas_stringset" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_stringset ("typeGalgas_stringset", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_stringset) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_stringset::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_stringset * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_stringset (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_stringset GGS_typeGalgas_stringset::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_stringset result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_stringset * p = dynamic_cast <const GGS_typeGalgas_stringset *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_stringset, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_stringset::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_stringset ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeGalgas_filewrapper'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_filewrapper::
cPtr_typeGalgas_filewrapper (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_filewrapper * GGS_typeGalgas_filewrapper::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_filewrapper *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_filewrapper *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_filewrapper::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_filewrapper::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("filewrapper") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_filewrapper::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_80453 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1879))).operator_isEqual (GGS_string ("setCurrentDirectory")) ;
  if (cond_80453.isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
  }else if (cond_80453.isBuiltAndFalse ()) {
    var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this modifier is not defined") COMMA_SOURCE_FILE_AT_LINE (1885)) ;
    var_cas_outModifierSignature.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_filewrapper::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_filewrapper:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_filewrapper::
static_string_message_messageGalgasType (void) {
  return "a '@filewrapper' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_filewrapper::
message_messageGalgasType (void) const {
  return "a '@filewrapper' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_filewrapper::
instanceMessage (void) const {
  return "a '@filewrapper' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_filewrapper::
_static_message (void) {
  return "a '@filewrapper' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_filewrapper (& typeid (cPtr_typeGalgas_filewrapper), & typeid (cPtr_AC_galgasType), "a '@filewrapper' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_filewrapper::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_filewrapper ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeGalgas_filewrapper'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_filewrapper ("typeGalgas_filewrapper", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_filewrapper::
GGS_typeGalgas_filewrapper (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_filewrapper::
GGS_typeGalgas_filewrapper (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_filewrapper GGS_typeGalgas_filewrapper::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_filewrapper result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_filewrapper *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_filewrapper) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_filewrapper (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_filewrapper),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_filewrapper * gSingleton_typeGalgas_filewrapper = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_filewrapper (void) {
  macroDetachPointer (gSingleton_typeGalgas_filewrapper, cPtr_typeGalgas_filewrapper) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_filewrapper GGS_typeGalgas_filewrapper::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_filewrapper result ;
  if (NULL == gSingleton_typeGalgas_filewrapper) {
    macroMyNew (gSingleton_typeGalgas_filewrapper, cPtr_typeGalgas_filewrapper (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_filewrapper) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_filewrapper) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_filewrapper::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_filewrapper *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_filewrapper * p = (cPtr_typeGalgas_filewrapper *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_filewrapper::actualTypeName (void) const {
  return "typeGalgas_filewrapper" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_filewrapper ("typeGalgas_filewrapper", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_filewrapper) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_filewrapper::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_filewrapper * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_filewrapper (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_filewrapper GGS_typeGalgas_filewrapper::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_filewrapper result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_filewrapper * p = dynamic_cast <const GGS_typeGalgas_filewrapper *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_filewrapper, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_filewrapper::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_filewrapper ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeGalgas_data'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_data::
cPtr_typeGalgas_data (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_data * GGS_typeGalgas_data::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_data *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_data *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_data::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_data::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("data") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_data::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_data (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
  const GGS_bool cond_81697 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1914))).operator_isEqual (GGS_string ("emptyData")) ;
  if (cond_81697.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (cond_81697.isBuiltAndFalse ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1918)) ;
    var_cas_outAccessorTypesList.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_data::
method_handleMethodInstructionCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outMethodSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string ("") ;
  const GGS_bool cond_82305 = (var_cas_inMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1930))).operator_isEqual (GGS_string ("writeToFile")) ;
  if (cond_82305.isBuiltAndTrue ()) {
    var_cas_outMethodSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outMethodSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
  }else if (cond_82305.isBuiltAndFalse ()) {
    var_cas_inMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this method is not defined ") COMMA_SOURCE_FILE_AT_LINE (1935)) ;
    var_cas_outMethodSignature.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_data::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_82762 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1945))).operator_isEqual (GGS_string ("appendByte")) ;
  if (cond_82762.isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
  }else if (cond_82762.isBuiltAndFalse ()) {
    const GGS_bool cond_82976 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1948))).operator_isEqual (GGS_string ("appendShortBE")) ;
    if (cond_82976.isBuiltAndTrue ()) {
      var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
      var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
    }else if (cond_82976.isBuiltAndFalse ()) {
      const GGS_bool cond_83190 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1951))).operator_isEqual (GGS_string ("appendShortLE")) ;
      if (cond_83190.isBuiltAndTrue ()) {
        var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
        var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
      }else if (cond_83190.isBuiltAndFalse ()) {
        const GGS_bool cond_83403 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1954))).operator_isEqual (GGS_string ("appendUIntBE")) ;
        if (cond_83403.isBuiltAndTrue ()) {
          var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
          var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
        }else if (cond_83403.isBuiltAndFalse ()) {
          const GGS_bool cond_83616 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1957))).operator_isEqual (GGS_string ("appendUIntLE")) ;
          if (cond_83616.isBuiltAndTrue ()) {
            var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
            var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
          }else if (cond_83616.isBuiltAndFalse ()) {
            const GGS_bool cond_83835 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1960))).operator_isEqual (GGS_string ("appendUTF8String")) ;
            if (cond_83835.isBuiltAndTrue ()) {
              var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
              var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
            }else if (cond_83835.isBuiltAndFalse ()) {
              const GGS_bool cond_84045 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1963))).operator_isEqual (GGS_string ("appendData")) ;
              if (cond_84045.isBuiltAndTrue ()) {
                var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
                var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_data ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
              }else if (cond_84045.isBuiltAndFalse ()) {
                var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this modifier is not defined") COMMA_SOURCE_FILE_AT_LINE (1969)) ;
                var_cas_outModifierSignature.drop () ;
              }
            }
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_data::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_data:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_data::
static_string_message_messageGalgasType (void) {
  return "a '@data' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_data::
message_messageGalgasType (void) const {
  return "a '@data' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_data::
instanceMessage (void) const {
  return "a '@data' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_data::
_static_message (void) {
  return "a '@data' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_data (& typeid (cPtr_typeGalgas_data), & typeid (cPtr_AC_galgasType), "a '@data' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_data::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_data ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_data'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_data ("typeGalgas_data", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_data::
GGS_typeGalgas_data (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_data::
GGS_typeGalgas_data (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_data GGS_typeGalgas_data::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_data result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_data *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_data) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_data (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_data),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_data * gSingleton_typeGalgas_data = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_data (void) {
  macroDetachPointer (gSingleton_typeGalgas_data, cPtr_typeGalgas_data) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_data GGS_typeGalgas_data::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_data result ;
  if (NULL == gSingleton_typeGalgas_data) {
    macroMyNew (gSingleton_typeGalgas_data, cPtr_typeGalgas_data (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_data) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_data) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_data::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_data *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_data * p = (cPtr_typeGalgas_data *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_data::actualTypeName (void) const {
  return "typeGalgas_data" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_data ("typeGalgas_data", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_data) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_data::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_data * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_data (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_data GGS_typeGalgas_data::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_data result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_data * p = dynamic_cast <const GGS_typeGalgas_data *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_data, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_data::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_data ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_object'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_object::
cPtr_typeGalgas_object (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_object * GGS_typeGalgas_object::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_object *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_object *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_object::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_object::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("object") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_object::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_object:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_object::
static_string_message_messageGalgasType (void) {
  return "a '@object' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_object::
message_messageGalgasType (void) const {
  return "a '@object' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_object::
instanceMessage (void) const {
  return "a '@object' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_object::
_static_message (void) {
  return "a '@object' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_object (& typeid (cPtr_typeGalgas_object), & typeid (cPtr_AC_galgasType), "a '@object' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_object::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_object ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_object'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_object ("typeGalgas_object", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_object::
GGS_typeGalgas_object (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_object::
GGS_typeGalgas_object (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_object GGS_typeGalgas_object::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_object result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_object *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_object) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_object (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_object),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_object * gSingleton_typeGalgas_object = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_object (void) {
  macroDetachPointer (gSingleton_typeGalgas_object, cPtr_typeGalgas_object) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_object GGS_typeGalgas_object::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_object result ;
  if (NULL == gSingleton_typeGalgas_object) {
    macroMyNew (gSingleton_typeGalgas_object, cPtr_typeGalgas_object (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_object) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_object) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_object::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_object *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_object * p = (cPtr_typeGalgas_object *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_object::actualTypeName (void) const {
  return "typeGalgas_object" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_object ("typeGalgas_object", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_object) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_object::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_object * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_object (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_object GGS_typeGalgas_object::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_object result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_object * p = dynamic_cast <const GGS_typeGalgas_object *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_object, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_object::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_object ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeGalgas_type'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_type::
cPtr_typeGalgas_type (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_type * GGS_typeGalgas_type::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_type::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_type::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("type") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_type::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
  const GGS_bool cond_86013 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2016))).operator_isEqual (GGS_string ("typeList")) ;
  if (cond_86013.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outReturnedType = function_EXbuild_typelist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (2018)) ;
  }else if (cond_86013.isBuiltAndFalse ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (2021)) ;
    var_cas_outAccessorTypesList.drop () ;
    var_cas_outReturnedType.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_type::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_type:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_type::
static_string_message_messageGalgasType (void) {
  return "a '@type' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_type::
message_messageGalgasType (void) const {
  return "a '@type' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_type::
instanceMessage (void) const {
  return "a '@type' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_type::
_static_message (void) {
  return "a '@type' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_type (& typeid (cPtr_typeGalgas_type), & typeid (cPtr_AC_galgasType), "a '@type' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_type::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_type'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_type ("typeGalgas_type", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_type::
GGS_typeGalgas_type (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_type::
GGS_typeGalgas_type (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_type GGS_typeGalgas_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_type *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_type),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_type * gSingleton_typeGalgas_type = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_type (void) {
  macroDetachPointer (gSingleton_typeGalgas_type, cPtr_typeGalgas_type) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_type GGS_typeGalgas_type::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_type result ;
  if (NULL == gSingleton_typeGalgas_type) {
    macroMyNew (gSingleton_typeGalgas_type, cPtr_typeGalgas_type (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_type) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_type) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_type::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_type * p = (cPtr_typeGalgas_type *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_type::actualTypeName (void) const {
  return "typeGalgas_type" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_type ("typeGalgas_type", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_type) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_type::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_type * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_type (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_type GGS_typeGalgas_type::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_type result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_type * p = dynamic_cast <const GGS_typeGalgas_type *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_type, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_type::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgas_function'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_function::
cPtr_typeGalgas_function (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_function * GGS_typeGalgas_function::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_function *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_function *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_function::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_function::
method_getTypeName (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string ("function") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_function::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_function (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
  const GGS_bool cond_87386 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2052))).operator_isEqual (GGS_string ("functionList")) ;
  if (cond_87386.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outReturnedType = function_EXbuild_functionlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (2054)) ;
  }else if (cond_87386.isBuiltAndFalse ()) {
    const GGS_bool cond_87637 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2055))).operator_isEqual (GGS_string ("functionWithName")) ;
    if (cond_87637.isBuiltAndTrue ()) {
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("\?\?\?"), GGS_location (inLexique) COMMA_HERE)) ;
    }else if (cond_87637.isBuiltAndFalse ()) {
      const GGS_bool cond_87938 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2058))).operator_isEqual (GGS_string ("isFunctionDefined")) ;
      if (cond_87938.isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("\?\?\?"), GGS_location (inLexique) COMMA_HERE)) ;
        var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
      }else if (cond_87938.isBuiltAndFalse ()) {
        var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (2064)) ;
        var_cas_outAccessorTypesList.drop () ;
        var_cas_outReturnedType.drop () ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_function::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeGalgas_function:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_function::
static_string_message_messageGalgasType (void) {
  return "a '@type' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_function::
message_messageGalgasType (void) const {
  return "a '@type' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_function::
instanceMessage (void) const {
  return "a '@type' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_function::
_static_message (void) {
  return "a '@type' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_function (& typeid (cPtr_typeGalgas_function), & typeid (cPtr_AC_galgasType), "a '@type' type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_function::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_function ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_function'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_function ("typeGalgas_function", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_function::
GGS_typeGalgas_function (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_function::
GGS_typeGalgas_function (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_function GGS_typeGalgas_function::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_function result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_function *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_function) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_function (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_function),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_function * gSingleton_typeGalgas_function = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_function (void) {
  macroDetachPointer (gSingleton_typeGalgas_function, cPtr_typeGalgas_function) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_function GGS_typeGalgas_function::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_function result ;
  if (NULL == gSingleton_typeGalgas_function) {
    macroMyNew (gSingleton_typeGalgas_function, cPtr_typeGalgas_function (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_function) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_function) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_function::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_function *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_function * p = (cPtr_typeGalgas_function *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_function::actualTypeName (void) const {
  return "typeGalgas_function" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_function ("typeGalgas_function", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_function) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_function::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_function * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_function (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_function GGS_typeGalgas_function::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_function result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_function * p = dynamic_cast <const GGS_typeGalgas_function *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_function, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_function::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_function ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_typeTableMethodes'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableMethodes::e_typeTableMethodes (void) :
aListeTypesParametres () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@typeTableMethodes'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTableMethodes ("typeTableMethodes", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeTableMethodes::
elementOf_GGS_typeTableMethodes (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableMethodes & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableMethodes::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aListeTypesParametres.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableMethodes::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableMethodes * ptr = dynamic_cast <const elementOf_GGS_typeTableMethodes *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.aListeTypesParametres.operator_isEqual (ptr->mInfo.aListeTypesParametres)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableMethodes::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableMethodes *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableMethodes * info = (e_typeTableMethodes *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableMethodes *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableMethodes * info = (e_typeTableMethodes *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodes result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableMethodes info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMethodes::
operator_isEqual (const GGS_typeTableMethodes & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMethodes::
operator_isNotEqual (const GGS_typeTableMethodes & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableMethodes info  ;
    info.aListeTypesParametres = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeTypesParametres ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableMethodes::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableMethodes::kInsertMessage_insertKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableMethodes & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodes result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMethodes::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableMethodes " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_typeTableMethodes::cEnumerator::_aListeTypesParametres (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aListeTypesParametres ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeTableMethodes::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTableMethodes * p = NULL ;
    macroMyNew (p, GGS_typeTableMethodes (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTableMethodes result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTableMethodes * p = dynamic_cast <const GGS_typeTableMethodes *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTableMethodes, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTableMethodes::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTableMethodes ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeGalgasUndefinedExternType'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedExternType::
cPtr_typeGalgasUndefinedExternType (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mGalgasClassName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedExternType * GGS_typeGalgasUndefinedExternType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedExternType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedExternType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedExternType * ptr = dynamic_cast <const cPtr_typeGalgasUndefinedExternType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mGalgasClassName.operator_isEqual (ptr->mGalgasClassName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedExternType::
method_getTypeName (C_Compiler & inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mGalgasClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2096)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedExternType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasUndefinedExternType:"
           << mGalgasClassName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedExternType::
static_string_message_messageGalgasType (void) {
  return "an undefined extern type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedExternType::
message_messageGalgasType (void) const {
  return "an undefined extern type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedExternType::
instanceMessage (void) const {
  return "an undefined extern type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedExternType::
_static_message (void) {
  return "an undefined extern type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasUndefinedExternType (& typeid (cPtr_typeGalgasUndefinedExternType), & typeid (cPtr_AC_galgasType), "an undefined extern type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasUndefinedExternType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasUndefinedExternType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasUndefinedExternType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasUndefinedExternType (mGalgasClassName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedExternType'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasUndefinedExternType ("typeGalgasUndefinedExternType", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedExternType::
GGS_typeGalgasUndefinedExternType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedExternType::
GGS_typeGalgasUndefinedExternType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasUndefinedExternType GGS_typeGalgasUndefinedExternType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedExternType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasUndefinedExternType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasUndefinedExternType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasUndefinedExternType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedExternType GGS_typeGalgasUndefinedExternType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedExternType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasUndefinedExternType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedExternType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasUndefinedExternType * p = (cPtr_typeGalgasUndefinedExternType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasUndefinedExternType::actualTypeName (void) const {
  return "typeGalgasUndefinedExternType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasUndefinedExternType ("typeGalgasUndefinedExternType", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgasUndefinedExternType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasUndefinedExternType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasUndefinedExternType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasUndefinedExternType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedExternType GGS_typeGalgasUndefinedExternType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedExternType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasUndefinedExternType * p = dynamic_cast <const GGS_typeGalgasUndefinedExternType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasUndefinedExternType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasUndefinedExternType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasUndefinedExternType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'e_M_externTypeConstructorMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_externTypeConstructorMap::e_M_externTypeConstructorMap (void) :
aListeDesAttributs () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map '@M_externTypeConstructorMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_externTypeConstructorMap ("M_externTypeConstructorMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_externTypeConstructorMap::
elementOf_GGS_M_externTypeConstructorMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_externTypeConstructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_externTypeConstructorMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aListeDesAttributs.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_externTypeConstructorMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_externTypeConstructorMap * ptr = dynamic_cast <const elementOf_GGS_M_externTypeConstructorMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.aListeDesAttributs.operator_isEqual (ptr->mInfo.aListeDesAttributs)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_externTypeConstructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_externTypeConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_externTypeConstructorMap * info = (e_M_externTypeConstructorMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_externTypeConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_externTypeConstructorMap * info = (e_M_externTypeConstructorMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_externTypeConstructorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_externTypeConstructorMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_externTypeConstructorMap::
operator_isEqual (const GGS_M_externTypeConstructorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_externTypeConstructorMap::
operator_isNotEqual (const GGS_M_externTypeConstructorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeListeAttributsSemantiques & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_externTypeConstructorMap info  ;
    info.aListeDesAttributs = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDesAttributs ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_externTypeConstructorMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_externTypeConstructorMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_externTypeConstructorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_externTypeConstructorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_externTypeConstructorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_externTypeConstructorMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_externTypeConstructorMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeAttributsSemantiques  & GGS_M_externTypeConstructorMap::cEnumerator::_aListeDesAttributs (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aListeDesAttributs ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_externTypeConstructorMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_externTypeConstructorMap * p = NULL ;
    macroMyNew (p, GGS_M_externTypeConstructorMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_externTypeConstructorMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_externTypeConstructorMap * p = dynamic_cast <const GGS_M_externTypeConstructorMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_externTypeConstructorMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_externTypeConstructorMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_externTypeConstructorMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeGalgasExternType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasExternType::
cPtr_typeGalgasExternType (const GGS_lstring & argument_0,
                                const GGS_M_externTypeConstructorMap & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_bool& argument_4,
                                const GGS_typeListeAttributsSemantiques & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedExternType (argument_0 COMMA_THERE),
mConstructorMap (argument_1),
mModifiersMap (argument_2),
mReadersInInstructionMap (argument_3),
mAcceptAddAssignOperatorCall (argument_4),
mAddAssignOperatorCallTypeList (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasExternType * GGS_typeGalgasExternType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasExternType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasExternType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasExternType * ptr = dynamic_cast <const cPtr_typeGalgasExternType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mGalgasClassName.operator_isEqual (ptr->mGalgasClassName).boolValue ()
         && mConstructorMap.operator_isEqual (ptr->mConstructorMap).boolValue ()
         && mModifiersMap.operator_isEqual (ptr->mModifiersMap).boolValue ()
         && mReadersInInstructionMap.operator_isEqual (ptr->mReadersInInstructionMap).boolValue ()
         && mAcceptAddAssignOperatorCall.operator_isEqual (ptr->mAcceptAddAssignOperatorCall).boolValue ()
         && mAddAssignOperatorCallTypeList.operator_isEqual (ptr->mAddAssignOperatorCallTypeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgasExternType (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_M_externTypeConstructorMap  temp_91433 = mConstructorMap ;
  if (temp_91433.isBuilt ()) {
    temp_91433 (HERE)->method_searchKey (inLexique, var_cas_inClassMethodName, var_cas_outAccessorTypesList COMMA_SOURCE_FILE_AT_LINE (2145)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_typeTableMethodes  temp_91688 = mModifiersMap ;
  if (temp_91688.isBuilt ()) {
    temp_91688 (HERE)->method_searchKey (inLexique, var_cas_inModifierName, var_cas_outModifierSignature COMMA_SOURCE_FILE_AT_LINE (2153)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleMethodInstructionCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outReaderSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string ("") ;
  const GGS_typeTableMethodes  temp_92107 = mReadersInInstructionMap ;
  if (temp_92107.isBuilt ()) {
    temp_92107 (HERE)->method_searchKey (inLexique, var_cas_inMethodName, var_cas_outReaderSignature COMMA_SOURCE_FILE_AT_LINE (2164)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleAddAssignOperatorCall (C_Compiler & inLexique,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  method_handleAddAssignOperatorCall (inLexique, var_cas_inErrorLocation, var_cas_outParametersList COMMA_SOURCE_FILE_AT_LINE (2172)) ;
  const GGS_bool cond_92540 = (mAcceptAddAssignOperatorCall).operator_not () ;
  if (cond_92540.isBuiltAndTrue ()) {
    inherited::method_handleAddAssignOperatorCall (inLexique, var_cas_inErrorLocation, var_cas_outParametersList COMMA_SOURCE_FILE_AT_LINE (2174)) ;
  }else if (cond_92540.isBuiltAndFalse ()) {
    var_cas_outParametersList = mAddAssignOperatorCallTypeList ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasExternType:"
           << mGalgasClassName.reader_description (inIndentation + 1)
           << mConstructorMap.reader_description (inIndentation + 1)
           << mModifiersMap.reader_description (inIndentation + 1)
           << mReadersInInstructionMap.reader_description (inIndentation + 1)
           << mAcceptAddAssignOperatorCall.reader_description (inIndentation + 1)
           << mAddAssignOperatorCallTypeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasExternType::
static_string_message_messageGalgasType (void) {
  return "an extern type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasExternType::
message_messageGalgasType (void) const {
  return "an extern type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasExternType::
instanceMessage (void) const {
  return "an extern type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasExternType::
_static_message (void) {
  return "an extern type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasExternType (& typeid (cPtr_typeGalgasExternType), & typeid (cPtr_typeGalgasUndefinedExternType), "an extern type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasExternType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasExternType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasExternType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasExternType (mGalgasClassName, mConstructorMap, mModifiersMap, mReadersInInstructionMap, mAcceptAddAssignOperatorCall, mAddAssignOperatorCallTypeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgasExternType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasExternType ("typeGalgasExternType", true, & kTypeDescriptor_GGS_typeGalgasUndefinedExternType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasExternType::
GGS_typeGalgasExternType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasExternType::
GGS_typeGalgasExternType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasExternType GGS_typeGalgasExternType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasExternType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasExternType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasExternType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasExternType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasExternType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasExternType GGS_typeGalgasExternType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_M_externTypeConstructorMap & argument_1,
                 const GGS_typeTableMethodes & argument_2,
                 const GGS_typeTableMethodes & argument_3,
                 const GGS_bool& argument_4,
                 const GGS_typeListeAttributsSemantiques & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasExternType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasExternType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasExternType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasExternType * p = (cPtr_typeGalgasExternType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasExternType::actualTypeName (void) const {
  return "typeGalgasExternType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasExternType ("typeGalgasExternType", gClassInfoFor__typeGalgasUndefinedExternType, & kTypeDescriptor_GGS_typeGalgasExternType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasExternType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasExternType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasExternType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasExternType GGS_typeGalgasExternType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasExternType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasExternType * p = dynamic_cast <const GGS_typeGalgasExternType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasExternType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasExternType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasExternType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'e_M_terminalSymbolsMapForUse'                    *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_terminalSymbolsMapForUse::e_M_terminalSymbolsMapForUse (void) :
aListeDesAttributs () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map '@M_terminalSymbolsMapForUse'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_terminalSymbolsMapForUse ("M_terminalSymbolsMapForUse", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_terminalSymbolsMapForUse::
elementOf_GGS_M_terminalSymbolsMapForUse (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_terminalSymbolsMapForUse & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_terminalSymbolsMapForUse::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aListeDesAttributs.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_terminalSymbolsMapForUse::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_terminalSymbolsMapForUse * ptr = dynamic_cast <const elementOf_GGS_M_terminalSymbolsMapForUse *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.aListeDesAttributs.operator_isEqual (ptr->mInfo.aListeDesAttributs)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_terminalSymbolsMapForUse::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_terminalSymbolsMapForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_terminalSymbolsMapForUse * info = (e_M_terminalSymbolsMapForUse *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_terminalSymbolsMapForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_terminalSymbolsMapForUse * info = (e_M_terminalSymbolsMapForUse *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_terminalSymbolsMapForUse result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_terminalSymbolsMapForUse info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_terminalSymbolsMapForUse::
operator_isEqual (const GGS_M_terminalSymbolsMapForUse & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_terminalSymbolsMapForUse::
operator_isNotEqual (const GGS_M_terminalSymbolsMapForUse & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeListeAttributsSemantiques & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_terminalSymbolsMapForUse info  ;
    info.aListeDesAttributs = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDesAttributs ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_terminalSymbolsMapForUse::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('m'),
  TO_UNICODE ('b'),
  TO_UNICODE ('o'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('$'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('$'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_terminalSymbolsMapForUse::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('m'),
  TO_UNICODE ('b'),
  TO_UNICODE ('o'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('$'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('$'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_terminalSymbolsMapForUse & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_terminalSymbolsMapForUse result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_terminalSymbolsMapForUse result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_terminalSymbolsMapForUse::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_terminalSymbolsMapForUse " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeAttributsSemantiques  & GGS_M_terminalSymbolsMapForUse::cEnumerator::_aListeDesAttributs (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aListeDesAttributs ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_terminalSymbolsMapForUse::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_terminalSymbolsMapForUse * p = NULL ;
    macroMyNew (p, GGS_M_terminalSymbolsMapForUse (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_terminalSymbolsMapForUse result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_terminalSymbolsMapForUse * p = dynamic_cast <const GGS_M_terminalSymbolsMapForUse *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_terminalSymbolsMapForUse, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_terminalSymbolsMapForUse::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_terminalSymbolsMapForUse ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_M_lexiqueComponents'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_lexiqueComponents::e_M_lexiqueComponents (void) :
mTerminalSymbolMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@M_lexiqueComponents'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_lexiqueComponents ("M_lexiqueComponents", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_lexiqueComponents::
elementOf_GGS_M_lexiqueComponents (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_lexiqueComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_lexiqueComponents::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mTerminalSymbolMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_lexiqueComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_lexiqueComponents * ptr = dynamic_cast <const elementOf_GGS_M_lexiqueComponents *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mTerminalSymbolMap.operator_isEqual (ptr->mInfo.mTerminalSymbolMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_lexiqueComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_lexiqueComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_lexiqueComponents * info = (e_M_lexiqueComponents *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_lexiqueComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_lexiqueComponents * info = (e_M_lexiqueComponents *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_lexiqueComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_lexiqueComponents info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_lexiqueComponents::
operator_isEqual (const GGS_M_lexiqueComponents & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_lexiqueComponents::
operator_isNotEqual (const GGS_M_lexiqueComponents & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_terminalSymbolsMapForUse & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_lexiqueComponents info  ;
    info.mTerminalSymbolMap = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_terminalSymbolsMapForUse   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mTerminalSymbolMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_lexiqueComponents::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('q'),
  TO_UNICODE ('u'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_terminalSymbolsMapForUse   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_lexiqueComponents::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('q'),
  TO_UNICODE ('u'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_terminalSymbolsMapForUse & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_lexiqueComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_lexiqueComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_lexiqueComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_lexiqueComponents::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_lexiqueComponents " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_terminalSymbolsMapForUse  & GGS_M_lexiqueComponents::cEnumerator::_mTerminalSymbolMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTerminalSymbolMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_lexiqueComponents::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_lexiqueComponents * p = NULL ;
    macroMyNew (p, GGS_M_lexiqueComponents (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_lexiqueComponents result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_lexiqueComponents * p = dynamic_cast <const GGS_M_lexiqueComponents *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_lexiqueComponents, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_lexiqueComponents::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_lexiqueComponents ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_typeTableEnAvant'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableEnAvant::e_typeTableEnAvant (void) :
mType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@typeTableEnAvant'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTableEnAvant ("typeTableEnAvant", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeTableEnAvant::
elementOf_GGS_typeTableEnAvant (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableEnAvant & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableEnAvant::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableEnAvant::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableEnAvant * ptr = dynamic_cast <const elementOf_GGS_typeTableEnAvant *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mType.operator_isEqual (ptr->mInfo.mType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableEnAvant::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableEnAvant *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableEnAvant * info = (e_typeTableEnAvant *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableEnAvant *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableEnAvant * info = (e_typeTableEnAvant *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableEnAvant result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableEnAvant info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableEnAvant::
operator_isEqual (const GGS_typeTableEnAvant & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableEnAvant::
operator_isNotEqual (const GGS_typeTableEnAvant & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_galgasType & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableEnAvant info  ;
    info.mType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableEnAvant::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableEnAvant::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableEnAvant & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableEnAvant result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableEnAvant result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableEnAvant::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableEnAvant " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeTableEnAvant::cEnumerator::_mType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeTableEnAvant::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTableEnAvant * p = NULL ;
    macroMyNew (p, GGS_typeTableEnAvant (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTableEnAvant result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTableEnAvant * p = dynamic_cast <const GGS_typeTableEnAvant *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTableEnAvant, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTableEnAvant::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTableEnAvant ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'e_M_nonterminalSymbolAlts'                      *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_nonterminalSymbolAlts::e_M_nonterminalSymbolAlts (void) :
mFormalParametersList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@M_nonterminalSymbolAlts'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_nonterminalSymbolAlts ("M_nonterminalSymbolAlts", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_nonterminalSymbolAlts::
elementOf_GGS_M_nonterminalSymbolAlts (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_nonterminalSymbolAlts & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonterminalSymbolAlts::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFormalParametersList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_nonterminalSymbolAlts::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_nonterminalSymbolAlts * ptr = dynamic_cast <const elementOf_GGS_M_nonterminalSymbolAlts *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFormalParametersList.operator_isEqual (ptr->mInfo.mFormalParametersList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonterminalSymbolAlts::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonterminalSymbolAlts *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonterminalSymbolAlts * info = (e_M_nonterminalSymbolAlts *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_nonterminalSymbolAlts *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_nonterminalSymbolAlts * info = (e_M_nonterminalSymbolAlts *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAlts result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_nonterminalSymbolAlts info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonterminalSymbolAlts::
operator_isEqual (const GGS_M_nonterminalSymbolAlts & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonterminalSymbolAlts::
operator_isNotEqual (const GGS_M_nonterminalSymbolAlts & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_nonterminalSymbolAlts info  ;
    info.mFormalParametersList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalParametersList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_nonterminalSymbolAlts::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_nonterminalSymbolAlts::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_nonterminalSymbolAlts & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAlts result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonterminalSymbolAlts result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonterminalSymbolAlts::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_nonterminalSymbolAlts " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_M_nonterminalSymbolAlts::cEnumerator::_mFormalParametersList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFormalParametersList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_nonterminalSymbolAlts::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_nonterminalSymbolAlts * p = NULL ;
    macroMyNew (p, GGS_M_nonterminalSymbolAlts (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAlts result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_nonterminalSymbolAlts * p = dynamic_cast <const GGS_M_nonterminalSymbolAlts *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_nonterminalSymbolAlts, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_nonterminalSymbolAlts::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_nonterminalSymbolAlts ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_grammarForSemantics'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarForSemantics::
cPtr_C_grammarForSemantics (const GGS_M_nonterminalSymbolAlts & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
mGrammarAltMap (argument_0),
mLexiqueClassName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_grammarForSemantics * GGS_C_grammarForSemantics::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarForSemantics *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_grammarForSemantics *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_grammarForSemantics::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_grammarForSemantics * ptr = dynamic_cast <const cPtr_C_grammarForSemantics *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mGrammarAltMap.operator_isEqual (ptr->mGrammarAltMap).boolValue ()
         && mLexiqueClassName.operator_isEqual (ptr->mLexiqueClassName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_grammarForSemantics::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_grammarForSemantics:"
           << mGrammarAltMap.reader_description (inIndentation + 1)
           << mLexiqueClassName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_grammarForSemantics::
static_string_message_messageTypeEntite (void) {
  return "a grammar entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_grammarForSemantics::
message_messageTypeEntite (void) const {
  return "a grammar entity" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_grammarForSemantics::
instanceMessage (void) const {
  return "a grammar entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_grammarForSemantics::
_static_message (void) {
  return "a grammar entity" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_grammarForSemantics (& typeid (cPtr_C_grammarForSemantics), & typeid (cPtr_AC_semanticsEntity), "a grammar entity") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_grammarForSemantics::galgasRTTI (void) const {
  return & gClassInfoFor__C_grammarForSemantics ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_grammarForSemantics::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_grammarForSemantics (mGrammarAltMap, mLexiqueClassName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarForSemantics'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_grammarForSemantics ("C_grammarForSemantics", true, & kTypeDescriptor_GGS_AC_semanticsEntity) ;

//---------------------------------------------------------------------------*

GGS_C_grammarForSemantics::
GGS_C_grammarForSemantics (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarForSemantics::
GGS_C_grammarForSemantics (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_grammarForSemantics GGS_C_grammarForSemantics::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_grammarForSemantics result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_grammarForSemantics *> (inPointer) != NULL)
      : (typeid (cPtr_C_grammarForSemantics) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_grammarForSemantics (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_grammarForSemantics),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarForSemantics GGS_C_grammarForSemantics::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_M_nonterminalSymbolAlts & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_grammarForSemantics result ;
  macroMyNew (result.mPointer, cPtr_C_grammarForSemantics (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_grammarForSemantics::
reader_messageTypeEntite (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarForSemantics *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_C_grammarForSemantics * p = (cPtr_C_grammarForSemantics *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts  GGS_C_grammarForSemantics::
reader_mGrammarAltMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonterminalSymbolAlts   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarForSemantics *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarForSemantics *) mPointer)->mGrammarAltMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarForSemantics::
reader_mLexiqueClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarForSemantics *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarForSemantics *) mPointer)->mLexiqueClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_grammarForSemantics::actualTypeName (void) const {
  return "C_grammarForSemantics" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_grammarForSemantics ("C_grammarForSemantics", gClassInfoFor__AC_semanticsEntity, & kTypeDescriptor_GGS_C_grammarForSemantics) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_grammarForSemantics::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_grammarForSemantics * p = NULL ;
    macroMyNew (p, GGS_C_grammarForSemantics (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarForSemantics GGS_C_grammarForSemantics::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_grammarForSemantics result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_grammarForSemantics * p = dynamic_cast <const GGS_C_grammarForSemantics *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_grammarForSemantics, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_grammarForSemantics::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_grammarForSemantics ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_AC_typeForGrammarComponent'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_typeForGrammarComponent::
cPtr_AC_typeForGrammarComponent (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_typeForGrammarComponent * GGS_AC_typeForGrammarComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_typeForGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_AC_typeForGrammarComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_typeForGrammarComponent::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@AC_typeForGrammarComponent:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent::
static_string_message_typeForGrammarComponentMessage (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent::
message_typeForGrammarComponentMessage (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_typeForGrammarComponent (& typeid (cPtr_AC_typeForGrammarComponent), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_AC_typeForGrammarComponent::galgasRTTI (void) const {
  return & gClassInfoFor__AC_typeForGrammarComponent ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_AC_typeForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_AC_typeForGrammarComponent ("AC_typeForGrammarComponent", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_AC_typeForGrammarComponent GGS_AC_typeForGrammarComponent::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_typeForGrammarComponent result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_typeForGrammarComponent *> (inPointer) != NULL)
      : (typeid (cPtr_AC_typeForGrammarComponent) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_AC_typeForGrammarComponent (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_typeForGrammarComponent),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_typeForGrammarComponent::
reader_typeForGrammarComponentMessage (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_typeForGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_AC_typeForGrammarComponent * p = (cPtr_AC_typeForGrammarComponent *) mPointer ;
    result = GGS_string (true, p->message_typeForGrammarComponentMessage ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_typeForGrammarComponent::actualTypeName (void) const {
  return "AC_typeForGrammarComponent" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_AC_typeForGrammarComponent::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__AC_typeForGrammarComponent ("AC_typeForGrammarComponent", & kTypeDescriptor_GGS_AC_typeForGrammarComponent) ;

//---------------------------------------------------------------------------*

GGS_object GGS_AC_typeForGrammarComponent::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_AC_typeForGrammarComponent * p = NULL ;
    macroMyNew (p, GGS_AC_typeForGrammarComponent (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent GGS_AC_typeForGrammarComponent::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_AC_typeForGrammarComponent result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_AC_typeForGrammarComponent * p = dynamic_cast <const GGS_AC_typeForGrammarComponent *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_AC_typeForGrammarComponent, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_AC_typeForGrammarComponent::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_AC_typeForGrammarComponent ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'e_M_typesForGrammarComponent'                    *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_typesForGrammarComponent::e_M_typesForGrammarComponent (void) :
mType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map '@M_typesForGrammarComponent'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_typesForGrammarComponent ("M_typesForGrammarComponent", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_typesForGrammarComponent::
elementOf_GGS_M_typesForGrammarComponent (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_typesForGrammarComponent & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_typesForGrammarComponent::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_typesForGrammarComponent::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_typesForGrammarComponent * ptr = dynamic_cast <const elementOf_GGS_M_typesForGrammarComponent *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mType.operator_isEqual (ptr->mInfo.mType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_typesForGrammarComponent::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_typesForGrammarComponent *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_typesForGrammarComponent * info = (e_M_typesForGrammarComponent *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_typesForGrammarComponent *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_typesForGrammarComponent * info = (e_M_typesForGrammarComponent *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_typesForGrammarComponent result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_typesForGrammarComponent info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_typesForGrammarComponent::
operator_isEqual (const GGS_M_typesForGrammarComponent & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_typesForGrammarComponent::
operator_isNotEqual (const GGS_M_typesForGrammarComponent & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_typeForGrammarComponent & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_typesForGrammarComponent info  ;
    info.mType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_typeForGrammarComponent   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_typesForGrammarComponent::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_typeForGrammarComponent   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_typesForGrammarComponent::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_typeForGrammarComponent & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_typesForGrammarComponent & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_typesForGrammarComponent result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_typesForGrammarComponent result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_typesForGrammarComponent::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_typesForGrammarComponent " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_typeForGrammarComponent  & GGS_M_typesForGrammarComponent::cEnumerator::_mType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_typesForGrammarComponent::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_typesForGrammarComponent * p = NULL ;
    macroMyNew (p, GGS_M_typesForGrammarComponent (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_typesForGrammarComponent result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_typesForGrammarComponent * p = dynamic_cast <const GGS_M_typesForGrammarComponent *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_typesForGrammarComponent, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_typesForGrammarComponent::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_typesForGrammarComponent ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "checkSignature_ForGrammarComponent"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkSignature_ForGrammarComponent (C_Compiler & inLexique,
                                const GGS_signatureForGrammarAnalysis   var_cas_inFormalReferenceSignature,
                                const GGS_signatureForGrammarAnalysis   var_cas_inFormalTestedSignature,
                                const GGS_location   var_cas_inFormalTestedLocation,
                                const GGS_location   var_cas_inFormalReferenceLocation COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkSignature_ForGrammarComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_bool cond_97191 = (var_cas_inFormalReferenceSignature.reader_length ()).operator_strictInf (var_cas_inFormalTestedSignature.reader_length ()) ;
  if (cond_97191.isBuiltAndTrue ()) {
    var_cas_inFormalTestedLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("too much formal parameters (from prototype in ")).operator_concat (var_cas_inFormalReferenceLocation.reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (2275)))).operator_concat (GGS_string (")")) COMMA_SOURCE_FILE_AT_LINE (2276)) ;
  }else if (cond_97191.isBuiltAndFalse ()) {
    const GGS_bool cond_97411 = (var_cas_inFormalReferenceSignature.reader_length ()).operator_strictSup (var_cas_inFormalTestedSignature.reader_length ()) ;
    if (cond_97411.isBuiltAndTrue ()) {
      var_cas_inFormalTestedLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("too much formal parameters (from prototype in ")).operator_concat (var_cas_inFormalReferenceLocation.reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (2277)))).operator_concat (GGS_string (")")) COMMA_SOURCE_FILE_AT_LINE (2278)) ;
    }else if (cond_97411.isBuiltAndFalse ()) {
      {
        GGS_signatureForGrammarAnalysis::cEnumerator enumerator_97450 (var_cas_inFormalReferenceSignature, true) ;
        const GGS_signatureForGrammarAnalysis::cElement * operand_97450 = NULL ;
        GGS_signatureForGrammarAnalysis::cEnumerator enumerator_97487 (var_cas_inFormalTestedSignature, true) ;
        const GGS_signatureForGrammarAnalysis::cElement * operand_97487 = NULL ;
        while (((operand_97450 = enumerator_97450.nextObject ()))
            && ((operand_97487 = enumerator_97487.nextObject ()))) {
          macroValidPointer (operand_97450) ;
          macroValidPointer (operand_97487) ;
          const GGS_bool cond_97905 = (operand_97450->mFormalArgumentPassingModeForGrammarAnalysis).operator_isNotEqual (operand_97487->mFormalArgumentPassingModeForGrammarAnalysis) ;
          if (cond_97905.isBuiltAndTrue ()) {
            operand_97487->mGalgasTypeNameForGrammarAnalysis.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("Prototype has ")).operator_concat (operand_97450->mFormalArgumentPassingModeForGrammarAnalysis.reader_formalArgumentMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (2282)))).operator_concat (GGS_string (", and "))).operator_concat (operand_97450->mFormalArgumentPassingModeForGrammarAnalysis.reader_formalArgumentMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (2283)))).operator_concat (GGS_string (" has been found")) COMMA_SOURCE_FILE_AT_LINE (2284)) ;
          }
          const GGS_bool cond_98253 = (operand_97450->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2285))).operator_isNotEqual (operand_97487->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2285))) ;
          if (cond_98253.isBuiltAndTrue ()) {
            operand_97487->mGalgasTypeNameForGrammarAnalysis.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("I was expecting the '@")).operator_concat (operand_97450->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2286)))).operator_concat (GGS_string ("' type, I have got the '@"))).operator_concat (operand_97487->mGalgasTypeNameForGrammarAnalysis.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2286)))).operator_concat (GGS_string ("' type")) COMMA_SOURCE_FILE_AT_LINE (2287)) ;
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkSignature_ForGrammarComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_L_grammarsMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_L_grammarsMap::e_L_grammarsMap (void) :
mStartSymbolParametersMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@L_grammarsMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_grammarsMap ("L_grammarsMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_L_grammarsMap::
elementOf_GGS_L_grammarsMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_L_grammarsMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_grammarsMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mStartSymbolParametersMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_grammarsMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_L_grammarsMap * ptr = dynamic_cast <const elementOf_GGS_L_grammarsMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mStartSymbolParametersMap.operator_isEqual (ptr->mInfo.mStartSymbolParametersMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_L_grammarsMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_L_grammarsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_L_grammarsMap * info = (e_L_grammarsMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_L_grammarsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_L_grammarsMap * info = (e_L_grammarsMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_grammarsMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_L_grammarsMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_grammarsMap::
operator_isEqual (const GGS_L_grammarsMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_grammarsMap::
operator_isNotEqual (const GGS_L_grammarsMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_nonterminalSymbolAlts & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_L_grammarsMap info  ;
    info.mStartSymbolParametersMap = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAlts   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mStartSymbolParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_L_grammarsMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('g'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_L_grammarsMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('g'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_L_grammarsMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_grammarsMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_grammarsMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_grammarsMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @L_grammarsMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_nonterminalSymbolAlts  & GGS_L_grammarsMap::cEnumerator::_mStartSymbolParametersMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mStartSymbolParametersMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_grammarsMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_grammarsMap * p = NULL ;
    macroMyNew (p, GGS_L_grammarsMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_grammarsMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_grammarsMap * p = dynamic_cast <const GGS_L_grammarsMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_grammarsMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_grammarsMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_grammarsMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeClassInheritedMessagesMap'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeClassInheritedMessagesMap ("typeClassInheritedMessagesMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeClassInheritedMessagesMap::
elementOf_GGS_typeClassInheritedMessagesMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeClassInheritedMessagesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeClassInheritedMessagesMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeClassInheritedMessagesMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassInheritedMessagesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeClassInheritedMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeClassInheritedMessagesMap * info = (e_typeClassInheritedMessagesMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeClassInheritedMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeClassInheritedMessagesMap * info = (e_typeClassInheritedMessagesMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassInheritedMessagesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeClassInheritedMessagesMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassInheritedMessagesMap::
operator_isEqual (const GGS_typeClassInheritedMessagesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassInheritedMessagesMap::
operator_isNotEqual (const GGS_typeClassInheritedMessagesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeClassInheritedMessagesMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeClassInheritedMessagesMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeClassInheritedMessagesMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeClassInheritedMessagesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassInheritedMessagesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassInheritedMessagesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeClassInheritedMessagesMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeClassInheritedMessagesMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeClassInheritedMessagesMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeClassInheritedMessagesMap * p = NULL ;
    macroMyNew (p, GGS_typeClassInheritedMessagesMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeClassInheritedMessagesMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeClassInheritedMessagesMap * p = dynamic_cast <const GGS_typeClassInheritedMessagesMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeClassInheritedMessagesMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeClassInheritedMessagesMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeClassInheritedMessagesMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'e_typeSemanticAttributesMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeSemanticAttributesMap::e_typeSemanticAttributesMap (void) :
mAttributType (),
mHasSetter (),
mHasGetter () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map '@typeSemanticAttributesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeSemanticAttributesMap ("typeSemanticAttributesMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeSemanticAttributesMap::
elementOf_GGS_typeSemanticAttributesMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeSemanticAttributesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSemanticAttributesMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAttributType.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasSetter.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasGetter.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeSemanticAttributesMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeSemanticAttributesMap * ptr = dynamic_cast <const elementOf_GGS_typeSemanticAttributesMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mAttributType.operator_isEqual (ptr->mInfo.mAttributType)).boolValue ()
           && (mInfo.mHasSetter.operator_isEqual (ptr->mInfo.mHasSetter)).boolValue ()
           && (mInfo.mHasGetter.operator_isEqual (ptr->mInfo.mHasGetter)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeSemanticAttributesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeSemanticAttributesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeSemanticAttributesMap * info = (e_typeSemanticAttributesMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeSemanticAttributesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeSemanticAttributesMap * info = (e_typeSemanticAttributesMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticAttributesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeSemanticAttributesMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSemanticAttributesMap::
operator_isEqual (const GGS_typeSemanticAttributesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSemanticAttributesMap::
operator_isNotEqual (const GGS_typeSemanticAttributesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_galgasType & inParameter0,
                const GGS_bool& inParameter1,
                const GGS_bool& inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeSemanticAttributesMap info  ;
    info.mAttributType = inParameter0 ;
    info.mHasSetter = inParameter1 ;
    info.mHasGetter = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_bool  & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mAttributType ;
    outParameter1 = node->mInfo.mHasSetter ;
    outParameter2 = node->mInfo.mHasGetter ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeSemanticAttributesMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_bool  & outParameter1,
                                GGS_bool  & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeSemanticAttributesMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0,
                                const GGS_bool& inParameter1,
                                const GGS_bool& inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeSemanticAttributesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticAttributesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSemanticAttributesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSemanticAttributesMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeSemanticAttributesMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeSemanticAttributesMap::cEnumerator::_mAttributType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAttributType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_typeSemanticAttributesMap::cEnumerator::_mHasSetter (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasSetter ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_typeSemanticAttributesMap::cEnumerator::_mHasGetter (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasGetter ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeSemanticAttributesMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeSemanticAttributesMap * p = NULL ;
    macroMyNew (p, GGS_typeSemanticAttributesMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeSemanticAttributesMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeSemanticAttributesMap * p = dynamic_cast <const GGS_typeSemanticAttributesMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeSemanticAttributesMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeSemanticAttributesMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeSemanticAttributesMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@insertOrSearchMethodList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_insertOrSearchMethodList::
elementOf_GGS_insertOrSearchMethodList (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMethodName (argument_0),
mErrorMessage (argument_1),
mIsGetIndexMethod (argument_2),
mShadowErrorMessage (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_insertOrSearchMethodList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_insertOrSearchMethodList * ptr = dynamic_cast <const elementOf_GGS_insertOrSearchMethodList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mErrorMessage.operator_isEqual (ptr->mErrorMessage).boolValue ()
         && mIsGetIndexMethod.operator_isEqual (ptr->mIsGetIndexMethod).boolValue ()
         && mShadowErrorMessage.operator_isEqual (ptr->mShadowErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_insertOrSearchMethodList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsGetIndexMethod.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mShadowErrorMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@insertOrSearchMethodList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_insertOrSearchMethodList ("insertOrSearchMethodList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_bool& argument_2,
                    const GGS_string& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_bool& argument_2,
                    const GGS_string& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2,
                                const GGS_string& argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList GGS_insertOrSearchMethodList::
operator_concat (const GGS_insertOrSearchMethodList & inOperand) const {
  GGS_insertOrSearchMethodList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
dotAssign_operation (const GGS_insertOrSearchMethodList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_insertOrSearchMethodList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_string p_1 = p->mErrorMessage ;
          GGS_bool p_2 = p->mIsGetIndexMethod ;
          GGS_string p_3 = p->mShadowErrorMessage ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_string& argument_1,
                     const GGS_bool& argument_2,
                     const GGS_string& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMethodName,
                                ptr->mErrorMessage,
                                ptr->mIsGetIndexMethod,
                                ptr->mShadowErrorMessage
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_insertOrSearchMethodList::
constructor_emptyList (void) {
  GGS_insertOrSearchMethodList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_insertOrSearchMethodList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2,
                                const GGS_string& argument_3) {
  GGS_insertOrSearchMethodList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
internalSubListWithRange (GGS_insertOrSearchMethodList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMethodName, ptr->mErrorMessage, ptr->mIsGetIndexMethod, ptr->mShadowErrorMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList GGS_insertOrSearchMethodList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_insertOrSearchMethodList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList GGS_insertOrSearchMethodList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_insertOrSearchMethodList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertOrSearchMethodList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@insertOrSearchMethodList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_string& _out_1,
              GGS_bool& _out_2,
              GGS_string& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
    _out_2 = ptr->mIsGetIndexMethod ;
    _out_3 = ptr->mShadowErrorMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_string& _out_1,
             GGS_bool& _out_2,
             GGS_string& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
    _out_2 = ptr->mIsGetIndexMethod ;
    _out_3 = ptr->mShadowErrorMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_string& _out_1,
                 GGS_bool& _out_2,
                 GGS_string& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
    _out_2 = ptr->mIsGetIndexMethod ;
    _out_3 = ptr->mShadowErrorMessage ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_string& _out_1,
                GGS_bool& _out_2,
                GGS_string& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
    _out_2 = ptr->mIsGetIndexMethod ;
    _out_3 = ptr->mShadowErrorMessage ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_insertOrSearchMethodList::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertOrSearchMethodList::
reader_mErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_insertOrSearchMethodList::
reader_mIsGetIndexMethodAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsGetIndexMethod ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertOrSearchMethodList::
reader_mShadowErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mShadowErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_setMErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_setMIsGetIndexMethodAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsGetIndexMethod = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_setMShadowErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mShadowErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_insertOrSearchMethodList::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_insertOrSearchMethodList::cEnumerator::_mErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mErrorMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_insertOrSearchMethodList::cEnumerator::_mIsGetIndexMethod (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsGetIndexMethod ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_insertOrSearchMethodList::cEnumerator::_mShadowErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mShadowErrorMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_insertOrSearchMethodList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_insertOrSearchMethodList * p = NULL ;
    macroMyNew (p, GGS_insertOrSearchMethodList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList GGS_insertOrSearchMethodList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_insertOrSearchMethodList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_insertOrSearchMethodList * p = dynamic_cast <const GGS_insertOrSearchMethodList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_insertOrSearchMethodList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_insertOrSearchMethodList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_insertOrSearchMethodList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeDefEntiteUtilisable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefEntiteUtilisable::
cPtr_typeDefEntiteUtilisable (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefEntiteUtilisable * GGS_typeDefEntiteUtilisable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefEntiteUtilisable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDefEntiteUtilisable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeDefEntiteUtilisable::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeDefEntiteUtilisable:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable::
static_string_message_messageTypeEntite (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable::
message_messageTypeEntite (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDefEntiteUtilisable (& typeid (cPtr_typeDefEntiteUtilisable), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeDefEntiteUtilisable::galgasRTTI (void) const {
  return & gClassInfoFor__typeDefEntiteUtilisable ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeDefEntiteUtilisable'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeDefEntiteUtilisable ("typeDefEntiteUtilisable", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDefEntiteUtilisable GGS_typeDefEntiteUtilisable::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDefEntiteUtilisable result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDefEntiteUtilisable *> (inPointer) != NULL)
      : (typeid (cPtr_typeDefEntiteUtilisable) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDefEntiteUtilisable (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDefEntiteUtilisable),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDefEntiteUtilisable::
reader_messageTypeEntite (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefEntiteUtilisable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeDefEntiteUtilisable * p = (cPtr_typeDefEntiteUtilisable *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDefEntiteUtilisable::actualTypeName (void) const {
  return "typeDefEntiteUtilisable" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_typeDefEntiteUtilisable::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__typeDefEntiteUtilisable ("typeDefEntiteUtilisable", & kTypeDescriptor_GGS_typeDefEntiteUtilisable) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeDefEntiteUtilisable::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeDefEntiteUtilisable * p = NULL ;
    macroMyNew (p, GGS_typeDefEntiteUtilisable (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable GGS_typeDefEntiteUtilisable::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeDefEntiteUtilisable result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeDefEntiteUtilisable * p = dynamic_cast <const GGS_typeDefEntiteUtilisable *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeDefEntiteUtilisable, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeDefEntiteUtilisable::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeDefEntiteUtilisable ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeGalgasUndefinedListType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedListType::
cPtr_typeGalgasUndefinedListType (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mListTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedListType * GGS_typeGalgasUndefinedListType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedListType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedListType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedListType * ptr = dynamic_cast <const cPtr_typeGalgasUndefinedListType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListTypeName.operator_isEqual (ptr->mListTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedListType::
method_getTypeName (C_Compiler & inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2364)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedListType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasUndefinedListType:"
           << mListTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedListType::
static_string_message_messageGalgasType (void) {
  return "an undefined list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedListType::
message_messageGalgasType (void) const {
  return "an undefined list type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedListType::
instanceMessage (void) const {
  return "an undefined list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedListType::
_static_message (void) {
  return "an undefined list type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasUndefinedListType (& typeid (cPtr_typeGalgasUndefinedListType), & typeid (cPtr_AC_galgasType), "an undefined list type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasUndefinedListType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasUndefinedListType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasUndefinedListType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasUndefinedListType (mListTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedListType'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasUndefinedListType ("typeGalgasUndefinedListType", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedListType::
GGS_typeGalgasUndefinedListType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedListType::
GGS_typeGalgasUndefinedListType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasUndefinedListType GGS_typeGalgasUndefinedListType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedListType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasUndefinedListType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasUndefinedListType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasUndefinedListType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasUndefinedListType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedListType GGS_typeGalgasUndefinedListType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedListType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasUndefinedListType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedListType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasUndefinedListType * p = (cPtr_typeGalgasUndefinedListType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasUndefinedListType::
reader_mListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasUndefinedListType *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasUndefinedListType::actualTypeName (void) const {
  return "typeGalgasUndefinedListType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasUndefinedListType ("typeGalgasUndefinedListType", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgasUndefinedListType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasUndefinedListType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasUndefinedListType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasUndefinedListType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedListType GGS_typeGalgasUndefinedListType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedListType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasUndefinedListType * p = dynamic_cast <const GGS_typeGalgasUndefinedListType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasUndefinedListType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasUndefinedListType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasUndefinedListType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgasListType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasListType::
cPtr_typeGalgasListType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_EXsignature & argument_2,
                                const GGS_L_EXsignature & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedListType (argument_0 COMMA_THERE),
mAttributeList (argument_1),
mExtractSignature (argument_2),
mInputSignature (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasListType * GGS_typeGalgasListType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasListType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasListType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasListType * ptr = dynamic_cast <const cPtr_typeGalgasListType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListTypeName.operator_isEqual (ptr->mListTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mExtractSignature.operator_isEqual (ptr->mExtractSignature).boolValue ()
         && mInputSignature.operator_isEqual (ptr->mInputSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_acceptForeachInstruction (C_Compiler & inLexique,
                                GGS_M_semanticsEntitiesForUse  /* var_cas_inSemanticsEntitiesForUse */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle,
                                GGS_bool& var_cas_outNewStyle COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outNewStyle = GGS_bool (false) ;
  var_cas_outForeachList = mAttributeList ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_listStyle (inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_104452 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2430))).operator_isEqual (GGS_string ("prependValue")) ;
  if (cond_104452.isBuiltAndTrue ()) {
    var_cas_outModifierSignature = mInputSignature ;
  }else if (cond_104452.isBuiltAndFalse ()) {
    const GGS_bool cond_104597 = ((var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2432))).operator_isEqual (GGS_string ("popFirst"))).operator_or ((var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2432))).operator_isEqual (GGS_string ("popLast"))) ;
    if (cond_104597.isBuiltAndTrue ()) {
      var_cas_outModifierSignature = mExtractSignature ;
    }else if (cond_104597.isBuiltAndFalse ()) {
      var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
      GGS_bool var_cas_found = GGS_bool (false) ;
      {
        GGS_typeListeAttributsSemantiques::cEnumerator enumerator_104714 (mAttributeList, true) ;
        const GGS_typeListeAttributsSemantiques::cElement * operand_104714 = NULL ;
        while (((operand_104714 = enumerator_104714.nextObject ()))
            && ((var_cas_found).operator_not ().isBuiltAndTrue ())) {
          macroValidPointer (operand_104714) ;
          var_cas_found = (((GGS_string ("set")).operator_concat (operand_104714->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2438)).reader_stringByCapitalizingFirstCharacter ())).operator_concat (GGS_string ("AtIndex"))).operator_isEqual (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2438))) ;
          const GGS_bool cond_105107 = var_cas_found ;
          if (cond_105107.isBuiltAndTrue ()) {
            var_cas_outModifierSignature.addAssign_operation (operand_104714->mAttributType, GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
            var_cas_outModifierSignature.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
          }
        }
      }
      const GGS_bool cond_105286 = (var_cas_found).operator_not () ;
      if (cond_105286.isBuiltAndTrue ()) {
        var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2446)))).operator_concat (GGS_string ("' modifier is not supported by the list")) COMMA_SOURCE_FILE_AT_LINE (2447)) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_handleMethodInstructionCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outReaderSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string ("") ;
  const GGS_bool cond_105806 = ((var_cas_inMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2461))).operator_isNotEqual (GGS_string ("first"))).operator_and ((var_cas_inMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2461))).operator_isNotEqual (GGS_string ("last"))) ;
  if (cond_105806.isBuiltAndTrue ()) {
    var_cas_inMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a list accepts only 'first' and 'last' methods") COMMA_SOURCE_FILE_AT_LINE (2463)) ;
  }
  var_cas_outReaderSignature = mExtractSignature ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_handleAddAssignOperatorCall (C_Compiler & /* inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outParametersList = mAttributeList ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgasListType (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
  const GGS_bool cond_106615 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2484))).operator_isEqual (GGS_string ("emptyList")) ;
  if (cond_106615.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (cond_106615.isBuiltAndFalse ()) {
    const GGS_bool cond_106722 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2486))).operator_isEqual (GGS_string ("listWithValue")) ;
    if (cond_106722.isBuiltAndTrue ()) {
      var_cas_outAccessorTypesList = mAttributeList ;
    }else if (cond_106722.isBuiltAndFalse ()) {
      var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (2490)) ;
      var_cas_outAccessorTypesList.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasListType:"
           << mListTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mExtractSignature.reader_description (inIndentation + 1)
           << mInputSignature.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListType::
static_string_message_messageGalgasType (void) {
  return "a list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListType::
message_messageGalgasType (void) const {
  return "a list type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListType::
instanceMessage (void) const {
  return "a list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListType::
_static_message (void) {
  return "a list type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasListType (& typeid (cPtr_typeGalgasListType), & typeid (cPtr_typeGalgasUndefinedListType), "a list type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasListType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasListType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasListType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasListType (mListTypeName, mAttributeList, mExtractSignature, mInputSignature COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasListType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasListType ("typeGalgasListType", true, & kTypeDescriptor_GGS_typeGalgasUndefinedListType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasListType::
GGS_typeGalgasListType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListType::
GGS_typeGalgasListType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasListType GGS_typeGalgasListType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasListType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasListType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasListType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasListType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListType GGS_typeGalgasListType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_L_EXsignature & argument_2,
                 const GGS_L_EXsignature & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasListType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasListType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasListType * p = (cPtr_typeGalgasListType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasListType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasListType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasListType::actualTypeName (void) const {
  return "typeGalgasListType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasListType ("typeGalgasListType", gClassInfoFor__typeGalgasUndefinedListType, & kTypeDescriptor_GGS_typeGalgasListType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasListType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasListType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasListType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListType GGS_typeGalgasListType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasListType * p = dynamic_cast <const GGS_typeGalgasListType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasListType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasListType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasListType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeGalgasStructType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasStructType::
cPtr_typeGalgasStructType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mStructTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasStructType * GGS_typeGalgasStructType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasStructType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasStructType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasStructType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasStructType * ptr = dynamic_cast <const cPtr_typeGalgasStructType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStructTypeName.operator_isEqual (ptr->mStructTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasStructType::
method_getTypeName (C_Compiler & inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mStructTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2509)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasStructType::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgasStructType (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
  const GGS_bool cond_108018 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2521))).operator_isEqual (GGS_string ("new")) ;
  if (cond_108018.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = mAttributeList ;
  }else if (cond_108018.isBuiltAndFalse ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (var_cas_inClassMethodName)).operator_concat (GGS_string ("' constructor is not defined")) COMMA_SOURCE_FILE_AT_LINE (2525)) ;
    var_cas_outAccessorTypesList.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasStructType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasStructType:"
           << mStructTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasStructType::
static_string_message_messageGalgasType (void) {
  return "a struct type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasStructType::
message_messageGalgasType (void) const {
  return "a struct type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasStructType::
instanceMessage (void) const {
  return "a struct type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasStructType::
_static_message (void) {
  return "a struct type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasStructType (& typeid (cPtr_typeGalgasStructType), & typeid (cPtr_AC_galgasType), "a struct type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasStructType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasStructType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasStructType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasStructType (mStructTypeName, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgasStructType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasStructType ("typeGalgasStructType", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasStructType::
GGS_typeGalgasStructType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasStructType::
GGS_typeGalgasStructType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasStructType GGS_typeGalgasStructType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasStructType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasStructType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasStructType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasStructType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasStructType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasStructType GGS_typeGalgasStructType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasStructType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasStructType (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasStructType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasStructType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasStructType * p = (cPtr_typeGalgasStructType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasStructType::
reader_mStructTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasStructType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasStructType *) mPointer)->mStructTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasStructType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasStructType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasStructType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasStructType::actualTypeName (void) const {
  return "typeGalgasStructType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasStructType ("typeGalgasStructType", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgasStructType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasStructType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasStructType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasStructType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasStructType GGS_typeGalgasStructType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasStructType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasStructType * p = dynamic_cast <const GGS_typeGalgasStructType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasStructType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasStructType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasStructType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeGalgasListmapType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasListmapType::
cPtr_typeGalgasListmapType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeGalgasListType & argument_2,
                                const GGS_typeListeAttributsSemantiques & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mListmapTypeName (argument_0),
mListTypename (argument_1),
mListType (argument_2),
mAttributeList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasListmapType * GGS_typeGalgasListmapType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListmapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasListmapType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasListmapType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasListmapType * ptr = dynamic_cast <const cPtr_typeGalgasListmapType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListmapTypeName.operator_isEqual (ptr->mListmapTypeName).boolValue ()
         && mListTypename.operator_isEqual (ptr->mListTypename).boolValue ()
         && mListType.operator_isEqual (ptr->mListType).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListmapType::
method_acceptForeachInstruction (C_Compiler & inLexique,
                                GGS_M_semanticsEntitiesForUse  /* var_cas_inSemanticsEntitiesForUse */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle,
                                GGS_bool& var_cas_outNewStyle COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outNewStyle = GGS_bool (true) ;
  var_cas_outForeachList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_outForeachList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("key"), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_outForeachList.addAssign_operation (mListType, GGS_lstring ::constructor_new (inLexique, GGS_string ("object"), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_listStyle (inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListmapType::
method_getTypeName (C_Compiler & inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mListmapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2564)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListmapType::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgasListmapType (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
  const GGS_bool cond_110189 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2576))).operator_isEqual (GGS_string ("emptyMap")) ;
  if (cond_110189.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (cond_110189.isBuiltAndFalse ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (var_cas_inClassMethodName)).operator_concat (GGS_string ("' constructor is not defined")) COMMA_SOURCE_FILE_AT_LINE (2580)) ;
    var_cas_outAccessorTypesList.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListmapType::
method_handleAddAssignOperatorCall (C_Compiler & inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outParametersList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_outParametersList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("key"), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_outParametersList = (var_cas_outParametersList).operator_concat (mAttributeList) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListmapType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasListmapType:"
           << mListmapTypeName.reader_description (inIndentation + 1)
           << mListTypename.reader_description (inIndentation + 1)
           << mListType.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListmapType::
static_string_message_messageGalgasType (void) {
  return "a listmap type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListmapType::
message_messageGalgasType (void) const {
  return "a listmap type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListmapType::
instanceMessage (void) const {
  return "a listmap type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListmapType::
_static_message (void) {
  return "a listmap type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasListmapType (& typeid (cPtr_typeGalgasListmapType), & typeid (cPtr_AC_galgasType), "a listmap type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasListmapType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasListmapType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasListmapType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasListmapType (mListmapTypeName, mListTypename, mListType, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgasListmapType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasListmapType ("typeGalgasListmapType", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasListmapType::
GGS_typeGalgasListmapType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListmapType::
GGS_typeGalgasListmapType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasListmapType GGS_typeGalgasListmapType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListmapType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasListmapType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasListmapType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasListmapType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasListmapType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListmapType GGS_typeGalgasListmapType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeGalgasListType & argument_2,
                 const GGS_typeListeAttributsSemantiques & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListmapType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasListmapType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasListmapType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListmapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasListmapType * p = (cPtr_typeGalgasListmapType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListType  GGS_typeGalgasListmapType::
reader_mListType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeGalgasListType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListmapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasListmapType *) mPointer)->mListType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasListmapType::actualTypeName (void) const {
  return "typeGalgasListmapType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasListmapType ("typeGalgasListmapType", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgasListmapType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasListmapType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasListmapType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasListmapType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListmapType GGS_typeGalgasListmapType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListmapType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasListmapType * p = dynamic_cast <const GGS_typeGalgasListmapType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasListmapType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasListmapType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasListmapType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of once function "EXbuild_uintlist_type"           *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_AC_galgasType  gCachedResultForOnceFunction_EXbuild_uintlist_type ;
static bool gCacheFlagForOnceFunction_EXbuild_uintlist_type = false ;

//---------------------------------------------------------------------------*

GGS_AC_galgasType  function_EXbuild_uintlist_type (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_EXbuild_uintlist_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_EXbuild_uintlist_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_AC_galgasType  var_cas_outType ;
    GGS_typeListeAttributsSemantiques  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue"), GGS_location (inLexique) COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_outType = GGS_typeGalgasListType ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uintlist"), GGS_location (inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_EXbuild_uintlist_type\n") ;
    #endif
    gCacheFlagForOnceFunction_EXbuild_uintlist_type = true ;
    gCachedResultForOnceFunction_EXbuild_uintlist_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_EXbuild_uintlist_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_EXbuild_uintlist_type (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_AC_galgasType  result = function_EXbuild_uintlist_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptor kFunction_descriptor_EXbuild_uintlist_type ("EXbuild_uintlist_type",
                              functionForGenericCall_EXbuild_uintlist_type,
                              & kTypeDescriptor_GGS_AC_galgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of once function "EXbuild_luintlist_type"          *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_AC_galgasType  gCachedResultForOnceFunction_EXbuild_luintlist_type ;
static bool gCacheFlagForOnceFunction_EXbuild_luintlist_type = false ;

//---------------------------------------------------------------------------*

GGS_AC_galgasType  function_EXbuild_luintlist_type (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_EXbuild_luintlist_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_EXbuild_luintlist_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_AC_galgasType  var_cas_outType ;
    GGS_typeListeAttributsSemantiques  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_luint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue"), GGS_location (inLexique) COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_luint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_luint ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_outType = GGS_typeGalgasListType ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("luintlist"), GGS_location (inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_EXbuild_luintlist_type\n") ;
    #endif
    gCacheFlagForOnceFunction_EXbuild_luintlist_type = true ;
    gCachedResultForOnceFunction_EXbuild_luintlist_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_EXbuild_luintlist_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_EXbuild_luintlist_type (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_AC_galgasType  result = function_EXbuild_luintlist_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptor kFunction_descriptor_EXbuild_luintlist_type ("EXbuild_luintlist_type",
                              functionForGenericCall_EXbuild_luintlist_type,
                              & kTypeDescriptor_GGS_AC_galgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of once function "EXbuild_uint64list_type"          *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_AC_galgasType  gCachedResultForOnceFunction_EXbuild_uint64list_type ;
static bool gCacheFlagForOnceFunction_EXbuild_uint64list_type = false ;

//---------------------------------------------------------------------------*

GGS_AC_galgasType  function_EXbuild_uint64list_type (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_EXbuild_uint64list_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_EXbuild_uint64list_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_AC_galgasType  var_cas_outType ;
    GGS_typeListeAttributsSemantiques  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue"), GGS_location (inLexique) COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_outType = GGS_typeGalgasListType ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint64list"), GGS_location (inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_EXbuild_uint64list_type\n") ;
    #endif
    gCacheFlagForOnceFunction_EXbuild_uint64list_type = true ;
    gCachedResultForOnceFunction_EXbuild_uint64list_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_EXbuild_uint64list_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_EXbuild_uint64list_type (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_AC_galgasType  result = function_EXbuild_uint64list_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptor kFunction_descriptor_EXbuild_uint64list_type ("EXbuild_uint64list_type",
                              functionForGenericCall_EXbuild_uint64list_type,
                              & kTypeDescriptor_GGS_AC_galgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of once function "EXbuild_charlist_type"           *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_AC_galgasType  gCachedResultForOnceFunction_EXbuild_charlist_type ;
static bool gCacheFlagForOnceFunction_EXbuild_charlist_type = false ;

//---------------------------------------------------------------------------*

GGS_AC_galgasType  function_EXbuild_charlist_type (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_EXbuild_charlist_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_EXbuild_charlist_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_AC_galgasType  var_cas_outType ;
    GGS_typeListeAttributsSemantiques  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_char ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue"), GGS_location (inLexique) COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_outType = GGS_typeGalgasListType ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("charlist"), GGS_location (inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_EXbuild_charlist_type\n") ;
    #endif
    gCacheFlagForOnceFunction_EXbuild_charlist_type = true ;
    gCachedResultForOnceFunction_EXbuild_charlist_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_EXbuild_charlist_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_EXbuild_charlist_type (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_AC_galgasType  result = function_EXbuild_charlist_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptor kFunction_descriptor_EXbuild_charlist_type ("EXbuild_charlist_type",
                              functionForGenericCall_EXbuild_charlist_type,
                              & kTypeDescriptor_GGS_AC_galgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of once function "EXbuild_lcharlist_type"          *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_AC_galgasType  gCachedResultForOnceFunction_EXbuild_lcharlist_type ;
static bool gCacheFlagForOnceFunction_EXbuild_lcharlist_type = false ;

//---------------------------------------------------------------------------*

GGS_AC_galgasType  function_EXbuild_lcharlist_type (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_EXbuild_lcharlist_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_EXbuild_lcharlist_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_AC_galgasType  var_cas_outType ;
    GGS_typeListeAttributsSemantiques  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_lchar ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue"), GGS_location (inLexique) COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_outType = GGS_typeGalgasListType ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lcharlist"), GGS_location (inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_EXbuild_lcharlist_type\n") ;
    #endif
    gCacheFlagForOnceFunction_EXbuild_lcharlist_type = true ;
    gCachedResultForOnceFunction_EXbuild_lcharlist_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_EXbuild_lcharlist_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_EXbuild_lcharlist_type (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_AC_galgasType  result = function_EXbuild_lcharlist_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptor kFunction_descriptor_EXbuild_lcharlist_type ("EXbuild_lcharlist_type",
                              functionForGenericCall_EXbuild_lcharlist_type,
                              & kTypeDescriptor_GGS_AC_galgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of once function "EXbuild_stringlist_type"          *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_AC_galgasType  gCachedResultForOnceFunction_EXbuild_stringlist_type ;
static bool gCacheFlagForOnceFunction_EXbuild_stringlist_type = false ;

//---------------------------------------------------------------------------*

GGS_AC_galgasType  function_EXbuild_stringlist_type (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_EXbuild_stringlist_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_EXbuild_stringlist_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_AC_galgasType  var_cas_outType ;
    GGS_typeListeAttributsSemantiques  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue"), GGS_location (inLexique) COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_outType = GGS_typeGalgasListType ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("stringlist"), GGS_location (inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_EXbuild_stringlist_type\n") ;
    #endif
    gCacheFlagForOnceFunction_EXbuild_stringlist_type = true ;
    gCachedResultForOnceFunction_EXbuild_stringlist_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_EXbuild_stringlist_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_EXbuild_stringlist_type (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_AC_galgasType  result = function_EXbuild_stringlist_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptor kFunction_descriptor_EXbuild_stringlist_type ("EXbuild_stringlist_type",
                              functionForGenericCall_EXbuild_stringlist_type,
                              & kTypeDescriptor_GGS_AC_galgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of once function "EXbuild_string2list_type"         *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_AC_galgasType  gCachedResultForOnceFunction_EXbuild_string2list_type ;
static bool gCacheFlagForOnceFunction_EXbuild_string2list_type = false ;

//---------------------------------------------------------------------------*

GGS_AC_galgasType  function_EXbuild_string2list_type (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_EXbuild_string2list_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_EXbuild_string2list_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_AC_galgasType  var_cas_outType ;
    GGS_typeListeAttributsSemantiques  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue0"), GGS_location (inLexique) COMMA_HERE)) ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue1"), GGS_location (inLexique) COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_outType = GGS_typeGalgasListType ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string2list"), GGS_location (inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_EXbuild_string2list_type\n") ;
    #endif
    gCacheFlagForOnceFunction_EXbuild_string2list_type = true ;
    gCachedResultForOnceFunction_EXbuild_string2list_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_EXbuild_string2list_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_EXbuild_string2list_type (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_AC_galgasType  result = function_EXbuild_string2list_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptor kFunction_descriptor_EXbuild_string2list_type ("EXbuild_string2list_type",
                              functionForGenericCall_EXbuild_string2list_type,
                              & kTypeDescriptor_GGS_AC_galgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of once function "EXbuild_string3list_type"         *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_AC_galgasType  gCachedResultForOnceFunction_EXbuild_string3list_type ;
static bool gCacheFlagForOnceFunction_EXbuild_string3list_type = false ;

//---------------------------------------------------------------------------*

GGS_AC_galgasType  function_EXbuild_string3list_type (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_EXbuild_string3list_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_EXbuild_string3list_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_AC_galgasType  var_cas_outType ;
    GGS_typeListeAttributsSemantiques  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue0"), GGS_location (inLexique) COMMA_HERE)) ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue1"), GGS_location (inLexique) COMMA_HERE)) ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue2"), GGS_location (inLexique) COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_outType = GGS_typeGalgasListType ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string3list"), GGS_location (inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_EXbuild_string3list_type\n") ;
    #endif
    gCacheFlagForOnceFunction_EXbuild_string3list_type = true ;
    gCachedResultForOnceFunction_EXbuild_string3list_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_EXbuild_string3list_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_EXbuild_string3list_type (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_AC_galgasType  result = function_EXbuild_string3list_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptor kFunction_descriptor_EXbuild_string3list_type ("EXbuild_string3list_type",
                              functionForGenericCall_EXbuild_string3list_type,
                              & kTypeDescriptor_GGS_AC_galgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of once function "EXbuild_lstringlist_type"         *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_AC_galgasType  gCachedResultForOnceFunction_EXbuild_lstringlist_type ;
static bool gCacheFlagForOnceFunction_EXbuild_lstringlist_type = false ;

//---------------------------------------------------------------------------*

GGS_AC_galgasType  function_EXbuild_lstringlist_type (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_EXbuild_lstringlist_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_EXbuild_lstringlist_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_AC_galgasType  var_cas_outType ;
    GGS_typeListeAttributsSemantiques  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_lstring ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue"), GGS_location (inLexique) COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_lstring ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_lstring ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_outType = GGS_typeGalgasListType ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstringlist"), GGS_location (inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_EXbuild_lstringlist_type\n") ;
    #endif
    gCacheFlagForOnceFunction_EXbuild_lstringlist_type = true ;
    gCachedResultForOnceFunction_EXbuild_lstringlist_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_EXbuild_lstringlist_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_EXbuild_lstringlist_type (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_AC_galgasType  result = function_EXbuild_lstringlist_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptor kFunction_descriptor_EXbuild_lstringlist_type ("EXbuild_lstringlist_type",
                              functionForGenericCall_EXbuild_lstringlist_type,
                              & kTypeDescriptor_GGS_AC_galgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of once function "EXbuild_typelist_type"           *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_AC_galgasType  gCachedResultForOnceFunction_EXbuild_typelist_type ;
static bool gCacheFlagForOnceFunction_EXbuild_typelist_type = false ;

//---------------------------------------------------------------------------*

GGS_AC_galgasType  function_EXbuild_typelist_type (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_EXbuild_typelist_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_EXbuild_typelist_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_AC_galgasType  var_cas_outType ;
    GGS_typeListeAttributsSemantiques  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue"), GGS_location (inLexique) COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_outType = GGS_typeGalgasListType ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("typelist"), GGS_location (inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_EXbuild_typelist_type\n") ;
    #endif
    gCacheFlagForOnceFunction_EXbuild_typelist_type = true ;
    gCachedResultForOnceFunction_EXbuild_typelist_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_EXbuild_typelist_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_EXbuild_typelist_type (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_AC_galgasType  result = function_EXbuild_typelist_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptor kFunction_descriptor_EXbuild_typelist_type ("EXbuild_typelist_type",
                              functionForGenericCall_EXbuild_typelist_type,
                              & kTypeDescriptor_GGS_AC_galgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of once function "EXbuild_objectlist_type"          *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_AC_galgasType  gCachedResultForOnceFunction_EXbuild_objectlist_type ;
static bool gCacheFlagForOnceFunction_EXbuild_objectlist_type = false ;

//---------------------------------------------------------------------------*

GGS_AC_galgasType  function_EXbuild_objectlist_type (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_EXbuild_objectlist_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_EXbuild_objectlist_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_AC_galgasType  var_cas_outType ;
    GGS_typeListeAttributsSemantiques  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue"), GGS_location (inLexique) COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_outType = GGS_typeGalgasListType ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("objectlist"), GGS_location (inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_EXbuild_objectlist_type\n") ;
    #endif
    gCacheFlagForOnceFunction_EXbuild_objectlist_type = true ;
    gCachedResultForOnceFunction_EXbuild_objectlist_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_EXbuild_objectlist_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_EXbuild_objectlist_type (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_AC_galgasType  result = function_EXbuild_objectlist_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptor kFunction_descriptor_EXbuild_objectlist_type ("EXbuild_objectlist_type",
                              functionForGenericCall_EXbuild_objectlist_type,
                              & kTypeDescriptor_GGS_AC_galgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of once function "EXbuild_functionlist_type"         *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_AC_galgasType  gCachedResultForOnceFunction_EXbuild_functionlist_type ;
static bool gCacheFlagForOnceFunction_EXbuild_functionlist_type = false ;

//---------------------------------------------------------------------------*

GGS_AC_galgasType  function_EXbuild_functionlist_type (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_EXbuild_functionlist_type) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_EXbuild_functionlist_type at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_AC_galgasType  var_cas_outType ;
    GGS_typeListeAttributsSemantiques  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_attributesList.addAssign_operation (GGS_typeGalgas_function ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue"), GGS_location (inLexique) COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_extractSignature.addAssign_operation (GGS_typeGalgas_function ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    GGS_L_EXsignature  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_inputSignature.addAssign_operation (GGS_typeGalgas_function ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_outType = GGS_typeGalgasListType ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("functionlist"), GGS_location (inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_EXbuild_functionlist_type\n") ;
    #endif
    gCacheFlagForOnceFunction_EXbuild_functionlist_type = true ;
    gCachedResultForOnceFunction_EXbuild_functionlist_type = var_cas_outType ;
  }
  return gCachedResultForOnceFunction_EXbuild_functionlist_type ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_EXbuild_functionlist_type (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_AC_galgasType  result = function_EXbuild_functionlist_type (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptor kFunction_descriptor_EXbuild_functionlist_type ("EXbuild_functionlist_type",
                              functionForGenericCall_EXbuild_functionlist_type,
                              & kTypeDescriptor_GGS_AC_galgasType ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_domainRelationMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_domainRelationMap::e_domainRelationMap (void) :
mDomains () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@domainRelationMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_domainRelationMap ("domainRelationMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_domainRelationMap::
elementOf_GGS_domainRelationMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_domainRelationMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_domainRelationMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mDomains.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_domainRelationMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_domainRelationMap * ptr = dynamic_cast <const elementOf_GGS_domainRelationMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mDomains.operator_isEqual (ptr->mInfo.mDomains)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_domainRelationMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_domainRelationMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_domainRelationMap * info = (e_domainRelationMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_domainRelationMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_domainRelationMap * info = (e_domainRelationMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_domainRelationMap GGS_domainRelationMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_domainRelationMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_domainRelationMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_domainRelationMap::
operator_isEqual (const GGS_domainRelationMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_domainRelationMap::
operator_isNotEqual (const GGS_domainRelationMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_stringlist & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_domainRelationMap info  ;
    info.mDomains = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_stringlist   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mDomains ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_domainRelationMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_stringlist   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_domainRelationMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_stringlist & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_domainRelationMap GGS_domainRelationMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_domainRelationMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_domainRelationMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainRelationMap GGS_domainRelationMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainRelationMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_domainRelationMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @domainRelationMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_stringlist  & GGS_domainRelationMap::cEnumerator::_mDomains (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDomains ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_domainRelationMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_domainRelationMap * p = NULL ;
    macroMyNew (p, GGS_domainRelationMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainRelationMap GGS_domainRelationMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_domainRelationMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_domainRelationMap * p = dynamic_cast <const GGS_domainRelationMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_domainRelationMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_domainRelationMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_domainRelationMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_domainModifierMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_domainModifierMap::e_domainModifierMap (void) :
mFormalParametersList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@domainModifierMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_domainModifierMap ("domainModifierMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_domainModifierMap::
elementOf_GGS_domainModifierMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_domainModifierMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_domainModifierMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFormalParametersList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_domainModifierMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_domainModifierMap * ptr = dynamic_cast <const elementOf_GGS_domainModifierMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFormalParametersList.operator_isEqual (ptr->mInfo.mFormalParametersList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_domainModifierMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_domainModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_domainModifierMap * info = (e_domainModifierMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_domainModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_domainModifierMap * info = (e_domainModifierMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_domainModifierMap GGS_domainModifierMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_domainModifierMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_domainModifierMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_domainModifierMap::
operator_isEqual (const GGS_domainModifierMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_domainModifierMap::
operator_isNotEqual (const GGS_domainModifierMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_domainModifierMap info  ;
    info.mFormalParametersList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalParametersList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_domainModifierMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_domainModifierMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_domainModifierMap GGS_domainModifierMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_domainModifierMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_domainModifierMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainModifierMap GGS_domainModifierMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainModifierMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_domainModifierMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @domainModifierMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_domainModifierMap::cEnumerator::_mFormalParametersList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFormalParametersList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_domainModifierMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_domainModifierMap * p = NULL ;
    macroMyNew (p, GGS_domainModifierMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainModifierMap GGS_domainModifierMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_domainModifierMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_domainModifierMap * p = dynamic_cast <const GGS_domainModifierMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_domainModifierMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_domainModifierMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_domainModifierMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@domainAttributeMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_domainAttributeMap ("domainAttributeMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_domainAttributeMap::
elementOf_GGS_domainAttributeMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_domainAttributeMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_domainAttributeMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_domainAttributeMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_domainAttributeMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_domainAttributeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_domainAttributeMap * info = (e_domainAttributeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_domainAttributeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_domainAttributeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_domainAttributeMap * info = (e_domainAttributeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_domainAttributeMap GGS_domainAttributeMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_domainAttributeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_domainAttributeMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_domainAttributeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_domainAttributeMap::
operator_isEqual (const GGS_domainAttributeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_domainAttributeMap::
operator_isNotEqual (const GGS_domainAttributeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_domainAttributeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_domainAttributeMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_domainAttributeMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_domainAttributeMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_domainAttributeMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_domainAttributeMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_domainAttributeMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_domainAttributeMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_domainAttributeMap GGS_domainAttributeMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_domainAttributeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_domainAttributeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainAttributeMap GGS_domainAttributeMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainAttributeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_domainAttributeMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @domainAttributeMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_domainAttributeMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_domainAttributeMap * p = NULL ;
    macroMyNew (p, GGS_domainAttributeMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainAttributeMap GGS_domainAttributeMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_domainAttributeMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_domainAttributeMap * p = dynamic_cast <const GGS_domainAttributeMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_domainAttributeMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_domainAttributeMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_domainAttributeMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeGalgasDomainType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasDomainType::
cPtr_typeGalgasDomainType (const GGS_lstring & argument_0,
                                const GGS_domainAttributeMap & argument_1,
                                const GGS_domainModifierMap & argument_2,
                                const GGS_domainRelationMap & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mDomainTypeName (argument_0),
mAttributeMap (argument_1),
mDomainModifierMap (argument_2),
mDomainRelationMap (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasDomainType * GGS_typeGalgasDomainType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasDomainType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasDomainType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasDomainType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasDomainType * ptr = dynamic_cast <const cPtr_typeGalgasDomainType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDomainTypeName.operator_isEqual (ptr->mDomainTypeName).boolValue ()
         && mAttributeMap.operator_isEqual (ptr->mAttributeMap).boolValue ()
         && mDomainModifierMap.operator_isEqual (ptr->mDomainModifierMap).boolValue ()
         && mDomainRelationMap.operator_isEqual (ptr->mDomainRelationMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasDomainType::
method_getTypeName (C_Compiler & inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mDomainTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2910)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasDomainType::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgasDomainType (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_126331 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2922))).operator_isEqual (GGS_string ("domainWithNames")) ;
  if (cond_126331.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t = function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (2924)) ;
    {
      GGS_domainAttributeMap::cEnumerator enumerator_126236 (mAttributeMap, true) ;
      const GGS_domainAttributeMap::cElement * operand_126236 = NULL ;
      while (((operand_126236 = enumerator_126236.nextObject ()))) {
        macroValidPointer (operand_126236) ;
        var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
      }
    }
  }else if (cond_126331.isBuiltAndFalse ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a domain only accepts 'domainWithNames' constructor") COMMA_SOURCE_FILE_AT_LINE (2930)) ;
    var_cas_outAccessorTypesList.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasDomainType::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_126752 = mDomainModifierMap.reader_hasKey (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2939))) ;
  if (cond_126752.isBuiltAndTrue ()) {
    const GGS_domainModifierMap  temp_126702 = mDomainModifierMap ;
    if (temp_126702.isBuilt ()) {
      temp_126702 (HERE)->method_searchKey (inLexique, var_cas_inModifierName, var_cas_outModifierSignature COMMA_SOURCE_FILE_AT_LINE (2940)) ;
    }
  }else if (cond_126752.isBuiltAndFalse ()) {
    var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this modifier is not defined") COMMA_SOURCE_FILE_AT_LINE (2943)) ;
    var_cas_outModifierSignature.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasDomainType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasDomainType:"
           << mDomainTypeName.reader_description (inIndentation + 1)
           << mAttributeMap.reader_description (inIndentation + 1)
           << mDomainModifierMap.reader_description (inIndentation + 1)
           << mDomainRelationMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasDomainType::
static_string_message_messageGalgasType (void) {
  return "a domain type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasDomainType::
message_messageGalgasType (void) const {
  return "a domain type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasDomainType::
instanceMessage (void) const {
  return "a domain type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasDomainType::
_static_message (void) {
  return "a domain type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasDomainType (& typeid (cPtr_typeGalgasDomainType), & typeid (cPtr_AC_galgasType), "a domain type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasDomainType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasDomainType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasDomainType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasDomainType (mDomainTypeName, mAttributeMap, mDomainModifierMap, mDomainRelationMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgasDomainType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasDomainType ("typeGalgasDomainType", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasDomainType::
GGS_typeGalgasDomainType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasDomainType::
GGS_typeGalgasDomainType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasDomainType GGS_typeGalgasDomainType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasDomainType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasDomainType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasDomainType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasDomainType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasDomainType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasDomainType GGS_typeGalgasDomainType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_domainAttributeMap & argument_1,
                 const GGS_domainModifierMap & argument_2,
                 const GGS_domainRelationMap & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasDomainType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasDomainType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasDomainType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasDomainType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasDomainType * p = (cPtr_typeGalgasDomainType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainModifierMap  GGS_typeGalgasDomainType::
reader_mDomainModifierMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainModifierMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasDomainType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasDomainType *) mPointer)->mDomainModifierMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainRelationMap  GGS_typeGalgasDomainType::
reader_mDomainRelationMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainRelationMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasDomainType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasDomainType *) mPointer)->mDomainRelationMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasDomainType::actualTypeName (void) const {
  return "typeGalgasDomainType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasDomainType ("typeGalgasDomainType", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgasDomainType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasDomainType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasDomainType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasDomainType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasDomainType GGS_typeGalgasDomainType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasDomainType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasDomainType * p = dynamic_cast <const GGS_typeGalgasDomainType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasDomainType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasDomainType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasDomainType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_typeGalgasUndefinedSortedListType'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedSortedListType::
cPtr_typeGalgasUndefinedSortedListType (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mListTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedSortedListType * GGS_typeGalgasUndefinedSortedListType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedSortedListType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedSortedListType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedSortedListType * ptr = dynamic_cast <const cPtr_typeGalgasUndefinedSortedListType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListTypeName.operator_isEqual (ptr->mListTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedSortedListType::
method_getTypeName (C_Compiler & inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2961)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedSortedListType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasUndefinedSortedListType:"
           << mListTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedSortedListType::
static_string_message_messageGalgasType (void) {
  return "a predeclared sorted list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedSortedListType::
message_messageGalgasType (void) const {
  return "a predeclared sorted list type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedSortedListType::
instanceMessage (void) const {
  return "a predeclared sorted list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedSortedListType::
_static_message (void) {
  return "a predeclared sorted list type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasUndefinedSortedListType (& typeid (cPtr_typeGalgasUndefinedSortedListType), & typeid (cPtr_AC_galgasType), "a predeclared sorted list type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasUndefinedSortedListType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasUndefinedSortedListType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasUndefinedSortedListType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasUndefinedSortedListType (mListTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeGalgasUndefinedSortedListType'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasUndefinedSortedListType ("typeGalgasUndefinedSortedListType", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedSortedListType::
GGS_typeGalgasUndefinedSortedListType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedSortedListType::
GGS_typeGalgasUndefinedSortedListType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasUndefinedSortedListType GGS_typeGalgasUndefinedSortedListType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedSortedListType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasUndefinedSortedListType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasUndefinedSortedListType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasUndefinedSortedListType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedSortedListType GGS_typeGalgasUndefinedSortedListType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedSortedListType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasUndefinedSortedListType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedSortedListType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasUndefinedSortedListType * p = (cPtr_typeGalgasUndefinedSortedListType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasUndefinedSortedListType::actualTypeName (void) const {
  return "typeGalgasUndefinedSortedListType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasUndefinedSortedListType ("typeGalgasUndefinedSortedListType", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgasUndefinedSortedListType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasUndefinedSortedListType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasUndefinedSortedListType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasUndefinedSortedListType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedSortedListType GGS_typeGalgasUndefinedSortedListType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedSortedListType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasUndefinedSortedListType * p = dynamic_cast <const GGS_typeGalgasUndefinedSortedListType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasUndefinedSortedListType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasUndefinedSortedListType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasUndefinedSortedListType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeGalgasSortedListType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasSortedListType::
cPtr_typeGalgasSortedListType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_EXsignature & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedSortedListType (argument_0 COMMA_THERE),
mAttributeList (argument_1),
mExtractSignature (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasSortedListType * GGS_typeGalgasSortedListType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasSortedListType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasSortedListType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasSortedListType * ptr = dynamic_cast <const cPtr_typeGalgasSortedListType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListTypeName.operator_isEqual (ptr->mListTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mExtractSignature.operator_isEqual (ptr->mExtractSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_acceptForeachInstruction (C_Compiler & inLexique,
                                GGS_M_semanticsEntitiesForUse  /* var_cas_inSemanticsEntitiesForUse */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle,
                                GGS_bool& var_cas_outNewStyle COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outNewStyle = GGS_bool (false) ;
  var_cas_outForeachList = mAttributeList ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_listStyle (inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_129202 = ((var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3000))).operator_isEqual (GGS_string ("popSmallest"))).operator_or ((var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3000))).operator_isEqual (GGS_string ("popGreatest"))) ;
  if (cond_129202.isBuiltAndTrue ()) {
    var_cas_outModifierSignature = mExtractSignature ;
  }else if (cond_129202.isBuiltAndFalse ()) {
    var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a sorted list accepts only 'popSmallest' and 'popGreatest' modifiers") COMMA_SOURCE_FILE_AT_LINE (3004)) ;
    var_cas_outModifierSignature.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_handleMethodInstructionCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outReaderSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string ("") ;
  const GGS_bool cond_129870 = ((var_cas_inMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3017))).operator_isNotEqual (GGS_string ("smallest"))).operator_and ((var_cas_inMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3017))).operator_isNotEqual (GGS_string ("greatest"))) ;
  if (cond_129870.isBuiltAndTrue ()) {
    var_cas_inMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a sorted list accepts only 'smallest' and 'greatest' methods") COMMA_SOURCE_FILE_AT_LINE (3019)) ;
  }
  var_cas_outReaderSignature = mExtractSignature ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_handleAddAssignOperatorCall (C_Compiler & /* inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outParametersList = mAttributeList ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgasSortedListType (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
  const GGS_bool cond_130685 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3040))).operator_isEqual (GGS_string ("emptySortedList")) ;
  if (cond_130685.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (cond_130685.isBuiltAndFalse ()) {
    const GGS_bool cond_130798 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3042))).operator_isEqual (GGS_string ("sortedListWithValue")) ;
    if (cond_130798.isBuiltAndTrue ()) {
      var_cas_outAccessorTypesList = mAttributeList ;
    }else if (cond_130798.isBuiltAndFalse ()) {
      var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (3046)) ;
      var_cas_outAccessorTypesList.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasSortedListType:"
           << mListTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mExtractSignature.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasSortedListType::
static_string_message_messageGalgasType (void) {
  return "a sorted list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasSortedListType::
message_messageGalgasType (void) const {
  return "a sorted list type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasSortedListType::
instanceMessage (void) const {
  return "a sorted list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasSortedListType::
_static_message (void) {
  return "a sorted list type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasSortedListType (& typeid (cPtr_typeGalgasSortedListType), & typeid (cPtr_typeGalgasUndefinedSortedListType), "a sorted list type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasSortedListType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasSortedListType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasSortedListType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasSortedListType (mListTypeName, mAttributeList, mExtractSignature COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeGalgasSortedListType'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasSortedListType ("typeGalgasSortedListType", true, & kTypeDescriptor_GGS_typeGalgasUndefinedSortedListType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasSortedListType::
GGS_typeGalgasSortedListType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasSortedListType::
GGS_typeGalgasSortedListType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasSortedListType GGS_typeGalgasSortedListType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasSortedListType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasSortedListType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasSortedListType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasSortedListType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasSortedListType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasSortedListType GGS_typeGalgasSortedListType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_L_EXsignature & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasSortedListType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasSortedListType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasSortedListType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasSortedListType * p = (cPtr_typeGalgasSortedListType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasSortedListType::actualTypeName (void) const {
  return "typeGalgasSortedListType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasSortedListType ("typeGalgasSortedListType", gClassInfoFor__typeGalgasUndefinedSortedListType, & kTypeDescriptor_GGS_typeGalgasSortedListType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasSortedListType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasSortedListType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasSortedListType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasSortedListType GGS_typeGalgasSortedListType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasSortedListType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasSortedListType * p = dynamic_cast <const GGS_typeGalgasSortedListType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasSortedListType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasSortedListType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasSortedListType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_typeTableBlocsDeTable'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableBlocsDeTable::e_typeTableBlocsDeTable (void) :
aSignatureDebut (),
aSignatureFin () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@typeTableBlocsDeTable'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTableBlocsDeTable ("typeTableBlocsDeTable", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeTableBlocsDeTable::
elementOf_GGS_typeTableBlocsDeTable (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableBlocsDeTable & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableBlocsDeTable::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aSignatureDebut.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aSignatureFin.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableBlocsDeTable::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableBlocsDeTable * ptr = dynamic_cast <const elementOf_GGS_typeTableBlocsDeTable *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.aSignatureDebut.operator_isEqual (ptr->mInfo.aSignatureDebut)).boolValue ()
           && (mInfo.aSignatureFin.operator_isEqual (ptr->mInfo.aSignatureFin)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableBlocsDeTable::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableBlocsDeTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableBlocsDeTable * info = (e_typeTableBlocsDeTable *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableBlocsDeTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableBlocsDeTable * info = (e_typeTableBlocsDeTable *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableBlocsDeTable result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableBlocsDeTable info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableBlocsDeTable::
operator_isEqual (const GGS_typeTableBlocsDeTable & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableBlocsDeTable::
operator_isNotEqual (const GGS_typeTableBlocsDeTable & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                const GGS_L_EXsignature & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableBlocsDeTable info  ;
    info.aSignatureDebut = inParameter0 ;
    info.aSignatureFin = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.aSignatureDebut ;
    outParameter1 = node->mInfo.aSignatureFin ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableBlocsDeTable::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('o'),
  TO_UNICODE ('c'),
  TO_UNICODE ('k'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_L_EXsignature   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableBlocsDeTable::kInsertMessage_insertKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('o'),
  TO_UNICODE ('c'),
  TO_UNICODE ('k'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_L_EXsignature & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableBlocsDeTable & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableBlocsDeTable result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableBlocsDeTable result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableBlocsDeTable::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableBlocsDeTable " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_typeTableBlocsDeTable::cEnumerator::_aSignatureDebut (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aSignatureDebut ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_typeTableBlocsDeTable::cEnumerator::_aSignatureFin (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aSignatureFin ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeTableBlocsDeTable::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTableBlocsDeTable * p = NULL ;
    macroMyNew (p, GGS_typeTableBlocsDeTable (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTableBlocsDeTable result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTableBlocsDeTable * p = dynamic_cast <const GGS_typeTableBlocsDeTable *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTableBlocsDeTable, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTableBlocsDeTable::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTableBlocsDeTable ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeGalgasUndefinedMapType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedMapType::
cPtr_typeGalgasUndefinedMapType (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mMapTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedMapType * GGS_typeGalgasUndefinedMapType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedMapType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedMapType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedMapType * ptr = dynamic_cast <const cPtr_typeGalgasUndefinedMapType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapType::
method_getTypeName (C_Compiler & inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3077)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasUndefinedMapType:"
           << mMapTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapType::
static_string_message_messageGalgasType (void) {
  return "an undefined map type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapType::
message_messageGalgasType (void) const {
  return "an undefined map type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapType::
instanceMessage (void) const {
  return "an undefined map type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapType::
_static_message (void) {
  return "an undefined map type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasUndefinedMapType (& typeid (cPtr_typeGalgasUndefinedMapType), & typeid (cPtr_AC_galgasType), "an undefined map type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasUndefinedMapType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasUndefinedMapType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasUndefinedMapType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasUndefinedMapType (mMapTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedMapType'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasUndefinedMapType ("typeGalgasUndefinedMapType", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapType::
GGS_typeGalgasUndefinedMapType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapType::
GGS_typeGalgasUndefinedMapType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasUndefinedMapType GGS_typeGalgasUndefinedMapType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedMapType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasUndefinedMapType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasUndefinedMapType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasUndefinedMapType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapType GGS_typeGalgasUndefinedMapType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedMapType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasUndefinedMapType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedMapType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasUndefinedMapType * p = (cPtr_typeGalgasUndefinedMapType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasUndefinedMapType::actualTypeName (void) const {
  return "typeGalgasUndefinedMapType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasUndefinedMapType ("typeGalgasUndefinedMapType", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgasUndefinedMapType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasUndefinedMapType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasUndefinedMapType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasUndefinedMapType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapType GGS_typeGalgasUndefinedMapType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedMapType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasUndefinedMapType * p = dynamic_cast <const GGS_typeGalgasUndefinedMapType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasUndefinedMapType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasUndefinedMapType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasUndefinedMapType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_mapModifierMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_mapModifierMap::e_mapModifierMap (void) :
mMethodSignature () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@mapModifierMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapModifierMap ("mapModifierMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_mapModifierMap::
elementOf_GGS_mapModifierMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_mapModifierMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapModifierMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMethodSignature.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapModifierMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_mapModifierMap * ptr = dynamic_cast <const elementOf_GGS_mapModifierMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mMethodSignature.operator_isEqual (ptr->mInfo.mMethodSignature)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapModifierMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapModifierMap * info = (e_mapModifierMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_mapModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_mapModifierMap * info = (e_mapModifierMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_mapModifierMap GGS_mapModifierMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapModifierMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_mapModifierMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapModifierMap::
operator_isEqual (const GGS_mapModifierMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapModifierMap::
operator_isNotEqual (const GGS_mapModifierMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_mapModifierMap info  ;
    info.mMethodSignature = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mMethodSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_mapModifierMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_mapModifierMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapModifierMap GGS_mapModifierMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_mapModifierMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapModifierMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapModifierMap GGS_mapModifierMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapModifierMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapModifierMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @mapModifierMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_mapModifierMap::cEnumerator::_mMethodSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMethodSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapModifierMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapModifierMap * p = NULL ;
    macroMyNew (p, GGS_mapModifierMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapModifierMap GGS_mapModifierMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapModifierMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapModifierMap * p = dynamic_cast <const GGS_mapModifierMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapModifierMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapModifierMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapModifierMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_EXmapMethodMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_EXmapMethodMap::e_EXmapMethodMap (void) :
mMethodSignature () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@EXmapMethodMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EXmapMethodMap ("EXmapMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_EXmapMethodMap::
elementOf_GGS_EXmapMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_EXmapMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_EXmapMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMethodSignature.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_EXmapMethodMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_EXmapMethodMap * ptr = dynamic_cast <const elementOf_GGS_EXmapMethodMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mMethodSignature.operator_isEqual (ptr->mInfo.mMethodSignature)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_EXmapMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_EXmapMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_EXmapMethodMap * info = (e_EXmapMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_EXmapMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_EXmapMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_EXmapMethodMap * info = (e_EXmapMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_EXmapMethodMap GGS_EXmapMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXmapMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXmapMethodMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_EXmapMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXmapMethodMap::
operator_isEqual (const GGS_EXmapMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXmapMethodMap::
operator_isNotEqual (const GGS_EXmapMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_EXmapMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_EXmapMethodMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_EXmapMethodMap info  ;
    info.mMethodSignature = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXmapMethodMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mMethodSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXmapMethodMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('c'),
  TO_UNICODE ('h'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXmapMethodMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXmapMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('c'),
  TO_UNICODE ('h'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXmapMethodMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_EXmapMethodMap GGS_EXmapMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_EXmapMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXmapMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXmapMethodMap GGS_EXmapMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_EXmapMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXmapMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @EXmapMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_EXmapMethodMap::cEnumerator::_mMethodSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMethodSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_EXmapMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EXmapMethodMap * p = NULL ;
    macroMyNew (p, GGS_EXmapMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXmapMethodMap GGS_EXmapMethodMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EXmapMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EXmapMethodMap * p = dynamic_cast <const GGS_EXmapMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EXmapMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EXmapMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EXmapMethodMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgasMapType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasMapType::
cPtr_typeGalgasMapType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableBlocsDeTable & argument_2,
                                const GGS_mapModifierMap & argument_3,
                                const GGS_EXmapMethodMap & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedMapType (argument_0 COMMA_THERE),
mAttributeList (argument_1),
aTableMethodesSurcharger (argument_2),
mModifierMethodMap (argument_3),
mReaderMethodMap (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasMapType * GGS_typeGalgasMapType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasMapType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasMapType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasMapType * ptr = dynamic_cast <const cPtr_typeGalgasMapType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && aTableMethodesSurcharger.operator_isEqual (ptr->aTableMethodesSurcharger).boolValue ()
         && mModifierMethodMap.operator_isEqual (ptr->mModifierMethodMap).boolValue ()
         && mReaderMethodMap.operator_isEqual (ptr->mReaderMethodMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_check_with_InstructionAccess (C_Compiler & inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_lstring  var_cas_searchMethodName,
                                GGS_AC_galgasType  var_cas_inKeyExpressionType,
                                GGS_string& var_cas_outMapTypeName,
                                GGS_string& var_cas_outErrorMessage,
                                GGS_typeListeAttributsSemantiques & var_cas_outAttributeList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outAttributeList = mAttributeList ;
  var_cas_outMapTypeName = mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3126)) ;
  const GGS_bool cond_134144 = (var_cas_searchMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3128))).operator_isEqual (GGS_string ("hasKey")) ;
  if (cond_134144.isBuiltAndTrue ()) {
    GGS_typeGalgas_string  var_cas_classType = GGS_typeGalgas_string::castFrom (inLexique, var_cas_inKeyExpressionType.getPtr (), true, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (3129)) ;
    var_cas_outErrorMessage = GGS_string ("") ;
  }else if (cond_134144.isBuiltAndFalse ()) {
    const GGS_bool cond_134374 = mReaderMethodMap.reader_hasKey (var_cas_searchMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3131))) ;
    if (cond_134374.isBuiltAndTrue ()) {
      GGS_typeGalgas_lstring  var_cas_classType = GGS_typeGalgas_lstring::castFrom (inLexique, var_cas_inKeyExpressionType.getPtr (), true, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (3132)) ;
      var_cas_outErrorMessage = var_cas_searchMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3133)) ;
    }else if (cond_134374.isBuiltAndFalse ()) {
      var_cas_searchMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this method does not exist: it should be the predefined 'hasKey', or a declared search method") COMMA_SOURCE_FILE_AT_LINE (3138)) ;
      var_cas_outErrorMessage.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_mapModifierMap  temp_134794 = mModifierMethodMap ;
  if (temp_134794.isBuilt ()) {
    temp_134794 (HERE)->method_searchKey (inLexique, var_cas_inModifierName, var_cas_outModifierSignature COMMA_SOURCE_FILE_AT_LINE (3147)) ;
  }
  const GGS_bool cond_135245 = (mModifierMethodMap.reader_hasKey (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3148)))).operator_not () ;
  if (cond_135245.isBuiltAndTrue ()) {
    {
      GGS_typeListeAttributsSemantiques::cEnumerator enumerator_134933 (mAttributeList, true) ;
      const GGS_typeListeAttributsSemantiques::cElement * operand_134933 = NULL ;
      while (((operand_134933 = enumerator_134933.nextObject ()))) {
        macroValidPointer (operand_134933) ;
        GGS_string var_cas_setValueForKeyName = ((GGS_string ("set")).operator_concat (operand_134933->mAttributeName.ggs_string ().reader_stringByCapitalizingFirstCharacter ())).operator_concat (GGS_string ("ForKey")) ;
        const GGS_bool cond_135212 = (var_cas_setValueForKeyName).operator_isEqual (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3151))) ;
        if (cond_135212.isBuiltAndTrue ()) {
          operand_134933->mAttributeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((GGS_string ("'")).operator_concat (operand_134933->mAttributeName)).operator_concat (GGS_string ("' attribute is declared here")) COMMA_SOURCE_FILE_AT_LINE (3152)) ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_handleMethodInstructionCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outReaderSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string ("") ;
  const GGS_EXmapMethodMap  temp_135622 = mReaderMethodMap ;
  if (temp_135622.isBuilt ()) {
    temp_135622 (HERE)->method_searchKey (inLexique, var_cas_inMethodName, var_cas_outReaderSignature COMMA_SOURCE_FILE_AT_LINE (3167)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_acceptForeachInstruction (C_Compiler & inLexique,
                                GGS_M_semanticsEntitiesForUse  /* var_cas_inSemanticsEntitiesForUse */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle,
                                GGS_bool& var_cas_outNewStyle COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outNewStyle = GGS_bool (false) ;
  var_cas_outForeachList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_outForeachList.addAssign_operation (GGS_typeGalgas_lstring ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("key"), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_outForeachList = (var_cas_outForeachList).operator_concat (mAttributeList) ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgasMapType (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_136810 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3196))).operator_isEqual (GGS_string ("emptyMap")) ;
  if (cond_136810.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (cond_136810.isBuiltAndFalse ()) {
    const GGS_bool cond_137087 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3198))).operator_isEqual (GGS_string ("mapWithMapToOverride")) ;
    if (cond_137087.isBuiltAndTrue ()) {
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgasUndefinedMapType ::constructor_new (inLexique, mMapTypeName COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("\?\?\?"), GGS_location (inLexique) COMMA_HERE)) ;
    }else if (cond_137087.isBuiltAndFalse ()) {
      var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (3203)) ;
      var_cas_outAccessorTypesList.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasMapType:"
           << mMapTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << aTableMethodesSurcharger.reader_description (inIndentation + 1)
           << mModifierMethodMap.reader_description (inIndentation + 1)
           << mReaderMethodMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapType::
static_string_message_messageGalgasType (void) {
  return "a map type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapType::
message_messageGalgasType (void) const {
  return "a map type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapType::
instanceMessage (void) const {
  return "a map type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapType::
_static_message (void) {
  return "a map type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasMapType (& typeid (cPtr_typeGalgasMapType), & typeid (cPtr_typeGalgasUndefinedMapType), "a map type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasMapType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasMapType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasMapType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasMapType (mMapTypeName, mAttributeList, aTableMethodesSurcharger, mModifierMethodMap, mReaderMethodMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgasMapType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasMapType ("typeGalgasMapType", true, & kTypeDescriptor_GGS_typeGalgasUndefinedMapType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasMapType::
GGS_typeGalgasMapType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasMapType::
GGS_typeGalgasMapType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasMapType GGS_typeGalgasMapType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasMapType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasMapType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasMapType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasMapType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasMapType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasMapType GGS_typeGalgasMapType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_typeTableBlocsDeTable & argument_2,
                 const GGS_mapModifierMap & argument_3,
                 const GGS_EXmapMethodMap & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasMapType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasMapType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasMapType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasMapType * p = (cPtr_typeGalgasMapType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasMapType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable  GGS_typeGalgasMapType::
reader_aTableMethodesSurcharger (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableBlocsDeTable   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapType *) mPointer)->aTableMethodesSurcharger ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapModifierMap  GGS_typeGalgasMapType::
reader_mModifierMethodMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapModifierMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapType *) mPointer)->mModifierMethodMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXmapMethodMap  GGS_typeGalgasMapType::
reader_mReaderMethodMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_EXmapMethodMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapType *) mPointer)->mReaderMethodMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasMapType::actualTypeName (void) const {
  return "typeGalgasMapType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasMapType ("typeGalgasMapType", gClassInfoFor__typeGalgasUndefinedMapType, & kTypeDescriptor_GGS_typeGalgasMapType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasMapType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasMapType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasMapType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasMapType GGS_typeGalgasMapType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasMapType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasMapType * p = dynamic_cast <const GGS_typeGalgasMapType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasMapType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasMapType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasMapType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeGalgasUndefinedMapindexType'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedMapindexType::
cPtr_typeGalgasUndefinedMapindexType (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mMapindexTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedMapindexType * GGS_typeGalgasUndefinedMapindexType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedMapindexType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedMapindexType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedMapindexType * ptr = dynamic_cast <const cPtr_typeGalgasUndefinedMapindexType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapindexTypeName.operator_isEqual (ptr->mMapindexTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapindexType::
method_getTypeName (C_Compiler & inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mMapindexTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3221)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapindexType::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgasUndefinedMapindexType (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_138396 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3233))).operator_isEqual (GGS_string ("null")) ;
  if (cond_138396.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (cond_138396.isBuiltAndFalse ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a map index only accepts 'null' constructor") COMMA_SOURCE_FILE_AT_LINE (3237)) ;
    var_cas_outAccessorTypesList.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapindexType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasUndefinedMapindexType:"
           << mMapindexTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapindexType::
static_string_message_messageGalgasType (void) {
  return "a predeclared mapindex type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapindexType::
message_messageGalgasType (void) const {
  return "a predeclared mapindex type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapindexType::
instanceMessage (void) const {
  return "a predeclared mapindex type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapindexType::
_static_message (void) {
  return "a predeclared mapindex type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasUndefinedMapindexType (& typeid (cPtr_typeGalgasUndefinedMapindexType), & typeid (cPtr_AC_galgasType), "a predeclared mapindex type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasUndefinedMapindexType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasUndefinedMapindexType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasUndefinedMapindexType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasUndefinedMapindexType (mMapindexTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeGalgasUndefinedMapindexType'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasUndefinedMapindexType ("typeGalgasUndefinedMapindexType", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapindexType::
GGS_typeGalgasUndefinedMapindexType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapindexType::
GGS_typeGalgasUndefinedMapindexType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasUndefinedMapindexType GGS_typeGalgasUndefinedMapindexType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedMapindexType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasUndefinedMapindexType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasUndefinedMapindexType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasUndefinedMapindexType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasUndefinedMapindexType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapindexType GGS_typeGalgasUndefinedMapindexType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedMapindexType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasUndefinedMapindexType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedMapindexType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasUndefinedMapindexType * p = (cPtr_typeGalgasUndefinedMapindexType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasUndefinedMapindexType::actualTypeName (void) const {
  return "typeGalgasUndefinedMapindexType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasUndefinedMapindexType ("typeGalgasUndefinedMapindexType", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgasUndefinedMapindexType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasUndefinedMapindexType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasUndefinedMapindexType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasUndefinedMapindexType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapindexType GGS_typeGalgasUndefinedMapindexType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedMapindexType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasUndefinedMapindexType * p = dynamic_cast <const GGS_typeGalgasUndefinedMapindexType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasUndefinedMapindexType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasUndefinedMapindexType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasUndefinedMapindexType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'e_mapIndexSearchReaderMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

e_mapIndexSearchReaderMap::e_mapIndexSearchReaderMap (void) :
mRetrieveErrorMessage () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@mapIndexSearchReaderMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapIndexSearchReaderMap ("mapIndexSearchReaderMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_mapIndexSearchReaderMap::
elementOf_GGS_mapIndexSearchReaderMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_mapIndexSearchReaderMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapIndexSearchReaderMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mRetrieveErrorMessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapIndexSearchReaderMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_mapIndexSearchReaderMap * ptr = dynamic_cast <const elementOf_GGS_mapIndexSearchReaderMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mRetrieveErrorMessage.operator_isEqual (ptr->mInfo.mRetrieveErrorMessage)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapIndexSearchReaderMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapIndexSearchReaderMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapIndexSearchReaderMap * info = (e_mapIndexSearchReaderMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_mapIndexSearchReaderMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_mapIndexSearchReaderMap * info = (e_mapIndexSearchReaderMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_mapIndexSearchReaderMap GGS_mapIndexSearchReaderMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapIndexSearchReaderMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_mapIndexSearchReaderMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapIndexSearchReaderMap::
operator_isEqual (const GGS_mapIndexSearchReaderMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapIndexSearchReaderMap::
operator_isNotEqual (const GGS_mapIndexSearchReaderMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_mapIndexSearchReaderMap info  ;
    info.mRetrieveErrorMessage = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mRetrieveErrorMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_mapIndexSearchReaderMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('c'),
  TO_UNICODE ('h'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_mapIndexSearchReaderMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('c'),
  TO_UNICODE ('h'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapIndexSearchReaderMap GGS_mapIndexSearchReaderMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_mapIndexSearchReaderMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapIndexSearchReaderMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapIndexSearchReaderMap GGS_mapIndexSearchReaderMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapIndexSearchReaderMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapIndexSearchReaderMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @mapIndexSearchReaderMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapIndexSearchReaderMap::cEnumerator::_mRetrieveErrorMessage (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRetrieveErrorMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapIndexSearchReaderMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapIndexSearchReaderMap * p = NULL ;
    macroMyNew (p, GGS_mapIndexSearchReaderMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapIndexSearchReaderMap GGS_mapIndexSearchReaderMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapIndexSearchReaderMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapIndexSearchReaderMap * p = dynamic_cast <const GGS_mapIndexSearchReaderMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapIndexSearchReaderMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapIndexSearchReaderMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapIndexSearchReaderMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeGalgasMapindexType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasMapindexType::
cPtr_typeGalgasMapindexType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_mapIndexSearchReaderMap & argument_3,
                                const GGS_typeTableBlocsDeTable & argument_4,
                                const GGS_mapModifierMap & argument_5,
                                const GGS_EXmapMethodMap & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedMapindexType (argument_0 COMMA_THERE),
mMapTypeName (argument_1),
mMapAttributesList (argument_2),
mMapIndexSearchReaderMap (argument_3),
aTableMethodesSurcharger (argument_4),
mModifierMethodMap (argument_5),
mReaderMethodMap (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasMapindexType * GGS_typeGalgasMapindexType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasMapindexType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasMapindexType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasMapindexType * ptr = dynamic_cast <const cPtr_typeGalgasMapindexType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapindexTypeName.operator_isEqual (ptr->mMapindexTypeName).boolValue ()
         && mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mMapAttributesList.operator_isEqual (ptr->mMapAttributesList).boolValue ()
         && mMapIndexSearchReaderMap.operator_isEqual (ptr->mMapIndexSearchReaderMap).boolValue ()
         && aTableMethodesSurcharger.operator_isEqual (ptr->aTableMethodesSurcharger).boolValue ()
         && mModifierMethodMap.operator_isEqual (ptr->mModifierMethodMap).boolValue ()
         && mReaderMethodMap.operator_isEqual (ptr->mReaderMethodMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapindexType::
method_handleMethodInstructionCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outReaderSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string ("") ;
  GGS_lstring  automatic_var_140191_0 ;
  const GGS_mapIndexSearchReaderMap  temp_140173 = mMapIndexSearchReaderMap ;
  if (temp_140173.isBuilt ()) {
    temp_140173 (HERE)->method_searchKey (inLexique, var_cas_inMethodName, automatic_var_140191_0 COMMA_SOURCE_FILE_AT_LINE (3277)) ;
  }
  var_cas_outReaderSignature = GGS_L_EXsignature ::constructor_listWithValue (GGS_typeGalgas_lstring ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
  {
    GGS_typeListeAttributsSemantiques::cEnumerator enumerator_140369 (mMapAttributesList, true) ;
    const GGS_typeListeAttributsSemantiques::cElement * operand_140369 = NULL ;
    while (((operand_140369 = enumerator_140369.nextObject ()))) {
      macroValidPointer (operand_140369) ;
      var_cas_outReaderSignature.addAssign_operation (operand_140369->mAttributType, GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapindexType::
method_handleClassMethodCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inTypeMethodName,
                                GGS_L_EXsignature & var_cas_outTypeMethodSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_141591 = (var_cas_inTypeMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3293))).operator_isEqual (GGS_string ("makeRegularIndex")) ;
  if (cond_141591.isBuiltAndTrue ()) {
    var_cas_outTypeMethodSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outTypeMethodSignature.addAssign_operation (GGS_typeGalgas_lstring ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
    var_cas_outTypeMethodSignature.addAssign_operation (GGS_typeGalgasMapType ::constructor_new (inLexique, mMapTypeName, mMapAttributesList, aTableMethodesSurcharger, mModifierMethodMap, mReaderMethodMap COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentInOut (inLexique COMMA_HERE)) ;
    var_cas_outTypeMethodSignature.addAssign_operation (GGS_typeGalgasMapindexType ::constructor_new (inLexique, mMapindexTypeName, mMapTypeName, mMapAttributesList, mMapIndexSearchReaderMap, aTableMethodesSurcharger, mModifierMethodMap, mReaderMethodMap COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
  }else if (cond_141591.isBuiltAndFalse ()) {
    var_cas_inTypeMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a map index only accepts 'regularIndex' type method") COMMA_SOURCE_FILE_AT_LINE (3323)) ;
    var_cas_outTypeMethodSignature.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapindexType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasMapindexType:"
           << mMapindexTypeName.reader_description (inIndentation + 1)
           << mMapTypeName.reader_description (inIndentation + 1)
           << mMapAttributesList.reader_description (inIndentation + 1)
           << mMapIndexSearchReaderMap.reader_description (inIndentation + 1)
           << aTableMethodesSurcharger.reader_description (inIndentation + 1)
           << mModifierMethodMap.reader_description (inIndentation + 1)
           << mReaderMethodMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapindexType::
static_string_message_messageGalgasType (void) {
  return "a mapindex type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapindexType::
message_messageGalgasType (void) const {
  return "a mapindex type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapindexType::
instanceMessage (void) const {
  return "a mapindex type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapindexType::
_static_message (void) {
  return "a mapindex type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasMapindexType (& typeid (cPtr_typeGalgasMapindexType), & typeid (cPtr_typeGalgasUndefinedMapindexType), "a mapindex type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasMapindexType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasMapindexType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasMapindexType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasMapindexType (mMapindexTypeName, mMapTypeName, mMapAttributesList, mMapIndexSearchReaderMap, aTableMethodesSurcharger, mModifierMethodMap, mReaderMethodMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeGalgasMapindexType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasMapindexType ("typeGalgasMapindexType", true, & kTypeDescriptor_GGS_typeGalgasUndefinedMapindexType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasMapindexType::
GGS_typeGalgasMapindexType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasMapindexType::
GGS_typeGalgasMapindexType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasMapindexType GGS_typeGalgasMapindexType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasMapindexType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasMapindexType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasMapindexType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasMapindexType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasMapindexType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasMapindexType GGS_typeGalgasMapindexType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_mapIndexSearchReaderMap & argument_3,
                 const GGS_typeTableBlocsDeTable & argument_4,
                 const GGS_mapModifierMap & argument_5,
                 const GGS_EXmapMethodMap & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasMapindexType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasMapindexType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasMapindexType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasMapindexType * p = (cPtr_typeGalgasMapindexType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasMapindexType::actualTypeName (void) const {
  return "typeGalgasMapindexType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasMapindexType ("typeGalgasMapindexType", gClassInfoFor__typeGalgasUndefinedMapindexType, & kTypeDescriptor_GGS_typeGalgasMapindexType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasMapindexType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasMapindexType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasMapindexType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasMapindexType GGS_typeGalgasMapindexType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasMapindexType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasMapindexType * p = dynamic_cast <const GGS_typeGalgasMapindexType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasMapindexType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasMapindexType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasMapindexType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeGalgasUndefinedClassType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedClassType::
cPtr_typeGalgasUndefinedClassType (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mClassTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedClassType * GGS_typeGalgasUndefinedClassType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedClassType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedClassType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedClassType * ptr = dynamic_cast <const cPtr_typeGalgasUndefinedClassType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mClassTypeName.operator_isEqual (ptr->mClassTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedClassType::
method_getTypeName (C_Compiler & inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3341)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedClassType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasUndefinedClassType:"
           << mClassTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedClassType::
static_string_message_messageGalgasType (void) {
  return "an undefined class type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedClassType::
message_messageGalgasType (void) const {
  return "an undefined class type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedClassType::
instanceMessage (void) const {
  return "an undefined class type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedClassType::
_static_message (void) {
  return "an undefined class type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasUndefinedClassType (& typeid (cPtr_typeGalgasUndefinedClassType), & typeid (cPtr_AC_galgasType), "an undefined class type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasUndefinedClassType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasUndefinedClassType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasUndefinedClassType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasUndefinedClassType (mClassTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedClassType'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasUndefinedClassType ("typeGalgasUndefinedClassType", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedClassType::
GGS_typeGalgasUndefinedClassType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedClassType::
GGS_typeGalgasUndefinedClassType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasUndefinedClassType GGS_typeGalgasUndefinedClassType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedClassType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasUndefinedClassType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasUndefinedClassType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasUndefinedClassType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedClassType GGS_typeGalgasUndefinedClassType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedClassType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasUndefinedClassType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedClassType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasUndefinedClassType * p = (cPtr_typeGalgasUndefinedClassType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasUndefinedClassType::
reader_mClassTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasUndefinedClassType *) mPointer)->mClassTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasUndefinedClassType::actualTypeName (void) const {
  return "typeGalgasUndefinedClassType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasUndefinedClassType ("typeGalgasUndefinedClassType", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgasUndefinedClassType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasUndefinedClassType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasUndefinedClassType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasUndefinedClassType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedClassType GGS_typeGalgasUndefinedClassType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedClassType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasUndefinedClassType * p = dynamic_cast <const GGS_typeGalgasUndefinedClassType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasUndefinedClassType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasUndefinedClassType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasUndefinedClassType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_lazyAttributeList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_lazyAttributeList::
elementOf_GGS_L_lazyAttributeList (const GGS_location & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLocationMagicNumber (argument_0),
mComputedAttributeTypeAndNameList (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_lazyAttributeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_lazyAttributeList * ptr = dynamic_cast <const elementOf_GGS_L_lazyAttributeList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLocationMagicNumber.operator_isEqual (ptr->mLocationMagicNumber).boolValue ()
         && mComputedAttributeTypeAndNameList.operator_isEqual (ptr->mComputedAttributeTypeAndNameList).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_lazyAttributeList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationMagicNumber.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mComputedAttributeTypeAndNameList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@L_lazyAttributeList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_lazyAttributeList ("L_lazyAttributeList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
internalAppendValues (const GGS_location & argument_0,
                    const GGS_typeListeAttributsSemantiques & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
internalPrependValues (const GGS_location & argument_0,
                    const GGS_typeListeAttributsSemantiques & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
addAssign_operation (const GGS_location & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_lazyAttributeList GGS_L_lazyAttributeList::
operator_concat (const GGS_L_lazyAttributeList & inOperand) const {
  GGS_L_lazyAttributeList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
dotAssign_operation (const GGS_L_lazyAttributeList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_lazyAttributeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mLocationMagicNumber ;
          GGS_typeListeAttributsSemantiques  p_1 = p->mComputedAttributeTypeAndNameList ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_typeListeAttributsSemantiques & argument_1,
                     const GGS_typeInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLocationMagicNumber,
                                ptr->mComputedAttributeTypeAndNameList,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_lazyAttributeList  GGS_L_lazyAttributeList::
constructor_emptyList (void) {
  GGS_L_lazyAttributeList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_lazyAttributeList  GGS_L_lazyAttributeList::
constructor_listWithValue (const GGS_location & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  GGS_L_lazyAttributeList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
internalSubListWithRange (GGS_L_lazyAttributeList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLocationMagicNumber, ptr->mComputedAttributeTypeAndNameList, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_lazyAttributeList GGS_L_lazyAttributeList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_lazyAttributeList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_lazyAttributeList GGS_L_lazyAttributeList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_lazyAttributeList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_lazyAttributeList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_lazyAttributeList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
method_first (C_Compiler & inLexique,
              GGS_location & _out_0,
              GGS_typeListeAttributsSemantiques & _out_1,
              GGS_typeInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLocationMagicNumber ;
    _out_1 = ptr->mComputedAttributeTypeAndNameList ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
method_last (C_Compiler & inLexique,
             GGS_location & _out_0,
             GGS_typeListeAttributsSemantiques & _out_1,
             GGS_typeInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLocationMagicNumber ;
    _out_1 = ptr->mComputedAttributeTypeAndNameList ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_location & _out_0,
                 GGS_typeListeAttributsSemantiques & _out_1,
                 GGS_typeInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLocationMagicNumber ;
    _out_1 = ptr->mComputedAttributeTypeAndNameList ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
modifier_popLast (C_Compiler & inLexique,
                GGS_location & _out_0,
                GGS_typeListeAttributsSemantiques & _out_1,
                GGS_typeInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLocationMagicNumber ;
    _out_1 = ptr->mComputedAttributeTypeAndNameList ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_location  GGS_L_lazyAttributeList::
reader_mLocationMagicNumberAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocationMagicNumber ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_L_lazyAttributeList::
reader_mComputedAttributeTypeAndNameListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mComputedAttributeTypeAndNameList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_L_lazyAttributeList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
modifier_setMLocationMagicNumberAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocationMagicNumber = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
modifier_setMComputedAttributeTypeAndNameListAtIndex (C_Compiler & inLexique,
                              const GGS_typeListeAttributsSemantiques  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mComputedAttributeTypeAndNameList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_L_lazyAttributeList::cEnumerator::_mLocationMagicNumber (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLocationMagicNumber ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeAttributsSemantiques  & GGS_L_lazyAttributeList::cEnumerator::_mComputedAttributeTypeAndNameList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mComputedAttributeTypeAndNameList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_L_lazyAttributeList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_lazyAttributeList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_lazyAttributeList * p = NULL ;
    macroMyNew (p, GGS_L_lazyAttributeList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_lazyAttributeList GGS_L_lazyAttributeList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_lazyAttributeList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_lazyAttributeList * p = dynamic_cast <const GGS_L_lazyAttributeList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_lazyAttributeList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_lazyAttributeList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_lazyAttributeList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgasClassType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasClassType::
cPtr_typeGalgasClassType (const GGS_lstring & argument_0,
                                const GGS_typeTableMethodes & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeSuperClassesMap & argument_3,
                                const GGS_typeClassInheritedMessagesMap & argument_4,
                                const GGS_typeSemanticAttributesMap & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_string& argument_7,
                                const GGS_bool& argument_8,
                                const GGS_L_lazyAttributeList & argument_9
                                COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedClassType (argument_0 COMMA_THERE),
mMethodMap (argument_1),
mAttributeList (argument_2),
mAncestorClassesMap (argument_3),
mMessagesMap (argument_4),
mNonExternAttributesMap (argument_5),
mClassIsAbstract (argument_6),
mClassMessage (argument_7),
mHasGeneratedInSeparateFileSetting (argument_8),
mLazyAttributeList (argument_9) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasClassType * GGS_typeGalgasClassType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasClassType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasClassType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasClassType * ptr = dynamic_cast <const cPtr_typeGalgasClassType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mClassTypeName.operator_isEqual (ptr->mClassTypeName).boolValue ()
         && mMethodMap.operator_isEqual (ptr->mMethodMap).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mAncestorClassesMap.operator_isEqual (ptr->mAncestorClassesMap).boolValue ()
         && mMessagesMap.operator_isEqual (ptr->mMessagesMap).boolValue ()
         && mNonExternAttributesMap.operator_isEqual (ptr->mNonExternAttributesMap).boolValue ()
         && mClassIsAbstract.operator_isEqual (ptr->mClassIsAbstract).boolValue ()
         && mClassMessage.operator_isEqual (ptr->mClassMessage).boolValue ()
         && mHasGeneratedInSeparateFileSetting.operator_isEqual (ptr->mHasGeneratedInSeparateFileSetting).boolValue ()
         && mLazyAttributeList.operator_isEqual (ptr->mLazyAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool var_cas_found = GGS_bool (false) ;
  var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
  {
    GGS_typeSemanticAttributesMap::cEnumerator enumerator_143945 (mNonExternAttributesMap, true) ;
    const GGS_typeSemanticAttributesMap::cElement * operand_143945 = NULL ;
    while (((operand_143945 = enumerator_143945.nextObject ()))
        && ((var_cas_found).operator_not ().isBuiltAndTrue ())) {
      macroValidPointer (operand_143945) ;
      GGS_string var_cas_testedModifierName = (GGS_string ("set")).operator_concat (operand_143945->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3395)).reader_stringByCapitalizingFirstCharacter ()) ;
      const GGS_bool cond_144506 = (var_cas_inModifierName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3396))).operator_isEqual (var_cas_testedModifierName) ;
      if (cond_144506.isBuiltAndTrue ()) {
        var_cas_found = GGS_bool (true) ;
        const GGS_bool cond_144276 = operand_143945->mInfo.mHasSetter ;
        if (cond_144276.isBuiltAndTrue ()) {
          var_cas_outModifierSignature.addAssign_operation (operand_143945->mInfo.mAttributType, GGS_formalArgumentPassingMode::constructor_argumentIn (inLexique COMMA_HERE)) ;
        }else if (cond_144276.isBuiltAndFalse ()) {
          var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("This modifier corresponds to the '")).operator_concat (operand_143945->mKey)).operator_concat (GGS_string ("' attribute that is not declared as settable")) COMMA_SOURCE_FILE_AT_LINE (3402)) ;
          operand_143945->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, GGS_string ("attribute declaration pointed out by previous error") COMMA_SOURCE_FILE_AT_LINE (3402)) ;
        }
      }
    }
  }
  const GGS_bool cond_144642 = (var_cas_found).operator_not () ;
  if (cond_144642.isBuiltAndTrue ()) {
    var_cas_inModifierName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (3408)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
method_handleMethodInstructionCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_EXcategoryMethodMap  var_cas_inCategoryMethodMap,
                                GGS_L_EXsignature & var_cas_outMethodSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string ("") ;
  const GGS_bool cond_145096 = mMethodMap.reader_hasKey (var_cas_inMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3421))) ;
  if (cond_145096.isBuiltAndTrue ()) {
    const GGS_typeTableMethodes  temp_145050 = mMethodMap ;
    if (temp_145050.isBuilt ()) {
      temp_145050 (HERE)->method_searchKey (inLexique, var_cas_inMethodName, var_cas_outMethodSignature COMMA_SOURCE_FILE_AT_LINE (3422)) ;
    }
  }else if (cond_145096.isBuiltAndFalse ()) {
    var_cas_outMethodSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    const GGS_lstring  var_cas_kKey = GGS_lstring ::constructor_new (inLexique, ((mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3425))).operator_concat (GGS_string (":"))).operator_concat (var_cas_inMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3425))), var_cas_inMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (3425)) COMMA_HERE) ;
    const GGS_bool cond_145636 = var_cas_inCategoryMethodMap.reader_hasKey (var_cas_kKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3426))) ;
    if (cond_145636.isBuiltAndTrue ()) {
      GGS_categoryMethodKind var_cas_categoryMethodKind ;
      const GGS_EXcategoryMethodMap  temp_145413 = var_cas_inCategoryMethodMap ;
      if (temp_145413.isBuilt ()) {
        temp_145413 (HERE)->method_searchKey (inLexique, var_cas_kKey, var_cas_categoryMethodKind, var_cas_outMethodSignature COMMA_SOURCE_FILE_AT_LINE (3428)) ;
      }
      const GGS_bool cond_145621 = (var_cas_categoryMethodKind).operator_isNotEqual (GGS_categoryMethodKind::constructor_overridingMethod (inLexique COMMA_HERE)) ;
      if (cond_145621.isBuiltAndTrue ()) {
        var_cas_outCategoryMethodClassBaseName = mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3430)) ;
      }
    }
    {
      GGS_typeSuperClassesMap::cEnumerator enumerator_145675 (mAncestorClassesMap, true) ;
      const GGS_typeSuperClassesMap::cElement * operand_145675 = NULL ;
      while (((operand_145675 = enumerator_145675.nextObject ()))
          && ((var_cas_outCategoryMethodClassBaseName).operator_isEqual (GGS_string ("")).isBuiltAndTrue ())) {
        macroValidPointer (operand_145675) ;
        GGS_lstring  var_cas_superKey = GGS_lstring ::constructor_new (inLexique, ((operand_145675->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3434))).operator_concat (GGS_string (":"))).operator_concat (var_cas_inMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3434))), var_cas_inMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (3434)) COMMA_HERE) ;
        const GGS_bool cond_146215 = var_cas_inCategoryMethodMap.reader_hasKey (var_cas_superKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3435))) ;
        if (cond_146215.isBuiltAndTrue ()) {
          GGS_categoryMethodKind var_cas_categoryMethodKind ;
          const GGS_EXcategoryMethodMap  temp_145980 = var_cas_inCategoryMethodMap ;
          if (temp_145980.isBuilt ()) {
            temp_145980 (HERE)->method_searchKey (inLexique, var_cas_superKey, var_cas_categoryMethodKind, var_cas_outMethodSignature COMMA_SOURCE_FILE_AT_LINE (3437)) ;
          }
          const GGS_bool cond_146198 = (var_cas_categoryMethodKind).operator_isNotEqual (GGS_categoryMethodKind::constructor_overridingMethod (inLexique COMMA_HERE)) ;
          if (cond_146198.isBuiltAndTrue ()) {
            var_cas_outCategoryMethodClassBaseName = mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3439)) ;
          }
        }
      }
    }
    const GGS_bool cond_146448 = (var_cas_outCategoryMethodClassBaseName).operator_isEqual (GGS_string ("")) ;
    if (cond_146448.isBuiltAndTrue ()) {
      var_cas_inMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("there is no '")).operator_concat (var_cas_inMethodName)).operator_concat (GGS_string ("' method defined for '@"))).operator_concat (mClassTypeName)).operator_concat (GGS_string ("' class")) COMMA_SOURCE_FILE_AT_LINE (3446)) ;
      var_cas_outMethodSignature.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgasClassType (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  const GGS_bool cond_146984 = mClassIsAbstract ;
  if (cond_146984.isBuiltAndTrue ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("an abstract class cannot be instancied") COMMA_SOURCE_FILE_AT_LINE (3461)) ;
    var_cas_outAccessorTypesList.drop () ;
  }else if (cond_146984.isBuiltAndFalse ()) {
    const GGS_bool cond_147081 = (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3461))).operator_isEqual (GGS_string ("new")) ;
    if (cond_147081.isBuiltAndTrue ()) {
      var_cas_outAccessorTypesList = mAttributeList ;
    }else if (cond_147081.isBuiltAndFalse ()) {
      var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (3465)) ;
      var_cas_outAccessorTypesList.drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasClassType:"
           << mClassTypeName.reader_description (inIndentation + 1)
           << mMethodMap.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mAncestorClassesMap.reader_description (inIndentation + 1)
           << mMessagesMap.reader_description (inIndentation + 1)
           << mNonExternAttributesMap.reader_description (inIndentation + 1)
           << mClassIsAbstract.reader_description (inIndentation + 1)
           << mClassMessage.reader_description (inIndentation + 1)
           << mHasGeneratedInSeparateFileSetting.reader_description (inIndentation + 1)
           << mLazyAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasClassType::
static_string_message_messageGalgasType (void) {
  return "a class type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasClassType::
message_messageGalgasType (void) const {
  return "a class type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasClassType::
instanceMessage (void) const {
  return "a class type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasClassType::
_static_message (void) {
  return "a class type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasClassType (& typeid (cPtr_typeGalgasClassType), & typeid (cPtr_typeGalgasUndefinedClassType), "a class type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasClassType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasClassType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasClassType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasClassType (mClassTypeName, mMethodMap, mAttributeList, mAncestorClassesMap, mMessagesMap, mNonExternAttributesMap, mClassIsAbstract, mClassMessage, mHasGeneratedInSeparateFileSetting, mLazyAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasClassType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasClassType ("typeGalgasClassType", true, & kTypeDescriptor_GGS_typeGalgasUndefinedClassType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasClassType::
GGS_typeGalgasClassType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasClassType::
GGS_typeGalgasClassType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasClassType GGS_typeGalgasClassType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasClassType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasClassType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasClassType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasClassType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasClassType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasClassType GGS_typeGalgasClassType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeTableMethodes & argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_typeSuperClassesMap & argument_3,
                 const GGS_typeClassInheritedMessagesMap & argument_4,
                 const GGS_typeSemanticAttributesMap & argument_5,
                 const GGS_bool& argument_6,
                 const GGS_string& argument_7,
                 const GGS_bool& argument_8,
                 const GGS_L_lazyAttributeList & argument_9
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasClassType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasClassType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasClassType::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasClassType * p = (cPtr_typeGalgasClassType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes  GGS_typeGalgasClassType::
reader_mMethodMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mMethodMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasClassType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap  GGS_typeGalgasClassType::
reader_mAncestorClassesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSuperClassesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mAncestorClassesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap  GGS_typeGalgasClassType::
reader_mMessagesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassInheritedMessagesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mMessagesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap  GGS_typeGalgasClassType::
reader_mNonExternAttributesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSemanticAttributesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mNonExternAttributesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasClassType::
reader_mClassIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mClassIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasClassType::
reader_mClassMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mClassMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasClassType::
reader_mHasGeneratedInSeparateFileSetting (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mHasGeneratedInSeparateFileSetting ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_lazyAttributeList  GGS_typeGalgasClassType::
reader_mLazyAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_lazyAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mLazyAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasClassType::actualTypeName (void) const {
  return "typeGalgasClassType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasClassType ("typeGalgasClassType", gClassInfoFor__typeGalgasUndefinedClassType, & kTypeDescriptor_GGS_typeGalgasClassType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasClassType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasClassType * p = NULL ;
    macroMyNew (p, GGS_typeGalgasClassType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasClassType GGS_typeGalgasClassType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasClassType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasClassType * p = dynamic_cast <const GGS_typeGalgasClassType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasClassType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasClassType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasClassType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeEntiteRoutine'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteRoutine::
cPtr_typeEntiteRoutine (const GGS_L_EXsignature & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aListeArgumentsFormels (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteRoutine * GGS_typeEntiteRoutine::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteRoutine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteRoutine *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteRoutine::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteRoutine * ptr = dynamic_cast <const cPtr_typeEntiteRoutine *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aListeArgumentsFormels.operator_isEqual (ptr->aListeArgumentsFormels).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteRoutine::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeEntiteRoutine:"
           << aListeArgumentsFormels.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutine::
static_string_message_messageTypeEntite (void) {
  return "a routine" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutine::
message_messageTypeEntite (void) const {
  return "a routine" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutine::
instanceMessage (void) const {
  return "a routine" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutine::
_static_message (void) {
  return "a routine" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntiteRoutine (& typeid (cPtr_typeEntiteRoutine), & typeid (cPtr_AC_semanticsEntity), "a routine") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeEntiteRoutine::galgasRTTI (void) const {
  return & gClassInfoFor__typeEntiteRoutine ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeEntiteRoutine::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeEntiteRoutine (aListeArgumentsFormels COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeEntiteRoutine'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeEntiteRoutine ("typeEntiteRoutine", true, & kTypeDescriptor_GGS_AC_semanticsEntity) ;

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutine::
GGS_typeEntiteRoutine (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutine::
GGS_typeEntiteRoutine (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEntiteRoutine GGS_typeEntiteRoutine::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntiteRoutine result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntiteRoutine *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntiteRoutine) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEntiteRoutine (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntiteRoutine),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutine GGS_typeEntiteRoutine::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_L_EXsignature & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteRoutine result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteRoutine (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteRoutine::
reader_messageTypeEntite (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteRoutine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeEntiteRoutine * p = (cPtr_typeEntiteRoutine *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeEntiteRoutine::
reader_aListeArgumentsFormels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteRoutine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteRoutine *) mPointer)->aListeArgumentsFormels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntiteRoutine::actualTypeName (void) const {
  return "typeEntiteRoutine" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeEntiteRoutine ("typeEntiteRoutine", gClassInfoFor__AC_semanticsEntity, & kTypeDescriptor_GGS_typeEntiteRoutine) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeEntiteRoutine::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeEntiteRoutine * p = NULL ;
    macroMyNew (p, GGS_typeEntiteRoutine (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutine GGS_typeEntiteRoutine::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeEntiteRoutine result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeEntiteRoutine * p = dynamic_cast <const GGS_typeEntiteRoutine *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeEntiteRoutine, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeEntiteRoutine::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeEntiteRoutine ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeEntiteFonction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteFonction::
cPtr_typeEntiteFonction (const GGS_L_EXsignature & argument_0,
                                const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aListeArgumentsFormels (argument_0),
mReturnedType (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteFonction * GGS_typeEntiteFonction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteFonction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteFonction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteFonction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteFonction * ptr = dynamic_cast <const cPtr_typeEntiteFonction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aListeArgumentsFormels.operator_isEqual (ptr->aListeArgumentsFormels).boolValue ()
         && mReturnedType.operator_isEqual (ptr->mReturnedType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteFonction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeEntiteFonction:"
           << aListeArgumentsFormels.reader_description (inIndentation + 1)
           << mReturnedType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteFonction::
static_string_message_messageTypeEntite (void) {
  return "a function" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteFonction::
message_messageTypeEntite (void) const {
  return "a function" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteFonction::
instanceMessage (void) const {
  return "a function" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteFonction::
_static_message (void) {
  return "a function" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntiteFonction (& typeid (cPtr_typeEntiteFonction), & typeid (cPtr_AC_semanticsEntity), "a function") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeEntiteFonction::galgasRTTI (void) const {
  return & gClassInfoFor__typeEntiteFonction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeEntiteFonction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeEntiteFonction (aListeArgumentsFormels, mReturnedType COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeEntiteFonction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeEntiteFonction ("typeEntiteFonction", true, & kTypeDescriptor_GGS_AC_semanticsEntity) ;

//---------------------------------------------------------------------------*

GGS_typeEntiteFonction::
GGS_typeEntiteFonction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteFonction::
GGS_typeEntiteFonction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEntiteFonction GGS_typeEntiteFonction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntiteFonction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntiteFonction *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntiteFonction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEntiteFonction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntiteFonction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteFonction GGS_typeEntiteFonction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_L_EXsignature & argument_0,
                 const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteFonction result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteFonction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteFonction::
reader_messageTypeEntite (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteFonction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeEntiteFonction * p = (cPtr_typeEntiteFonction *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeEntiteFonction::
reader_aListeArgumentsFormels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteFonction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteFonction *) mPointer)->aListeArgumentsFormels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeEntiteFonction::
reader_mReturnedType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteFonction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteFonction *) mPointer)->mReturnedType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntiteFonction::actualTypeName (void) const {
  return "typeEntiteFonction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeEntiteFonction ("typeEntiteFonction", gClassInfoFor__AC_semanticsEntity, & kTypeDescriptor_GGS_typeEntiteFonction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeEntiteFonction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeEntiteFonction * p = NULL ;
    macroMyNew (p, GGS_typeEntiteFonction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteFonction GGS_typeEntiteFonction::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeEntiteFonction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeEntiteFonction * p = dynamic_cast <const GGS_typeEntiteFonction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeEntiteFonction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeEntiteFonction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeEntiteFonction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_typeEnumMessageMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeEnumMessageMap::e_typeEnumMessageMap (void) :
mMessageStringList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@typeEnumMessageMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeEnumMessageMap ("typeEnumMessageMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumMessageMap::
elementOf_GGS_typeEnumMessageMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeEnumMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEnumMessageMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMessageStringList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeEnumMessageMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeEnumMessageMap * ptr = dynamic_cast <const elementOf_GGS_typeEnumMessageMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mMessageStringList.operator_isEqual (ptr->mInfo.mMessageStringList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeEnumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumMessageMap * info = (e_typeEnumMessageMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeEnumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeEnumMessageMap * info = (e_typeEnumMessageMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumMessageMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeEnumMessageMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumMessageMap::
operator_isEqual (const GGS_typeEnumMessageMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumMessageMap::
operator_isNotEqual (const GGS_typeEnumMessageMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstringlist & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeEnumMessageMap info  ;
    info.mMessageStringList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstringlist   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessageStringList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeEnumMessageMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstringlist   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeEnumMessageMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstringlist & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeEnumMessageMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumMessageMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumMessageMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEnumMessageMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeEnumMessageMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_typeEnumMessageMap::cEnumerator::_mMessageStringList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMessageStringList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeEnumMessageMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeEnumMessageMap * p = NULL ;
    macroMyNew (p, GGS_typeEnumMessageMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeEnumMessageMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeEnumMessageMap * p = dynamic_cast <const GGS_typeEnumMessageMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeEnumMessageMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeEnumMessageMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeEnumMessageMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@enumModifierDefinitionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumModifierDefinitionList::
elementOf_GGS_enumModifierDefinitionList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSourceState (argument_0),
mTargetState (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumModifierDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumModifierDefinitionList * ptr = dynamic_cast <const elementOf_GGS_enumModifierDefinitionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSourceState.operator_isEqual (ptr->mSourceState).boolValue ()
         && mTargetState.operator_isEqual (ptr->mTargetState).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumModifierDefinitionList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceState.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetState.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@enumModifierDefinitionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumModifierDefinitionList ("enumModifierDefinitionList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumModifierDefinitionList GGS_enumModifierDefinitionList::
operator_concat (const GGS_enumModifierDefinitionList & inOperand) const {
  GGS_enumModifierDefinitionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
dotAssign_operation (const GGS_enumModifierDefinitionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumModifierDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSourceState ;
          GGS_lstring  p_1 = p->mTargetState ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_typeInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSourceState,
                                ptr->mTargetState,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumModifierDefinitionList  GGS_enumModifierDefinitionList::
constructor_emptyList (void) {
  GGS_enumModifierDefinitionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierDefinitionList  GGS_enumModifierDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  GGS_enumModifierDefinitionList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
internalSubListWithRange (GGS_enumModifierDefinitionList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSourceState, ptr->mTargetState, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumModifierDefinitionList GGS_enumModifierDefinitionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumModifierDefinitionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierDefinitionList GGS_enumModifierDefinitionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumModifierDefinitionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumModifierDefinitionList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumModifierDefinitionList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_typeInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceState ;
    _out_1 = ptr->mTargetState ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_typeInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceState ;
    _out_1 = ptr->mTargetState ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_typeInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceState ;
    _out_1 = ptr->mTargetState ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_typeInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceState ;
    _out_1 = ptr->mTargetState ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumModifierDefinitionList::
reader_mSourceStateAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceState ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumModifierDefinitionList::
reader_mTargetStateAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTargetState ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_enumModifierDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
modifier_setMSourceStateAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceState = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
modifier_setMTargetStateAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTargetState = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumModifierDefinitionList::cEnumerator::_mSourceState (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSourceState ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumModifierDefinitionList::cEnumerator::_mTargetState (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTargetState ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_enumModifierDefinitionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumModifierDefinitionList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumModifierDefinitionList * p = NULL ;
    macroMyNew (p, GGS_enumModifierDefinitionList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierDefinitionList GGS_enumModifierDefinitionList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumModifierDefinitionList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumModifierDefinitionList * p = dynamic_cast <const GGS_enumModifierDefinitionList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumModifierDefinitionList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumModifierDefinitionList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumModifierDefinitionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_enumModifierMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_enumModifierMap::e_enumModifierMap (void) :
mActionDefinitionList (),
mSignature (),
mArgumentTypeAndNameList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@enumModifierMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumModifierMap ("enumModifierMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_enumModifierMap::
elementOf_GGS_enumModifierMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_enumModifierMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumModifierMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mActionDefinitionList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mArgumentTypeAndNameList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumModifierMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_enumModifierMap * ptr = dynamic_cast <const elementOf_GGS_enumModifierMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mActionDefinitionList.operator_isEqual (ptr->mInfo.mActionDefinitionList)).boolValue ()
           && (mInfo.mSignature.operator_isEqual (ptr->mInfo.mSignature)).boolValue ()
           && (mInfo.mArgumentTypeAndNameList.operator_isEqual (ptr->mInfo.mArgumentTypeAndNameList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumModifierMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumModifierMap * info = (e_enumModifierMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_enumModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_enumModifierMap * info = (e_enumModifierMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierMap GGS_enumModifierMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumModifierMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_enumModifierMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumModifierMap::
operator_isEqual (const GGS_enumModifierMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumModifierMap::
operator_isNotEqual (const GGS_enumModifierMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_enumModifierDefinitionList & inParameter0,
                const GGS_L_EXsignature & inParameter1,
                const GGS_typeListeTypesEtNomsArgMethode & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_enumModifierMap info  ;
    info.mActionDefinitionList = inParameter0 ;
    info.mSignature = inParameter1 ;
    info.mArgumentTypeAndNameList = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_enumModifierDefinitionList   & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_typeListeTypesEtNomsArgMethode   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mActionDefinitionList ;
    outParameter1 = node->mInfo.mSignature ;
    outParameter2 = node->mInfo.mArgumentTypeAndNameList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumModifierMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_enumModifierDefinitionList   & outParameter0,
                                GGS_L_EXsignature   & outParameter1,
                                GGS_typeListeTypesEtNomsArgMethode   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumModifierMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_enumModifierDefinitionList & inParameter0,
                                const GGS_L_EXsignature & inParameter1,
                                const GGS_typeListeTypesEtNomsArgMethode & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierMap GGS_enumModifierMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_enumModifierMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumModifierMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierMap GGS_enumModifierMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumModifierMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumModifierMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @enumModifierMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumModifierDefinitionList  & GGS_enumModifierMap::cEnumerator::_mActionDefinitionList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mActionDefinitionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_enumModifierMap::cEnumerator::_mSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeTypesEtNomsArgMethode  & GGS_enumModifierMap::cEnumerator::_mArgumentTypeAndNameList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mArgumentTypeAndNameList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumModifierMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumModifierMap * p = NULL ;
    macroMyNew (p, GGS_enumModifierMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierMap GGS_enumModifierMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumModifierMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumModifierMap * p = dynamic_cast <const GGS_enumModifierMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumModifierMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumModifierMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumModifierMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@enumMethodDefinitionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMethodDefinitionList::
elementOf_GGS_enumMethodDefinitionList (const GGS_lstring & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSourceState (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMethodDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMethodDefinitionList * ptr = dynamic_cast <const elementOf_GGS_enumMethodDefinitionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSourceState.operator_isEqual (ptr->mSourceState).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMethodDefinitionList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceState.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@enumMethodDefinitionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMethodDefinitionList ("enumMethodDefinitionList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMethodDefinitionList GGS_enumMethodDefinitionList::
operator_concat (const GGS_enumMethodDefinitionList & inOperand) const {
  GGS_enumMethodDefinitionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
dotAssign_operation (const GGS_enumMethodDefinitionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumMethodDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSourceState ;
          GGS_typeInstructionList  p_1 = p->mInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_typeInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSourceState,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMethodDefinitionList  GGS_enumMethodDefinitionList::
constructor_emptyList (void) {
  GGS_enumMethodDefinitionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodDefinitionList  GGS_enumMethodDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  GGS_enumMethodDefinitionList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
internalSubListWithRange (GGS_enumMethodDefinitionList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSourceState, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMethodDefinitionList GGS_enumMethodDefinitionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMethodDefinitionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodDefinitionList GGS_enumMethodDefinitionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMethodDefinitionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMethodDefinitionList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumMethodDefinitionList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_typeInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceState ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_typeInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceState ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_typeInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceState ;
    _out_1 = ptr->mInstructionList ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_typeInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceState ;
    _out_1 = ptr->mInstructionList ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMethodDefinitionList::
reader_mSourceStateAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceState ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_enumMethodDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
modifier_setMSourceStateAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceState = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumMethodDefinitionList::cEnumerator::_mSourceState (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSourceState ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_enumMethodDefinitionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMethodDefinitionList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMethodDefinitionList * p = NULL ;
    macroMyNew (p, GGS_enumMethodDefinitionList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodDefinitionList GGS_enumMethodDefinitionList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMethodDefinitionList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMethodDefinitionList * p = dynamic_cast <const GGS_enumMethodDefinitionList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMethodDefinitionList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMethodDefinitionList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMethodDefinitionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_enumMethodMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_enumMethodMap::e_enumMethodMap (void) :
mActionDefinitionList (),
mSignature (),
mArgumentTypeAndNameList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@enumMethodMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMethodMap ("enumMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_enumMethodMap::
elementOf_GGS_enumMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_enumMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mActionDefinitionList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mArgumentTypeAndNameList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMethodMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_enumMethodMap * ptr = dynamic_cast <const elementOf_GGS_enumMethodMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mActionDefinitionList.operator_isEqual (ptr->mInfo.mActionDefinitionList)).boolValue ()
           && (mInfo.mSignature.operator_isEqual (ptr->mInfo.mSignature)).boolValue ()
           && (mInfo.mArgumentTypeAndNameList.operator_isEqual (ptr->mInfo.mArgumentTypeAndNameList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumMethodMap * info = (e_enumMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_enumMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_enumMethodMap * info = (e_enumMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodMap GGS_enumMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_enumMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumMethodMap::
operator_isEqual (const GGS_enumMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumMethodMap::
operator_isNotEqual (const GGS_enumMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_enumMethodDefinitionList & inParameter0,
                const GGS_L_EXsignature & inParameter1,
                const GGS_typeListeTypesEtNomsArgMethode & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_enumMethodMap info  ;
    info.mActionDefinitionList = inParameter0 ;
    info.mSignature = inParameter1 ;
    info.mArgumentTypeAndNameList = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_enumMethodDefinitionList   & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_typeListeTypesEtNomsArgMethode   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mActionDefinitionList ;
    outParameter1 = node->mInfo.mSignature ;
    outParameter2 = node->mInfo.mArgumentTypeAndNameList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumMethodMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_enumMethodDefinitionList   & outParameter0,
                                GGS_L_EXsignature   & outParameter1,
                                GGS_typeListeTypesEtNomsArgMethode   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_enumMethodDefinitionList & inParameter0,
                                const GGS_L_EXsignature & inParameter1,
                                const GGS_typeListeTypesEtNomsArgMethode & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodMap GGS_enumMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_enumMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodMap GGS_enumMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @enumMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumMethodDefinitionList  & GGS_enumMethodMap::cEnumerator::_mActionDefinitionList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mActionDefinitionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_enumMethodMap::cEnumerator::_mSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeTypesEtNomsArgMethode  & GGS_enumMethodMap::cEnumerator::_mArgumentTypeAndNameList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mArgumentTypeAndNameList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMethodMap * p = NULL ;
    macroMyNew (p, GGS_enumMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodMap GGS_enumMethodMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMethodMap * p = dynamic_cast <const GGS_enumMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMethodMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@enumOperatorDefinitionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumOperatorDefinitionList::
elementOf_GGS_enumOperatorDefinitionList (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_uint & argument_5,
                                const GGS_typeInstructionList & argument_6
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLeftSourceState (argument_0),
mLeftSourceStateIndex (argument_1),
mRightSourceState (argument_2),
mRightSourceStateIndex (argument_3),
mTargetState (argument_4),
mTargetStateIndex (argument_5),
mInstructionList (argument_6) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumOperatorDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumOperatorDefinitionList * ptr = dynamic_cast <const elementOf_GGS_enumOperatorDefinitionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftSourceState.operator_isEqual (ptr->mLeftSourceState).boolValue ()
         && mLeftSourceStateIndex.operator_isEqual (ptr->mLeftSourceStateIndex).boolValue ()
         && mRightSourceState.operator_isEqual (ptr->mRightSourceState).boolValue ()
         && mRightSourceStateIndex.operator_isEqual (ptr->mRightSourceStateIndex).boolValue ()
         && mTargetState.operator_isEqual (ptr->mTargetState).boolValue ()
         && mTargetStateIndex.operator_isEqual (ptr->mTargetStateIndex).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumOperatorDefinitionList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftSourceState.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftSourceStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightSourceState.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightSourceStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetState.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@enumOperatorDefinitionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumOperatorDefinitionList ("enumOperatorDefinitionList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_uint & argument_3,
                    const GGS_lstring & argument_4,
                    const GGS_uint & argument_5,
                    const GGS_typeInstructionList & argument_6
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_uint & argument_3,
                    const GGS_lstring & argument_4,
                    const GGS_uint & argument_5,
                    const GGS_typeInstructionList & argument_6
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_uint & argument_5,
                                const GGS_typeInstructionList & argument_6) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()&& argument_5.isBuilt ()&& argument_6.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumOperatorDefinitionList GGS_enumOperatorDefinitionList::
operator_concat (const GGS_enumOperatorDefinitionList & inOperand) const {
  GGS_enumOperatorDefinitionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
dotAssign_operation (const GGS_enumOperatorDefinitionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumOperatorDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLeftSourceState ;
          GGS_uint  p_1 = p->mLeftSourceStateIndex ;
          GGS_lstring  p_2 = p->mRightSourceState ;
          GGS_uint  p_3 = p->mRightSourceStateIndex ;
          GGS_lstring  p_4 = p->mTargetState ;
          GGS_uint  p_5 = p->mTargetStateIndex ;
          GGS_typeInstructionList  p_6 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5, p_6 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_uint & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_uint & argument_3,
                     const GGS_lstring & argument_4,
                     const GGS_uint & argument_5,
                     const GGS_typeInstructionList & argument_6
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLeftSourceState,
                                ptr->mLeftSourceStateIndex,
                                ptr->mRightSourceState,
                                ptr->mRightSourceStateIndex,
                                ptr->mTargetState,
                                ptr->mTargetStateIndex,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumOperatorDefinitionList  GGS_enumOperatorDefinitionList::
constructor_emptyList (void) {
  GGS_enumOperatorDefinitionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorDefinitionList  GGS_enumOperatorDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_uint & argument_5,
                                const GGS_typeInstructionList & argument_6) {
  GGS_enumOperatorDefinitionList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
internalSubListWithRange (GGS_enumOperatorDefinitionList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLeftSourceState, ptr->mLeftSourceStateIndex, ptr->mRightSourceState, ptr->mRightSourceStateIndex, ptr->mTargetState, ptr->mTargetStateIndex, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumOperatorDefinitionList GGS_enumOperatorDefinitionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumOperatorDefinitionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorDefinitionList GGS_enumOperatorDefinitionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumOperatorDefinitionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumOperatorDefinitionList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumOperatorDefinitionList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_uint & _out_1,
              GGS_lstring & _out_2,
              GGS_uint & _out_3,
              GGS_lstring & _out_4,
              GGS_uint & _out_5,
              GGS_typeInstructionList & _out_6
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLeftSourceState ;
    _out_1 = ptr->mLeftSourceStateIndex ;
    _out_2 = ptr->mRightSourceState ;
    _out_3 = ptr->mRightSourceStateIndex ;
    _out_4 = ptr->mTargetState ;
    _out_5 = ptr->mTargetStateIndex ;
    _out_6 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_uint & _out_1,
             GGS_lstring & _out_2,
             GGS_uint & _out_3,
             GGS_lstring & _out_4,
             GGS_uint & _out_5,
             GGS_typeInstructionList & _out_6
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLeftSourceState ;
    _out_1 = ptr->mLeftSourceStateIndex ;
    _out_2 = ptr->mRightSourceState ;
    _out_3 = ptr->mRightSourceStateIndex ;
    _out_4 = ptr->mTargetState ;
    _out_5 = ptr->mTargetStateIndex ;
    _out_6 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_uint & _out_1,
                 GGS_lstring & _out_2,
                 GGS_uint & _out_3,
                 GGS_lstring & _out_4,
                 GGS_uint & _out_5,
                 GGS_typeInstructionList & _out_6
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLeftSourceState ;
    _out_1 = ptr->mLeftSourceStateIndex ;
    _out_2 = ptr->mRightSourceState ;
    _out_3 = ptr->mRightSourceStateIndex ;
    _out_4 = ptr->mTargetState ;
    _out_5 = ptr->mTargetStateIndex ;
    _out_6 = ptr->mInstructionList ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_uint & _out_1,
                GGS_lstring & _out_2,
                GGS_uint & _out_3,
                GGS_lstring & _out_4,
                GGS_uint & _out_5,
                GGS_typeInstructionList & _out_6
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLeftSourceState ;
    _out_1 = ptr->mLeftSourceStateIndex ;
    _out_2 = ptr->mRightSourceState ;
    _out_3 = ptr->mRightSourceStateIndex ;
    _out_4 = ptr->mTargetState ;
    _out_5 = ptr->mTargetStateIndex ;
    _out_6 = ptr->mInstructionList ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumOperatorDefinitionList::
reader_mLeftSourceStateAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLeftSourceState ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_enumOperatorDefinitionList::
reader_mLeftSourceStateIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLeftSourceStateIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumOperatorDefinitionList::
reader_mRightSourceStateAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRightSourceState ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_enumOperatorDefinitionList::
reader_mRightSourceStateIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRightSourceStateIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumOperatorDefinitionList::
reader_mTargetStateAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTargetState ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_enumOperatorDefinitionList::
reader_mTargetStateIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTargetStateIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_enumOperatorDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_setMLeftSourceStateAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLeftSourceState = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_setMLeftSourceStateIndexAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLeftSourceStateIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_setMRightSourceStateAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRightSourceState = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_setMRightSourceStateIndexAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRightSourceStateIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_setMTargetStateAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTargetState = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_setMTargetStateIndexAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTargetStateIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumOperatorDefinitionList::cEnumerator::_mLeftSourceState (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLeftSourceState ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_enumOperatorDefinitionList::cEnumerator::_mLeftSourceStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLeftSourceStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumOperatorDefinitionList::cEnumerator::_mRightSourceState (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRightSourceState ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_enumOperatorDefinitionList::cEnumerator::_mRightSourceStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRightSourceStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumOperatorDefinitionList::cEnumerator::_mTargetState (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTargetState ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_enumOperatorDefinitionList::cEnumerator::_mTargetStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTargetStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_enumOperatorDefinitionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumOperatorDefinitionList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumOperatorDefinitionList * p = NULL ;
    macroMyNew (p, GGS_enumOperatorDefinitionList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorDefinitionList GGS_enumOperatorDefinitionList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumOperatorDefinitionList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumOperatorDefinitionList * p = dynamic_cast <const GGS_enumOperatorDefinitionList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumOperatorDefinitionList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumOperatorDefinitionList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumOperatorDefinitionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_enumOperatorMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_enumOperatorMap::e_enumOperatorMap (void) :
mActionDefinitionList (),
mSignature (),
mArgumentTypeAndNameList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@enumOperatorMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumOperatorMap ("enumOperatorMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_enumOperatorMap::
elementOf_GGS_enumOperatorMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_enumOperatorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumOperatorMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mActionDefinitionList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mArgumentTypeAndNameList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumOperatorMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_enumOperatorMap * ptr = dynamic_cast <const elementOf_GGS_enumOperatorMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mActionDefinitionList.operator_isEqual (ptr->mInfo.mActionDefinitionList)).boolValue ()
           && (mInfo.mSignature.operator_isEqual (ptr->mInfo.mSignature)).boolValue ()
           && (mInfo.mArgumentTypeAndNameList.operator_isEqual (ptr->mInfo.mArgumentTypeAndNameList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumOperatorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumOperatorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumOperatorMap * info = (e_enumOperatorMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_enumOperatorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_enumOperatorMap * info = (e_enumOperatorMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorMap GGS_enumOperatorMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumOperatorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_enumOperatorMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumOperatorMap::
operator_isEqual (const GGS_enumOperatorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumOperatorMap::
operator_isNotEqual (const GGS_enumOperatorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_enumOperatorDefinitionList & inParameter0,
                const GGS_L_EXsignature & inParameter1,
                const GGS_typeListeTypesEtNomsArgMethode & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_enumOperatorMap info  ;
    info.mActionDefinitionList = inParameter0 ;
    info.mSignature = inParameter1 ;
    info.mArgumentTypeAndNameList = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_enumOperatorDefinitionList   & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_typeListeTypesEtNomsArgMethode   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mActionDefinitionList ;
    outParameter1 = node->mInfo.mSignature ;
    outParameter2 = node->mInfo.mArgumentTypeAndNameList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumOperatorMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_enumOperatorDefinitionList   & outParameter0,
                                GGS_L_EXsignature   & outParameter1,
                                GGS_typeListeTypesEtNomsArgMethode   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_enumOperatorMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_enumOperatorDefinitionList & inParameter0,
                                const GGS_L_EXsignature & inParameter1,
                                const GGS_typeListeTypesEtNomsArgMethode & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorMap GGS_enumOperatorMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_enumOperatorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumOperatorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorMap GGS_enumOperatorMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumOperatorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumOperatorMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @enumOperatorMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumOperatorDefinitionList  & GGS_enumOperatorMap::cEnumerator::_mActionDefinitionList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mActionDefinitionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_enumOperatorMap::cEnumerator::_mSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeTypesEtNomsArgMethode  & GGS_enumOperatorMap::cEnumerator::_mArgumentTypeAndNameList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mArgumentTypeAndNameList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumOperatorMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumOperatorMap * p = NULL ;
    macroMyNew (p, GGS_enumOperatorMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorMap GGS_enumOperatorMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumOperatorMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumOperatorMap * p = dynamic_cast <const GGS_enumOperatorMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumOperatorMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumOperatorMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumOperatorMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeGalgas_enum'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_enum::
cPtr_typeGalgas_enum (const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2,
                                const GGS_enumModifierMap & argument_3,
                                const GGS_enumMethodMap & argument_4,
                                const GGS_enumOperatorMap & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEnumTypeName (argument_0),
mEnumConstantesMap (argument_1),
mMessagesMap (argument_2),
mModifierMap (argument_3),
mMethodMap (argument_4),
mOperatorMap (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_enum * GGS_typeGalgas_enum::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_enum *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_enum::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgas_enum * ptr = dynamic_cast <const cPtr_typeGalgas_enum *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumTypeName.operator_isEqual (ptr->mEnumTypeName).boolValue ()
         && mEnumConstantesMap.operator_isEqual (ptr->mEnumConstantesMap).boolValue ()
         && mMessagesMap.operator_isEqual (ptr->mMessagesMap).boolValue ()
         && mModifierMap.operator_isEqual (ptr->mModifierMap).boolValue ()
         && mMethodMap.operator_isEqual (ptr->mMethodMap).boolValue ()
         && mOperatorMap.operator_isEqual (ptr->mOperatorMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
method_getTypeName (C_Compiler & inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3584)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
method_handleConstructorInvocation (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments,
                                GGS_AC_galgasType & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outReturnedType = GGS_typeGalgas_enum (this) ;
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  GGS_bool var_cas_hasConstructor ;
  GGS_uint  automatic_var_151666_0 ;
  const GGS_enumConstantMap  temp_151627 = mEnumConstantesMap ;
  if (temp_151627.isBuilt ()) {
    temp_151627 (HERE)->method_searchKey (inLexique, var_cas_inClassMethodName, automatic_var_151666_0, var_cas_hasConstructor COMMA_SOURCE_FILE_AT_LINE (3597)) ;
  }
  const GGS_bool cond_151779 = var_cas_hasConstructor ;
  if (cond_151779.isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (cond_151779.isBuiltAndFalse ()) {
    var_cas_inClassMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (var_cas_inClassMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3602)))).operator_concat (GGS_string ("' is not declared as constructor")) COMMA_SOURCE_FILE_AT_LINE (3605)) ;
    var_cas_outAccessorTypesList.drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
method_handleModifierCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumModifierDefinitionList  automatic_var_152163_0 ;
  GGS_typeListeTypesEtNomsArgMethode  automatic_var_152163_1 ;
  const GGS_enumModifierMap  temp_152118 = mModifierMap ;
  if (temp_152118.isBuilt ()) {
    temp_152118 (HERE)->method_searchKey (inLexique, var_cas_inModifierName, automatic_var_152163_0, var_cas_outModifierSignature, automatic_var_152163_1 COMMA_SOURCE_FILE_AT_LINE (3614)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
method_handleMethodInstructionCall (C_Compiler & inLexique,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outReaderSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string ("") ;
  GGS_enumMethodDefinitionList  automatic_var_152521_0 ;
  GGS_typeListeTypesEtNomsArgMethode  automatic_var_152521_1 ;
  const GGS_enumMethodMap  temp_152480 = mMethodMap ;
  if (temp_152480.isBuilt ()) {
    temp_152480 (HERE)->method_searchKey (inLexique, var_cas_inMethodName, automatic_var_152521_0, var_cas_outReaderSignature, automatic_var_152521_1 COMMA_SOURCE_FILE_AT_LINE (3626)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgas_enum:"
           << mEnumTypeName.reader_description (inIndentation + 1)
           << mEnumConstantesMap.reader_description (inIndentation + 1)
           << mMessagesMap.reader_description (inIndentation + 1)
           << mModifierMap.reader_description (inIndentation + 1)
           << mMethodMap.reader_description (inIndentation + 1)
           << mOperatorMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_enum::
static_string_message_messageGalgasType (void) {
  return "an enum type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_enum::
message_messageGalgasType (void) const {
  return "an enum type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_enum::
instanceMessage (void) const {
  return "an enum type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_enum::
_static_message (void) {
  return "an enum type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_enum (& typeid (cPtr_typeGalgas_enum), & typeid (cPtr_AC_galgasType), "an enum type") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgas_enum::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_enum ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgas_enum::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgas_enum (mEnumTypeName, mEnumConstantesMap, mMessagesMap, mModifierMap, mMethodMap, mOperatorMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_enum'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgas_enum ("typeGalgas_enum", true, & kTypeDescriptor_GGS_AC_galgasType) ;

//---------------------------------------------------------------------------*

GGS_typeGalgas_enum::
GGS_typeGalgas_enum (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_enum::
GGS_typeGalgas_enum (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgas_enum GGS_typeGalgas_enum::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_enum result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_enum *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_enum) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgas_enum (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_enum),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_enum GGS_typeGalgas_enum::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_enumConstantMap & argument_1,
                 const GGS_typeEnumMessageMap & argument_2,
                 const GGS_enumModifierMap & argument_3,
                 const GGS_enumMethodMap & argument_4,
                 const GGS_enumOperatorMap & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_enum result ;
  macroMyNew (result.mPointer, cPtr_typeGalgas_enum (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_enum::
reader_messageGalgasType (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_enum * p = (cPtr_typeGalgas_enum *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgas_enum::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_enum *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap  GGS_typeGalgas_enum::
reader_mEnumConstantesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumConstantMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_enum *) mPointer)->mEnumConstantesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap  GGS_typeGalgas_enum::
reader_mMessagesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumMessageMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_enum *) mPointer)->mMessagesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_enum::actualTypeName (void) const {
  return "typeGalgas_enum" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgas_enum ("typeGalgas_enum", gClassInfoFor__AC_galgasType, & kTypeDescriptor_GGS_typeGalgas_enum) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgas_enum::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgas_enum * p = NULL ;
    macroMyNew (p, GGS_typeGalgas_enum (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_enum GGS_typeGalgas_enum::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_enum result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgas_enum * p = dynamic_cast <const GGS_typeGalgas_enum *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgas_enum, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgas_enum::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgas_enum ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "checkAssignmentTypesCompatibility"        *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkAssignmentTypesCompatibility (C_Compiler & inLexique,
                                const GGS_AC_galgasType   var_cas_inFormalType,
                                const GGS_AC_galgasType   var_cas_inEffectiveType,
                                const GGS_location   var_cas_inErrorLocation,
                                const GGS_bool  var_cas_inAcceptPolymorphism COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkAssignmentTypesCompatibility at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (var_cas_inFormalType.isBuilt () && var_cas_inEffectiveType.isBuilt ()) {
    cPtr_AC_galgasType * ptr_153202 = var_cas_inFormalType (HERE) ;
    cPtr_AC_galgasType * ptr_153220 = var_cas_inEffectiveType (HERE) ;
    cPtr_typeGalgas_object * operand_153202 = dynamic_cast <cPtr_typeGalgas_object *> (ptr_153202) ;
    cPtr_typeGalgas_object * operand_153220 = dynamic_cast <cPtr_typeGalgas_object *> (ptr_153220) ;
    if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
    }else{
      cPtr_typeGalgas_type * operand_153202 = dynamic_cast <cPtr_typeGalgas_type *> (ptr_153202) ;
      cPtr_typeGalgas_type * operand_153220 = dynamic_cast <cPtr_typeGalgas_type *> (ptr_153220) ;
      if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
      }else{
        cPtr_typeGalgas_function * operand_153202 = dynamic_cast <cPtr_typeGalgas_function *> (ptr_153202) ;
        cPtr_typeGalgas_function * operand_153220 = dynamic_cast <cPtr_typeGalgas_function *> (ptr_153220) ;
        if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
        }else{
          cPtr_typeGalgas_binaryset * operand_153202 = dynamic_cast <cPtr_typeGalgas_binaryset *> (ptr_153202) ;
          cPtr_typeGalgas_binaryset * operand_153220 = dynamic_cast <cPtr_typeGalgas_binaryset *> (ptr_153220) ;
          if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
          }else{
            cPtr_typeGalgas_stringset * operand_153202 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_153202) ;
            cPtr_typeGalgas_stringset * operand_153220 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_153220) ;
            if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
            }else{
              cPtr_typeGalgas_data * operand_153202 = dynamic_cast <cPtr_typeGalgas_data *> (ptr_153202) ;
              cPtr_typeGalgas_data * operand_153220 = dynamic_cast <cPtr_typeGalgas_data *> (ptr_153220) ;
              if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
              }else{
                cPtr_typeGalgas_uint * operand_153202 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_153202) ;
                cPtr_typeGalgas_uint * operand_153220 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_153220) ;
                if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                }else{
                  cPtr_typeGalgas_sint * operand_153202 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_153202) ;
                  cPtr_typeGalgas_sint * operand_153220 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_153220) ;
                  if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                  }else{
                    cPtr_typeGalgas_uint64 * operand_153202 = dynamic_cast <cPtr_typeGalgas_uint64 *> (ptr_153202) ;
                    cPtr_typeGalgas_uint64 * operand_153220 = dynamic_cast <cPtr_typeGalgas_uint64 *> (ptr_153220) ;
                    if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                    }else{
                      cPtr_typeGalgas_sint64 * operand_153202 = dynamic_cast <cPtr_typeGalgas_sint64 *> (ptr_153202) ;
                      cPtr_typeGalgas_sint64 * operand_153220 = dynamic_cast <cPtr_typeGalgas_sint64 *> (ptr_153220) ;
                      if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                      }else{
                        cPtr_typeGalgas_char * operand_153202 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_153202) ;
                        cPtr_typeGalgas_char * operand_153220 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_153220) ;
                        if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                        }else{
                          cPtr_typeGalgas_string * operand_153202 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_153202) ;
                          cPtr_typeGalgas_string * operand_153220 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_153220) ;
                          if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                          }else{
                            cPtr_typeGalgas_bool * operand_153202 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_153202) ;
                            cPtr_typeGalgas_bool * operand_153220 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_153220) ;
                            if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                            }else{
                              cPtr_typeGalgas_double * operand_153202 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_153202) ;
                              cPtr_typeGalgas_double * operand_153220 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_153220) ;
                              if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                              }else{
                                cPtr_typeGalgas_lbool * operand_153202 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_153202) ;
                                cPtr_typeGalgas_lbool * operand_153220 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_153220) ;
                                if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                }else{
                                  cPtr_typeGalgas_lchar * operand_153202 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_153202) ;
                                  cPtr_typeGalgas_lchar * operand_153220 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_153220) ;
                                  if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                  }else{
                                    cPtr_typeGalgas_luint * operand_153202 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_153202) ;
                                    cPtr_typeGalgas_luint * operand_153220 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_153220) ;
                                    if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                    }else{
                                      cPtr_typeGalgas_lsint * operand_153202 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_153202) ;
                                      cPtr_typeGalgas_lsint * operand_153220 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_153220) ;
                                      if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                      }else{
                                        cPtr_typeGalgas_luint64 * operand_153202 = dynamic_cast <cPtr_typeGalgas_luint64 *> (ptr_153202) ;
                                        cPtr_typeGalgas_luint64 * operand_153220 = dynamic_cast <cPtr_typeGalgas_luint64 *> (ptr_153220) ;
                                        if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                        }else{
                                          cPtr_typeGalgas_lsint64 * operand_153202 = dynamic_cast <cPtr_typeGalgas_lsint64 *> (ptr_153202) ;
                                          cPtr_typeGalgas_lsint64 * operand_153220 = dynamic_cast <cPtr_typeGalgas_lsint64 *> (ptr_153220) ;
                                          if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                          }else{
                                            cPtr_typeGalgas_ldouble * operand_153202 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_153202) ;
                                            cPtr_typeGalgas_ldouble * operand_153220 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_153220) ;
                                            if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                            }else{
                                              cPtr_typeGalgas_lstring * operand_153202 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_153202) ;
                                              cPtr_typeGalgas_lstring * operand_153220 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_153220) ;
                                              if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                              }else{
                                                cPtr_typeGalgas_location * operand_153202 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_153202) ;
                                                cPtr_typeGalgas_location * operand_153220 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_153220) ;
                                                if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                                }else{
                                                  cPtr_typeGalgas_filewrapper * operand_153202 = dynamic_cast <cPtr_typeGalgas_filewrapper *> (ptr_153202) ;
                                                  cPtr_typeGalgas_filewrapper * operand_153220 = dynamic_cast <cPtr_typeGalgas_filewrapper *> (ptr_153220) ;
                                                  if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                                  }else{
                                                    cPtr_typeGalgasStructType * operand_153202 = dynamic_cast <cPtr_typeGalgasStructType *> (ptr_153202) ;
                                                    cPtr_typeGalgasStructType * operand_153220 = dynamic_cast <cPtr_typeGalgasStructType *> (ptr_153220) ;
                                                    if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                                      GGS_bool var_cas_accept = (operand_153202->mStructTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3673))).operator_isEqual (operand_153220->mStructTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3673))) ;
                                                      const GGS_bool cond_155090 = (var_cas_accept).operator_not () ;
                                                      if (cond_155090.isBuiltAndTrue ()) {
                                                        var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("I was expecting the struct type '@")).operator_concat (operand_153202->mStructTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3675)))).operator_concat (GGS_string ("', I have got the struc type '@"))).operator_concat (operand_153220->mStructTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3676)))).operator_concat (GGS_string ("\"")) COMMA_SOURCE_FILE_AT_LINE (3677)) ;
                                                      }
                                                    }else{
                                                      cPtr_typeGalgasUndefinedClassType * operand_153202 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_153202) ;
                                                      cPtr_typeGalgasClassType * operand_153220 = dynamic_cast <cPtr_typeGalgasClassType *> (ptr_153220) ;
                                                      if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                                        GGS_bool var_cas_accept = (operand_153202->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3681))).operator_isEqual (operand_153220->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3681))) ;
                                                        const GGS_bool cond_155439 = ((var_cas_accept).operator_not ()).operator_and (var_cas_inAcceptPolymorphism) ;
                                                        if (cond_155439.isBuiltAndTrue ()) {
                                                          var_cas_accept = operand_153220->mAncestorClassesMap.reader_hasKey (operand_153202->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3683))) ;
                                                        }
                                                        const GGS_bool cond_155658 = (var_cas_accept).operator_not () ;
                                                        if (cond_155658.isBuiltAndTrue ()) {
                                                          var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("I was expecting the class type '@")).operator_concat (operand_153202->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3686)))).operator_concat (GGS_string ("', I have got the class type '@"))).operator_concat (operand_153220->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3687)))).operator_concat (GGS_string ("\"")) COMMA_SOURCE_FILE_AT_LINE (3688)) ;
                                                        }
                                                      }else{
                                                        cPtr_typeGalgasUndefinedMapindexType * operand_153202 = dynamic_cast <cPtr_typeGalgasUndefinedMapindexType *> (ptr_153202) ;
                                                        cPtr_typeGalgasUndefinedMapindexType * operand_153220 = dynamic_cast <cPtr_typeGalgasUndefinedMapindexType *> (ptr_153220) ;
                                                        if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                                          const GGS_bool cond_156058 = (operand_153202->mMapindexTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3691))).operator_isNotEqual (operand_153220->mMapindexTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3691))) ;
                                                          if (cond_156058.isBuiltAndTrue ()) {
                                                            var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("I was expecting the map index type '@")).operator_concat (operand_153202->mMapindexTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3692)))).operator_concat (GGS_string ("', I have got the map index type '@"))).operator_concat (operand_153220->mMapindexTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3693)))).operator_concat (GGS_string ("\"")) COMMA_SOURCE_FILE_AT_LINE (3694)) ;
                                                          }
                                                        }else{
                                                          cPtr_typeGalgasUndefinedListType * operand_153202 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_153202) ;
                                                          cPtr_typeGalgasUndefinedListType * operand_153220 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_153220) ;
                                                          if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                                            const GGS_bool cond_156432 = (operand_153202->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3697))).operator_isNotEqual (operand_153220->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3697))) ;
                                                            if (cond_156432.isBuiltAndTrue ()) {
                                                              var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("I was expecting the list type '@")).operator_concat (operand_153202->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3698)))).operator_concat (GGS_string ("', I have got the list type '@"))).operator_concat (operand_153220->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3699)))).operator_concat (GGS_string ("\"")) COMMA_SOURCE_FILE_AT_LINE (3700)) ;
                                                            }
                                                          }else{
                                                            cPtr_typeGalgasUndefinedSortedListType * operand_153202 = dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (ptr_153202) ;
                                                            cPtr_typeGalgasUndefinedSortedListType * operand_153220 = dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (ptr_153220) ;
                                                            if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                                              const GGS_bool cond_156832 = (operand_153202->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3703))).operator_isNotEqual (operand_153220->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3703))) ;
                                                              if (cond_156832.isBuiltAndTrue ()) {
                                                                var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("I was expecting the sorted list type '@")).operator_concat (operand_153202->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3704)))).operator_concat (GGS_string ("', I have got the sorted list type '@"))).operator_concat (operand_153220->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3705)))).operator_concat (GGS_string ("\"")) COMMA_SOURCE_FILE_AT_LINE (3706)) ;
                                                              }
                                                            }else{
                                                              cPtr_typeGalgasUndefinedMapType * operand_153202 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_153202) ;
                                                              cPtr_typeGalgasUndefinedMapType * operand_153220 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_153220) ;
                                                              if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                                                const GGS_bool cond_157200 = (operand_153202->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3709))).operator_isNotEqual (operand_153220->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3709))) ;
                                                                if (cond_157200.isBuiltAndTrue ()) {
                                                                  var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("I was expecting the map type '@")).operator_concat (operand_153202->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3710)))).operator_concat (GGS_string ("', I have got the map type '@"))).operator_concat (operand_153220->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3711)))).operator_concat (GGS_string ("\"")) COMMA_SOURCE_FILE_AT_LINE (3712)) ;
                                                                }
                                                              }else{
                                                                cPtr_typeGalgasUndefinedClassType * operand_153202 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_153202) ;
                                                                cPtr_typeGalgasUndefinedClassType * operand_153220 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_153220) ;
                                                                if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                                                  const GGS_bool cond_157576 = (operand_153202->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3715))).operator_isNotEqual (operand_153220->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3715))) ;
                                                                  if (cond_157576.isBuiltAndTrue ()) {
                                                                    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("I was expecting the class type '@")).operator_concat (operand_153202->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3716)))).operator_concat (GGS_string ("', I have got the class type '@"))).operator_concat (operand_153220->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3717)))).operator_concat (GGS_string ("\"")) COMMA_SOURCE_FILE_AT_LINE (3718)) ;
                                                                  }
                                                                }else{
                                                                  cPtr_typeGalgasListmapType * operand_153202 = dynamic_cast <cPtr_typeGalgasListmapType *> (ptr_153202) ;
                                                                  cPtr_typeGalgasListmapType * operand_153220 = dynamic_cast <cPtr_typeGalgasListmapType *> (ptr_153220) ;
                                                                  if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                                                    const GGS_bool cond_157987 = (operand_153202->mListmapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3722))).operator_isNotEqual (operand_153220->mListmapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3722))) ;
                                                                    if (cond_157987.isBuiltAndTrue ()) {
                                                                      var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("I was expecting an extern variable of listmap '@")).operator_concat (operand_153202->mListmapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3723)))).operator_concat (GGS_string ("' type variable, and I got a listmap '@"))).operator_concat (operand_153220->mListmapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3724)))).operator_concat (GGS_string ("' type variable")) COMMA_SOURCE_FILE_AT_LINE (3725)) ;
                                                                    }
                                                                  }else{
                                                                    cPtr_typeGalgasUndefinedExternType * operand_153202 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_153202) ;
                                                                    cPtr_typeGalgasUndefinedExternType * operand_153220 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_153220) ;
                                                                    if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                                                      const GGS_bool cond_158405 = (operand_153202->mGalgasClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3729))).operator_isNotEqual (operand_153220->mGalgasClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3729))) ;
                                                                      if (cond_158405.isBuiltAndTrue ()) {
                                                                        var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("I was expecting an extern variable of extern '@")).operator_concat (operand_153202->mGalgasClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3730)))).operator_concat (GGS_string ("' type variable, and I got an extern '@"))).operator_concat (operand_153220->mGalgasClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3731)))).operator_concat (GGS_string ("' type variable")) COMMA_SOURCE_FILE_AT_LINE (3732)) ;
                                                                      }
                                                                    }else{
                                                                      cPtr_typeGalgas_enum * operand_153202 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_153202) ;
                                                                      cPtr_typeGalgas_enum * operand_153220 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_153220) ;
                                                                      if ((operand_153202 != NULL) && (operand_153220 != NULL)) {
                                                                        const GGS_bool cond_158786 = (operand_153202->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3736))).operator_isNotEqual (operand_153220->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3736))) ;
                                                                        if (cond_158786.isBuiltAndTrue ()) {
                                                                          var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("I was expecting an enum variable of  '@")).operator_concat (operand_153202->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3737)))).operator_concat (GGS_string ("' type variable, and I got an enum '@"))).operator_concat (operand_153220->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (3738)))).operator_concat (GGS_string ("' type variable")) COMMA_SOURCE_FILE_AT_LINE (3739)) ;
                                                                        }
                                                                      }else{
                                                                        var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((var_cas_inFormalType.reader_messageGalgasType (inLexique COMMA_SOURCE_FILE_AT_LINE (3742))).operator_concat (GGS_string (" is not compatible with "))).operator_concat (var_cas_inEffectiveType.reader_messageGalgasType (inLexique COMMA_SOURCE_FILE_AT_LINE (3742))) COMMA_SOURCE_FILE_AT_LINE (3743)) ;
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkAssignmentTypesCompatibility\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of routine "verifierCompatibiliteSignatures"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteSignatures (C_Compiler & inLexique,
                                const GGS_L_EXsignature   var_cas_signatureReference,
                                const GGS_L_EXsignature   var_cas_signatureTestee,
                                const GGS_location   var_cas_ouSignalerErreur COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_verifierCompatibiliteSignatures at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_bool cond_159632 = (var_cas_signatureReference.reader_length ()).operator_strictInf (var_cas_signatureTestee.reader_length ()) ;
  if (cond_159632.isBuiltAndTrue ()) {
    var_cas_ouSignalerErreur.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("there are too much parameters") COMMA_SOURCE_FILE_AT_LINE (3759)) ;
  }else if (cond_159632.isBuiltAndFalse ()) {
    const GGS_bool cond_159763 = (var_cas_signatureReference.reader_length ()).operator_strictSup (var_cas_signatureTestee.reader_length ()) ;
    if (cond_159763.isBuiltAndTrue ()) {
      var_cas_ouSignalerErreur.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("one or more parameters missing") COMMA_SOURCE_FILE_AT_LINE (3761)) ;
    }else if (cond_159763.isBuiltAndFalse ()) {
      {
        GGS_L_EXsignature::cEnumerator enumerator_159795 (var_cas_signatureReference, true) ;
        const GGS_L_EXsignature::cElement * operand_159795 = NULL ;
        GGS_L_EXsignature::cEnumerator enumerator_159824 (var_cas_signatureTestee, true) ;
        const GGS_L_EXsignature::cElement * operand_159824 = NULL ;
        while (((operand_159795 = enumerator_159795.nextObject ()))
            && ((operand_159824 = enumerator_159824.nextObject ()))) {
          macroValidPointer (operand_159795) ;
          macroValidPointer (operand_159824) ;
          ::routine_checkAssignmentTypesCompatibility (inLexique,  operand_159795->mType,  operand_159824->mType,  var_cas_ouSignalerErreur,  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (3764)) ;
          const GGS_bool cond_160267 = (operand_159795->mFormalArgumentPassingMode).operator_isNotEqual (operand_159824->mFormalArgumentPassingMode) ;
          if (cond_160267.isBuiltAndTrue ()) {
            var_cas_ouSignalerErreur.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((operand_159795->mFormalArgumentPassingMode.reader_formalArgumentMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (3771))).operator_concat (GGS_string (" is not compatible with "))).operator_concat (operand_159824->mFormalArgumentPassingMode.reader_formalArgumentMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (3772))) COMMA_SOURCE_FILE_AT_LINE (3773)) ;
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_verifierCompatibiliteSignatures\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_M_cli_options'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_cli_options::e_M_cli_options (void) :
mOptionChar (),
mOptionString (),
mComment () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@M_cli_options'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_cli_options ("M_cli_options", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_cli_options::
elementOf_GGS_M_cli_options (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_cli_options & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_cli_options::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mOptionChar.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mOptionString.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mComment.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_cli_options::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_cli_options * ptr = dynamic_cast <const elementOf_GGS_M_cli_options *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mOptionChar.operator_isEqual (ptr->mInfo.mOptionChar)).boolValue ()
           && (mInfo.mOptionString.operator_isEqual (ptr->mInfo.mOptionString)).boolValue ()
           && (mInfo.mComment.operator_isEqual (ptr->mInfo.mComment)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_cli_options::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_cli_options *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_cli_options * info = (e_M_cli_options *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_cli_options *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_cli_options * info = (e_M_cli_options *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_cli_options result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_cli_options info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_cli_options::
operator_isEqual (const GGS_M_cli_options & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_cli_options::
operator_isNotEqual (const GGS_M_cli_options & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lchar & inParameter0,
                const GGS_lstring & inParameter1,
                const GGS_lstring & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_cli_options info  ;
    info.mOptionChar = inParameter0 ;
    info.mOptionString = inParameter1 ;
    info.mComment = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lchar   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mOptionChar ;
    outParameter1 = node->mInfo.mOptionString ;
    outParameter2 = node->mInfo.mComment ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_cli_options::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('p'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lchar   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_lstring   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_cli_options::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('p'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lchar & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_lstring & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_cli_options & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_cli_options result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_cli_options result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_cli_options::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_cli_options " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lchar  & GGS_M_cli_options::cEnumerator::_mOptionChar (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mOptionChar ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_M_cli_options::cEnumerator::_mOptionString (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mOptionString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_M_cli_options::cEnumerator::_mComment (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mComment ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_cli_options::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_cli_options * p = NULL ;
    macroMyNew (p, GGS_M_cli_options (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_cli_options result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_cli_options * p = dynamic_cast <const GGS_M_cli_options *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_cli_options, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_cli_options::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_cli_options ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_M_optionComponents'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_optionComponents::e_M_optionComponents (void) :
mBoolOptionsMap (),
mUintOptionsMap (),
mStringOptionsMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@M_optionComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_optionComponents ("M_optionComponents", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_optionComponents::
elementOf_GGS_M_optionComponents (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_optionComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_optionComponents::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mBoolOptionsMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mUintOptionsMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mStringOptionsMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_optionComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_optionComponents * ptr = dynamic_cast <const elementOf_GGS_M_optionComponents *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mBoolOptionsMap.operator_isEqual (ptr->mInfo.mBoolOptionsMap)).boolValue ()
           && (mInfo.mUintOptionsMap.operator_isEqual (ptr->mInfo.mUintOptionsMap)).boolValue ()
           && (mInfo.mStringOptionsMap.operator_isEqual (ptr->mInfo.mStringOptionsMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_optionComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_optionComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_optionComponents * info = (e_M_optionComponents *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_optionComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_optionComponents * info = (e_M_optionComponents *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_optionComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_optionComponents info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_optionComponents::
operator_isEqual (const GGS_M_optionComponents & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_optionComponents::
operator_isNotEqual (const GGS_M_optionComponents & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_cli_options & inParameter0,
                const GGS_M_cli_options & inParameter1,
                const GGS_M_cli_options & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_optionComponents info  ;
    info.mBoolOptionsMap = inParameter0 ;
    info.mUintOptionsMap = inParameter1 ;
    info.mStringOptionsMap = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_cli_options   & outParameter0,
               GGS_M_cli_options   & outParameter1,
               GGS_M_cli_options   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mBoolOptionsMap ;
    outParameter1 = node->mInfo.mUintOptionsMap ;
    outParameter2 = node->mInfo.mStringOptionsMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_optionComponents::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('p'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_cli_options   & outParameter0,
                                GGS_M_cli_options   & outParameter1,
                                GGS_M_cli_options   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_optionComponents::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('p'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_cli_options & inParameter0,
                                const GGS_M_cli_options & inParameter1,
                                const GGS_M_cli_options & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_optionComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_optionComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_optionComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_optionComponents::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_optionComponents " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_cli_options  & GGS_M_optionComponents::cEnumerator::_mBoolOptionsMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mBoolOptionsMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_cli_options  & GGS_M_optionComponents::cEnumerator::_mUintOptionsMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mUintOptionsMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_cli_options  & GGS_M_optionComponents::cEnumerator::_mStringOptionsMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mStringOptionsMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_optionComponents::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_optionComponents * p = NULL ;
    macroMyNew (p, GGS_M_optionComponents (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_optionComponents result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_optionComponents * p = dynamic_cast <const GGS_M_optionComponents *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_optionComponents, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_optionComponents::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_optionComponents ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_M_grammarComponents'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_grammarComponents::e_M_grammarComponents (void) :
mNonterminalSymbolParametersMap (),
mLexiqueName (),
mOptionsMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@M_grammarComponents'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_grammarComponents ("M_grammarComponents", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_grammarComponents::
elementOf_GGS_M_grammarComponents (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_grammarComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_grammarComponents::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mNonterminalSymbolParametersMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mLexiqueName.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mOptionsMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_grammarComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_grammarComponents * ptr = dynamic_cast <const elementOf_GGS_M_grammarComponents *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mNonterminalSymbolParametersMap.operator_isEqual (ptr->mInfo.mNonterminalSymbolParametersMap)).boolValue ()
           && (mInfo.mLexiqueName.operator_isEqual (ptr->mInfo.mLexiqueName)).boolValue ()
           && (mInfo.mOptionsMap.operator_isEqual (ptr->mInfo.mOptionsMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_grammarComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_grammarComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_grammarComponents * info = (e_M_grammarComponents *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_grammarComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_grammarComponents * info = (e_M_grammarComponents *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_grammarComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_grammarComponents info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_grammarComponents::
operator_isEqual (const GGS_M_grammarComponents & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_grammarComponents::
operator_isNotEqual (const GGS_M_grammarComponents & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_nonterminalSymbolLabelMapForGrammarAnalysis & inParameter0,
                const GGS_lstring & inParameter1,
                const GGS_M_optionComponents & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_grammarComponents info  ;
    info.mNonterminalSymbolParametersMap = inParameter0 ;
    info.mLexiqueName = inParameter1 ;
    info.mOptionsMap = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_nonterminalSymbolLabelMapForGrammarAnalysis   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_M_optionComponents   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolParametersMap ;
    outParameter1 = node->mInfo.mLexiqueName ;
    outParameter2 = node->mInfo.mOptionsMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_grammarComponents::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('g'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_nonterminalSymbolLabelMapForGrammarAnalysis   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_M_optionComponents   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_grammarComponents::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('g'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_nonterminalSymbolLabelMapForGrammarAnalysis & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_M_optionComponents & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_grammarComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_grammarComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_grammarComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_grammarComponents::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_grammarComponents " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_nonterminalSymbolLabelMapForGrammarAnalysis  & GGS_M_grammarComponents::cEnumerator::_mNonterminalSymbolParametersMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mNonterminalSymbolParametersMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_M_grammarComponents::cEnumerator::_mLexiqueName (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mLexiqueName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_optionComponents  & GGS_M_grammarComponents::cEnumerator::_mOptionsMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mOptionsMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_grammarComponents::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_grammarComponents * p = NULL ;
    macroMyNew (p, GGS_M_grammarComponents (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_grammarComponents result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_grammarComponents * p = dynamic_cast <const GGS_M_grammarComponents *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_grammarComponents, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_grammarComponents::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_grammarComponents ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_M_semanticsComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_semanticsComponents::e_M_semanticsComponents (void) :
mModelMap (),
mActionMap (),
mImportedSemanticsComponents (),
mImportedMetamodelComponents (),
mImportedOptionsComponents (),
mOptionsComponents (),
mSemanticsEntitiesMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@M_semanticsComponents'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_semanticsComponents ("M_semanticsComponents", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_semanticsComponents::
elementOf_GGS_M_semanticsComponents (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_semanticsComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_semanticsComponents::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mModelMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mActionMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mImportedSemanticsComponents.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mImportedMetamodelComponents.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mImportedOptionsComponents.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mOptionsComponents.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mSemanticsEntitiesMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_semanticsComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_semanticsComponents * ptr = dynamic_cast <const elementOf_GGS_M_semanticsComponents *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mModelMap.operator_isEqual (ptr->mInfo.mModelMap)).boolValue ()
           && (mInfo.mActionMap.operator_isEqual (ptr->mInfo.mActionMap)).boolValue ()
           && (mInfo.mImportedSemanticsComponents.operator_isEqual (ptr->mInfo.mImportedSemanticsComponents)).boolValue ()
           && (mInfo.mImportedMetamodelComponents.operator_isEqual (ptr->mInfo.mImportedMetamodelComponents)).boolValue ()
           && (mInfo.mImportedOptionsComponents.operator_isEqual (ptr->mInfo.mImportedOptionsComponents)).boolValue ()
           && (mInfo.mOptionsComponents.operator_isEqual (ptr->mInfo.mOptionsComponents)).boolValue ()
           && (mInfo.mSemanticsEntitiesMap.operator_isEqual (ptr->mInfo.mSemanticsEntitiesMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_semanticsComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_semanticsComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_semanticsComponents * info = (e_M_semanticsComponents *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_semanticsComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_semanticsComponents * info = (e_M_semanticsComponents *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_semanticsComponents info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_semanticsComponents::
operator_isEqual (const GGS_M_semanticsComponents & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_semanticsComponents::
operator_isNotEqual (const GGS_M_semanticsComponents & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_ModelMap & inParameter0,
                const GGS_ActionMap & inParameter1,
                const GGS_stringset & inParameter2,
                const GGS_stringset & inParameter3,
                const GGS_stringset & inParameter4,
                const GGS_M_optionComponents & inParameter5,
                const GGS_M_semanticsEntitiesForUse & inParameter6,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inParameter5.isBuilt ()
   && inParameter6.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_semanticsComponents info  ;
    info.mModelMap = inParameter0 ;
    info.mActionMap = inParameter1 ;
    info.mImportedSemanticsComponents = inParameter2 ;
    info.mImportedMetamodelComponents = inParameter3 ;
    info.mImportedOptionsComponents = inParameter4 ;
    info.mOptionsComponents = inParameter5 ;
    info.mSemanticsEntitiesMap = inParameter6 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_ModelMap   & outParameter0,
               GGS_ActionMap   & outParameter1,
               GGS_stringset   & outParameter2,
               GGS_stringset   & outParameter3,
               GGS_stringset   & outParameter4,
               GGS_M_optionComponents   & outParameter5,
               GGS_M_semanticsEntitiesForUse   & outParameter6,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    outParameter4.drop () ;
    outParameter5.drop () ;
    outParameter6.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mModelMap ;
    outParameter1 = node->mInfo.mActionMap ;
    outParameter2 = node->mInfo.mImportedSemanticsComponents ;
    outParameter3 = node->mInfo.mImportedMetamodelComponents ;
    outParameter4 = node->mInfo.mImportedOptionsComponents ;
    outParameter5 = node->mInfo.mOptionsComponents ;
    outParameter6 = node->mInfo.mSemanticsEntitiesMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_semanticsComponents::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_ModelMap   & outParameter0,
                                GGS_ActionMap   & outParameter1,
                                GGS_stringset   & outParameter2,
                                GGS_stringset   & outParameter3,
                                GGS_stringset   & outParameter4,
                                GGS_M_optionComponents   & outParameter5,
                                GGS_M_semanticsEntitiesForUse   & outParameter6 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  outParameter5,
                  outParameter6,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_semanticsComponents::kInsertMessage_insertKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_ModelMap & inParameter0,
                                const GGS_ActionMap & inParameter1,
                                const GGS_stringset & inParameter2,
                                const GGS_stringset & inParameter3,
                                const GGS_stringset & inParameter4,
                                const GGS_M_optionComponents & inParameter5,
                                const GGS_M_semanticsEntitiesForUse & inParameter6 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_semanticsComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_semanticsComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_semanticsComponents::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_semanticsComponents " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_ModelMap  & GGS_M_semanticsComponents::cEnumerator::_mModelMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mModelMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_ActionMap  & GGS_M_semanticsComponents::cEnumerator::_mActionMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mActionMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_stringset  & GGS_M_semanticsComponents::cEnumerator::_mImportedSemanticsComponents (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mImportedSemanticsComponents ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_stringset  & GGS_M_semanticsComponents::cEnumerator::_mImportedMetamodelComponents (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mImportedMetamodelComponents ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_stringset  & GGS_M_semanticsComponents::cEnumerator::_mImportedOptionsComponents (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mImportedOptionsComponents ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_optionComponents  & GGS_M_semanticsComponents::cEnumerator::_mOptionsComponents (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mOptionsComponents ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_semanticsEntitiesForUse  & GGS_M_semanticsComponents::cEnumerator::_mSemanticsEntitiesMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSemanticsEntitiesMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_semanticsComponents::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_semanticsComponents * p = NULL ;
    macroMyNew (p, GGS_M_semanticsComponents (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_semanticsComponents result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_semanticsComponents * p = dynamic_cast <const GGS_M_semanticsComponents *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_semanticsComponents, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_semanticsComponents::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_semanticsComponents ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_M_regularFiles'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_regularFiles::e_M_regularFiles (void) :
mWrapperDirectoryIndex (),
mWrapperFileIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@M_regularFiles'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_regularFiles ("M_regularFiles", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_regularFiles::
elementOf_GGS_M_regularFiles (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_regularFiles & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_regularFiles::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mWrapperDirectoryIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mWrapperFileIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_regularFiles::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_regularFiles * ptr = dynamic_cast <const elementOf_GGS_M_regularFiles *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mWrapperDirectoryIndex.operator_isEqual (ptr->mInfo.mWrapperDirectoryIndex)).boolValue ()
           && (mInfo.mWrapperFileIndex.operator_isEqual (ptr->mInfo.mWrapperFileIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_regularFiles::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_regularFiles *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_regularFiles * info = (e_M_regularFiles *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_regularFiles *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_regularFiles * info = (e_M_regularFiles *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_regularFiles GGS_M_regularFiles::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_regularFiles result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_regularFiles info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_regularFiles::
operator_isEqual (const GGS_M_regularFiles & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_regularFiles::
operator_isNotEqual (const GGS_M_regularFiles & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                const GGS_uint & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_regularFiles info  ;
    info.mWrapperDirectoryIndex = inParameter0 ;
    info.mWrapperFileIndex = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_uint   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mWrapperDirectoryIndex ;
    outParameter1 = node->mInfo.mWrapperFileIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_regularFiles::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('g'),
  TO_UNICODE ('u'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_uint   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_regularFiles::kInsertMessage_insertKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('g'),
  TO_UNICODE ('u'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_uint & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_regularFiles GGS_M_regularFiles::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_regularFiles & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_regularFiles result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_regularFiles GGS_M_regularFiles::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_regularFiles result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_regularFiles::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_regularFiles " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_regularFiles::cEnumerator::_mWrapperDirectoryIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mWrapperDirectoryIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_regularFiles::cEnumerator::_mWrapperFileIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mWrapperFileIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_regularFiles::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_regularFiles * p = NULL ;
    macroMyNew (p, GGS_M_regularFiles (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_regularFiles GGS_M_regularFiles::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_regularFiles result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_regularFiles * p = dynamic_cast <const GGS_M_regularFiles *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_regularFiles, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_regularFiles::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_regularFiles ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_filewrapperTemplateMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

e_filewrapperTemplateMap::e_filewrapperTemplateMap (void) :
mFormalAttributeList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@filewrapperTemplateMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperTemplateMap ("filewrapperTemplateMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperTemplateMap::
elementOf_GGS_filewrapperTemplateMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_filewrapperTemplateMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperTemplateMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFormalAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperTemplateMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_filewrapperTemplateMap * ptr = dynamic_cast <const elementOf_GGS_filewrapperTemplateMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFormalAttributeList.operator_isEqual (ptr->mInfo.mFormalAttributeList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_filewrapperTemplateMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_filewrapperTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_filewrapperTemplateMap * info = (e_filewrapperTemplateMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_filewrapperTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_filewrapperTemplateMap * info = (e_filewrapperTemplateMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_filewrapperTemplateMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperTemplateMap::
operator_isEqual (const GGS_filewrapperTemplateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperTemplateMap::
operator_isNotEqual (const GGS_filewrapperTemplateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeListeAttributsSemantiques & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_filewrapperTemplateMap info  ;
    info.mFormalAttributeList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalAttributeList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperTemplateMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperTemplateMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_filewrapperTemplateMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperTemplateMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @filewrapperTemplateMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeAttributsSemantiques  & GGS_filewrapperTemplateMap::cEnumerator::_mFormalAttributeList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFormalAttributeList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperTemplateMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperTemplateMap * p = NULL ;
    macroMyNew (p, GGS_filewrapperTemplateMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperTemplateMap * p = dynamic_cast <const GGS_filewrapperTemplateMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperTemplateMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperTemplateMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperTemplateMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_M_filewrappers'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_filewrappers::e_M_filewrappers (void) :
mRegularFileMap (),
mTemplateMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@M_filewrappers'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_filewrappers ("M_filewrappers", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_filewrappers::
elementOf_GGS_M_filewrappers (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_filewrappers & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_filewrappers::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mRegularFileMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mTemplateMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_filewrappers::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_filewrappers * ptr = dynamic_cast <const elementOf_GGS_M_filewrappers *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mRegularFileMap.operator_isEqual (ptr->mInfo.mRegularFileMap)).boolValue ()
           && (mInfo.mTemplateMap.operator_isEqual (ptr->mInfo.mTemplateMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_filewrappers::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_filewrappers *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_filewrappers * info = (e_M_filewrappers *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_filewrappers *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_filewrappers * info = (e_M_filewrappers *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_filewrappers GGS_M_filewrappers::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_filewrappers result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_filewrappers info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_filewrappers::
operator_isEqual (const GGS_M_filewrappers & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_filewrappers::
operator_isNotEqual (const GGS_M_filewrappers & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_regularFiles & inParameter0,
                const GGS_filewrapperTemplateMap & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_filewrappers info  ;
    info.mRegularFileMap = inParameter0 ;
    info.mTemplateMap = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_regularFiles   & outParameter0,
               GGS_filewrapperTemplateMap   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mRegularFileMap ;
    outParameter1 = node->mInfo.mTemplateMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_filewrappers::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_regularFiles   & outParameter0,
                                GGS_filewrapperTemplateMap   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_filewrappers::kInsertMessage_insertKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_regularFiles & inParameter0,
                                const GGS_filewrapperTemplateMap & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_filewrappers GGS_M_filewrappers::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_filewrappers & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_filewrappers result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_filewrappers GGS_M_filewrappers::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_filewrappers result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_filewrappers::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_filewrappers " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_regularFiles  & GGS_M_filewrappers::cEnumerator::_mRegularFileMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRegularFileMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_filewrapperTemplateMap  & GGS_M_filewrappers::cEnumerator::_mTemplateMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTemplateMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_filewrappers::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_filewrappers * p = NULL ;
    macroMyNew (p, GGS_M_filewrappers (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_filewrappers GGS_M_filewrappers::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_filewrappers result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_filewrappers * p = dynamic_cast <const GGS_M_filewrappers *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_filewrappers, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_filewrappers::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_filewrappers ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@labelForPopUpList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_labelForPopUpList::
elementOf_GGS_labelForPopUpList (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mTerminal1 (argument_0),
mTerminal1ID (argument_1),
mTerminal2 (argument_2),
mTerminal2ID (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_labelForPopUpList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_labelForPopUpList * ptr = dynamic_cast <const elementOf_GGS_labelForPopUpList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTerminal1.operator_isEqual (ptr->mTerminal1).boolValue ()
         && mTerminal1ID.operator_isEqual (ptr->mTerminal1ID).boolValue ()
         && mTerminal2.operator_isEqual (ptr->mTerminal2).boolValue ()
         && mTerminal2ID.operator_isEqual (ptr->mTerminal2ID).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_labelForPopUpList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminal1.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminal1ID.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminal2.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminal2ID.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@labelForPopUpList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_labelForPopUpList ("labelForPopUpList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_uint & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_uint & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_uint & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_labelForPopUpList GGS_labelForPopUpList::
operator_concat (const GGS_labelForPopUpList & inOperand) const {
  GGS_labelForPopUpList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
dotAssign_operation (const GGS_labelForPopUpList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_labelForPopUpList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTerminal1 ;
          GGS_uint  p_1 = p->mTerminal1ID ;
          GGS_lstring  p_2 = p->mTerminal2 ;
          GGS_uint  p_3 = p->mTerminal2ID ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_uint & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_uint & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mTerminal1,
                                ptr->mTerminal1ID,
                                ptr->mTerminal2,
                                ptr->mTerminal2ID
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_labelForPopUpList  GGS_labelForPopUpList::
constructor_emptyList (void) {
  GGS_labelForPopUpList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_labelForPopUpList  GGS_labelForPopUpList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_uint & argument_3) {
  GGS_labelForPopUpList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
internalSubListWithRange (GGS_labelForPopUpList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mTerminal1, ptr->mTerminal1ID, ptr->mTerminal2, ptr->mTerminal2ID) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_labelForPopUpList GGS_labelForPopUpList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_labelForPopUpList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_labelForPopUpList GGS_labelForPopUpList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_labelForPopUpList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_labelForPopUpList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@labelForPopUpList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_uint & _out_1,
              GGS_lstring & _out_2,
              GGS_uint & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTerminal1 ;
    _out_1 = ptr->mTerminal1ID ;
    _out_2 = ptr->mTerminal2 ;
    _out_3 = ptr->mTerminal2ID ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_uint & _out_1,
             GGS_lstring & _out_2,
             GGS_uint & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTerminal1 ;
    _out_1 = ptr->mTerminal1ID ;
    _out_2 = ptr->mTerminal2 ;
    _out_3 = ptr->mTerminal2ID ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_uint & _out_1,
                 GGS_lstring & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTerminal1 ;
    _out_1 = ptr->mTerminal1ID ;
    _out_2 = ptr->mTerminal2 ;
    _out_3 = ptr->mTerminal2ID ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_uint & _out_1,
                GGS_lstring & _out_2,
                GGS_uint & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTerminal1 ;
    _out_1 = ptr->mTerminal1ID ;
    _out_2 = ptr->mTerminal2 ;
    _out_3 = ptr->mTerminal2ID ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_labelForPopUpList::
reader_mTerminal1AtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTerminal1 ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_labelForPopUpList::
reader_mTerminal1IDAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTerminal1ID ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_labelForPopUpList::
reader_mTerminal2AtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTerminal2 ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_labelForPopUpList::
reader_mTerminal2IDAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTerminal2ID ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
modifier_setMTerminal1AtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTerminal1 = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
modifier_setMTerminal1IDAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTerminal1ID = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
modifier_setMTerminal2AtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTerminal2 = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
modifier_setMTerminal2IDAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTerminal2ID = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_labelForPopUpList::cEnumerator::_mTerminal1 (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTerminal1 ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_labelForPopUpList::cEnumerator::_mTerminal1ID (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTerminal1ID ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_labelForPopUpList::cEnumerator::_mTerminal2 (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTerminal2 ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_labelForPopUpList::cEnumerator::_mTerminal2ID (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTerminal2ID ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_labelForPopUpList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_labelForPopUpList * p = NULL ;
    macroMyNew (p, GGS_labelForPopUpList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_labelForPopUpList GGS_labelForPopUpList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_labelForPopUpList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_labelForPopUpList * p = dynamic_cast <const GGS_labelForPopUpList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_labelForPopUpList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_labelForPopUpList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_labelForPopUpList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@EXtextMacroList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_EXtextMacroList::
elementOf_GGS_EXtextMacroList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mKey (argument_0),
mContents (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_EXtextMacroList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_EXtextMacroList * ptr = dynamic_cast <const elementOf_GGS_EXtextMacroList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mKey.operator_isEqual (ptr->mKey).boolValue ()
         && mContents.operator_isEqual (ptr->mContents).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_EXtextMacroList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mKey.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mContents.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@EXtextMacroList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EXtextMacroList ("EXtextMacroList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_EXtextMacroList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_EXtextMacroList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_EXtextMacroList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_EXtextMacroList GGS_EXtextMacroList::
operator_concat (const GGS_EXtextMacroList & inOperand) const {
  GGS_EXtextMacroList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXtextMacroList::
dotAssign_operation (const GGS_EXtextMacroList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_EXtextMacroList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mKey ;
          GGS_lstring  p_1 = p->mContents ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_EXtextMacroList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXtextMacroList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mKey,
                                ptr->mContents
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_EXtextMacroList  GGS_EXtextMacroList::
constructor_emptyList (void) {
  GGS_EXtextMacroList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXtextMacroList  GGS_EXtextMacroList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_EXtextMacroList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXtextMacroList::
internalSubListWithRange (GGS_EXtextMacroList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mKey, ptr->mContents) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_EXtextMacroList GGS_EXtextMacroList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_EXtextMacroList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXtextMacroList GGS_EXtextMacroList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_EXtextMacroList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXtextMacroList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@EXtextMacroList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_EXtextMacroList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mKey ;
    _out_1 = ptr->mContents ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXtextMacroList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mKey ;
    _out_1 = ptr->mContents ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXtextMacroList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mKey ;
    _out_1 = ptr->mContents ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXtextMacroList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mKey ;
    _out_1 = ptr->mContents ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_EXtextMacroList::
reader_mKeyAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mKey ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_EXtextMacroList::
reader_mContentsAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mContents ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXtextMacroList::
modifier_setMKeyAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mKey = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_EXtextMacroList::
modifier_setMContentsAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mContents = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_EXtextMacroList::cEnumerator::_mKey (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mKey ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_EXtextMacroList::cEnumerator::_mContents (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mContents ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_EXtextMacroList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EXtextMacroList * p = NULL ;
    macroMyNew (p, GGS_EXtextMacroList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXtextMacroList GGS_EXtextMacroList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EXtextMacroList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EXtextMacroList * p = dynamic_cast <const GGS_EXtextMacroList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EXtextMacroList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EXtextMacroList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EXtextMacroList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_EXreaderMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_EXreaderMap::e_EXreaderMap (void) :
mAccessorTypesList (),
mReturnedType (),
mHasLexiqueAndLocationArguments () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@EXreaderMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EXreaderMap ("EXreaderMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_EXreaderMap::
elementOf_GGS_EXreaderMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_EXreaderMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_EXreaderMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAccessorTypesList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReturnedType.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasLexiqueAndLocationArguments.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_EXreaderMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_EXreaderMap * ptr = dynamic_cast <const elementOf_GGS_EXreaderMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mAccessorTypesList.operator_isEqual (ptr->mInfo.mAccessorTypesList)).boolValue ()
           && (mInfo.mReturnedType.operator_isEqual (ptr->mInfo.mReturnedType)).boolValue ()
           && (mInfo.mHasLexiqueAndLocationArguments.operator_isEqual (ptr->mInfo.mHasLexiqueAndLocationArguments)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_EXreaderMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_EXreaderMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_EXreaderMap * info = (e_EXreaderMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_EXreaderMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_EXreaderMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_EXreaderMap * info = (e_EXreaderMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_EXreaderMap GGS_EXreaderMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXreaderMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXreaderMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_EXreaderMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXreaderMap::
operator_isEqual (const GGS_EXreaderMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXreaderMap::
operator_isNotEqual (const GGS_EXreaderMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_EXreaderMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_EXreaderMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeListeAttributsSemantiques & inParameter0,
                const GGS_AC_galgasType & inParameter1,
                const GGS_bool& inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_EXreaderMap info  ;
    info.mAccessorTypesList = inParameter0 ;
    info.mReturnedType = inParameter1 ;
    info.mHasLexiqueAndLocationArguments = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXreaderMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_bool  & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mAccessorTypesList ;
    outParameter1 = node->mInfo.mReturnedType ;
    outParameter2 = node->mInfo.mHasLexiqueAndLocationArguments ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXreaderMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXreaderMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0,
                                GGS_AC_galgasType   & outParameter1,
                                GGS_bool  & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXreaderMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXreaderMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0,
                                const GGS_AC_galgasType & inParameter1,
                                const GGS_bool& inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_EXreaderMap GGS_EXreaderMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_EXreaderMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXreaderMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXreaderMap GGS_EXreaderMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_EXreaderMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXreaderMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @EXreaderMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeAttributsSemantiques  & GGS_EXreaderMap::cEnumerator::_mAccessorTypesList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAccessorTypesList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_EXreaderMap::cEnumerator::_mReturnedType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReturnedType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_EXreaderMap::cEnumerator::_mHasLexiqueAndLocationArguments (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasLexiqueAndLocationArguments ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_EXreaderMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EXreaderMap * p = NULL ;
    macroMyNew (p, GGS_EXreaderMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXreaderMap GGS_EXreaderMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EXreaderMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EXreaderMap * p = dynamic_cast <const GGS_EXreaderMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EXreaderMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EXreaderMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EXreaderMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "EXenterReaderWithoutArgument"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_EXenterReaderWithoutArgument (C_Compiler & inLexique,
                                GGS_EXreaderMap  & var_cas_ioReaderMap,
                                const GGS_string  var_cas_inName,
                                const GGS_AC_galgasType   var_cas_inReturnedType,
                                const GGS_bool  var_cas_inHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_EXenterReaderWithoutArgument at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioReaderMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inName, GGS_location (inLexique) COMMA_HERE), GGS_typeListeAttributsSemantiques ::constructor_emptyList (), var_cas_inReturnedType, var_cas_inHasLexiqueAndLocationArguments COMMA_SOURCE_FILE_AT_LINE (3914)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_EXenterReaderWithoutArgument\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of routine "EXenterReaderWithStringArgument"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_EXenterReaderWithStringArgument (C_Compiler & inLexique,
                                GGS_EXreaderMap  & var_cas_ioReaderMap,
                                const GGS_string  var_cas_inName,
                                const GGS_AC_galgasType   var_cas_inReturnedType,
                                const GGS_bool  var_cas_inHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_EXenterReaderWithStringArgument at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeListeAttributsSemantiques  var_cas_argList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_argList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_ioReaderMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inName, GGS_location (inLexique) COMMA_HERE), var_cas_argList, var_cas_inReturnedType, var_cas_inHasLexiqueAndLocationArguments COMMA_SOURCE_FILE_AT_LINE (3932)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_EXenterReaderWithStringArgument\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "EXenterReaderWith2StringArguments"        *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_EXenterReaderWith2StringArguments (C_Compiler & inLexique,
                                GGS_EXreaderMap  & var_cas_ioReaderMap,
                                const GGS_string  var_cas_inName,
                                const GGS_AC_galgasType   var_cas_inReturnedType,
                                const GGS_bool  var_cas_inHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_EXenterReaderWith2StringArguments at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeListeAttributsSemantiques  var_cas_argList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_argList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_argList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_ioReaderMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inName, GGS_location (inLexique) COMMA_HERE), var_cas_argList, var_cas_inReturnedType, var_cas_inHasLexiqueAndLocationArguments COMMA_SOURCE_FILE_AT_LINE (3951)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_EXenterReaderWith2StringArguments\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "EXenterReaderWithBoolArgument"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_EXenterReaderWithBoolArgument (C_Compiler & inLexique,
                                GGS_EXreaderMap  & var_cas_ioReaderMap,
                                const GGS_string  var_cas_inName,
                                const GGS_AC_galgasType   var_cas_inReturnedType,
                                const GGS_bool  var_cas_inHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_EXenterReaderWithBoolArgument at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeListeAttributsSemantiques  var_cas_argList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_argList.addAssign_operation (GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_ioReaderMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inName, GGS_location (inLexique) COMMA_HERE), var_cas_argList, var_cas_inReturnedType, var_cas_inHasLexiqueAndLocationArguments COMMA_SOURCE_FILE_AT_LINE (3969)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_EXenterReaderWithBoolArgument\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Implementation of routine "EXenterReaderWithBoolStringlistArguments"    *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_EXenterReaderWithBoolStringlistArguments (C_Compiler & inLexique,
                                GGS_EXreaderMap  & var_cas_ioReaderMap,
                                const GGS_string  var_cas_inName,
                                const GGS_AC_galgasType   var_cas_inReturnedType,
                                const GGS_bool  var_cas_inHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_EXenterReaderWithBoolStringlistArguments at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeListeAttributsSemantiques  var_cas_argList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_argList.addAssign_operation (GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_argList.addAssign_operation (function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (3987)), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_ioReaderMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inName, GGS_location (inLexique) COMMA_HERE), var_cas_argList, var_cas_inReturnedType, var_cas_inHasLexiqueAndLocationArguments COMMA_SOURCE_FILE_AT_LINE (3988)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_EXenterReaderWithBoolStringlistArguments\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "EXenterReaderWithUintArgument"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_EXenterReaderWithUintArgument (C_Compiler & inLexique,
                                GGS_EXreaderMap  & var_cas_ioReaderMap,
                                const GGS_string  var_cas_inName,
                                const GGS_AC_galgasType   var_cas_inReturnedType,
                                const GGS_bool  var_cas_inHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_EXenterReaderWithUintArgument at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeListeAttributsSemantiques  var_cas_argList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_argList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_ioReaderMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inName, GGS_location (inLexique) COMMA_HERE), var_cas_argList, var_cas_inReturnedType, var_cas_inHasLexiqueAndLocationArguments COMMA_SOURCE_FILE_AT_LINE (4006)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_EXenterReaderWithUintArgument\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "enterReaderWith2UintArguments"          *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterReaderWith2UintArguments (C_Compiler & inLexique,
                                GGS_EXreaderMap  & var_cas_ioReaderMap,
                                const GGS_string  var_cas_inName,
                                const GGS_AC_galgasType   var_cas_inReturnedType,
                                const GGS_bool  var_cas_inHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_enterReaderWith2UintArguments at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeListeAttributsSemantiques  var_cas_argList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_argList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_argList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_ioReaderMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inName, GGS_location (inLexique) COMMA_HERE), var_cas_argList, var_cas_inReturnedType, var_cas_inHasLexiqueAndLocationArguments COMMA_SOURCE_FILE_AT_LINE (4025)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_enterReaderWith2UintArguments\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "EXenterReaderWithUintCharArguments"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_EXenterReaderWithUintCharArguments (C_Compiler & inLexique,
                                GGS_EXreaderMap  & var_cas_ioReaderMap,
                                const GGS_string  var_cas_inName,
                                const GGS_AC_galgasType   var_cas_inReturnedType,
                                const GGS_bool  var_cas_inHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_EXenterReaderWithUintCharArguments at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeListeAttributsSemantiques  var_cas_argList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_argList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_argList.addAssign_operation (GGS_typeGalgas_char ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_ioReaderMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inName, GGS_location (inLexique) COMMA_HERE), var_cas_argList, var_cas_inReturnedType, var_cas_inHasLexiqueAndLocationArguments COMMA_SOURCE_FILE_AT_LINE (4044)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_EXenterReaderWithUintCharArguments\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of once function "stringReaderMap"              *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_EXreaderMap  gCachedResultForOnceFunction_stringReaderMap ;
static bool gCacheFlagForOnceFunction_stringReaderMap = false ;

//---------------------------------------------------------------------------*

GGS_EXreaderMap  function_stringReaderMap (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_stringReaderMap) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_stringReaderMap at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_EXreaderMap  var_cas_outMap ;
    var_cas_outMap = GGS_EXreaderMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("description"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4060)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("object"),  GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4061)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("dynamicType"),  GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4062)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("doesEnvironmentVariableExist"),  GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4063)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("length"),  GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4064)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("identifierRepresentation"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4065)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("HTMLRepresentation"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4066)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("utf8Representation"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4067)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("utf32Representation"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4068)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("stringByTrimmingWhiteSpaces"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4069)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("md5"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4070)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("decimalUnsignedNumber"),  GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (4071)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("isDecimalUnsignedNumber"),  GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4072)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("capacity"),  GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4073)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("fileExists"),  GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4074)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("directoryExists"),  GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4075)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("pathExtension"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4076)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("nativePathWithUnixPath"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4077)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("unixPathWithNativePath"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4078)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("lastPathComponent"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4079)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("stringByDeletingPathExtension"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4080)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("stringByCapitalizingFirstCharacter"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4081)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("firstCharacterOrNul"),  GGS_typeGalgas_char ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4082)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("stringByDeletingLastPathComponent"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4083)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("stringByStandardizingPath"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4084)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("lowercaseString"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4085)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("uppercaseString"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4086)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("reversedString"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4087)) ;
    ::routine_EXenterReaderWithoutArgument (inLexique,  var_cas_outMap,  GGS_string ("system"),  GGS_typeGalgas_sint ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4088)) ;
    ::routine_EXenterReaderWithUintArgument (inLexique,  var_cas_outMap,  GGS_string ("characterAtIndex"),  GGS_typeGalgas_char ::constructor_new (inLexique COMMA_HERE),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (4089)) ;
    ::routine_EXenterReaderWithUintArgument (inLexique,  var_cas_outMap,  GGS_string ("stringByRemovingCharacterAtIndex"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (4090)) ;
    ::routine_EXenterReaderWithUintArgument (inLexique,  var_cas_outMap,  GGS_string ("rightSubString"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4091)) ;
    ::routine_EXenterReaderWithUintArgument (inLexique,  var_cas_outMap,  GGS_string ("leftSubString"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4092)) ;
    ::routine_enterReaderWith2UintArguments (inLexique,  var_cas_outMap,  GGS_string ("subString"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4093)) ;
    ::routine_EXenterReaderWithStringArgument (inLexique,  var_cas_outMap,  GGS_string ("absolutePathFromPath"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4094)) ;
    ::routine_EXenterReaderWithStringArgument (inLexique,  var_cas_outMap,  GGS_string ("relativePathFromPath"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4095)) ;
    ::routine_EXenterReaderWithStringArgument (inLexique,  var_cas_outMap,  GGS_string ("componentsSeparatedByString"),  function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4096)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4096)) ;
    ::routine_EXenterReaderWithUintCharArguments (inLexique,  var_cas_outMap,  GGS_string ("stringByLeftPadding"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4097)) ;
    ::routine_EXenterReaderWithUintCharArguments (inLexique,  var_cas_outMap,  GGS_string ("stringByRightPadding"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4098)) ;
    ::routine_EXenterReaderWithUintCharArguments (inLexique,  var_cas_outMap,  GGS_string ("stringByLeftAndRightPadding"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4099)) ;
    ::routine_EXenterReaderWith2StringArguments (inLexique,  var_cas_outMap,  GGS_string ("stringByReplacingStringByString"),  GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (4100)) ;
    ::routine_EXenterReaderWithBoolArgument (inLexique,  var_cas_outMap,  GGS_string ("regularFiles"),  function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4101)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4101)) ;
    ::routine_EXenterReaderWithBoolArgument (inLexique,  var_cas_outMap,  GGS_string ("hiddenFiles"),  function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4102)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4102)) ;
    ::routine_EXenterReaderWithBoolArgument (inLexique,  var_cas_outMap,  GGS_string ("directories"),  function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4103)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4103)) ;
    ::routine_EXenterReaderWithBoolStringlistArguments (inLexique,  var_cas_outMap,  GGS_string ("directoriesWithExtensions"),  function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4104)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4104)) ;
    ::routine_EXenterReaderWithBoolStringlistArguments (inLexique,  var_cas_outMap,  GGS_string ("regularFilesWithExtensions"),  function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4105)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (4105)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_stringReaderMap\n") ;
    #endif
    gCacheFlagForOnceFunction_stringReaderMap = true ;
    gCachedResultForOnceFunction_stringReaderMap = var_cas_outMap ;
  }
  return gCachedResultForOnceFunction_stringReaderMap ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_stringReaderMap (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_EXreaderMap  result = function_stringReaderMap (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptor kFunction_descriptor_stringReaderMap ("stringReaderMap",
                              functionForGenericCall_stringReaderMap,
                              & kTypeDescriptor_GGS_EXreaderMap ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "handleStringReaderCall"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleStringReaderCall (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inReaderName,
                                GGS_typeListeAttributsSemantiques  & var_cas_outAccessorTypesList,
                                GGS_AC_galgasType  & var_cas_outReturnedType,
                                GGS_bool & var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_handleStringReaderCall at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_EXreaderMap  temp_176280 = function_stringReaderMap (inLexique COMMA_SOURCE_FILE_AT_LINE (4116)) ;
  if (temp_176280.isBuilt ()) {
    temp_176280 (HERE)->method_searchKey (inLexique, var_cas_inReaderName, var_cas_outAccessorTypesList, var_cas_outReturnedType, var_cas_outHasLexiqueAndLocationArguments COMMA_SOURCE_FILE_AT_LINE (4116)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_handleStringReaderCall\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of routine "handleReaderCall"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleReaderCall (C_Compiler & inLexique,
                                const GGS_M_semanticsEntitiesForUse   var_cas_ioEntitiesMap,
                                const GGS_EXcategoryReaderMap   var_cas_inCategoryReaderMap,
                                const GGS_AC_galgasType   var_cas_inReceiverType,
                                const GGS_lstring   var_cas_inReaderName,
                                GGS_typeListeAttributsSemantiques  & var_cas_outAccessorTypesList,
                                GGS_AC_galgasType  & var_cas_outReturnedType,
                                GGS_string & var_cas_outCppConversionMethod,
                                GGS_string & var_cas_outCategoryReaderClassBaseName,
                                GGS_bool & var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_handleReaderCall at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true) ;
  var_cas_outCppConversionMethod = GGS_string ("") ;
  var_cas_outCategoryReaderClassBaseName = GGS_string ("") ;
  { const GGS_AC_galgasType _var_245063 = var_cas_inReceiverType ; // CAST instruction
    if (_var_245063.getPtr () != NULL) {
      macroValidPointer (_var_245063.getPtr ()) ;
      if (dynamic_cast <cPtr_typeGalgasDomainType *> (_var_245063.getPtr ()) != NULL) {
        const GGS_typeGalgasDomainType var_cas_t (_var_245063.getPtr ()) ;
        const GGS_bool cond_177661 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4147))).operator_isEqual (GGS_string ("description")) ;
        if (cond_177661.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_177661.isBuiltAndFalse ()) {
          const GGS_bool cond_177888 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4151))).operator_isEqual (GGS_string ("object")) ;
          if (cond_177888.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_177888.isBuiltAndFalse ()) {
            const GGS_bool cond_178117 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4155))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_178117.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_178117.isBuiltAndFalse ()) {
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outReturnedType = function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4161)) ;
              GGS_bool var_cas_found = GGS_bool (false) ;
              GGS_string var_cas_s = GGS_string ("") ;
              {
                GGS_domainRelationMap::cEnumerator enumerator_178327 (var_cas_t.reader_mDomainRelationMap (inLexique COMMA_SOURCE_FILE_AT_LINE (4164)), true) ;
                const GGS_domainRelationMap::cElement * operand_178327 = NULL ;
                while (((operand_178327 = enumerator_178327.nextObject ()))
                    && ((var_cas_found).operator_not ().isBuiltAndTrue ())) {
                  macroValidPointer (operand_178327) ;
                  const GGS_bool cond_178615 = (operand_178327->mInfo.mDomains.reader_length ()).operator_isEqual (GGS_uint (1U)) ;
                  if (cond_178615.isBuiltAndTrue ()) {
                    var_cas_s.appendCString (" ") ;
                    var_cas_s.dotAssign_operation (operand_178327->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4166))) ;
                    var_cas_s.appendCString ("StringValueList") ;
                    var_cas_found = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4167))).operator_isEqual ((operand_178327->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4167))).operator_concat (GGS_string ("StringValueList"))) ;
                    var_cas_outReturnedType = function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4168)) ;
                  }else if (cond_178615.isBuiltAndFalse ()) {
                    const GGS_bool cond_178853 = (operand_178327->mInfo.mDomains.reader_length ()).operator_isEqual (GGS_uint (2U)) ;
                    if (cond_178853.isBuiltAndTrue ()) {
                      var_cas_s.appendCString (" ") ;
                      var_cas_s.dotAssign_operation (operand_178327->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4170))) ;
                      var_cas_s.appendCString ("StringValueList") ;
                      var_cas_found = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4171))).operator_isEqual ((operand_178327->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4171))).operator_concat (GGS_string ("StringValueList"))) ;
                      var_cas_outReturnedType = function_EXbuild_string2list_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4172)) ;
                    }else if (cond_178853.isBuiltAndFalse ()) {
                      const GGS_bool cond_179089 = (operand_178327->mInfo.mDomains.reader_length ()).operator_isEqual (GGS_uint (3U)) ;
                      if (cond_179089.isBuiltAndTrue ()) {
                        var_cas_s.appendCString (" ") ;
                        var_cas_s.dotAssign_operation (operand_178327->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4174))) ;
                        var_cas_s.appendCString ("StringValueList") ;
                        var_cas_found = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4175))).operator_isEqual ((operand_178327->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4175))).operator_concat (GGS_string ("StringValueList"))) ;
                        var_cas_outReturnedType = function_EXbuild_string3list_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4176)) ;
                      }
                    }
                  }
                }
              }
              const GGS_bool cond_179226 = (var_cas_found).operator_not () ;
              if (cond_179226.isBuiltAndTrue ()) {
                var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("this domain accepts the following readers:")).operator_concat (var_cas_s) COMMA_SOURCE_FILE_AT_LINE (4181)) ;
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_filewrapper *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_179520 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4184))).operator_isEqual (GGS_string ("description")) ;
        if (cond_179520.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_179520.isBuiltAndFalse ()) {
          const GGS_bool cond_179747 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4188))).operator_isEqual (GGS_string ("object")) ;
          if (cond_179747.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_179747.isBuiltAndFalse ()) {
            const GGS_bool cond_179977 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4192))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_179977.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_179977.isBuiltAndFalse ()) {
              const GGS_bool cond_180162 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4196))).operator_isEqual (GGS_string ("allFilePathes")) ;
              if (cond_180162.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4198)) ;
              }else if (cond_180162.isBuiltAndFalse ()) {
                const GGS_bool cond_180352 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4199))).operator_isEqual (GGS_string ("allDirectoryPathes")) ;
                if (cond_180352.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4201)) ;
                }else if (cond_180352.isBuiltAndFalse ()) {
                  const GGS_bool cond_180538 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4202))).operator_isEqual (GGS_string ("currentDirectory")) ;
                  if (cond_180538.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_180538.isBuiltAndFalse ()) {
                    const GGS_bool cond_180811 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4205))).operator_isEqual (GGS_string ("directoryExistsAtPath")) ;
                    if (cond_180811.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                      var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_180811.isBuiltAndFalse ()) {
                      const GGS_bool cond_181079 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4209))).operator_isEqual (GGS_string ("fileExistsAtPath")) ;
                      if (cond_181079.isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                        var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                      }else if (cond_181079.isBuiltAndFalse ()) {
                        const GGS_bool cond_181351 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4213))).operator_isEqual (GGS_string ("fileContentsAtPath")) ;
                        if (cond_181351.isBuiltAndTrue ()) {
                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                          var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                        }else if (cond_181351.isBuiltAndFalse ()) {
                          const GGS_bool cond_181623 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4217))).operator_isEqual (GGS_string ("absolutePathForPath")) ;
                          if (cond_181623.isBuiltAndTrue ()) {
                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                            var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                          }else if (cond_181623.isBuiltAndFalse ()) {
                            var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4224)) ;
                            var_cas_outAccessorTypesList.drop () ;
                            var_cas_outReturnedType.drop () ;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgasUndefinedMapindexType *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_182031 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4226))).operator_isEqual (GGS_string ("description")) ;
        if (cond_182031.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_182031.isBuiltAndFalse ()) {
          const GGS_bool cond_182258 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4230))).operator_isEqual (GGS_string ("object")) ;
          if (cond_182258.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_182258.isBuiltAndFalse ()) {
            const GGS_bool cond_182488 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4234))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_182488.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_182488.isBuiltAndFalse ()) {
              const GGS_bool cond_182665 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4238))).operator_isEqual (GGS_string ("isRegular")) ;
              if (cond_182665.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_182665.isBuiltAndFalse ()) {
                const GGS_bool cond_182839 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4241))).operator_isEqual (GGS_string ("isNull")) ;
                if (cond_182839.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_182839.isBuiltAndFalse ()) {
                  const GGS_bool cond_183013 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4244))).operator_isEqual (GGS_string ("key")) ;
                  if (cond_183013.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_lstring ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_183013.isBuiltAndFalse ()) {
                    const GGS_bool cond_183188 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4247))).operator_isEqual (GGS_string ("isSolved")) ;
                    if (cond_183188.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_183188.isBuiltAndFalse ()) {
                      var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4253)) ;
                      var_cas_outAccessorTypesList.drop () ;
                      var_cas_outReturnedType.drop () ;
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_string *> (_var_245063.getPtr ()) != NULL) {
        ::routine_handleStringReaderCall (inLexique,  var_cas_inReaderName,  var_cas_outAccessorTypesList,  var_cas_outReturnedType,  var_cas_outHasLexiqueAndLocationArguments COMMA_SOURCE_FILE_AT_LINE (4255)) ;
      }else if (dynamic_cast <cPtr_typeGalgas_lstring *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_183728 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4257))).operator_isEqual (GGS_string ("description")) ;
        if (cond_183728.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_183728.isBuiltAndFalse ()) {
          const GGS_bool cond_183955 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4261))).operator_isEqual (GGS_string ("object")) ;
          if (cond_183955.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_183955.isBuiltAndFalse ()) {
            const GGS_bool cond_184185 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4265))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_184185.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_184185.isBuiltAndFalse ()) {
              const GGS_bool cond_184361 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4269))).operator_isEqual (GGS_string ("string")) ;
              if (cond_184361.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_184361.isBuiltAndFalse ()) {
                const GGS_bool cond_184541 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4272))).operator_isEqual (GGS_string ("location")) ;
                if (cond_184541.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_184541.isBuiltAndFalse ()) {
                  const GGS_bool cond_184724 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4275))).operator_isEqual (GGS_string ("locationString")) ;
                  if (cond_184724.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_184724.isBuiltAndFalse ()) {
                    ::routine_handleStringReaderCall (inLexique,  var_cas_inReaderName,  var_cas_outAccessorTypesList,  var_cas_outReturnedType,  var_cas_outHasLexiqueAndLocationArguments COMMA_SOURCE_FILE_AT_LINE (4279)) ;
                    var_cas_outCppConversionMethod = GGS_string ("ggs_string") ;
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_location *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_185207 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4283))).operator_isEqual (GGS_string ("description")) ;
        if (cond_185207.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_185207.isBuiltAndFalse ()) {
          const GGS_bool cond_185434 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4287))).operator_isEqual (GGS_string ("object")) ;
          if (cond_185434.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_185434.isBuiltAndFalse ()) {
            const GGS_bool cond_185664 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4291))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_185664.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_185664.isBuiltAndFalse ()) {
              const GGS_bool cond_185848 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4295))).operator_isEqual (GGS_string ("locationString")) ;
              if (cond_185848.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_185848.isBuiltAndFalse ()) {
                const GGS_bool cond_186029 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4298))).operator_isEqual (GGS_string ("locationIndex")) ;
                if (cond_186029.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_186029.isBuiltAndFalse ()) {
                  const GGS_bool cond_186201 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4301))).operator_isEqual (GGS_string ("line")) ;
                  if (cond_186201.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_186201.isBuiltAndFalse ()) {
                    const GGS_bool cond_186374 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4304))).operator_isEqual (GGS_string ("column")) ;
                    if (cond_186374.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_186374.isBuiltAndFalse ()) {
                      var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4310)) ;
                      var_cas_outAccessorTypesList.drop () ;
                      var_cas_outReturnedType.drop () ;
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_binaryset *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_186767 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4312))).operator_isEqual (GGS_string ("description")) ;
        if (cond_186767.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_186767.isBuiltAndFalse ()) {
          const GGS_bool cond_186994 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4316))).operator_isEqual (GGS_string ("object")) ;
          if (cond_186994.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_186994.isBuiltAndFalse ()) {
            const GGS_bool cond_187224 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4320))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_187224.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_187224.isBuiltAndFalse ()) {
              const GGS_bool cond_187398 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4324))).operator_isEqual (GGS_string ("isFull")) ;
              if (cond_187398.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_187398.isBuiltAndFalse ()) {
                const GGS_bool cond_187573 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4327))).operator_isEqual (GGS_string ("isEmpty")) ;
                if (cond_187573.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_187573.isBuiltAndFalse ()) {
                  const GGS_bool cond_187765 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4330))).operator_isEqual (GGS_string ("significantVariableCount")) ;
                  if (cond_187765.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_187765.isBuiltAndFalse ()) {
                    const GGS_bool cond_188076 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4333))).operator_isEqual (GGS_string ("ITE")) ;
                    if (cond_188076.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outAccessorTypesList.addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                      var_cas_outAccessorTypesList.addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                      var_cas_outReturnedType = var_cas_inReceiverType ;
                    }else if (cond_188076.isBuiltAndFalse ()) {
                      const GGS_bool cond_188334 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4338))).operator_isEqual (GGS_string ("forAllOnBitIndex")) ;
                      if (cond_188334.isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                        var_cas_outReturnedType = var_cas_inReceiverType ;
                      }else if (cond_188334.isBuiltAndFalse ()) {
                        const GGS_bool cond_188601 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4342))).operator_isEqual (GGS_string ("forAllOnBitIndexAndBeyond")) ;
                        if (cond_188601.isBuiltAndTrue ()) {
                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                          var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                          var_cas_outReturnedType = var_cas_inReceiverType ;
                        }else if (cond_188601.isBuiltAndFalse ()) {
                          const GGS_bool cond_188858 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4346))).operator_isEqual (GGS_string ("existOnBitIndex")) ;
                          if (cond_188858.isBuiltAndTrue ()) {
                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                            var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                            var_cas_outReturnedType = var_cas_inReceiverType ;
                          }else if (cond_188858.isBuiltAndFalse ()) {
                            const GGS_bool cond_189124 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4350))).operator_isEqual (GGS_string ("existOnBitIndexAndBeyond")) ;
                            if (cond_189124.isBuiltAndTrue ()) {
                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                              var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                              var_cas_outReturnedType = var_cas_inReceiverType ;
                            }else if (cond_189124.isBuiltAndFalse ()) {
                              const GGS_bool cond_189386 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4354))).operator_isEqual (GGS_string ("valueCount")) ;
                              if (cond_189386.isBuiltAndTrue ()) {
                                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE) ;
                              }else if (cond_189386.isBuiltAndFalse ()) {
                                const GGS_bool cond_189576 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4358))).operator_isEqual (GGS_string ("compressedValueCount")) ;
                                if (cond_189576.isBuiltAndTrue ()) {
                                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                  var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE) ;
                                }else if (cond_189576.isBuiltAndFalse ()) {
                                  const GGS_bool cond_189845 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4361))).operator_isEqual (GGS_string ("uint64ValueList")) ;
                                  if (cond_189845.isBuiltAndTrue ()) {
                                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                    var_cas_outReturnedType = function_EXbuild_uint64list_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4364)) ;
                                  }else if (cond_189845.isBuiltAndFalse ()) {
                                    const GGS_bool cond_190114 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4365))).operator_isEqual (GGS_string ("stringValueList")) ;
                                    if (cond_190114.isBuiltAndTrue ()) {
                                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                      var_cas_outReturnedType = function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4368)) ;
                                    }else if (cond_190114.isBuiltAndFalse ()) {
                                      const GGS_bool cond_190481 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4369))).operator_isEqual (GGS_string ("stringValueListWithNameList")) ;
                                      if (cond_190481.isBuiltAndTrue ()) {
                                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                        var_cas_outAccessorTypesList.addAssign_operation (function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4372)), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                        var_cas_outReturnedType = function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4373)) ;
                                      }else if (cond_190481.isBuiltAndFalse ()) {
                                        const GGS_bool cond_190671 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4374))).operator_isEqual (GGS_string ("predicateStringValue")) ;
                                        if (cond_190671.isBuiltAndTrue ()) {
                                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                                        }else if (cond_190671.isBuiltAndFalse ()) {
                                          const GGS_bool cond_190950 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4377))).operator_isEqual (GGS_string ("compressedStringValueList")) ;
                                          if (cond_190950.isBuiltAndTrue ()) {
                                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                            var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                            var_cas_outReturnedType = function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4380)) ;
                                          }else if (cond_190950.isBuiltAndFalse ()) {
                                            const GGS_bool cond_191280 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4381))).operator_isEqual (GGS_string ("swap21")) ;
                                            if (cond_191280.isBuiltAndTrue ()) {
                                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                              var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                              var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                              var_cas_outReturnedType = var_cas_inReceiverType ;
                                            }else if (cond_191280.isBuiltAndFalse ()) {
                                              const GGS_bool cond_191693 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4386))).operator_isEqual (GGS_string ("swap132")) ;
                                              if (cond_191693.isBuiltAndTrue ()) {
                                                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                var_cas_outReturnedType = var_cas_inReceiverType ;
                                              }else if (cond_191693.isBuiltAndFalse ()) {
                                                const GGS_bool cond_192106 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4392))).operator_isEqual (GGS_string ("swap213")) ;
                                                if (cond_192106.isBuiltAndTrue ()) {
                                                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                  var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                  var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                  var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                  var_cas_outReturnedType = var_cas_inReceiverType ;
                                                }else if (cond_192106.isBuiltAndFalse ()) {
                                                  const GGS_bool cond_192519 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4398))).operator_isEqual (GGS_string ("swap231")) ;
                                                  if (cond_192519.isBuiltAndTrue ()) {
                                                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                    var_cas_outReturnedType = var_cas_inReceiverType ;
                                                  }else if (cond_192519.isBuiltAndFalse ()) {
                                                    const GGS_bool cond_192932 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4404))).operator_isEqual (GGS_string ("swap312")) ;
                                                    if (cond_192932.isBuiltAndTrue ()) {
                                                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                      var_cas_outReturnedType = var_cas_inReceiverType ;
                                                    }else if (cond_192932.isBuiltAndFalse ()) {
                                                      const GGS_bool cond_193345 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4410))).operator_isEqual (GGS_string ("swap321")) ;
                                                      if (cond_193345.isBuiltAndTrue ()) {
                                                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                        var_cas_outReturnedType = var_cas_inReceiverType ;
                                                      }else if (cond_193345.isBuiltAndFalse ()) {
                                                        const GGS_bool cond_193604 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4416))).operator_isEqual (GGS_string ("transitiveClosure")) ;
                                                        if (cond_193604.isBuiltAndTrue ()) {
                                                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                          var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                          var_cas_outReturnedType = var_cas_inReceiverType ;
                                                        }else if (cond_193604.isBuiltAndFalse ()) {
                                                          const GGS_bool cond_193936 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4420))).operator_isEqual (GGS_string ("accessibleStates")) ;
                                                          if (cond_193936.isBuiltAndTrue ()) {
                                                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                            var_cas_outAccessorTypesList.addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                            var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                            var_cas_outReturnedType = var_cas_inReceiverType ;
                                                          }else if (cond_193936.isBuiltAndFalse ()) {
                                                            const GGS_bool cond_194177 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4425))).operator_isEqual (GGS_string ("equalTo")) ;
                                                            if (cond_194177.isBuiltAndTrue ()) {
                                                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                              var_cas_outAccessorTypesList.addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                              var_cas_outReturnedType = var_cas_inReceiverType ;
                                                            }else if (cond_194177.isBuiltAndFalse ()) {
                                                              const GGS_bool cond_194421 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4429))).operator_isEqual (GGS_string ("notEqualTo")) ;
                                                              if (cond_194421.isBuiltAndTrue ()) {
                                                                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                                var_cas_outAccessorTypesList.addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                                var_cas_outReturnedType = var_cas_inReceiverType ;
                                                              }else if (cond_194421.isBuiltAndFalse ()) {
                                                                const GGS_bool cond_194669 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4433))).operator_isEqual (GGS_string ("lowerOrEqualTo")) ;
                                                                if (cond_194669.isBuiltAndTrue ()) {
                                                                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                                  var_cas_outAccessorTypesList.addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                                  var_cas_outReturnedType = var_cas_inReceiverType ;
                                                                }else if (cond_194669.isBuiltAndFalse ()) {
                                                                  const GGS_bool cond_194919 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4437))).operator_isEqual (GGS_string ("greaterOrEqualTo")) ;
                                                                  if (cond_194919.isBuiltAndTrue ()) {
                                                                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                                    var_cas_outAccessorTypesList.addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                                    var_cas_outReturnedType = var_cas_inReceiverType ;
                                                                  }else if (cond_194919.isBuiltAndFalse ()) {
                                                                    const GGS_bool cond_195164 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4441))).operator_isEqual (GGS_string ("greaterThan")) ;
                                                                    if (cond_195164.isBuiltAndTrue ()) {
                                                                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                                      var_cas_outAccessorTypesList.addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                                      var_cas_outReturnedType = var_cas_inReceiverType ;
                                                                    }else if (cond_195164.isBuiltAndFalse ()) {
                                                                      const GGS_bool cond_195407 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4445))).operator_isEqual (GGS_string ("lowerThan")) ;
                                                                      if (cond_195407.isBuiltAndTrue ()) {
                                                                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                                        var_cas_outAccessorTypesList.addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                                        var_cas_outReturnedType = var_cas_inReceiverType ;
                                                                      }else if (cond_195407.isBuiltAndFalse ()) {
                                                                        const GGS_bool cond_195762 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4449))).operator_isEqual (GGS_string ("binarySetByTranslatingFromIndex")) ;
                                                                        if (cond_195762.isBuiltAndTrue ()) {
                                                                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                                          var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                                          var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                                          var_cas_outReturnedType = var_cas_inReceiverType ;
                                                                        }else if (cond_195762.isBuiltAndFalse ()) {
                                                                          const GGS_bool cond_196191 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4454))).operator_isEqual (GGS_string ("containsValue")) ;
                                                                          if (cond_196191.isBuiltAndTrue ()) {
                                                                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                                            var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                                            var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                                            var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                                            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                                                                          }else if (cond_196191.isBuiltAndFalse ()) {
                                                                            const GGS_bool cond_196530 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4460))).operator_isEqual (GGS_string ("existsOnBitRange")) ;
                                                                            if (cond_196530.isBuiltAndTrue ()) {
                                                                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                                              var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                                              var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                                                                              var_cas_outReturnedType = var_cas_inReceiverType ;
                                                                            }else if (cond_196530.isBuiltAndFalse ()) {
                                                                              var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4468)) ;
                                                                              var_cas_outAccessorTypesList.drop () ;
                                                                              var_cas_outReturnedType.drop () ;
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_uint *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_196918 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4470))).operator_isEqual (GGS_string ("description")) ;
        if (cond_196918.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_196918.isBuiltAndFalse ()) {
          const GGS_bool cond_197145 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4474))).operator_isEqual (GGS_string ("object")) ;
          if (cond_197145.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_197145.isBuiltAndFalse ()) {
            const GGS_bool cond_197375 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4478))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_197375.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_197375.isBuiltAndFalse ()) {
              const GGS_bool cond_197551 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4482))).operator_isEqual (GGS_string ("double")) ;
              if (cond_197551.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_double ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_197551.isBuiltAndFalse ()) {
                const GGS_bool cond_197723 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4485))).operator_isEqual (GGS_string ("sint")) ;
                if (cond_197723.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_sint ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_197723.isBuiltAndFalse ()) {
                  const GGS_bool cond_197899 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4488))).operator_isEqual (GGS_string ("uint64")) ;
                  if (cond_197899.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_197899.isBuiltAndFalse ()) {
                    const GGS_bool cond_198075 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4491))).operator_isEqual (GGS_string ("lsbIndex")) ;
                    if (cond_198075.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_198075.isBuiltAndFalse ()) {
                      const GGS_bool cond_198262 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4494))).operator_isEqual (GGS_string ("significantBitCount")) ;
                      if (cond_198262.isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                        var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                      }else if (cond_198262.isBuiltAndFalse ()) {
                        const GGS_bool cond_198438 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4497))).operator_isEqual (GGS_string ("sint64")) ;
                        if (cond_198438.isBuiltAndTrue ()) {
                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                          var_cas_outReturnedType = GGS_typeGalgas_sint64 ::constructor_new (inLexique COMMA_HERE) ;
                        }else if (cond_198438.isBuiltAndFalse ()) {
                          const GGS_bool cond_198614 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4500))).operator_isEqual (GGS_string ("string")) ;
                          if (cond_198614.isBuiltAndTrue ()) {
                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                          }else if (cond_198614.isBuiltAndFalse ()) {
                            const GGS_bool cond_198793 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4503))).operator_isEqual (GGS_string ("hexString")) ;
                            if (cond_198793.isBuiltAndTrue ()) {
                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                              var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                            }else if (cond_198793.isBuiltAndFalse ()) {
                              const GGS_bool cond_198982 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4506))).operator_isEqual (GGS_string ("isUnicodeValueAssigned")) ;
                              if (cond_198982.isBuiltAndTrue ()) {
                                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                              }else if (cond_198982.isBuiltAndFalse ()) {
                                var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4512)) ;
                                var_cas_outAccessorTypesList.drop () ;
                                var_cas_outReturnedType.drop () ;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_char *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_199370 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4514))).operator_isEqual (GGS_string ("description")) ;
        if (cond_199370.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_199370.isBuiltAndFalse ()) {
          const GGS_bool cond_199597 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4518))).operator_isEqual (GGS_string ("object")) ;
          if (cond_199597.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_199597.isBuiltAndFalse ()) {
            const GGS_bool cond_199827 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4522))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_199827.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_199827.isBuiltAndFalse ()) {
              const GGS_bool cond_200003 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4526))).operator_isEqual (GGS_string ("string")) ;
              if (cond_200003.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_200003.isBuiltAndFalse ()) {
                const GGS_bool cond_200204 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4529))).operator_isEqual (GGS_string ("utf32CharConstantRepresentation")) ;
                if (cond_200204.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_200204.isBuiltAndFalse ()) {
                  const GGS_bool cond_200376 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4532))).operator_isEqual (GGS_string ("uint")) ;
                  if (cond_200376.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_200376.isBuiltAndFalse ()) {
                    const GGS_bool cond_200551 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4535))).operator_isEqual (GGS_string ("isalnum")) ;
                    if (cond_200551.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_200551.isBuiltAndFalse ()) {
                      const GGS_bool cond_200726 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4538))).operator_isEqual (GGS_string ("isalpha")) ;
                      if (cond_200726.isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                        var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                      }else if (cond_200726.isBuiltAndFalse ()) {
                        const GGS_bool cond_200901 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4541))).operator_isEqual (GGS_string ("iscntrl")) ;
                        if (cond_200901.isBuiltAndTrue ()) {
                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                          var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                        }else if (cond_200901.isBuiltAndFalse ()) {
                          const GGS_bool cond_201076 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4544))).operator_isEqual (GGS_string ("isdigit")) ;
                          if (cond_201076.isBuiltAndTrue ()) {
                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                          }else if (cond_201076.isBuiltAndFalse ()) {
                            const GGS_bool cond_201251 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4547))).operator_isEqual (GGS_string ("islower")) ;
                            if (cond_201251.isBuiltAndTrue ()) {
                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                              var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                            }else if (cond_201251.isBuiltAndFalse ()) {
                              const GGS_bool cond_201426 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4550))).operator_isEqual (GGS_string ("isupper")) ;
                              if (cond_201426.isBuiltAndTrue ()) {
                                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                              }else if (cond_201426.isBuiltAndFalse ()) {
                                const GGS_bool cond_201602 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4553))).operator_isEqual (GGS_string ("isxdigit")) ;
                                if (cond_201602.isBuiltAndTrue ()) {
                                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                  var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                                }else if (cond_201602.isBuiltAndFalse ()) {
                                  const GGS_bool cond_201779 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4556))).operator_isEqual (GGS_string ("uintValue")) ;
                                  if (cond_201779.isBuiltAndTrue ()) {
                                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                    var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                                  }else if (cond_201779.isBuiltAndFalse ()) {
                                    const GGS_bool cond_201962 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4559))).operator_isEqual (GGS_string ("isUnicodeLetter")) ;
                                    if (cond_201962.isBuiltAndTrue ()) {
                                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                      var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                                    }else if (cond_201962.isBuiltAndFalse ()) {
                                      const GGS_bool cond_202143 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4562))).operator_isEqual (GGS_string ("isUnicodeMark")) ;
                                      if (cond_202143.isBuiltAndTrue ()) {
                                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                        var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                                      }else if (cond_202143.isBuiltAndFalse ()) {
                                        const GGS_bool cond_202326 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4565))).operator_isEqual (GGS_string ("isUnicodeNumber")) ;
                                        if (cond_202326.isBuiltAndTrue ()) {
                                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                          var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                                        }else if (cond_202326.isBuiltAndFalse ()) {
                                          const GGS_bool cond_202512 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4568))).operator_isEqual (GGS_string ("isUnicodeSeparator")) ;
                                          if (cond_202512.isBuiltAndTrue ()) {
                                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                                          }else if (cond_202512.isBuiltAndFalse ()) {
                                            const GGS_bool cond_202696 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4571))).operator_isEqual (GGS_string ("isUnicodeCommand")) ;
                                            if (cond_202696.isBuiltAndTrue ()) {
                                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                              var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                                            }else if (cond_202696.isBuiltAndFalse ()) {
                                              const GGS_bool cond_202884 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4574))).operator_isEqual (GGS_string ("isUnicodePunctuation")) ;
                                              if (cond_202884.isBuiltAndTrue ()) {
                                                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                                              }else if (cond_202884.isBuiltAndFalse ()) {
                                                const GGS_bool cond_203067 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4577))).operator_isEqual (GGS_string ("isUnicodeSymbol")) ;
                                                if (cond_203067.isBuiltAndTrue ()) {
                                                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                  var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                                                }else if (cond_203067.isBuiltAndFalse ()) {
                                                  const GGS_bool cond_203248 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4580))).operator_isEqual (GGS_string ("unicodeName")) ;
                                                  if (cond_203248.isBuiltAndTrue ()) {
                                                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                                                  }else if (cond_203248.isBuiltAndFalse ()) {
                                                    const GGS_bool cond_203430 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4583))).operator_isEqual (GGS_string ("unicodeToLower")) ;
                                                    if (cond_203430.isBuiltAndTrue ()) {
                                                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                      var_cas_outReturnedType = GGS_typeGalgas_char ::constructor_new (inLexique COMMA_HERE) ;
                                                    }else if (cond_203430.isBuiltAndFalse ()) {
                                                      const GGS_bool cond_203611 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4586))).operator_isEqual (GGS_string ("unicodeToUpper")) ;
                                                      if (cond_203611.isBuiltAndTrue ()) {
                                                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                                                        var_cas_outReturnedType = GGS_typeGalgas_char ::constructor_new (inLexique COMMA_HERE) ;
                                                      }else if (cond_203611.isBuiltAndFalse ()) {
                                                        var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4592)) ;
                                                        var_cas_outAccessorTypesList.drop () ;
                                                        var_cas_outReturnedType.drop () ;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_uint64 *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_204001 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4594))).operator_isEqual (GGS_string ("description")) ;
        if (cond_204001.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_204001.isBuiltAndFalse ()) {
          const GGS_bool cond_204228 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4598))).operator_isEqual (GGS_string ("object")) ;
          if (cond_204228.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_204228.isBuiltAndFalse ()) {
            const GGS_bool cond_204458 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4602))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_204458.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_204458.isBuiltAndFalse ()) {
              const GGS_bool cond_204634 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4606))).operator_isEqual (GGS_string ("double")) ;
              if (cond_204634.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_double ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_204634.isBuiltAndFalse ()) {
                const GGS_bool cond_204810 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4609))).operator_isEqual (GGS_string ("sint64")) ;
                if (cond_204810.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_sint64 ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_204810.isBuiltAndFalse ()) {
                  const GGS_bool cond_204982 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4612))).operator_isEqual (GGS_string ("sint")) ;
                  if (cond_204982.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_sint ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_204982.isBuiltAndFalse ()) {
                    const GGS_bool cond_205154 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4615))).operator_isEqual (GGS_string ("uint")) ;
                    if (cond_205154.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_205154.isBuiltAndFalse ()) {
                      const GGS_bool cond_205495 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4618))).operator_isEqual (GGS_string ("uintSlice")) ;
                      if (cond_205495.isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                        var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                      }else if (cond_205495.isBuiltAndFalse ()) {
                        const GGS_bool cond_205671 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4623))).operator_isEqual (GGS_string ("string")) ;
                        if (cond_205671.isBuiltAndTrue ()) {
                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                        }else if (cond_205671.isBuiltAndFalse ()) {
                          const GGS_bool cond_205849 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4626))).operator_isEqual (GGS_string ("hexString")) ;
                          if (cond_205849.isBuiltAndTrue ()) {
                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                          }else if (cond_205849.isBuiltAndFalse ()) {
                            var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4632)) ;
                            var_cas_outAccessorTypesList.drop () ;
                            var_cas_outReturnedType.drop () ;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_sint *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_206237 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4634))).operator_isEqual (GGS_string ("description")) ;
        if (cond_206237.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_206237.isBuiltAndFalse ()) {
          const GGS_bool cond_206464 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4638))).operator_isEqual (GGS_string ("object")) ;
          if (cond_206464.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_206464.isBuiltAndFalse ()) {
            const GGS_bool cond_206694 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4642))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_206694.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_206694.isBuiltAndFalse ()) {
              const GGS_bool cond_206870 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4646))).operator_isEqual (GGS_string ("double")) ;
              if (cond_206870.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_double ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_206870.isBuiltAndFalse ()) {
                const GGS_bool cond_207042 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4649))).operator_isEqual (GGS_string ("uint")) ;
                if (cond_207042.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_207042.isBuiltAndFalse ()) {
                  const GGS_bool cond_207218 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4652))).operator_isEqual (GGS_string ("uint64")) ;
                  if (cond_207218.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_207218.isBuiltAndFalse ()) {
                    const GGS_bool cond_207394 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4655))).operator_isEqual (GGS_string ("sint64")) ;
                    if (cond_207394.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = GGS_typeGalgas_sint64 ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_207394.isBuiltAndFalse ()) {
                      const GGS_bool cond_207569 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4658))).operator_isEqual (GGS_string ("string")) ;
                      if (cond_207569.isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                        var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                      }else if (cond_207569.isBuiltAndFalse ()) {
                        var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4664)) ;
                        var_cas_outAccessorTypesList.drop () ;
                        var_cas_outReturnedType.drop () ;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_sint64 *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_207959 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4666))).operator_isEqual (GGS_string ("description")) ;
        if (cond_207959.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_207959.isBuiltAndFalse ()) {
          const GGS_bool cond_208186 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4670))).operator_isEqual (GGS_string ("object")) ;
          if (cond_208186.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_208186.isBuiltAndFalse ()) {
            const GGS_bool cond_208416 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4674))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_208416.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_208416.isBuiltAndFalse ()) {
              const GGS_bool cond_208592 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4678))).operator_isEqual (GGS_string ("double")) ;
              if (cond_208592.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_double ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_208592.isBuiltAndFalse ()) {
                const GGS_bool cond_208768 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4681))).operator_isEqual (GGS_string ("uint64")) ;
                if (cond_208768.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_208768.isBuiltAndFalse ()) {
                  const GGS_bool cond_208940 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4684))).operator_isEqual (GGS_string ("uint")) ;
                  if (cond_208940.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_208940.isBuiltAndFalse ()) {
                    const GGS_bool cond_209112 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4687))).operator_isEqual (GGS_string ("sint")) ;
                    if (cond_209112.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = GGS_typeGalgas_sint ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_209112.isBuiltAndFalse ()) {
                      const GGS_bool cond_209287 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4690))).operator_isEqual (GGS_string ("string")) ;
                      if (cond_209287.isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                        var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                      }else if (cond_209287.isBuiltAndFalse ()) {
                        var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4696)) ;
                        var_cas_outAccessorTypesList.drop () ;
                        var_cas_outReturnedType.drop () ;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_data *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_209675 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4698))).operator_isEqual (GGS_string ("description")) ;
        if (cond_209675.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_209675.isBuiltAndFalse ()) {
          const GGS_bool cond_209902 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4702))).operator_isEqual (GGS_string ("object")) ;
          if (cond_209902.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_209902.isBuiltAndFalse ()) {
            const GGS_bool cond_210132 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4706))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_210132.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_210132.isBuiltAndFalse ()) {
              const GGS_bool cond_210356 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4710))).operator_isEqual (GGS_string ("length")) ;
              if (cond_210356.isBuiltAndTrue ()) {
                var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_210356.isBuiltAndFalse ()) {
                var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4717)) ;
                var_cas_outAccessorTypesList.drop () ;
                var_cas_outReturnedType.drop () ;
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_object *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_210746 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4719))).operator_isEqual (GGS_string ("description")) ;
        if (cond_210746.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_210746.isBuiltAndFalse ()) {
          const GGS_bool cond_210973 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4723))).operator_isEqual (GGS_string ("object")) ;
          if (cond_210973.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_210973.isBuiltAndFalse ()) {
            const GGS_bool cond_211203 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4727))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_211203.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_211203.isBuiltAndFalse ()) {
              const GGS_bool cond_211438 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4731))).operator_isEqual (GGS_string ("objectDynamicType")) ;
              if (cond_211438.isBuiltAndTrue ()) {
                var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
              }else if (cond_211438.isBuiltAndFalse ()) {
                var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4738)) ;
                var_cas_outAccessorTypesList.drop () ;
                var_cas_outReturnedType.drop () ;
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_type *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_211826 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4740))).operator_isEqual (GGS_string ("description")) ;
        if (cond_211826.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_211826.isBuiltAndFalse ()) {
          const GGS_bool cond_212053 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4744))).operator_isEqual (GGS_string ("object")) ;
          if (cond_212053.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_212053.isBuiltAndFalse ()) {
            const GGS_bool cond_212283 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4748))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_212283.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_212283.isBuiltAndFalse ()) {
              const GGS_bool cond_212508 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4752))).operator_isEqual (GGS_string ("name")) ;
              if (cond_212508.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
              }else if (cond_212508.isBuiltAndFalse ()) {
                const GGS_bool cond_212738 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4756))).operator_isEqual (GGS_string ("isClassType")) ;
                if (cond_212738.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
                }else if (cond_212738.isBuiltAndFalse ()) {
                  const GGS_bool cond_212970 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4760))).operator_isEqual (GGS_string ("hasSuperclass")) ;
                  if (cond_212970.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
                    var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
                  }else if (cond_212970.isBuiltAndFalse ()) {
                    const GGS_bool cond_213147 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4764))).operator_isEqual (GGS_string ("superclass")) ;
                    if (cond_213147.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_213147.isBuiltAndFalse ()) {
                      var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4770)) ;
                      var_cas_outAccessorTypesList.drop () ;
                      var_cas_outReturnedType.drop () ;
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_function *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_213539 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4772))).operator_isEqual (GGS_string ("description")) ;
        if (cond_213539.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_213539.isBuiltAndFalse ()) {
          const GGS_bool cond_213766 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4776))).operator_isEqual (GGS_string ("object")) ;
          if (cond_213766.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_213766.isBuiltAndFalse ()) {
            const GGS_bool cond_213997 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4780))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_213997.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_213997.isBuiltAndFalse ()) {
              const GGS_bool cond_214222 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4784))).operator_isEqual (GGS_string ("name")) ;
              if (cond_214222.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
              }else if (cond_214222.isBuiltAndFalse ()) {
                const GGS_bool cond_214451 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4788))).operator_isEqual (GGS_string ("resultType")) ;
                if (cond_214451.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
                  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
                }else if (cond_214451.isBuiltAndFalse ()) {
                  const GGS_bool cond_214695 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4792))).operator_isEqual (GGS_string ("formalParameterTypeList")) ;
                  if (cond_214695.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = function_EXbuild_typelist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4794)) ;
                    var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
                  }else if (cond_214695.isBuiltAndFalse ()) {
                    const GGS_bool cond_215071 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4796))).operator_isEqual (GGS_string ("invoke")) ;
                    if (cond_215071.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      GGS_AC_galgasType  var_cas_t = function_EXbuild_objectlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (4798)) ;
                      var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                      var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                      var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_215071.isBuiltAndFalse ()) {
                      var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4805)) ;
                      var_cas_outAccessorTypesList.drop () ;
                      var_cas_outReturnedType.drop () ;
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_double *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_215461 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4807))).operator_isEqual (GGS_string ("description")) ;
        if (cond_215461.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_215461.isBuiltAndFalse ()) {
          const GGS_bool cond_215688 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4811))).operator_isEqual (GGS_string ("object")) ;
          if (cond_215688.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_215688.isBuiltAndFalse ()) {
            const GGS_bool cond_215918 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4815))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_215918.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_215918.isBuiltAndFalse ()) {
              const GGS_bool cond_216094 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4819))).operator_isEqual (GGS_string ("string")) ;
              if (cond_216094.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_216094.isBuiltAndFalse ()) {
                const GGS_bool cond_216266 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4822))).operator_isEqual (GGS_string ("uint")) ;
                if (cond_216266.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_216266.isBuiltAndFalse ()) {
                  const GGS_bool cond_216442 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4825))).operator_isEqual (GGS_string ("uint64")) ;
                  if (cond_216442.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_216442.isBuiltAndFalse ()) {
                    const GGS_bool cond_216614 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4828))).operator_isEqual (GGS_string ("sint")) ;
                    if (cond_216614.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_216614.isBuiltAndFalse ()) {
                      const GGS_bool cond_216789 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4831))).operator_isEqual (GGS_string ("sint64")) ;
                      if (cond_216789.isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                        var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE) ;
                      }else if (cond_216789.isBuiltAndFalse ()) {
                        var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4837)) ;
                        var_cas_outAccessorTypesList.drop () ;
                        var_cas_outReturnedType.drop () ;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_bool *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_217177 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4839))).operator_isEqual (GGS_string ("description")) ;
        if (cond_217177.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_217177.isBuiltAndFalse ()) {
          const GGS_bool cond_217404 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4843))).operator_isEqual (GGS_string ("object")) ;
          if (cond_217404.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_217404.isBuiltAndFalse ()) {
            const GGS_bool cond_217634 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4847))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_217634.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_217634.isBuiltAndFalse ()) {
              const GGS_bool cond_217811 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4851))).operator_isEqual (GGS_string ("cString")) ;
              if (cond_217811.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_217811.isBuiltAndFalse ()) {
                const GGS_bool cond_217989 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4854))).operator_isEqual (GGS_string ("ocString")) ;
                if (cond_217989.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_217989.isBuiltAndFalse ()) {
                  const GGS_bool cond_218161 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4857))).operator_isEqual (GGS_string ("uint")) ;
                  if (cond_218161.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_218161.isBuiltAndFalse ()) {
                    const GGS_bool cond_218333 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4860))).operator_isEqual (GGS_string ("sint")) ;
                    if (cond_218333.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = GGS_typeGalgas_sint ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_218333.isBuiltAndFalse ()) {
                      const GGS_bool cond_218509 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4863))).operator_isEqual (GGS_string ("uint64")) ;
                      if (cond_218509.isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                        var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE) ;
                      }else if (cond_218509.isBuiltAndFalse ()) {
                        const GGS_bool cond_218684 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4866))).operator_isEqual (GGS_string ("sint64")) ;
                        if (cond_218684.isBuiltAndTrue ()) {
                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                          var_cas_outReturnedType = GGS_typeGalgas_sint64 ::constructor_new (inLexique COMMA_HERE) ;
                        }else if (cond_218684.isBuiltAndFalse ()) {
                          var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4872)) ;
                          var_cas_outAccessorTypesList.drop () ;
                          var_cas_outReturnedType.drop () ;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_lchar *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_219073 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4874))).operator_isEqual (GGS_string ("description")) ;
        if (cond_219073.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_219073.isBuiltAndFalse ()) {
          const GGS_bool cond_219300 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4878))).operator_isEqual (GGS_string ("object")) ;
          if (cond_219300.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_219300.isBuiltAndFalse ()) {
            const GGS_bool cond_219530 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4882))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_219530.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_219530.isBuiltAndFalse ()) {
              const GGS_bool cond_219702 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4886))).operator_isEqual (GGS_string ("char")) ;
              if (cond_219702.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_char ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_219702.isBuiltAndFalse ()) {
                const GGS_bool cond_219882 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4889))).operator_isEqual (GGS_string ("location")) ;
                if (cond_219882.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_219882.isBuiltAndFalse ()) {
                  const GGS_bool cond_220065 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4892))).operator_isEqual (GGS_string ("locationString")) ;
                  if (cond_220065.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_220065.isBuiltAndFalse ()) {
                    var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4898)) ;
                    var_cas_outAccessorTypesList.drop () ;
                    var_cas_outReturnedType.drop () ;
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_lbool *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_220454 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4900))).operator_isEqual (GGS_string ("description")) ;
        if (cond_220454.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_220454.isBuiltAndFalse ()) {
          const GGS_bool cond_220681 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4904))).operator_isEqual (GGS_string ("object")) ;
          if (cond_220681.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_220681.isBuiltAndFalse ()) {
            const GGS_bool cond_220911 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4908))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_220911.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_220911.isBuiltAndFalse ()) {
              const GGS_bool cond_221083 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4912))).operator_isEqual (GGS_string ("bool")) ;
              if (cond_221083.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_221083.isBuiltAndFalse ()) {
                const GGS_bool cond_221262 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4915))).operator_isEqual (GGS_string ("location")) ;
                if (cond_221262.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_221262.isBuiltAndFalse ()) {
                  var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4921)) ;
                  var_cas_outAccessorTypesList.drop () ;
                  var_cas_outReturnedType.drop () ;
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_luint *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_221651 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4923))).operator_isEqual (GGS_string ("description")) ;
        if (cond_221651.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_221651.isBuiltAndFalse ()) {
          const GGS_bool cond_221878 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4927))).operator_isEqual (GGS_string ("object")) ;
          if (cond_221878.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_221878.isBuiltAndFalse ()) {
            const GGS_bool cond_222108 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4931))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_222108.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_222108.isBuiltAndFalse ()) {
              const GGS_bool cond_222280 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4935))).operator_isEqual (GGS_string ("uint")) ;
              if (cond_222280.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_222280.isBuiltAndFalse ()) {
                const GGS_bool cond_222460 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4938))).operator_isEqual (GGS_string ("location")) ;
                if (cond_222460.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_222460.isBuiltAndFalse ()) {
                  const GGS_bool cond_222643 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4941))).operator_isEqual (GGS_string ("locationString")) ;
                  if (cond_222643.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_222643.isBuiltAndFalse ()) {
                    var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4947)) ;
                    var_cas_outAccessorTypesList.drop () ;
                    var_cas_outReturnedType.drop () ;
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_luint64 *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_223034 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4949))).operator_isEqual (GGS_string ("description")) ;
        if (cond_223034.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_223034.isBuiltAndFalse ()) {
          const GGS_bool cond_223261 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4953))).operator_isEqual (GGS_string ("object")) ;
          if (cond_223261.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_223261.isBuiltAndFalse ()) {
            const GGS_bool cond_223491 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4957))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_223491.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_223491.isBuiltAndFalse ()) {
              const GGS_bool cond_223667 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4961))).operator_isEqual (GGS_string ("uint64")) ;
              if (cond_223667.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_223667.isBuiltAndFalse ()) {
                const GGS_bool cond_223847 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4964))).operator_isEqual (GGS_string ("location")) ;
                if (cond_223847.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_223847.isBuiltAndFalse ()) {
                  const GGS_bool cond_224030 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4967))).operator_isEqual (GGS_string ("locationString")) ;
                  if (cond_224030.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_224030.isBuiltAndFalse ()) {
                    var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4973)) ;
                    var_cas_outAccessorTypesList.drop () ;
                    var_cas_outReturnedType.drop () ;
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_lsint *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_224419 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4975))).operator_isEqual (GGS_string ("description")) ;
        if (cond_224419.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_224419.isBuiltAndFalse ()) {
          const GGS_bool cond_224646 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4979))).operator_isEqual (GGS_string ("object")) ;
          if (cond_224646.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_224646.isBuiltAndFalse ()) {
            const GGS_bool cond_224876 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4983))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_224876.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_224876.isBuiltAndFalse ()) {
              const GGS_bool cond_225048 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4987))).operator_isEqual (GGS_string ("sint")) ;
              if (cond_225048.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_sint ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_225048.isBuiltAndFalse ()) {
                const GGS_bool cond_225224 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4990))).operator_isEqual (GGS_string ("string")) ;
                if (cond_225224.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_225224.isBuiltAndFalse ()) {
                  const GGS_bool cond_225404 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4993))).operator_isEqual (GGS_string ("location")) ;
                  if (cond_225404.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_225404.isBuiltAndFalse ()) {
                    const GGS_bool cond_225587 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (4996))).operator_isEqual (GGS_string ("locationString")) ;
                    if (cond_225587.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_225587.isBuiltAndFalse ()) {
                      var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (5002)) ;
                      var_cas_outAccessorTypesList.drop () ;
                      var_cas_outReturnedType.drop () ;
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_lsint64 *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_225978 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5004))).operator_isEqual (GGS_string ("description")) ;
        if (cond_225978.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_225978.isBuiltAndFalse ()) {
          const GGS_bool cond_226205 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5008))).operator_isEqual (GGS_string ("object")) ;
          if (cond_226205.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_226205.isBuiltAndFalse ()) {
            const GGS_bool cond_226435 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5012))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_226435.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_226435.isBuiltAndFalse ()) {
              const GGS_bool cond_226611 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5016))).operator_isEqual (GGS_string ("sint64")) ;
              if (cond_226611.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_sint64 ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_226611.isBuiltAndFalse ()) {
                const GGS_bool cond_226787 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5019))).operator_isEqual (GGS_string ("string")) ;
                if (cond_226787.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_226787.isBuiltAndFalse ()) {
                  const GGS_bool cond_226967 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5022))).operator_isEqual (GGS_string ("location")) ;
                  if (cond_226967.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_226967.isBuiltAndFalse ()) {
                    const GGS_bool cond_227150 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5025))).operator_isEqual (GGS_string ("locationString")) ;
                    if (cond_227150.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_227150.isBuiltAndFalse ()) {
                      var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (5031)) ;
                      var_cas_outAccessorTypesList.drop () ;
                      var_cas_outReturnedType.drop () ;
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_ldouble *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_227541 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5033))).operator_isEqual (GGS_string ("description")) ;
        if (cond_227541.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_227541.isBuiltAndFalse ()) {
          const GGS_bool cond_227768 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5037))).operator_isEqual (GGS_string ("object")) ;
          if (cond_227768.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_227768.isBuiltAndFalse ()) {
            const GGS_bool cond_227998 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5041))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_227998.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_227998.isBuiltAndFalse ()) {
              const GGS_bool cond_228174 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5045))).operator_isEqual (GGS_string ("double")) ;
              if (cond_228174.isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_double ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_228174.isBuiltAndFalse ()) {
                const GGS_bool cond_228350 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5048))).operator_isEqual (GGS_string ("string")) ;
                if (cond_228350.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_228350.isBuiltAndFalse ()) {
                  const GGS_bool cond_228530 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5051))).operator_isEqual (GGS_string ("location")) ;
                  if (cond_228530.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_228530.isBuiltAndFalse ()) {
                    const GGS_bool cond_228713 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5054))).operator_isEqual (GGS_string ("locationString")) ;
                    if (cond_228713.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_228713.isBuiltAndFalse ()) {
                      var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (5060)) ;
                      var_cas_outAccessorTypesList.drop () ;
                      var_cas_outReturnedType.drop () ;
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgasListType *> (_var_245063.getPtr ()) != NULL) {
        const GGS_typeGalgasListType var_cas_listType (_var_245063.getPtr ()) ;
        const GGS_bool cond_229113 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5062))).operator_isEqual (GGS_string ("description")) ;
        if (cond_229113.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_229113.isBuiltAndFalse ()) {
          const GGS_bool cond_229340 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5066))).operator_isEqual (GGS_string ("object")) ;
          if (cond_229340.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_229340.isBuiltAndFalse ()) {
            const GGS_bool cond_229570 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5070))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_229570.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_229570.isBuiltAndFalse ()) {
              const GGS_bool cond_229795 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5074))).operator_isEqual (GGS_string ("length")) ;
              if (cond_229795.isBuiltAndTrue ()) {
                var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_229795.isBuiltAndFalse ()) {
                const GGS_bool cond_230053 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5078))).operator_isEqual (GGS_string ("subListFromIndex")) ;
                if (cond_230053.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                  var_cas_outReturnedType = var_cas_inReceiverType ;
                }else if (cond_230053.isBuiltAndFalse ()) {
                  const GGS_bool cond_230392 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5082))).operator_isEqual (GGS_string ("subListWithRange")) ;
                  if (cond_230392.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                    var_cas_outReturnedType = var_cas_inReceiverType ;
                  }else if (cond_230392.isBuiltAndFalse ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                    var_cas_outReturnedType = var_cas_inReceiverType ;
                    GGS_typeListeAttributsSemantiques  var_cas_attributeList = var_cas_listType.reader_mAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (5091)) ;
                    GGS_bool var_cas_found = GGS_bool (false) ;
                    {
                      GGS_typeListeAttributsSemantiques::cEnumerator enumerator_230742 (var_cas_attributeList, true) ;
                      const GGS_typeListeAttributsSemantiques::cElement * operand_230742 = NULL ;
                      while (((operand_230742 = enumerator_230742.nextObject ()))
                          && ((var_cas_found).operator_not ().isBuiltAndTrue ())) {
                        macroValidPointer (operand_230742) ;
                        var_cas_found = ((operand_230742->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5094))).operator_concat (GGS_string ("AtIndex"))).operator_isEqual (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5094))) ;
                        const GGS_bool cond_230924 = var_cas_found ;
                        if (cond_230924.isBuiltAndTrue ()) {
                          var_cas_outReturnedType = operand_230742->mAttributType ;
                        }
                      }
                    }
                    const GGS_bool cond_231095 = (var_cas_found).operator_not () ;
                    if (cond_231095.isBuiltAndTrue ()) {
                      var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5101)))).operator_concat (GGS_string ("' reader is not supported by a list")) COMMA_SOURCE_FILE_AT_LINE (5102)) ;
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgasSortedListType *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_231391 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5105))).operator_isEqual (GGS_string ("description")) ;
        if (cond_231391.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_231391.isBuiltAndFalse ()) {
          const GGS_bool cond_231618 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5109))).operator_isEqual (GGS_string ("object")) ;
          if (cond_231618.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_231618.isBuiltAndFalse ()) {
            const GGS_bool cond_231848 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5113))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_231848.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_231848.isBuiltAndFalse ()) {
              const GGS_bool cond_232072 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5117))).operator_isEqual (GGS_string ("length")) ;
              if (cond_232072.isBuiltAndTrue ()) {
                var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_232072.isBuiltAndFalse ()) {
                var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("sorted list supports only 'length' reader call") COMMA_SOURCE_FILE_AT_LINE (5124)) ;
                var_cas_outAccessorTypesList.drop () ;
                var_cas_outReturnedType.drop () ;
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgasMapType *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_232484 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5126))).operator_isEqual (GGS_string ("description")) ;
        if (cond_232484.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_232484.isBuiltAndFalse ()) {
          const GGS_bool cond_232711 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5130))).operator_isEqual (GGS_string ("object")) ;
          if (cond_232711.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_232711.isBuiltAndFalse ()) {
            const GGS_bool cond_232941 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5134))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_232941.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_232941.isBuiltAndFalse ()) {
              const GGS_bool cond_233250 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5138))).operator_isEqual (GGS_string ("hasKey")) ;
              if (cond_233250.isBuiltAndTrue ()) {
                var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_233250.isBuiltAndFalse ()) {
                const GGS_bool cond_233520 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5143))).operator_isEqual (GGS_string ("locationForKey")) ;
                if (cond_233520.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                  var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_233520.isBuiltAndFalse ()) {
                  const GGS_bool cond_233744 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5147))).operator_isEqual (GGS_string ("count")) ;
                  if (cond_233744.isBuiltAndTrue ()) {
                    var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_233744.isBuiltAndFalse ()) {
                    const GGS_bool cond_233924 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5151))).operator_isEqual (GGS_string ("allKeys")) ;
                    if (cond_233924.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = GGS_typeGalgas_stringset ::constructor_new (inLexique COMMA_HERE) ;
                    }else if (cond_233924.isBuiltAndFalse ()) {
                      const GGS_bool cond_234104 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5154))).operator_isEqual (GGS_string ("keyList")) ;
                      if (cond_234104.isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                        var_cas_outReturnedType = function_EXbuild_lstringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5156)) ;
                      }else if (cond_234104.isBuiltAndFalse ()) {
                        const GGS_bool cond_234290 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5157))).operator_isEqual (GGS_string ("unsolvedIndexCount")) ;
                        if (cond_234290.isBuiltAndTrue ()) {
                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                          var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                        }else if (cond_234290.isBuiltAndFalse ()) {
                          const GGS_bool cond_234488 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5160))).operator_isEqual (GGS_string ("unsolvedIndexKeyStringList")) ;
                          if (cond_234488.isBuiltAndTrue ()) {
                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                            var_cas_outReturnedType = function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5162)) ;
                          }else if (cond_234488.isBuiltAndFalse ()) {
                            const GGS_bool cond_234660 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5163))).operator_isEqual (GGS_string ("overriddenMap")) ;
                            if (cond_234660.isBuiltAndTrue ()) {
                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                              var_cas_outReturnedType = var_cas_inReceiverType ;
                            }else if (cond_234660.isBuiltAndFalse ()) {
                              var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (5169)) ;
                              var_cas_outAccessorTypesList.drop () ;
                              var_cas_outReturnedType.drop () ;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgasListmapType *> (_var_245063.getPtr ()) != NULL) {
        const GGS_typeGalgasListmapType var_cas_mapType (_var_245063.getPtr ()) ;
        const GGS_bool cond_235062 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5171))).operator_isEqual (GGS_string ("description")) ;
        if (cond_235062.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_235062.isBuiltAndFalse ()) {
          const GGS_bool cond_235289 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5175))).operator_isEqual (GGS_string ("object")) ;
          if (cond_235289.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_235289.isBuiltAndFalse ()) {
            const GGS_bool cond_235519 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5179))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_235519.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_235519.isBuiltAndFalse ()) {
              const GGS_bool cond_235828 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5183))).operator_isEqual (GGS_string ("hasKey")) ;
              if (cond_235828.isBuiltAndTrue ()) {
                var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_235828.isBuiltAndFalse ()) {
                const GGS_bool cond_236008 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5188))).operator_isEqual (GGS_string ("allKeys")) ;
                if (cond_236008.isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_stringset ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_236008.isBuiltAndFalse ()) {
                  const GGS_bool cond_236232 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5191))).operator_isEqual (GGS_string ("count")) ;
                  if (cond_236232.isBuiltAndTrue ()) {
                    var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                  }else if (cond_236232.isBuiltAndFalse ()) {
                    const GGS_bool cond_236411 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5195))).operator_isEqual (GGS_string ("keyList")) ;
                    if (cond_236411.isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                      var_cas_outReturnedType = function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5197)) ;
                    }else if (cond_236411.isBuiltAndFalse ()) {
                      const GGS_bool cond_236669 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5198))).operator_isEqual (GGS_string ("listForKey")) ;
                      if (cond_236669.isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                        var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                        var_cas_outReturnedType = var_cas_mapType.reader_mListType (inLexique COMMA_SOURCE_FILE_AT_LINE (5201)) ;
                      }else if (cond_236669.isBuiltAndFalse ()) {
                        var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (5205)) ;
                        var_cas_outAccessorTypesList.drop () ;
                        var_cas_outReturnedType.drop () ;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_stringset *> (_var_245063.getPtr ()) != NULL) {
        const GGS_bool cond_237062 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5207))).operator_isEqual (GGS_string ("description")) ;
        if (cond_237062.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_237062.isBuiltAndFalse ()) {
          const GGS_bool cond_237289 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5211))).operator_isEqual (GGS_string ("object")) ;
          if (cond_237289.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_237289.isBuiltAndFalse ()) {
            const GGS_bool cond_237519 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5215))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_237519.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_237519.isBuiltAndFalse ()) {
              const GGS_bool cond_237828 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5219))).operator_isEqual (GGS_string ("hasKey")) ;
              if (cond_237828.isBuiltAndTrue ()) {
                var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                var_cas_outAccessorTypesList.addAssign_operation (GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE)) ;
                var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) ;
              }else if (cond_237828.isBuiltAndFalse ()) {
                const GGS_bool cond_238052 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5224))).operator_isEqual (GGS_string ("count")) ;
                if (cond_238052.isBuiltAndTrue ()) {
                  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                  var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) ;
                }else if (cond_238052.isBuiltAndFalse ()) {
                  const GGS_bool cond_238233 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5228))).operator_isEqual (GGS_string ("stringList")) ;
                  if (cond_238233.isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
                    var_cas_outReturnedType = function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5230)) ;
                  }else if (cond_238233.isBuiltAndFalse ()) {
                    var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (5234)) ;
                    var_cas_outAccessorTypesList.drop () ;
                    var_cas_outReturnedType.drop () ;
                  }
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgasClassType *> (_var_245063.getPtr ()) != NULL) {
        const GGS_typeGalgasClassType var_cas_t (_var_245063.getPtr ()) ;
        const GGS_bool cond_238628 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5237))).operator_isEqual (GGS_string ("description")) ;
        if (cond_238628.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_238628.isBuiltAndFalse ()) {
          const GGS_bool cond_238855 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5241))).operator_isEqual (GGS_string ("object")) ;
          if (cond_238855.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_238855.isBuiltAndFalse ()) {
            const GGS_bool cond_239084 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5245))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_239084.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_239084.isBuiltAndFalse ()) {
              var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              GGS_stringlist  var_cas_acceptedReaderList = GGS_stringlist ::constructor_emptyList () ;
              const GGS_bool cond_242662 = (var_cas_t.reader_mMessagesMap (inLexique COMMA_SOURCE_FILE_AT_LINE (5253)).reader_hasKey (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5253)))).operator_not () ;
              if (cond_242662.isBuiltAndTrue ()) {
                GGS_bool var_cas_found = GGS_bool (false) ;
                const GGS_bool cond_239958 = var_cas_t.reader_mNonExternAttributesMap (inLexique COMMA_SOURCE_FILE_AT_LINE (5256)).reader_hasKey (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5256))) ;
                if (cond_239958.isBuiltAndTrue ()) {
                  var_cas_found = GGS_bool (true) ;
                  GGS_bool var_cas_hasGetter ;
                  GGS_bool automatic_var_239630_0 ;
                  const GGS_typeSemanticAttributesMap  temp_239583 = var_cas_t.reader_mNonExternAttributesMap (inLexique COMMA_SOURCE_FILE_AT_LINE (5259)) ;
                  if (temp_239583.isBuilt ()) {
                    temp_239583 (HERE)->method_searchKey (inLexique, var_cas_inReaderName, var_cas_outReturnedType, automatic_var_239630_0, var_cas_hasGetter COMMA_SOURCE_FILE_AT_LINE (5259)) ;
                  }
                  const GGS_bool cond_239941 = (var_cas_hasGetter).operator_not () ;
                  if (cond_239941.isBuiltAndTrue ()) {
                    var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (var_cas_inReaderName)).operator_concat (GGS_string ("' attribute has 'nogetter' feature, it cannot be used as a reader")) COMMA_SOURCE_FILE_AT_LINE (5262)) ;
                    var_cas_t.reader_mNonExternAttributesMap (inLexique COMMA_SOURCE_FILE_AT_LINE (5262)).reader_locationForKey (inLexique, var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5262)) COMMA_SOURCE_FILE_AT_LINE (5262)).reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, GGS_string ("for previous error, attribute is declared here") COMMA_SOURCE_FILE_AT_LINE (5262)) ;
                  }
                }
                {
                  GGS_L_lazyAttributeList::cEnumerator enumerator_240018 (var_cas_t.reader_mLazyAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (5266)), true) ;
                  const GGS_L_lazyAttributeList::cElement * operand_240018 = NULL ;
                  while (((operand_240018 = enumerator_240018.nextObject ()))
                      && ((var_cas_found).operator_not ().isBuiltAndTrue ())) {
                    macroValidPointer (operand_240018) ;
                    {
                      GGS_typeListeAttributsSemantiques::cEnumerator enumerator_240110 (operand_240018->mComputedAttributeTypeAndNameList, true) ;
                      const GGS_typeListeAttributsSemantiques::cElement * operand_240110 = NULL ;
                      while (((operand_240110 = enumerator_240110.nextObject ()))
                          && ((var_cas_found).operator_not ().isBuiltAndTrue ())) {
                        macroValidPointer (operand_240110) ;
                        var_cas_outReturnedType = operand_240110->mAttributType ;
                        var_cas_found = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5269))).operator_isEqual (operand_240110->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5269))) ;
                      }
                    }
                  }
                }
                {
                  GGS_typeSuperClassesMap::cEnumerator enumerator_240366 (var_cas_t.reader_mAncestorClassesMap (inLexique COMMA_SOURCE_FILE_AT_LINE (5273)), true) ;
                  const GGS_typeSuperClassesMap::cElement * operand_240366 = NULL ;
                  while (((operand_240366 = enumerator_240366.nextObject ()))
                      && ((var_cas_found).operator_not ().isBuiltAndTrue ())) {
                    macroValidPointer (operand_240366) ;
                    GGS_AC_semanticsEntity  var_cas_entite ;
                    const GGS_M_semanticsEntitiesForUse  temp_240481 = var_cas_ioEntitiesMap ;
                    if (temp_240481.isBuilt ()) {
                      temp_240481 (HERE)->method_searchKey (inLexique, operand_240366->mKey, var_cas_entite COMMA_SOURCE_FILE_AT_LINE (5275)) ;
                    }
                    GGS_AC_galgasType  var_cas_type = GGS_typeEntiteType::castFrom (inLexique, var_cas_entite.getPtr (), true, operand_240366->mKey COMMA_SOURCE_FILE_AT_LINE (5276)).reader_aDefType (inLexique COMMA_SOURCE_FILE_AT_LINE (5276)) ;
                    GGS_typeGalgasClassType  var_cas_classType = GGS_typeGalgasClassType::castFrom (inLexique, var_cas_type.getPtr (), true, operand_240366->mKey COMMA_SOURCE_FILE_AT_LINE (5277)) ;
                    {
                      GGS_L_lazyAttributeList::cEnumerator enumerator_240714 (var_cas_classType.reader_mLazyAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (5278)), true) ;
                      const GGS_L_lazyAttributeList::cElement * operand_240714 = NULL ;
                      while (((operand_240714 = enumerator_240714.nextObject ()))
                          && ((var_cas_found).operator_not ().isBuiltAndTrue ())) {
                        macroValidPointer (operand_240714) ;
                        {
                          GGS_typeListeAttributsSemantiques::cEnumerator enumerator_240816 (operand_240714->mComputedAttributeTypeAndNameList, true) ;
                          const GGS_typeListeAttributsSemantiques::cElement * operand_240816 = NULL ;
                          while (((operand_240816 = enumerator_240816.nextObject ()))
                              && ((var_cas_found).operator_not ().isBuiltAndTrue ())) {
                            macroValidPointer (operand_240816) ;
                            var_cas_outReturnedType = operand_240816->mAttributType ;
                            var_cas_found = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5281))).operator_isEqual (operand_240816->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5281))) ;
                          }
                        }
                      }
                    }
                  }
                }
                const GGS_bool cond_242532 = (var_cas_found).operator_not () ;
                if (cond_242532.isBuiltAndTrue ()) {
                  GGS_L_EXsignature  var_cas_signature = GGS_L_EXsignature ::constructor_emptyList () ;
                  GGS_string var_cas_className = var_cas_t.reader_mClassTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (5288)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5288)) ;
                  GGS_lstring  var_cas_kKey = GGS_lstring ::constructor_new (inLexique, ((var_cas_className).operator_concat (GGS_string (":"))).operator_concat (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5289))), var_cas_inReaderName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (5289)) COMMA_HERE) ;
                  const GGS_bool cond_241693 = var_cas_inCategoryReaderMap.reader_hasKey (var_cas_kKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5290))) ;
                  if (cond_241693.isBuiltAndTrue ()) {
                    GGS_categoryMethodKind var_cas_categoryMethodKind ;
                    const GGS_EXcategoryReaderMap  temp_241460 = var_cas_inCategoryReaderMap ;
                    if (temp_241460.isBuilt ()) {
                      temp_241460 (HERE)->method_searchKey (inLexique, var_cas_kKey, var_cas_categoryMethodKind, var_cas_signature, var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (5292)) ;
                    }
                    const GGS_bool cond_241674 = (var_cas_categoryMethodKind).operator_isNotEqual (GGS_categoryMethodKind::constructor_overridingMethod (inLexique COMMA_HERE)) ;
                    if (cond_241674.isBuiltAndTrue ()) {
                      var_cas_outCategoryReaderClassBaseName = var_cas_className ;
                    }
                  }
                  {
                    GGS_typeSuperClassesMap::cEnumerator enumerator_241718 (var_cas_t.reader_mAncestorClassesMap (inLexique COMMA_SOURCE_FILE_AT_LINE (5297)), true) ;
                    const GGS_typeSuperClassesMap::cElement * operand_241718 = NULL ;
                    while (((operand_241718 = enumerator_241718.nextObject ()))
                        && ((var_cas_outCategoryReaderClassBaseName).operator_isEqual (GGS_string ("")).isBuiltAndTrue ())) {
                      macroValidPointer (operand_241718) ;
                      GGS_lstring  var_cas_superKey = GGS_lstring ::constructor_new (inLexique, ((operand_241718->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5298))).operator_concat (GGS_string (":"))).operator_concat (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5298))), var_cas_inReaderName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (5298)) COMMA_HERE) ;
                      const GGS_bool cond_242306 = var_cas_inCategoryReaderMap.reader_hasKey (var_cas_superKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5299))) ;
                      if (cond_242306.isBuiltAndTrue ()) {
                        GGS_categoryMethodKind var_cas_categoryMethodKind ;
                        const GGS_EXcategoryReaderMap  temp_242061 = var_cas_inCategoryReaderMap ;
                        if (temp_242061.isBuilt ()) {
                          temp_242061 (HERE)->method_searchKey (inLexique, var_cas_superKey, var_cas_categoryMethodKind, var_cas_signature, var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (5301)) ;
                        }
                        const GGS_bool cond_242285 = (var_cas_categoryMethodKind).operator_isNotEqual (GGS_categoryMethodKind::constructor_overridingMethod (inLexique COMMA_HERE)) ;
                        if (cond_242285.isBuiltAndTrue ()) {
                          var_cas_outCategoryReaderClassBaseName = var_cas_className ;
                        }
                      }
                    }
                  }
                  var_cas_found = (var_cas_outCategoryReaderClassBaseName).operator_isNotEqual (GGS_string ("")) ;
                  {
                    GGS_L_EXsignature::cEnumerator enumerator_242421 (var_cas_signature, true) ;
                    const GGS_L_EXsignature::cElement * operand_242421 = NULL ;
                    while (((operand_242421 = enumerator_242421.nextObject ()))) {
                      macroValidPointer (operand_242421) ;
                      var_cas_outAccessorTypesList.addAssign_operation (operand_242421->mType, GGS_lstring ::constructor_new (inLexique, GGS_string ("\?"), GGS_location (inLexique) COMMA_HERE)) ;
                    }
                  }
                }
                const GGS_bool cond_242647 = (var_cas_found).operator_not () ;
                if (cond_242647.isBuiltAndTrue ()) {
                  var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (5315)) ;
                }
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgasStructType *> (_var_245063.getPtr ()) != NULL) {
        const GGS_typeGalgasStructType var_cas_t (_var_245063.getPtr ()) ;
        const GGS_bool cond_242956 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5319))).operator_isEqual (GGS_string ("description")) ;
        if (cond_242956.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_242956.isBuiltAndFalse ()) {
          const GGS_bool cond_243183 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5323))).operator_isEqual (GGS_string ("object")) ;
          if (cond_243183.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_243183.isBuiltAndFalse ()) {
            const GGS_bool cond_243412 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5327))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_243412.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_243412.isBuiltAndFalse ()) {
              var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              GGS_bool var_cas_found = GGS_bool (false) ;
              {
                GGS_typeListeAttributsSemantiques::cEnumerator enumerator_243596 (var_cas_t.reader_mAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (5335)), true) ;
                const GGS_typeListeAttributsSemantiques::cElement * operand_243596 = NULL ;
                while (((operand_243596 = enumerator_243596.nextObject ()))
                    && ((var_cas_found).operator_not ().isBuiltAndTrue ())) {
                  macroValidPointer (operand_243596) ;
                  var_cas_outReturnedType = operand_243596->mAttributType ;
                  var_cas_found = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5337))).operator_isEqual (operand_243596->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5337))) ;
                }
              }
              const GGS_bool cond_243902 = (var_cas_found).operator_not () ;
              if (cond_243902.isBuiltAndTrue ()) {
                var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this reader is not defined (you can name as reader any struct attribute)") COMMA_SOURCE_FILE_AT_LINE (5341)) ;
              }
            }
          }
        }
      }else if (dynamic_cast <cPtr_typeGalgas_enum *> (_var_245063.getPtr ()) != NULL) {
        const GGS_typeGalgas_enum var_cas_e (_var_245063.getPtr ()) ;
        const GGS_bool cond_244191 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5344))).operator_isEqual (GGS_string ("description")) ;
        if (cond_244191.isBuiltAndTrue ()) {
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
        }else if (cond_244191.isBuiltAndFalse ()) {
          const GGS_bool cond_244418 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5348))).operator_isEqual (GGS_string ("object")) ;
          if (cond_244418.isBuiltAndTrue ()) {
            var_cas_outReturnedType = GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
          }else if (cond_244418.isBuiltAndFalse ()) {
            const GGS_bool cond_244647 = (var_cas_inReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5352))).operator_isEqual (GGS_string ("dynamicType")) ;
            if (cond_244647.isBuiltAndTrue ()) {
              var_cas_outReturnedType = GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) ;
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outHasLexiqueAndLocationArguments = GGS_bool (false) ;
            }else if (cond_244647.isBuiltAndFalse ()) {
              GGS_typeEnumMessageMap  var_cas_kMessagesMap = var_cas_e.reader_mMessagesMap (inLexique COMMA_SOURCE_FILE_AT_LINE (5357)) ;
              GGS_lstringlist  automatic_var_244757_0 ;
              const GGS_typeEnumMessageMap  temp_244738 = var_cas_kMessagesMap ;
              if (temp_244738.isBuilt ()) {
                temp_244738 (HERE)->method_searchKey (inLexique, var_cas_inReaderName, automatic_var_244757_0 COMMA_SOURCE_FILE_AT_LINE (5358)) ;
              }
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
              var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) ;
            }
          }
        }
      }else{
        var_cas_inReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("variables of this type do not support reader call") COMMA_SOURCE_FILE_AT_LINE (5366)) ;
        var_cas_outAccessorTypesList.drop () ;
        var_cas_outReturnedType.drop () ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_handleReaderCall\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "importSemanticsComponent"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_importSemanticsComponent (C_Compiler & inLexique,
                                GGS_M_semanticsComponents  & var_cas_ioSemanticsComponentsMap,
                                GGS_ModelMap  & var_cas_ioModelMap,
                                GGS_ActionMap  & var_cas_ioActionMap,
                                GGS_stringset  & var_cas_ioAlreadyImportedSemanticsComponents,
                                GGS_stringset  & var_cas_ioAlreadyImportedMetamodelComponents,
                                GGS_lstring   var_cas_inSemanticsComponentName COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_importSemanticsComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_bool cond_247526 = (var_cas_ioAlreadyImportedSemanticsComponents.reader_hasKey (var_cas_inSemanticsComponentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5391)))).operator_not () ;
  if (cond_247526.isBuiltAndTrue ()) {
    GGS_ModelMap  var_cas_modelMap ;
    GGS_ActionMap  var_cas_actionMap ;
    GGS_stringset  var_cas_importedSemanticsComponents ;
    GGS_stringset  var_cas_importedMetamodelComponents ;
    GGS_stringset  var_cas_importedOptionsComponents ;
    GGS_M_optionComponents  automatic_var_246523_0 ;
    GGS_M_semanticsEntitiesForUse  automatic_var_246523_1 ;
    const GGS_M_semanticsComponents  temp_246331 = var_cas_ioSemanticsComponentsMap ;
    if (temp_246331.isBuilt ()) {
      temp_246331 (HERE)->method_searchKey (inLexique, var_cas_inSemanticsComponentName, var_cas_modelMap, var_cas_actionMap, var_cas_importedSemanticsComponents, var_cas_importedMetamodelComponents, var_cas_importedOptionsComponents, automatic_var_246523_0, automatic_var_246523_1 COMMA_SOURCE_FILE_AT_LINE (5397)) ;
    }
    var_cas_ioAlreadyImportedMetamodelComponents = (var_cas_ioAlreadyImportedMetamodelComponents).operator_or (var_cas_importedMetamodelComponents) ;
    {
      GGS_stringset::cEnumerator enumerator_246762 (var_cas_importedSemanticsComponents, true) ;
      while (enumerator_246762.hasCurrentObject ()) {
        ::routine_importSemanticsComponent (inLexique,  var_cas_ioSemanticsComponentsMap,  var_cas_ioModelMap,  var_cas_ioActionMap,  var_cas_ioAlreadyImportedSemanticsComponents,  var_cas_ioAlreadyImportedMetamodelComponents,  GGS_lstring ::constructor_new (inLexique, enumerator_246762._key (HERE), GGS_location (inLexique) COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (5411)) ;
        enumerator_246762.next () ;
      }
    }
    {
      GGS_ModelMap::cEnumerator enumerator_247076 (var_cas_modelMap, true) ;
      const GGS_ModelMap::cElement * operand_247076 = NULL ;
      while (((operand_247076 = enumerator_247076.nextObject ()))) {
        macroValidPointer (operand_247076) ;
        const GGS_bool cond_247188 = (var_cas_ioModelMap.reader_hasKey (operand_247076->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5422)))).operator_not () ;
        if (cond_247188.isBuiltAndTrue ()) {
          var_cas_ioModelMap.modifier_insertKey (inLexique, operand_247076->mKey, operand_247076->mInfo.mType COMMA_SOURCE_FILE_AT_LINE (5423)) ;
        }
      }
    }
    {
      GGS_ActionMap::cEnumerator enumerator_247252 (var_cas_actionMap, true) ;
      const GGS_ActionMap::cElement * operand_247252 = NULL ;
      while (((operand_247252 = enumerator_247252.nextObject ()))) {
        macroValidPointer (operand_247252) ;
        const GGS_bool cond_247382 = (var_cas_ioActionMap.reader_hasKey (operand_247252->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5428)))).operator_not () ;
        if (cond_247382.isBuiltAndTrue ()) {
          var_cas_ioActionMap.modifier_insertKey (inLexique, operand_247252->mKey, operand_247252->mInfo.mSignature, operand_247252->mInfo.mIsExtern COMMA_SOURCE_FILE_AT_LINE (5429)) ;
        }
      }
    }
    var_cas_ioAlreadyImportedSemanticsComponents.addAssign_operation (var_cas_inSemanticsComponentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5433))) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_importSemanticsComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "enterBuiltinTypes"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterBuiltinTypes (C_Compiler & inLexique,
                                GGS_M_semanticsEntitiesForUse  & var_cas_ioComponentSemanticsEntitiesMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_enterBuiltinTypes at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioComponentSemanticsEntitiesMap = GGS_M_semanticsEntitiesForUse ::constructor_emptyMap (inLexique COMMA_HERE) ;
  GGS_AC_semanticsEntity  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_lstring ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5447)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_lbool ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lbool"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5450)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_luint ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("luint"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5453)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_lsint ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lsint"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5456)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_luint64 ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("luint64"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5459)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_lsint64 ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lsint64"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5462)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_ldouble ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("ldouble"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5465)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_lchar ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lchar"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5468)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_location ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("location"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5471)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_uint ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5474)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_sint ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("sint"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5477)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_uint64 ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint64"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5480)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_sint64 ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("sint64"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5483)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_char ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("char"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5486)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_string ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5489)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_bool ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("bool"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5492)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_binaryset ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("binaryset"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5495)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_double ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("double"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5498)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_stringset ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("stringset"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5501)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_filewrapper ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("filewrapper"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5504)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_data ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("data"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5507)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_type ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("type"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5510)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_object ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("object"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5513)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, GGS_typeGalgas_function ::constructor_new (inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("function"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5516)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, function_EXbuild_uintlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5518)) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uintlist"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5519)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, function_EXbuild_luintlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5521)) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("luintlist"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5522)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, function_EXbuild_uint64list_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5524)) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint64list"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5525)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, function_EXbuild_charlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5527)) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("charlist"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5528)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, function_EXbuild_lcharlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5530)) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lcharlist"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5531)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, function_EXbuild_stringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5533)) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("stringlist"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5534)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, function_EXbuild_lstringlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5536)) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstringlist"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5537)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, function_EXbuild_string2list_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5539)) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string2list"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5540)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, function_EXbuild_string3list_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5542)) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string3list"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5543)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, function_EXbuild_typelist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5545)) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("typelist"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5546)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, function_EXbuild_objectlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5548)) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("objectlist"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5549)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (inLexique, function_EXbuild_functionlist_type (inLexique COMMA_SOURCE_FILE_AT_LINE (5551)) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("functionlist"), GGS_location (inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (5552)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_enterBuiltinTypes\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_templateInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstruction::
cPtr_templateInstruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstruction * GGS_templateInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_templateInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_templateInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@templateInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstruction (& typeid (cPtr_templateInstruction), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_templateInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstruction ("templateInstruction", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_templateInstruction::
GGS_templateInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstruction::
GGS_templateInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstruction GGS_templateInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstruction::actualTypeName (void) const {
  return "templateInstruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_templateInstruction::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__templateInstruction ("templateInstruction", & kTypeDescriptor_GGS_templateInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstruction * p = NULL ;
    macroMyNew (p, GGS_templateInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstruction GGS_templateInstruction::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstruction * p = dynamic_cast <const GGS_templateInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@templateInstructionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_templateInstructionList::
elementOf_GGS_templateInstructionList (const GGS_templateInstruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateInstructionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_templateInstructionList * ptr = dynamic_cast <const elementOf_GGS_templateInstructionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateInstructionList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@templateInstructionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionList ("templateInstructionList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
internalAppendValues (const GGS_templateInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
internalPrependValues (const GGS_templateInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
addAssign_operation (const GGS_templateInstruction & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionList GGS_templateInstructionList::
operator_concat (const GGS_templateInstructionList & inOperand) const {
  GGS_templateInstructionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
dotAssign_operation (const GGS_templateInstructionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_templateInstructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_templateInstruction  p_0 = p->mInstruction ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_templateInstruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionList  GGS_templateInstructionList::
constructor_emptyList (void) {
  GGS_templateInstructionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionList  GGS_templateInstructionList::
constructor_listWithValue (const GGS_templateInstruction & argument_0) {
  GGS_templateInstructionList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
internalSubListWithRange (GGS_templateInstructionList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionList GGS_templateInstructionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionList GGS_templateInstructionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@templateInstructionList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
method_first (C_Compiler & inLexique,
              GGS_templateInstruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
method_last (C_Compiler & inLexique,
             GGS_templateInstruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_templateInstruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_templateInstruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstruction  GGS_templateInstructionList::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_templateInstruction  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_templateInstruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_templateInstruction  & GGS_templateInstructionList::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionList * p = NULL ;
    macroMyNew (p, GGS_templateInstructionList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionList GGS_templateInstructionList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionList * p = dynamic_cast <const GGS_templateInstructionList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExpression::
cPtr_typeExpression (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeExpression * GGS_typeExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeExpression (& typeid (cPtr_typeExpression), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeExpression ("typeExpression", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeExpression GGS_typeExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeExpression::actualTypeName (void) const {
  return "typeExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_typeExpression::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__typeExpression ("typeExpression", & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeExpression * p = NULL ;
    macroMyNew (p, GGS_typeExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression GGS_typeExpression::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeExpression * p = dynamic_cast <const GGS_typeExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_templateInstructionString'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionString::
cPtr_templateInstructionString (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstruction (THERE),
mTemplateString (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionString * GGS_templateInstructionString::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionString *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_templateInstructionString *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionString::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionString * ptr = dynamic_cast <const cPtr_templateInstructionString *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTemplateString.operator_isEqual (ptr->mTemplateString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionString::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionString:"
           << mTemplateString.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionString::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionString::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionString (& typeid (cPtr_templateInstructionString), & typeid (cPtr_templateInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionString::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionString ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionString::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionString (mTemplateString COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_templateInstructionString'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionString ("templateInstructionString", true, & kTypeDescriptor_GGS_templateInstruction) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionString::
GGS_templateInstructionString (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionString::
GGS_templateInstructionString (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionString GGS_templateInstructionString::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionString result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionString *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionString) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionString (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionString),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionString GGS_templateInstructionString::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionString result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionString (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionString::actualTypeName (void) const {
  return "templateInstructionString" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionString ("templateInstructionString", gClassInfoFor__templateInstruction, & kTypeDescriptor_GGS_templateInstructionString) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionString::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionString * p = NULL ;
    macroMyNew (p, GGS_templateInstructionString (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionString GGS_templateInstructionString::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionString result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionString * p = dynamic_cast <const GGS_templateInstructionString *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionString, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionString::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionString ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_templateInstructionExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionExpression::
cPtr_templateInstructionExpression (const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstruction (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionExpression * GGS_templateInstructionExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_templateInstructionExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionExpression * ptr = dynamic_cast <const cPtr_templateInstructionExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionExpression:"
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionExpression (& typeid (cPtr_templateInstructionExpression), & typeid (cPtr_templateInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionExpression::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionExpression (mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_templateInstructionExpression'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionExpression ("templateInstructionExpression", true, & kTypeDescriptor_GGS_templateInstruction) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionExpression::
GGS_templateInstructionExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionExpression::
GGS_templateInstructionExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionExpression GGS_templateInstructionExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionExpression *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionExpression GGS_templateInstructionExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionExpression result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionExpression::actualTypeName (void) const {
  return "templateInstructionExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionExpression ("templateInstructionExpression", gClassInfoFor__templateInstruction, & kTypeDescriptor_GGS_templateInstructionExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionExpression * p = NULL ;
    macroMyNew (p, GGS_templateInstructionExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionExpression GGS_templateInstructionExpression::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionExpression * p = dynamic_cast <const GGS_templateInstructionExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_templateBlockInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateBlockInstruction::
cPtr_templateBlockInstruction (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_templateInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstruction (THERE),
mExpression (argument_0),
mMagicNumber (argument_1),
mBlockInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateBlockInstruction * GGS_templateBlockInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateBlockInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_templateBlockInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateBlockInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateBlockInstruction * ptr = dynamic_cast <const cPtr_templateBlockInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mMagicNumber.operator_isEqual (ptr->mMagicNumber).boolValue ()
         && mBlockInstructionList.operator_isEqual (ptr->mBlockInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateBlockInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateBlockInstruction:"
           << mExpression.reader_description (inIndentation + 1)
           << mMagicNumber.reader_description (inIndentation + 1)
           << mBlockInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateBlockInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateBlockInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateBlockInstruction (& typeid (cPtr_templateBlockInstruction), & typeid (cPtr_templateInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateBlockInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__templateBlockInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateBlockInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateBlockInstruction (mExpression, mMagicNumber, mBlockInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_templateBlockInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateBlockInstruction ("templateBlockInstruction", true, & kTypeDescriptor_GGS_templateInstruction) ;

//---------------------------------------------------------------------------*

GGS_templateBlockInstruction::
GGS_templateBlockInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateBlockInstruction::
GGS_templateBlockInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateBlockInstruction GGS_templateBlockInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateBlockInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateBlockInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_templateBlockInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateBlockInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateBlockInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateBlockInstruction GGS_templateBlockInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_location & argument_1,
                 const GGS_templateInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateBlockInstruction result ;
  macroMyNew (result.mPointer, cPtr_templateBlockInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateBlockInstruction::actualTypeName (void) const {
  return "templateBlockInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateBlockInstruction ("templateBlockInstruction", gClassInfoFor__templateInstruction, & kTypeDescriptor_GGS_templateBlockInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateBlockInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateBlockInstruction * p = NULL ;
    macroMyNew (p, GGS_templateBlockInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateBlockInstruction GGS_templateBlockInstruction::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateBlockInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateBlockInstruction * p = dynamic_cast <const GGS_templateBlockInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateBlockInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateBlockInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateBlockInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_templateInstructionConstant'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionConstant::
cPtr_templateInstructionConstant (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstruction (THERE),
mCppName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionConstant * GGS_templateInstructionConstant::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionConstant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_templateInstructionConstant *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionConstant::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionConstant * ptr = dynamic_cast <const cPtr_templateInstructionConstant *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCppName.operator_isEqual (ptr->mCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionConstant::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionConstant:"
           << mCppName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionConstant::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionConstant::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionConstant (& typeid (cPtr_templateInstructionConstant), & typeid (cPtr_templateInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionConstant::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionConstant ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionConstant::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionConstant (mCppName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_templateInstructionConstant'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionConstant ("templateInstructionConstant", true, & kTypeDescriptor_GGS_templateInstruction) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionConstant::
GGS_templateInstructionConstant (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionConstant::
GGS_templateInstructionConstant (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionConstant GGS_templateInstructionConstant::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionConstant result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionConstant *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionConstant) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionConstant (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionConstant),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionConstant GGS_templateInstructionConstant::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionConstant result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionConstant (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionConstant::actualTypeName (void) const {
  return "templateInstructionConstant" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionConstant ("templateInstructionConstant", gClassInfoFor__templateInstruction, & kTypeDescriptor_GGS_templateInstructionConstant) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionConstant::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionConstant * p = NULL ;
    macroMyNew (p, GGS_templateInstructionConstant (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionConstant GGS_templateInstructionConstant::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionConstant result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionConstant * p = dynamic_cast <const GGS_templateInstructionConstant *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionConstant, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionConstant::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionConstant ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_templateInstructionColumnString'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionColumnString::
cPtr_templateInstructionColumnString (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstruction (THERE),
mCppName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionColumnString * GGS_templateInstructionColumnString::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionColumnString *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_templateInstructionColumnString *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionColumnString::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionColumnString * ptr = dynamic_cast <const cPtr_templateInstructionColumnString *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCppName.operator_isEqual (ptr->mCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionColumnString::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionColumnString:"
           << mCppName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionColumnString::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionColumnString::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionColumnString (& typeid (cPtr_templateInstructionColumnString), & typeid (cPtr_templateInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionColumnString::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionColumnString ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionColumnString::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionColumnString (mCppName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_templateInstructionColumnString'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionColumnString ("templateInstructionColumnString", true, & kTypeDescriptor_GGS_templateInstruction) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionColumnString::
GGS_templateInstructionColumnString (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionColumnString::
GGS_templateInstructionColumnString (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionColumnString GGS_templateInstructionColumnString::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionColumnString result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionColumnString *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionColumnString) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionColumnString (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionColumnString),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionColumnString GGS_templateInstructionColumnString::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionColumnString result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionColumnString (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionColumnString::actualTypeName (void) const {
  return "templateInstructionColumnString" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionColumnString ("templateInstructionColumnString", gClassInfoFor__templateInstruction, & kTypeDescriptor_GGS_templateInstructionColumnString) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionColumnString::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionColumnString * p = NULL ;
    macroMyNew (p, GGS_templateInstructionColumnString (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionColumnString GGS_templateInstructionColumnString::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionColumnString result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionColumnString * p = dynamic_cast <const GGS_templateInstructionColumnString *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionColumnString, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionColumnString::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionColumnString ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_templateInstructionForeach'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionForeach::
cPtr_templateInstructionForeach (const GGS_bool& argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_location & argument_4,
                                const GGS_templateInstructionList & argument_5,
                                const GGS_templateInstructionList & argument_6,
                                const GGS_lstring & argument_7,
                                const GGS_templateInstructionList & argument_8,
                                const GGS_templateInstructionList & argument_9
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstruction (THERE),
mIsAscending (argument_0),
mCppExpressionTypeName (argument_1),
mNewEnumerationStyle (argument_2),
mExpression (argument_3),
mInstructionLocation (argument_4),
mBeforeInstructionList (argument_5),
mDoInstructionList (argument_6),
mIndexIdentifier (argument_7),
mBetweenInstructionList (argument_8),
mAfterInstructionList (argument_9) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionForeach * GGS_templateInstructionForeach::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeach *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_templateInstructionForeach *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionForeach::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionForeach * ptr = dynamic_cast <const cPtr_templateInstructionForeach *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAscending.operator_isEqual (ptr->mIsAscending).boolValue ()
         && mCppExpressionTypeName.operator_isEqual (ptr->mCppExpressionTypeName).boolValue ()
         && mNewEnumerationStyle.operator_isEqual (ptr->mNewEnumerationStyle).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mBeforeInstructionList.operator_isEqual (ptr->mBeforeInstructionList).boolValue ()
         && mDoInstructionList.operator_isEqual (ptr->mDoInstructionList).boolValue ()
         && mIndexIdentifier.operator_isEqual (ptr->mIndexIdentifier).boolValue ()
         && mBetweenInstructionList.operator_isEqual (ptr->mBetweenInstructionList).boolValue ()
         && mAfterInstructionList.operator_isEqual (ptr->mAfterInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionForeach::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionForeach:"
           << mIsAscending.reader_description (inIndentation + 1)
           << mCppExpressionTypeName.reader_description (inIndentation + 1)
           << mNewEnumerationStyle.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1)
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mBeforeInstructionList.reader_description (inIndentation + 1)
           << mDoInstructionList.reader_description (inIndentation + 1)
           << mIndexIdentifier.reader_description (inIndentation + 1)
           << mBetweenInstructionList.reader_description (inIndentation + 1)
           << mAfterInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionForeach::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionForeach::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionForeach (& typeid (cPtr_templateInstructionForeach), & typeid (cPtr_templateInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionForeach::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionForeach ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionForeach::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionForeach (mIsAscending, mCppExpressionTypeName, mNewEnumerationStyle, mExpression, mInstructionLocation, mBeforeInstructionList, mDoInstructionList, mIndexIdentifier, mBetweenInstructionList, mAfterInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_templateInstructionForeach'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionForeach ("templateInstructionForeach", true, & kTypeDescriptor_GGS_templateInstruction) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionForeach::
GGS_templateInstructionForeach (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionForeach::
GGS_templateInstructionForeach (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionForeach GGS_templateInstructionForeach::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionForeach result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionForeach *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionForeach) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionForeach (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionForeach),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionForeach GGS_templateInstructionForeach::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_string& argument_1,
                 const GGS_bool& argument_2,
                 const GGS_typeExpression & argument_3,
                 const GGS_location & argument_4,
                 const GGS_templateInstructionList & argument_5,
                 const GGS_templateInstructionList & argument_6,
                 const GGS_lstring & argument_7,
                 const GGS_templateInstructionList & argument_8,
                 const GGS_templateInstructionList & argument_9
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionForeach result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionForeach (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionForeach::actualTypeName (void) const {
  return "templateInstructionForeach" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionForeach ("templateInstructionForeach", gClassInfoFor__templateInstruction, & kTypeDescriptor_GGS_templateInstructionForeach) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionForeach::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionForeach * p = NULL ;
    macroMyNew (p, GGS_templateInstructionForeach (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionForeach GGS_templateInstructionForeach::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionForeach result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionForeach * p = dynamic_cast <const GGS_templateInstructionForeach *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionForeach, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionForeach::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionForeach ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@templateInstructionIfBranchList'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_templateInstructionIfBranchList::
elementOf_GGS_templateInstructionIfBranchList (const GGS_typeExpression & argument_0,
                                const GGS_templateInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mExpression (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateInstructionIfBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_templateInstructionIfBranchList * ptr = dynamic_cast <const elementOf_GGS_templateInstructionIfBranchList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateInstructionIfBranchList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@templateInstructionIfBranchList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionIfBranchList ("templateInstructionIfBranchList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchList::
internalAppendValues (const GGS_typeExpression & argument_0,
                    const GGS_templateInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchList::
internalPrependValues (const GGS_typeExpression & argument_0,
                    const GGS_templateInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchList::
addAssign_operation (const GGS_typeExpression & argument_0,
                                const GGS_templateInstructionList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchList GGS_templateInstructionIfBranchList::
operator_concat (const GGS_templateInstructionIfBranchList & inOperand) const {
  GGS_templateInstructionIfBranchList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchList::
dotAssign_operation (const GGS_templateInstructionIfBranchList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_templateInstructionIfBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeExpression  p_0 = p->mExpression ;
          GGS_templateInstructionList  p_1 = p->mInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeExpression & argument_0,
                     const GGS_templateInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mExpression,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchList  GGS_templateInstructionIfBranchList::
constructor_emptyList (void) {
  GGS_templateInstructionIfBranchList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchList  GGS_templateInstructionIfBranchList::
constructor_listWithValue (const GGS_typeExpression & argument_0,
                                const GGS_templateInstructionList & argument_1) {
  GGS_templateInstructionIfBranchList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchList::
internalSubListWithRange (GGS_templateInstructionIfBranchList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mExpression, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchList GGS_templateInstructionIfBranchList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionIfBranchList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchList GGS_templateInstructionIfBranchList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionIfBranchList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionIfBranchList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@templateInstructionIfBranchList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchList::
method_first (C_Compiler & inLexique,
              GGS_typeExpression & _out_0,
              GGS_templateInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchList::
method_last (C_Compiler & inLexique,
             GGS_typeExpression & _out_0,
             GGS_templateInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeExpression & _out_0,
                 GGS_templateInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mInstructionList ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchList::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeExpression & _out_0,
                GGS_templateInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mInstructionList ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_templateInstructionIfBranchList::
reader_mExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionList  GGS_templateInstructionIfBranchList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchList::
modifier_setMExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_typeExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_templateInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeExpression  & GGS_templateInstructionIfBranchList::cEnumerator::_mExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_templateInstructionList  & GGS_templateInstructionIfBranchList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionIfBranchList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionIfBranchList * p = NULL ;
    macroMyNew (p, GGS_templateInstructionIfBranchList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchList GGS_templateInstructionIfBranchList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionIfBranchList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionIfBranchList * p = dynamic_cast <const GGS_templateInstructionIfBranchList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionIfBranchList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionIfBranchList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionIfBranchList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_templateInstructionIf'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionIf::
cPtr_templateInstructionIf (const GGS_templateInstructionIfBranchList & argument_0,
                                const GGS_templateInstructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstruction (THERE),
mTemplateInstructionIfBranchList (argument_0),
mElseInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionIf * GGS_templateInstructionIf::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionIf *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_templateInstructionIf *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionIf::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionIf * ptr = dynamic_cast <const cPtr_templateInstructionIf *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTemplateInstructionIfBranchList.operator_isEqual (ptr->mTemplateInstructionIfBranchList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionIf::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionIf:"
           << mTemplateInstructionIfBranchList.reader_description (inIndentation + 1)
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionIf::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionIf::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionIf (& typeid (cPtr_templateInstructionIf), & typeid (cPtr_templateInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionIf::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionIf ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionIf::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionIf (mTemplateInstructionIfBranchList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_templateInstructionIf'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionIf ("templateInstructionIf", true, & kTypeDescriptor_GGS_templateInstruction) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionIf::
GGS_templateInstructionIf (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIf::
GGS_templateInstructionIf (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionIf GGS_templateInstructionIf::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionIf result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionIf *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionIf) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionIf (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionIf),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIf GGS_templateInstructionIf::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_templateInstructionIfBranchList & argument_0,
                 const GGS_templateInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionIf result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionIf (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionIf::actualTypeName (void) const {
  return "templateInstructionIf" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionIf ("templateInstructionIf", gClassInfoFor__templateInstruction, & kTypeDescriptor_GGS_templateInstructionIf) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionIf::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionIf * p = NULL ;
    macroMyNew (p, GGS_templateInstructionIf (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIf GGS_templateInstructionIf::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionIf result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionIf * p = dynamic_cast <const GGS_templateInstructionIf *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionIf, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionIf::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionIf ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of 'EXsemanticContext' struct                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EXsemanticContext ("EXsemanticContext", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_EXsemanticContext::GGS_EXsemanticContext (void) :
mFilewrappers (),
mImportedSemanticComponents (),
mCategoryMethodMap (),
mCategoryReaderMap (),
mCategoryTemplateMap () {
}

//---------------------------------------------------------------------------*

GGS_EXsemanticContext::~GGS_EXsemanticContext (void) {
}

//---------------------------------------------------------------------------*

void GGS_EXsemanticContext::drop (void) {
  mFilewrappers.drop () ;
  mImportedSemanticComponents.drop () ;
  mCategoryMethodMap.drop () ;
  mCategoryReaderMap.drop () ;
  mCategoryTemplateMap.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_EXsemanticContext::isBuilt (void) const {
  return mFilewrappers.isBuilt ()
    && mImportedSemanticComponents.isBuilt ()
    && mCategoryMethodMap.isBuilt ()
    && mCategoryReaderMap.isBuilt ()
    && mCategoryTemplateMap.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsemanticContext::
operator_isEqual (const GGS_EXsemanticContext & inOperand) const {
  return mFilewrappers.operator_isEqual (inOperand.mFilewrappers)
    .operator_and (mImportedSemanticComponents.operator_isEqual (inOperand.mImportedSemanticComponents))
    .operator_and (mCategoryMethodMap.operator_isEqual (inOperand.mCategoryMethodMap))
    .operator_and (mCategoryReaderMap.operator_isEqual (inOperand.mCategoryReaderMap))
    .operator_and (mCategoryTemplateMap.operator_isEqual (inOperand.mCategoryTemplateMap)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsemanticContext::
operator_isNotEqual (const GGS_EXsemanticContext & inOperand) const {
  return mFilewrappers.operator_isNotEqual (inOperand.mFilewrappers)
    .operator_or (mImportedSemanticComponents.operator_isNotEqual (inOperand.mImportedSemanticComponents))
    .operator_or (mCategoryMethodMap.operator_isNotEqual (inOperand.mCategoryMethodMap))
    .operator_or (mCategoryReaderMap.operator_isNotEqual (inOperand.mCategoryReaderMap))
    .operator_or (mCategoryTemplateMap.operator_isNotEqual (inOperand.mCategoryTemplateMap)) ;
}

//---------------------------------------------------------------------------*

GGS_EXsemanticContext GGS_EXsemanticContext::
constructor_new (const GGS_M_filewrappers & argument_0,
                 const GGS_stringset & argument_1,
                 const GGS_EXcategoryMethodMap & argument_2,
                 const GGS_EXcategoryReaderMap & argument_3,
                 const GGS_EXcategoryTemplateMap & argument_4) {
  GGS_EXsemanticContext result ;
  result.mFilewrappers = argument_0 ;
  result.mImportedSemanticComponents = argument_1 ;
  result.mCategoryMethodMap = argument_2 ;
  result.mCategoryReaderMap = argument_3 ;
  result.mCategoryTemplateMap = argument_4 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXsemanticContext::
reader_description (const PMSInt32 inIndentation) const {
  C_String _s ;
  _s << "<struct @EXsemanticContext" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mFilewrappers " ;
    _s << mFilewrappers.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mImportedSemanticComponents " ;
    _s << mImportedSemanticComponents.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mCategoryMethodMap " ;
    _s << mCategoryMethodMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mCategoryReaderMap " ;
    _s << mCategoryReaderMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mCategoryTemplateMap " ;
    _s << mCategoryTemplateMap.reader_description (inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_EXsemanticContext::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EXsemanticContext * p = NULL ;
    macroMyNew (p, GGS_EXsemanticContext (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXsemanticContext GGS_EXsemanticContext::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EXsemanticContext result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EXsemanticContext * p = dynamic_cast <const GGS_EXsemanticContext *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EXsemanticContext, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EXsemanticContext::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EXsemanticContext ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_M_syntaxComponents'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_syntaxComponents::e_M_syntaxComponents (void) :
mNonterminalSymbolsMap (),
mProductionRulesList (),
mLexiqueComponentName () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@M_syntaxComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_syntaxComponents ("M_syntaxComponents", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_syntaxComponents::
elementOf_GGS_M_syntaxComponents (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_syntaxComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_syntaxComponents::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mNonterminalSymbolsMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mProductionRulesList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mLexiqueComponentName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_syntaxComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_syntaxComponents * ptr = dynamic_cast <const elementOf_GGS_M_syntaxComponents *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mNonterminalSymbolsMap.operator_isEqual (ptr->mInfo.mNonterminalSymbolsMap)).boolValue ()
           && (mInfo.mProductionRulesList.operator_isEqual (ptr->mInfo.mProductionRulesList)).boolValue ()
           && (mInfo.mLexiqueComponentName.operator_isEqual (ptr->mInfo.mLexiqueComponentName)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_syntaxComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_syntaxComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_syntaxComponents * info = (e_M_syntaxComponents *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_syntaxComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_syntaxComponents * info = (e_M_syntaxComponents *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_syntaxComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_syntaxComponents info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_syntaxComponents::
operator_isEqual (const GGS_M_syntaxComponents & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_syntaxComponents::
operator_isNotEqual (const GGS_M_syntaxComponents & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_nonTerminalSymbolMapForGrammarAnalysis & inParameter0,
                const GGS_productionRuleListForGrammarAnalysis & inParameter1,
                const GGS_lstring & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_syntaxComponents info  ;
    info.mNonterminalSymbolsMap = inParameter0 ;
    info.mProductionRulesList = inParameter1 ;
    info.mLexiqueComponentName = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_nonTerminalSymbolMapForGrammarAnalysis   & outParameter0,
               GGS_productionRuleListForGrammarAnalysis   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolsMap ;
    outParameter1 = node->mInfo.mProductionRulesList ;
    outParameter2 = node->mInfo.mLexiqueComponentName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_syntaxComponents::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('x'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_nonTerminalSymbolMapForGrammarAnalysis   & outParameter0,
                                GGS_productionRuleListForGrammarAnalysis   & outParameter1,
                                GGS_lstring   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_syntaxComponents::kInsertMessage_insertKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('x'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_nonTerminalSymbolMapForGrammarAnalysis & inParameter0,
                                const GGS_productionRuleListForGrammarAnalysis & inParameter1,
                                const GGS_lstring & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_syntaxComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_syntaxComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_syntaxComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_syntaxComponents::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_syntaxComponents " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_nonTerminalSymbolMapForGrammarAnalysis  & GGS_M_syntaxComponents::cEnumerator::_mNonterminalSymbolsMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mNonterminalSymbolsMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_productionRuleListForGrammarAnalysis  & GGS_M_syntaxComponents::cEnumerator::_mProductionRulesList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mProductionRulesList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_M_syntaxComponents::cEnumerator::_mLexiqueComponentName (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mLexiqueComponentName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_syntaxComponents::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_syntaxComponents * p = NULL ;
    macroMyNew (p, GGS_M_syntaxComponents (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_syntaxComponents result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_syntaxComponents * p = dynamic_cast <const GGS_M_syntaxComponents *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_syntaxComponents, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_syntaxComponents::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_syntaxComponents ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void epilogueRoutineFor_common_semantics (void) {
  gCachedResultForOnceFunction_EXbuild_uintlist_type.drop () ;
  gCachedResultForOnceFunction_EXbuild_luintlist_type.drop () ;
  gCachedResultForOnceFunction_EXbuild_uint64list_type.drop () ;
  gCachedResultForOnceFunction_EXbuild_charlist_type.drop () ;
  gCachedResultForOnceFunction_EXbuild_lcharlist_type.drop () ;
  gCachedResultForOnceFunction_EXbuild_stringlist_type.drop () ;
  gCachedResultForOnceFunction_EXbuild_string2list_type.drop () ;
  gCachedResultForOnceFunction_EXbuild_string3list_type.drop () ;
  gCachedResultForOnceFunction_EXbuild_lstringlist_type.drop () ;
  gCachedResultForOnceFunction_EXbuild_typelist_type.drop () ;
  gCachedResultForOnceFunction_EXbuild_objectlist_type.drop () ;
  gCachedResultForOnceFunction_EXbuild_functionlist_type.drop () ;
  gCachedResultForOnceFunction_stringReaderMap.drop () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_common_semantics (NULL,
                                   epilogueRoutineFor_common_semantics) ;

//---------------------------------------------------------------------------*

