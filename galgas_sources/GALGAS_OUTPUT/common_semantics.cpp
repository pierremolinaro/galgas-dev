//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'common_semantics.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      march 23th, 2006, at 15h21'48"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "common_semantics.h"


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//           Class for 'actualParametersPassingMode' Enumeration             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator == (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator != (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator <= (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator >= (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator < (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator > (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParametersPassingMode::
reader_actualArgumentMessage (void) const {
  const char * kMessages [4] = {"",
    "an output (!) actual parameter",
    "an output/input (!\?) actual parameter",
    "an input (\?) actual parameter"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParametersPassingMode::
reader_description (void) const {
  C_String s ;
  s << "<enum @actualParametersPassingMode" ;
  switch (mValue) {
case enum_parameterOut:
  s << " parameterOut" ;
    break ;
case enum_parameterOutIn:
  s << " parameterOutIn" ;
    break ;
case enum_parameterIn:
  s << " parameterIn" ;
    break ;
  case kNotBuilt:
    s << " (not built)" ;
    break ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Class for 'formalArgumentPassingMode' Enumeration              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator == (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator != (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator <= (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator >= (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator < (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator > (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingMode::
reader_formalArgumentMessage (void) const {
  const char * kMessages [5] = {"",
    "an input (\?) formal argument",
    "an output (!) formal argument",
    "an input/output (\?!) argument",
    "a constant input (\?\?) formal argument"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingMode::
reader_description (void) const {
  C_String s ;
  s << "<enum @formalArgumentPassingMode" ;
  switch (mValue) {
case enum_argumentIn:
  s << " argumentIn" ;
    break ;
case enum_argumentOut:
  s << " argumentOut" ;
    break ;
case enum_argumentInOut:
  s << " argumentInOut" ;
    break ;
case enum_argumentConstantIn:
  s << " argumentConstantIn" ;
    break ;
  case kNotBuilt:
    s << " (not built)" ;
    break ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@L_signature'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_signature::
elementOf_GGS_L_signature (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (elementOf_GGS_L_signature *) NULL ;
  mFormalArgumentPassingMode = argument_0 ;
  mGalgasTypeName = argument_1 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_signature::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mFormalArgumentPassingMode.reader_description () ;
  ioString << mGalgasTypeName.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@L_signature'                             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_signature
::GGS_L_signature (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_L_signature
::GGS_L_signature (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_signature::~GGS_L_signature (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_signature::GGS_L_signature (const GGS_L_signature & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature
::operator = (const GGS_L_signature & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
internalAppendItem (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
addAssign_operation (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mFormalArgumentPassingMode,
                                p->mGalgasTypeName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_signature  GGS_L_signature::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_signature result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_signature::reader_description (void) const {
  C_String s ;
  s << "<list @L_signature" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_signature
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@typeListModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListModel::
elementOf_GGS_typeListModel (const GGS_lstring & argument_0) {
  mNextItem = (elementOf_GGS_typeListModel *) NULL ;
  mTypeName = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListModel::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mTypeName.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@typeListModel'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListModel
::GGS_typeListModel (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_typeListModel
::GGS_typeListModel (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeListModel::~GGS_typeListModel (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel::GGS_typeListModel (const GGS_typeListModel & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel
::operator = (const GGS_typeListModel & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mTypeName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_typeListModel::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeListModel result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListModel::reader_description (void) const {
  C_String s ;
  s << "<list @typeListModel" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeListModel
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_TypeModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_TypeModel::
cPtr_TypeModel (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_TypeModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (void) {
  mPointer = (cPtr_TypeModel *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (const GGS_TypeModel & inOperand) {
  mPointer = (cPtr_TypeModel *) NULL ;
  macroTransfertPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_TypeModel::
~GGS_TypeModel (void) {
  macroDetachPointer (mPointer, cPtr_TypeModel) ;
}

//---------------------------------------------------------------------------*

void GGS_TypeModel::
operator = (const GGS_TypeModel & inOperand) {
  macroTransfertPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_TypeModel::
operator = (cPtr_TypeModel * inSource) {
  macroTransfertPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (cPtr_TypeModel * inSource) {
  mPointer = (cPtr_TypeModel *) NULL ;
  macroTransfertPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_TypeModel * GGS_TypeModel
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_TypeModel
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_TypeModel) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_TypeModel
::reader_description (void) const {
  C_String s ;
  s << "<class @TypeModel" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'BoolModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_BoolModel::cPtr_BoolModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_BoolModel::appendForDescription (C_String & ioString) const {
  ioString << "->@BoolModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_BoolModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_BoolModel * GGS_BoolModel::
    constructor_new (LOCATION_ARGS) {
    cPtr_BoolModel * ptr_ = (cPtr_BoolModel *) NULL ;
    macroMyNew (ptr_, cPtr_BoolModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'CharModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_CharModel::cPtr_CharModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_CharModel::appendForDescription (C_String & ioString) const {
  ioString << "->@CharModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_CharModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_CharModel * GGS_CharModel::
    constructor_new (LOCATION_ARGS) {
    cPtr_CharModel * ptr_ = (cPtr_CharModel *) NULL ;
    macroMyNew (ptr_, cPtr_CharModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'UIntModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_UIntModel::cPtr_UIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_UIntModel::appendForDescription (C_String & ioString) const {
  ioString << "->@UIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_UIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_UIntModel * GGS_UIntModel::
    constructor_new (LOCATION_ARGS) {
    cPtr_UIntModel * ptr_ = (cPtr_UIntModel *) NULL ;
    macroMyNew (ptr_, cPtr_UIntModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'SIntModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_SIntModel::cPtr_SIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_SIntModel::appendForDescription (C_String & ioString) const {
  ioString << "->@SIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_SIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_SIntModel * GGS_SIntModel::
    constructor_new (LOCATION_ARGS) {
    cPtr_SIntModel * ptr_ = (cPtr_SIntModel *) NULL ;
    macroMyNew (ptr_, cPtr_SIntModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'DoubleModel'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_DoubleModel::cPtr_DoubleModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_DoubleModel::appendForDescription (C_String & ioString) const {
  ioString << "->@DoubleModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_DoubleModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_DoubleModel * GGS_DoubleModel::
    constructor_new (LOCATION_ARGS) {
    cPtr_DoubleModel * ptr_ = (cPtr_DoubleModel *) NULL ;
    macroMyNew (ptr_, cPtr_DoubleModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'StringModel'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_StringModel::cPtr_StringModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_StringModel::appendForDescription (C_String & ioString) const {
  ioString << "->@StringModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_StringModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_StringModel * GGS_StringModel::
    constructor_new (LOCATION_ARGS) {
    cPtr_StringModel * ptr_ = (cPtr_StringModel *) NULL ;
    macroMyNew (ptr_, cPtr_StringModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'LBoolModel'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LBoolModel::cPtr_LBoolModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LBoolModel::appendForDescription (C_String & ioString) const {
  ioString << "->@LBoolModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LBoolModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_LBoolModel * GGS_LBoolModel::
    constructor_new (LOCATION_ARGS) {
    cPtr_LBoolModel * ptr_ = (cPtr_LBoolModel *) NULL ;
    macroMyNew (ptr_, cPtr_LBoolModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'LCharModel'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LCharModel::cPtr_LCharModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LCharModel::appendForDescription (C_String & ioString) const {
  ioString << "->@LCharModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LCharModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_LCharModel * GGS_LCharModel::
    constructor_new (LOCATION_ARGS) {
    cPtr_LCharModel * ptr_ = (cPtr_LCharModel *) NULL ;
    macroMyNew (ptr_, cPtr_LCharModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'LUIntModel'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LUIntModel::cPtr_LUIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LUIntModel::appendForDescription (C_String & ioString) const {
  ioString << "->@LUIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LUIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_LUIntModel * GGS_LUIntModel::
    constructor_new (LOCATION_ARGS) {
    cPtr_LUIntModel * ptr_ = (cPtr_LUIntModel *) NULL ;
    macroMyNew (ptr_, cPtr_LUIntModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'LSIntModel'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LSIntModel::cPtr_LSIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LSIntModel::appendForDescription (C_String & ioString) const {
  ioString << "->@LSIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LSIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_LSIntModel * GGS_LSIntModel::
    constructor_new (LOCATION_ARGS) {
    cPtr_LSIntModel * ptr_ = (cPtr_LSIntModel *) NULL ;
    macroMyNew (ptr_, cPtr_LSIntModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'LDoubleModel'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LDoubleModel::cPtr_LDoubleModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LDoubleModel::appendForDescription (C_String & ioString) const {
  ioString << "->@LDoubleModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LDoubleModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_LDoubleModel * GGS_LDoubleModel::
    constructor_new (LOCATION_ARGS) {
    cPtr_LDoubleModel * ptr_ = (cPtr_LDoubleModel *) NULL ;
    macroMyNew (ptr_, cPtr_LDoubleModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'LStringModel'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LStringModel::cPtr_LStringModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LStringModel::appendForDescription (C_String & ioString) const {
  ioString << "->@LStringModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LStringModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_LStringModel * GGS_LStringModel::
    constructor_new (LOCATION_ARGS) {
    cPtr_LStringModel * ptr_ = (cPtr_LStringModel *) NULL ;
    macroMyNew (ptr_, cPtr_LStringModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'StringsetModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_StringsetModel::cPtr_StringsetModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_StringsetModel::appendForDescription (C_String & ioString) const {
  ioString << "->@StringsetModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_StringsetModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_StringsetModel * GGS_StringsetModel::
    constructor_new (LOCATION_ARGS) {
    cPtr_StringsetModel * ptr_ = (cPtr_StringsetModel *) NULL ;
    macroMyNew (ptr_, cPtr_StringsetModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'LocationModel'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LocationModel::cPtr_LocationModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LocationModel::appendForDescription (C_String & ioString) const {
  ioString << "->@LocationModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LocationModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_LocationModel * GGS_LocationModel::
    constructor_new (LOCATION_ARGS) {
    cPtr_LocationModel * ptr_ = (cPtr_LocationModel *) NULL ;
    macroMyNew (ptr_, cPtr_LocationModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'ListModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ListModel::cPtr_ListModel (const GGS_typeListModel & argument_0 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mAttributeList (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_ListModel::appendForDescription (C_String & ioString) const {
  ioString << "->@ListModel:" ;
mAttributeList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_ListModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_ListModel * GGS_ListModel::
    constructor_new (const GGS_typeListModel & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_ListModel * ptr_ = (cPtr_ListModel *) NULL ;
    macroMyNew (ptr_, cPtr_ListModel (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                             class 'MapModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_MapModel::cPtr_MapModel (const GGS_typeListModel & argument_0 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mAttributeList (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_MapModel::appendForDescription (C_String & ioString) const {
  ioString << "->@MapModel:" ;
mAttributeList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_MapModel'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_MapModel * GGS_MapModel::
    constructor_new (const GGS_typeListModel & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_MapModel * ptr_ = (cPtr_MapModel *) NULL ;
    macroMyNew (ptr_, cPtr_MapModel (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'enumConstantMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumConstantMap::
elementOf_GGS_enumConstantMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_enumConstantMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumConstantMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumConstantMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumConstantMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumConstantMap * info = (e_enumConstantMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap GGS_enumConstantMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_enumConstantMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_enumConstantMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey) {
  searchElement (inLexique,
                 "the '%K' constant is not declared",
                 inKey,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey) {
  insertElement (lexique_var_,
                 "the '%K' constant is already declared in %L",
                 inKey,
                 NULL) ;
}

GGS_string GGS_enumConstantMap::reader_description (void) const {
  C_String s ;
  s << "<map @enumConstantMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'enumMessageMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageMap::
elementOf_GGS_enumMessageMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_enumMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumMessageMap * info = (e_enumMessageMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap GGS_enumMessageMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_enumMessageMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_enumMessageMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey) {
  searchElement (inLexique,
                 "the '%K' message name is not declared",
                 inKey,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey) {
  insertElement (lexique_var_,
                 "the '%K' message name is already declared in %L",
                 inKey,
                 NULL) ;
}

GGS_string GGS_enumMessageMap::reader_description (void) const {
  C_String s ;
  s << "<map @enumMessageMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'EnumModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_EnumModel::cPtr_EnumModel (const GGS_enumConstantMap & argument_0,
                                const GGS_enumMessageMap & argument_1 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mEnumConstantesMap (argument_0),
mMessagesMap (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_EnumModel::appendForDescription (C_String & ioString) const {
  ioString << "->@EnumModel:" ;
mEnumConstantesMap.reader_description () ;
mMessagesMap.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_EnumModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_EnumModel * GGS_EnumModel::
    constructor_new (const GGS_enumConstantMap & argument_0,
                                const GGS_enumMessageMap & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_EnumModel * ptr_ = (cPtr_EnumModel *) NULL ;
    macroMyNew (ptr_, cPtr_EnumModel (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'constructorMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_constructorMap::
elementOf_GGS_constructorMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_constructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constructorMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mFormalInputArgumentList.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_constructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constructorMap * info = (e_constructorMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_constructorMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeListModel &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_constructorMap info  ;
    info.mFormalInputArgumentList = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListModel   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalInputArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListModel   & outParameter0) {
  searchElement (inLexique,
                 "the '%K' constructor is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_typeListModel & inParameter0) {
  insertElement (lexique_var_,
                 "the '%K' constructor is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_constructorMap::reader_description (void) const {
  C_String s ;
  s << "<map @constructorMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'readerMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_readerMap::
elementOf_GGS_readerMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_readerMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_readerMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mReaderFormalArgumentList.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_readerMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_readerMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_readerMap * info = (e_readerMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_readerMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_readerMap info  ;
    info.mReaderFormalArgumentList = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mReaderFormalArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_readerMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0) {
  searchElement (inLexique,
                 "the '%K' reader is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0) {
  insertElement (lexique_var_,
                 "the '%K' reader is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_readerMap::reader_description (void) const {
  C_String s ;
  s << "<map @readerMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'modifierMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_modifierMap::
elementOf_GGS_modifierMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_modifierMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_modifierMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mModifierFormalArgumentList.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_modifierMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_modifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_modifierMap * info = (e_modifierMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_modifierMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_modifierMap info  ;
    info.mModifierFormalArgumentList = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mModifierFormalArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0) {
  searchElement (inLexique,
                 "the '%K' modifier is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0) {
  insertElement (lexique_var_,
                 "the '%K' modifier is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_modifierMap::reader_description (void) const {
  C_String s ;
  s << "<map @modifierMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'ExternTypeModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ExternTypeModel::cPtr_ExternTypeModel (const GGS_constructorMap & argument_0,
                                const GGS_readerMap & argument_1,
                                const GGS_modifierMap & argument_2,
                                const GGS_typeListModel & argument_3 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mExternTypeConstructorMap (argument_0),
mReaderMap (argument_1),
mModifierMap (argument_2),
mAddAssignFormalInputArgumentList (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_ExternTypeModel::appendForDescription (C_String & ioString) const {
  ioString << "->@ExternTypeModel:" ;
mExternTypeConstructorMap.reader_description () ;
mReaderMap.reader_description () ;
mModifierMap.reader_description () ;
mAddAssignFormalInputArgumentList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_ExternTypeModel'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_ExternTypeModel * GGS_ExternTypeModel::
    constructor_new (const GGS_constructorMap & argument_0,
                                const GGS_readerMap & argument_1,
                                const GGS_modifierMap & argument_2,
                                const GGS_typeListModel & argument_3 COMMA_LOCATION_ARGS) {
    cPtr_ExternTypeModel * ptr_ = (cPtr_ExternTypeModel *) NULL ;
    macroMyNew (ptr_, cPtr_ExternTypeModel (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'classMessageMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_classMessageMap::
elementOf_GGS_classMessageMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_classMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classMessageMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_classMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_classMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_classMessageMap * info = (e_classMessageMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap GGS_classMessageMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_classMessageMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_classMessageMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey) {
  searchElement (inLexique,
                 "the '%K' message is not declared",
                 inKey,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey) {
  insertElement (lexique_var_,
                 "the '%K' message is already declared in %L",
                 inKey,
                 NULL) ;
}

GGS_string GGS_classMessageMap::reader_description (void) const {
  C_String s ;
  s << "<map @classMessageMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'ClassModel'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ClassModel::cPtr_ClassModel (const GGS_bool& argument_0,
                                const GGS_stringset & argument_1,
                                const GGS_typeListModel & argument_2,
                                const GGS_classMessageMap & argument_3 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mIsAbstract (argument_0),
mSuperClasses (argument_1),
mAttributeList (argument_2),
mMessageMap (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_ClassModel::appendForDescription (C_String & ioString) const {
  ioString << "->@ClassModel:" ;
mIsAbstract.reader_description () ;
mSuperClasses.reader_description () ;
mAttributeList.reader_description () ;
mMessageMap.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_ClassModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_ClassModel * GGS_ClassModel::
    constructor_new (const GGS_bool& argument_0,
                                const GGS_stringset & argument_1,
                                const GGS_typeListModel & argument_2,
                                const GGS_classMessageMap & argument_3 COMMA_LOCATION_ARGS) {
    cPtr_ClassModel * ptr_ = (cPtr_ClassModel *) NULL ;
    macroMyNew (ptr_, cPtr_ClassModel (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'ModelMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ModelMap::
elementOf_GGS_ModelMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_ModelMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ModelMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mType.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ModelMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_ModelMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ModelMap * info = (e_ModelMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_ModelMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_TypeModel &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_ModelMap info  ;
    info.mType = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_TypeModel   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_TypeModel   & outParameter0) {
  searchElement (inLexique,
                 "the '@%K' type is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_TypeModel & inParameter0) {
  insertElement (lexique_var_,
                 "the '@%K' type has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_ModelMap::reader_description (void) const {
  C_String s ;
  s << "<map @ModelMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'ActionMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ActionMap::
elementOf_GGS_ActionMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_ActionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ActionMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mSignature.reader_description () ;
  ioString << mInfo.mIsExtern.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ActionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_ActionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ActionMap * info = (e_ActionMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_ActionMap GGS_ActionMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_ActionMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               const GGS_bool&  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_ActionMap info  ;
    info.mSignature = inParameter0 ;
    info.mIsExtern = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mSignature ;
    outParameter1 = node->mInfo.mIsExtern ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0,
                                GGS_bool  & outParameter1) {
  searchElement (inLexique,
                 "the '%K' action is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0,
                                const GGS_bool& inParameter1) {
  insertElement (lexique_var_,
                 "the '%K' extern action has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

GGS_string GGS_ActionMap::reader_description (void) const {
  C_String s ;
  s << "<map @ActionMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Class for 'localConstantBuildStyleEnum' Enumeration             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator == (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator != (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator <= (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator >= (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator < (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator > (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localConstantBuildStyleEnum::
reader_description (void) const {
  C_String s ;
  s << "<enum @localConstantBuildStyleEnum" ;
  switch (mValue) {
case enum_listStyle:
  s << " listStyle" ;
    break ;
case enum_mapStyle:
  s << " mapStyle" ;
    break ;
case enum_firstIsKeyOtherMapStyle:
  s << " firstIsKeyOtherMapStyle" ;
    break ;
  case kNotBuilt:
    s << " (not built)" ;
    break ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_AC_galgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_galgasType::
cPtr_AC_galgasType (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_acceptAssignmentFromHere (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inErrorLocation) {
    var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "assignment from 'here' is not allowed for variables of this type")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_acceptForeachInstruction (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & /* var_cas_outForeachList */,
                                GGS_localConstantBuildStyleEnum& /* var_cas_outStyle */) {
    var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type cannot be enumerated by in 'foreach' instruction")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_acceptToBeKeyForMap (C_Lexique & lexique_var_) {
    GGS_location (lexique_var_).reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this type cannot be a key for map")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleModifierCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & /* var_cas_outModifierSignature */) {
    var_cas_inModifierName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support modifier call")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleReaderInstructionCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_EXsignature & /* var_cas_outReaderSignature */) {
    var_cas_inReaderName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support reader instruction")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & /* var_cas_outAccessorTypesList */) {
    var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleAddAssignOperatorCall (C_Lexique & lexique_var_,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & /* var_cas_outParametersList */,
                                GGS_bool& /* var_cas_outAccept_uint_assignment */) {
    var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support call of '+=' operator")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleIncrementOperatorCall (C_Lexique & lexique_var_,
                                GGS_location  var_cas_inErrorLocation) {
    var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support call of '++' operator")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & lexique_var_) {
    GGS_location (lexique_var_).reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type cannot be silently converted to @location value")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_typeCanBeUsedInObjectDeclaration (C_Lexique & /* lexique_var_ */) {
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType
::static_string_message_messageGalgasType (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType::
message_messageGalgasType (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_galgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (void) {
  mPointer = (cPtr_AC_galgasType *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (const GGS_AC_galgasType & inOperand) {
  mPointer = (cPtr_AC_galgasType *) NULL ;
  macroTransfertPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
~GGS_AC_galgasType (void) {
  macroDetachPointer (mPointer, cPtr_AC_galgasType) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_galgasType::
operator = (const GGS_AC_galgasType & inOperand) {
  macroTransfertPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_galgasType::
operator = (cPtr_AC_galgasType * inSource) {
  macroTransfertPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (cPtr_AC_galgasType * inSource) {
  mPointer = (cPtr_AC_galgasType *) NULL ;
  macroTransfertPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_AC_galgasType * GGS_AC_galgasType
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_AC_galgasType::reader_messageGalgasType (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_galgasType
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_galgasType) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_galgasType
::reader_description (void) const {
  C_String s ;
  s << "<class @AC_galgasType" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Class for 'metamodelPropertyKind' Enumeration                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelPropertyKind::
operator == (const GGS_metamodelPropertyKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelPropertyKind::
operator != (const GGS_metamodelPropertyKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelPropertyKind::
operator <= (const GGS_metamodelPropertyKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelPropertyKind::
operator >= (const GGS_metamodelPropertyKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelPropertyKind::
operator < (const GGS_metamodelPropertyKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelPropertyKind::
operator > (const GGS_metamodelPropertyKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelPropertyKind::
reader_description (void) const {
  C_String s ;
  s << "<enum @metamodelPropertyKind" ;
  switch (mValue) {
case enum_attributeProperty:
  s << " attributeProperty" ;
    break ;
case enum_singleReferenceProperty:
  s << " singleReferenceProperty" ;
    break ;
case enum_multipleReferenceProperty:
  s << " multipleReferenceProperty" ;
    break ;
case enum_mapProperty:
  s << " mapProperty" ;
    break ;
case enum_contextProperty:
  s << " contextProperty" ;
    break ;
case enum_fetchedProperty:
  s << " fetchedProperty" ;
    break ;
  case kNotBuilt:
    s << " (not built)" ;
    break ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_propertyPath'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_propertyPath::
elementOf_GGS_L_propertyPath (const GGS_lstring & argument_0) {
  mNextItem = (elementOf_GGS_L_propertyPath *) NULL ;
  mPathElement = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_propertyPath::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mPathElement.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_propertyPath'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_propertyPath
::GGS_L_propertyPath (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_L_propertyPath
::GGS_L_propertyPath (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_propertyPath::~GGS_L_propertyPath (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_propertyPath::GGS_L_propertyPath (const GGS_L_propertyPath & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath
::operator = (const GGS_L_propertyPath & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mPathElement) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_propertyPath  GGS_L_propertyPath::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_propertyPath result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_propertyPath::reader_description (void) const {
  C_String s ;
  s << "<list @L_propertyPath" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_propertyPath
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@L_ListOfPropertyPathes'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_ListOfPropertyPathes::
elementOf_GGS_L_ListOfPropertyPathes (const GGS_L_propertyPath & argument_0,
                                const GGS_location & argument_1) {
  mNextItem = (elementOf_GGS_L_ListOfPropertyPathes *) NULL ;
  mPath = argument_0 ;
  mEndOfPathLocation = argument_1 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_ListOfPropertyPathes::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mPath.reader_description () ;
  ioString << mEndOfPathLocation.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@L_ListOfPropertyPathes'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes
::GGS_L_ListOfPropertyPathes (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_L_ListOfPropertyPathes
::GGS_L_ListOfPropertyPathes (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes::~GGS_L_ListOfPropertyPathes (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes::GGS_L_ListOfPropertyPathes (const GGS_L_ListOfPropertyPathes & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes
::operator = (const GGS_L_ListOfPropertyPathes & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
internalAppendItem (const GGS_L_propertyPath & argument_0,
                                const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
addAssign_operation (const GGS_L_propertyPath & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mPath,
                                p->mEndOfPathLocation) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes  GGS_L_ListOfPropertyPathes::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_ListOfPropertyPathes result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_ListOfPropertyPathes::reader_description (void) const {
  C_String s ;
  s << "<list @L_ListOfPropertyPathes" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_ListOfPropertyPathes
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'entityPropertyMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_entityPropertyMap::
elementOf_GGS_entityPropertyMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_entityPropertyMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_entityPropertyMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mKind.reader_description () ;
  ioString << mInfo.mTypeName.reader_description () ;
  ioString << mInfo.mPropertyOptionPathes.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_entityPropertyMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_entityPropertyMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_entityPropertyMap * info = (e_entityPropertyMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_entityPropertyMap GGS_entityPropertyMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_entityPropertyMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_metamodelPropertyKind&  inParameter0,
               const GGS_lstring &  inParameter1,
               const GGS_L_ListOfPropertyPathes &  inParameter2,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_entityPropertyMap info  ;
    info.mKind = inParameter0 ;
    info.mTypeName = inParameter1 ;
    info.mPropertyOptionPathes = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_metamodelPropertyKind  & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_L_ListOfPropertyPathes   & outParameter2,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mKind ;
    outParameter1 = node->mInfo.mTypeName ;
    outParameter2 = node->mInfo.mPropertyOptionPathes ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_metamodelPropertyKind  & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_L_ListOfPropertyPathes   & outParameter2) {
  searchElement (inLexique,
                 "the '%K' property is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_metamodelPropertyKind& inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_L_ListOfPropertyPathes & inParameter2) {
  insertElement (lexique_var_,
                 "the '%K' property has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL) ;
}

GGS_string GGS_entityPropertyMap::reader_description (void) const {
  C_String s ;
  s << "<map @entityPropertyMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'contextPropertyMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_contextPropertyMap::
elementOf_GGS_contextPropertyMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_contextPropertyMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_contextPropertyMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mTypeName.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_contextPropertyMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_contextPropertyMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_contextPropertyMap * info = (e_contextPropertyMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_contextPropertyMap GGS_contextPropertyMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_contextPropertyMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_contextPropertyMap info  ;
    info.mTypeName = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mTypeName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0) {
  searchElement (inLexique,
                 "the '%K' context property is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0) {
  insertElement (lexique_var_,
                 "the '%K' context property has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_contextPropertyMap::reader_description (void) const {
  C_String s ;
  s << "<map @contextPropertyMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'fetchedPropertyMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_fetchedPropertyMap::
elementOf_GGS_fetchedPropertyMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_fetchedPropertyMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_fetchedPropertyMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mTypeName.reader_description () ;
  ioString << mInfo.mAttributeName.reader_description () ;
  ioString << mInfo.mPath.reader_description () ;
  ioString << mInfo.mEndOfPathLocation.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_fetchedPropertyMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_fetchedPropertyMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_fetchedPropertyMap * info = (e_fetchedPropertyMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_fetchedPropertyMap GGS_fetchedPropertyMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_fetchedPropertyMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_fetchedPropertyMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_fetchedPropertyMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               const GGS_lstring &  inParameter1,
               const GGS_L_propertyPath &  inParameter2,
               const GGS_location &  inParameter3,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_fetchedPropertyMap info  ;
    info.mTypeName = inParameter0 ;
    info.mAttributeName = inParameter1 ;
    info.mPath = inParameter2 ;
    info.mEndOfPathLocation = inParameter3 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_fetchedPropertyMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_L_propertyPath   & outParameter2,
               GGS_location   & outParameter3,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mTypeName ;
    outParameter1 = node->mInfo.mAttributeName ;
    outParameter2 = node->mInfo.mPath ;
    outParameter3 = node->mInfo.mEndOfPathLocation ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_fetchedPropertyMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_L_propertyPath   & outParameter2,
                                GGS_location   & outParameter3) {
  searchElement (inLexique,
                 "the '%K' fetched property is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_fetchedPropertyMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_L_propertyPath & inParameter2,
                                const GGS_location & inParameter3) {
  insertElement (lexique_var_,
                 "the '%K' fetched property has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL) ;
}

GGS_string GGS_fetchedPropertyMap::reader_description (void) const {
  C_String s ;
  s << "<map @fetchedPropertyMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'mapPropertyMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapPropertyMap::
elementOf_GGS_mapPropertyMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapPropertyMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapPropertyMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mEntityName.reader_description () ;
  ioString << mInfo.mListOfPropertyPathes.reader_description () ;
  ioString << mInfo.mInsertErrorMessage.reader_description () ;
  ioString << mInfo.mSearchErrorMessage.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapPropertyMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapPropertyMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapPropertyMap * info = (e_mapPropertyMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_mapPropertyMap GGS_mapPropertyMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_mapPropertyMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               const GGS_L_ListOfPropertyPathes &  inParameter1,
               const GGS_lstring &  inParameter2,
               const GGS_lstring &  inParameter3,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_mapPropertyMap info  ;
    info.mEntityName = inParameter0 ;
    info.mListOfPropertyPathes = inParameter1 ;
    info.mInsertErrorMessage = inParameter2 ;
    info.mSearchErrorMessage = inParameter3 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_L_ListOfPropertyPathes   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_lstring   & outParameter3,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mEntityName ;
    outParameter1 = node->mInfo.mListOfPropertyPathes ;
    outParameter2 = node->mInfo.mInsertErrorMessage ;
    outParameter3 = node->mInfo.mSearchErrorMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_L_ListOfPropertyPathes   & outParameter1,
                                GGS_lstring   & outParameter2,
                                GGS_lstring   & outParameter3) {
  searchElement (inLexique,
                 "the '%K' map property is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_L_ListOfPropertyPathes & inParameter1,
                                const GGS_lstring & inParameter2,
                                const GGS_lstring & inParameter3) {
  insertElement (lexique_var_,
                 "the '%K' map property has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL) ;
}

GGS_string GGS_mapPropertyMap::reader_description (void) const {
  C_String s ;
  s << "<map @mapPropertyMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'entityToImplementMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_entityToImplementMap::
elementOf_GGS_entityToImplementMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_entityToImplementMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_entityToImplementMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mAllPropertiesMap.reader_description () ;
  ioString << mInfo.mIsAbstract.reader_description () ;
  ioString << mInfo.mEntityPropertiesMap.reader_description () ;
  ioString << mInfo.mSuperEntityName.reader_description () ;
  ioString << mInfo.mMapOfPropertyMaps.reader_description () ;
  ioString << mInfo.mAllContextAttributes.reader_description () ;
  ioString << mInfo.mFetchedPropertyMap.reader_description () ;
  ioString << mInfo.mAllFetchedPropertyMap.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_entityToImplementMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_entityToImplementMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_entityToImplementMap * info = (e_entityToImplementMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_entityToImplementMap GGS_entityToImplementMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_entityToImplementMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_entityPropertyMap &  inParameter0,
               const GGS_bool&  inParameter1,
               const GGS_entityPropertyMap &  inParameter2,
               const GGS_lstring &  inParameter3,
               const GGS_mapPropertyMap &  inParameter4,
               const GGS_contextPropertyMap &  inParameter5,
               const GGS_fetchedPropertyMap &  inParameter6,
               const GGS_fetchedPropertyMap &  inParameter7,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_entityToImplementMap info  ;
    info.mAllPropertiesMap = inParameter0 ;
    info.mIsAbstract = inParameter1 ;
    info.mEntityPropertiesMap = inParameter2 ;
    info.mSuperEntityName = inParameter3 ;
    info.mMapOfPropertyMaps = inParameter4 ;
    info.mAllContextAttributes = inParameter5 ;
    info.mFetchedPropertyMap = inParameter6 ;
    info.mAllFetchedPropertyMap = inParameter7 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_entityPropertyMap   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_entityPropertyMap   & outParameter2,
               GGS_lstring   & outParameter3,
               GGS_mapPropertyMap   & outParameter4,
               GGS_contextPropertyMap   & outParameter5,
               GGS_fetchedPropertyMap   & outParameter6,
               GGS_fetchedPropertyMap   & outParameter7,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    outParameter4.drop_operation () ;
    outParameter5.drop_operation () ;
    outParameter6.drop_operation () ;
    outParameter7.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAllPropertiesMap ;
    outParameter1 = node->mInfo.mIsAbstract ;
    outParameter2 = node->mInfo.mEntityPropertiesMap ;
    outParameter3 = node->mInfo.mSuperEntityName ;
    outParameter4 = node->mInfo.mMapOfPropertyMaps ;
    outParameter5 = node->mInfo.mAllContextAttributes ;
    outParameter6 = node->mInfo.mFetchedPropertyMap ;
    outParameter7 = node->mInfo.mAllFetchedPropertyMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_entityPropertyMap   & outParameter0,
                                GGS_bool  & outParameter1,
                                GGS_entityPropertyMap   & outParameter2,
                                GGS_lstring   & outParameter3,
                                GGS_mapPropertyMap   & outParameter4,
                                GGS_contextPropertyMap   & outParameter5,
                                GGS_fetchedPropertyMap   & outParameter6,
                                GGS_fetchedPropertyMap   & outParameter7) {
  searchElement (inLexique,
                 "the '@%K' entity is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_entityPropertyMap & inParameter0,
                                const GGS_bool& inParameter1,
                                const GGS_entityPropertyMap & inParameter2,
                                const GGS_lstring & inParameter3,
                                const GGS_mapPropertyMap & inParameter4,
                                const GGS_contextPropertyMap & inParameter5,
                                const GGS_fetchedPropertyMap & inParameter6,
                                const GGS_fetchedPropertyMap & inParameter7) {
  insertElement (lexique_var_,
                 "the '@%K' entity has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 NULL) ;
}

GGS_string GGS_entityToImplementMap::reader_description (void) const {
  C_String s ;
  s << "<map @entityToImplementMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeGalgas_singleEntity'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_singleEntity::cPtr_typeGalgas_singleEntity (const GGS_lstring & argument_0,
                                const GGS_entityPropertyMap & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_entityPropertyMap & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_stringset & argument_5 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEntityName (argument_0),
mAllPropertiesMap (argument_1),
mIsAbstract (argument_2),
mEntityPropertiesMap (argument_3),
mSuperEntityName (argument_4),
mSuperEntitiesSet (argument_5) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_singleEntity::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mEntityName.reader_value () ;
}


const char * cPtr_typeGalgas_singleEntity::message_messageGalgasType (void) const {
  return "an entity" ;
}

const char * cPtr_typeGalgas_singleEntity::static_string_message_messageGalgasType (void) {
  return "an entity" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_singleEntity::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_singleEntity:" ;
mEntityName.reader_description () ;
mAllPropertiesMap.reader_description () ;
mIsAbstract.reader_description () ;
mEntityPropertiesMap.reader_description () ;
mSuperEntityName.reader_description () ;
mSuperEntitiesSet.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeGalgas_singleEntity'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_singleEntity * GGS_typeGalgas_singleEntity::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_entityPropertyMap & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_entityPropertyMap & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_stringset & argument_5 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_singleEntity * ptr_ = (cPtr_typeGalgas_singleEntity *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_singleEntity (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeGalgas_multipleEntity'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_multipleEntity::cPtr_typeGalgas_multipleEntity (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEntityName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_multipleEntity::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = ((GGS_string (true, "_listOf_")) + (mEntityName.reader_value ())) ;
}


const char * cPtr_typeGalgas_multipleEntity::message_messageGalgasType (void) const {
  return "a list of entities" ;
}

const char * cPtr_typeGalgas_multipleEntity::static_string_message_messageGalgasType (void) {
  return "a list of entities" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_multipleEntity::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_multipleEntity:" ;
mEntityName.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeGalgas_multipleEntity'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_multipleEntity * GGS_typeGalgas_multipleEntity::
    constructor_new (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_multipleEntity * ptr_ = (cPtr_typeGalgas_multipleEntity *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_multipleEntity (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeAttributsSemantiques'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeAttributsSemantiques::
elementOf_GGS_typeListeAttributsSemantiques (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (elementOf_GGS_typeListeAttributsSemantiques *) NULL ;
  mAttributType = argument_0 ;
  aNomAttribut = argument_1 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeAttributsSemantiques::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mAttributType.reader_description () ;
  ioString << aNomAttribut.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeAttributsSemantiques'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques
::GGS_typeListeAttributsSemantiques (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_typeListeAttributsSemantiques
::GGS_typeListeAttributsSemantiques (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::~GGS_typeListeAttributsSemantiques (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::GGS_typeListeAttributsSemantiques (const GGS_typeListeAttributsSemantiques & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques
::operator = (const GGS_typeListeAttributsSemantiques & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mAttributType,
                                p->aNomAttribut) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeListeAttributsSemantiques::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeListeAttributsSemantiques result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeAttributsSemantiques::reader_description (void) const {
  C_String s ;
  s << "<list @typeListeAttributsSemantiques" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeListeAttributsSemantiques
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@typeTypesList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTypesList::
elementOf_GGS_typeTypesList (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  mNextItem = (elementOf_GGS_typeTypesList *) NULL ;
  mType = argument_0 ;
  mEndOfExpressionLocation = argument_1 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTypesList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mType.reader_description () ;
  ioString << mEndOfExpressionLocation.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@typeTypesList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTypesList
::GGS_typeTypesList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_typeTypesList
::GGS_typeTypesList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeTypesList::~GGS_typeTypesList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeTypesList::GGS_typeTypesList (const GGS_typeTypesList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList
::operator = (const GGS_typeTypesList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mEndOfExpressionLocation) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeTypesList  GGS_typeTypesList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeTypesList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTypesList::reader_description (void) const {
  C_String s ;
  s << "<list @typeTypesList" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeTypesList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_EXsignature'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_EXsignature::
elementOf_GGS_L_EXsignature (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) {
  mNextItem = (elementOf_GGS_L_EXsignature *) NULL ;
  mType = argument_0 ;
  mFormalArgumentPassingMode = argument_1 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_EXsignature::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mType.reader_description () ;
  ioString << mFormalArgumentPassingMode.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_EXsignature'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_EXsignature
::GGS_L_EXsignature (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_L_EXsignature
::GGS_L_EXsignature (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_EXsignature::~GGS_L_EXsignature (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature::GGS_L_EXsignature (const GGS_L_EXsignature & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature
::operator = (const GGS_L_EXsignature & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mFormalArgumentPassingMode) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_L_EXsignature::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_EXsignature result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_EXsignature::reader_description (void) const {
  C_String s ;
  s << "<list @L_EXsignature" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_EXsignature
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_actualParametersSignature'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_actualParametersSignature::
elementOf_GGS_L_actualParametersSignature (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1) {
  mNextItem = (elementOf_GGS_L_actualParametersSignature *) NULL ;
  mType = argument_0 ;
  mFormalArgumentPassingMode = argument_1 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_actualParametersSignature::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mType.reader_description () ;
  ioString << mFormalArgumentPassingMode.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@L_actualParametersSignature'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature
::GGS_L_actualParametersSignature (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_L_actualParametersSignature
::GGS_L_actualParametersSignature (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::~GGS_L_actualParametersSignature (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::GGS_L_actualParametersSignature (const GGS_L_actualParametersSignature & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature
::operator = (const GGS_L_actualParametersSignature & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mFormalArgumentPassingMode) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature  GGS_L_actualParametersSignature::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_actualParametersSignature result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_actualParametersSignature::reader_description (void) const {
  C_String s ;
  s << "<list @L_actualParametersSignature" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_actualParametersSignature
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'M_accessors_map'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_accessors_map::
elementOf_GGS_M_accessors_map (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_accessors_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_accessors_map::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mAccessorSignature.reader_description () ;
  ioString << mInfo.mReturnedType.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_accessors_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_accessors_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_accessors_map * info = (e_M_accessors_map *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_accessors_map result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_EXsignature &  inParameter0,
               const GGS_AC_galgasType &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_accessors_map info  ;
    info.mAccessorSignature = inParameter0 ;
    info.mReturnedType = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAccessorSignature ;
    outParameter1 = node->mInfo.mReturnedType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_AC_galgasType   & outParameter1) {
  searchElement (inLexique,
                 "the '%K' accessor is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_AC_galgasType & inParameter1) {
  insertElement (lexique_var_,
                 "the '%K' accessor has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

GGS_string GGS_M_accessors_map::reader_description (void) const {
  C_String s ;
  s << "<map @M_accessors_map " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_stringList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_stringList::
elementOf_GGS_L_stringList (const GGS_string& argument_0) {
  mNextItem = (elementOf_GGS_L_stringList *) NULL ;
  mErrorMessageElement = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_stringList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mErrorMessageElement.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@L_stringList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_stringList
::GGS_L_stringList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_L_stringList
::GGS_L_stringList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_stringList::~GGS_L_stringList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_stringList::GGS_L_stringList (const GGS_L_stringList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_stringList
::operator = (const GGS_L_stringList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
internalAppendItem (const GGS_string& argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
addAssign_operation (const GGS_string& argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mErrorMessageElement) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_stringList  GGS_L_stringList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_stringList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_stringList::reader_description (void) const {
  C_String s ;
  s << "<list @L_stringList" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_stringList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_lstringList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_lstringList::
elementOf_GGS_L_lstringList (const GGS_lstring & argument_0) {
  mNextItem = (elementOf_GGS_L_lstringList *) NULL ;
  mString = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_lstringList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mString.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_lstringList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_lstringList
::GGS_L_lstringList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_L_lstringList
::GGS_L_lstringList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_lstringList::~GGS_L_lstringList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_lstringList::GGS_L_lstringList (const GGS_L_lstringList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList
::operator = (const GGS_L_lstringList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mString) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_lstringList  GGS_L_lstringList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_lstringList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_lstringList::reader_description (void) const {
  C_String s ;
  s << "<list @L_lstringList" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_lstringList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeGalgas_jokerInParameterList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_jokerInParameterList::cPtr_typeGalgas_jokerInParameterList (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_jokerInParameterList::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "") ;
}


const char * cPtr_typeGalgas_jokerInParameterList::message_messageGalgasType (void) const {
  return "\?\?" ;
}

const char * cPtr_typeGalgas_jokerInParameterList::static_string_message_messageGalgasType (void) {
  return "\?\?" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_jokerInParameterList::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_jokerInParameterList:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeGalgas_jokerInParameterList'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_jokerInParameterList * GGS_typeGalgas_jokerInParameterList::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_jokerInParameterList * ptr_ = (cPtr_typeGalgas_jokerInParameterList *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_jokerInParameterList (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_bool'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_bool::cPtr_typeGalgas_bool (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "bool") ;
}


const char * cPtr_typeGalgas_bool::message_messageGalgasType (void) const {
  return "a bool type" ;
}

const char * cPtr_typeGalgas_bool::static_string_message_messageGalgasType (void) {
  return "a bool type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_bool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_bool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_bool * GGS_typeGalgas_bool::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_bool * ptr_ = (cPtr_typeGalgas_bool *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_bool (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_string'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_string::cPtr_typeGalgas_string (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "string") ;
}


const char * cPtr_typeGalgas_string::message_messageGalgasType (void) const {
  return "a 'string' type" ;
}

const char * cPtr_typeGalgas_string::static_string_message_messageGalgasType (void) {
  return "a 'string' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_string:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_string'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_string * GGS_typeGalgas_string::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_string * ptr_ = (cPtr_typeGalgas_string *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_string (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_sint'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_sint::cPtr_typeGalgas_sint (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "sint") ;
}


const char * cPtr_typeGalgas_sint::message_messageGalgasType (void) const {
  return "a 'sint' type" ;
}

const char * cPtr_typeGalgas_sint::static_string_message_messageGalgasType (void) {
  return "a 'sint' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_sint:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_sint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_sint * GGS_typeGalgas_sint::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_sint * ptr_ = (cPtr_typeGalgas_sint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_sint (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_uint'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_uint::cPtr_typeGalgas_uint (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "uint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
methode_handleIncrementOperatorCall (C_Lexique & /* lexique_var_ */,
                                GGS_location  /* var_cas_inErrorLocation */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "max"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}


const char * cPtr_typeGalgas_uint::message_messageGalgasType (void) const {
  return "a 'uint' type" ;
}

const char * cPtr_typeGalgas_uint::static_string_message_messageGalgasType (void) {
  return "a 'uint' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_uint:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_uint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_uint * GGS_typeGalgas_uint::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_uint * ptr_ = (cPtr_typeGalgas_uint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_uint (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_char'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_char::cPtr_typeGalgas_char (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "char") ;
}


const char * cPtr_typeGalgas_char::message_messageGalgasType (void) const {
  return "a 'char' type" ;
}

const char * cPtr_typeGalgas_char::static_string_message_messageGalgasType (void) {
  return "a 'char' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_char:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_char'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_char * GGS_typeGalgas_char::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_char * ptr_ = (cPtr_typeGalgas_char *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_char (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_double'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_double::cPtr_typeGalgas_double (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_double::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "double") ;
}


const char * cPtr_typeGalgas_double::message_messageGalgasType (void) const {
  return "a double type" ;
}

const char * cPtr_typeGalgas_double::static_string_message_messageGalgasType (void) {
  return "a double type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_double::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_double:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_double'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_double * GGS_typeGalgas_double::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_double * ptr_ = (cPtr_typeGalgas_double *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_double (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_galgasPrimitiveType'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_galgasPrimitiveType::
cPtr_C_galgasPrimitiveType (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType
::static_string_message_messageGalgasType (void) {
  return "any primitive type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType::
message_messageGalgasType (void) const {
  return "any primitive type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_galgasPrimitiveType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (void) {
  mPointer = (cPtr_C_galgasPrimitiveType *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (const GGS_C_galgasPrimitiveType & inOperand) {
  mPointer = (cPtr_C_galgasPrimitiveType *) NULL ;
  macroTransfertPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
~GGS_C_galgasPrimitiveType (void) {
  macroDetachPointer (mPointer, cPtr_C_galgasPrimitiveType) ;
}

//---------------------------------------------------------------------------*

void GGS_C_galgasPrimitiveType::
operator = (const GGS_C_galgasPrimitiveType & inOperand) {
  macroTransfertPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_C_galgasPrimitiveType::
operator = (cPtr_C_galgasPrimitiveType * inSource) {
  macroTransfertPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (cPtr_C_galgasPrimitiveType * inSource) {
  mPointer = (cPtr_C_galgasPrimitiveType *) NULL ;
  macroTransfertPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_galgasPrimitiveType * GGS_C_galgasPrimitiveType
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_galgasPrimitiveType::reader_messageGalgasType (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_C_galgasPrimitiveType
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_C_galgasPrimitiveType) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_galgasPrimitiveType
::reader_description (void) const {
  C_String s ;
  s << "<class @C_galgasPrimitiveType" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgas_location'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_location::cPtr_typeGalgas_location (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "location") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
methode_acceptAssignmentFromHere (C_Lexique & /* lexique_var_ */,
                                GGS_lstring  /* var_cas_inErrorLocation */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_location::message_messageGalgasType (void) const {
  return "'location' type" ;
}

const char * cPtr_typeGalgas_location::static_string_message_messageGalgasType (void) {
  return "'location' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_location:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_location'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_location * GGS_typeGalgas_location::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_location * ptr_ = (cPtr_typeGalgas_location *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_location (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_lstring'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lstring::cPtr_typeGalgas_lstring (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "lstring") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_string::constructor_new (HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
methode_acceptToBeKeyForMap (C_Lexique & /* lexique_var_ */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_lstring::message_messageGalgasType (void) const {
  return "a 'lstring' type" ;
}

const char * cPtr_typeGalgas_lstring::static_string_message_messageGalgasType (void) {
  return "a 'lstring' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_lstring:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_lstring'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_lstring * GGS_typeGalgas_lstring::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_lstring * ptr_ = (cPtr_typeGalgas_lstring *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lstring (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lchar'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lchar::cPtr_typeGalgas_lchar (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "lchar") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_char::constructor_new (HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_lchar::message_messageGalgasType (void) const {
  return "a 'lchar' type" ;
}

const char * cPtr_typeGalgas_lchar::static_string_message_messageGalgasType (void) {
  return "a 'lchar' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_lchar:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lchar'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_lchar * GGS_typeGalgas_lchar::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_lchar * ptr_ = (cPtr_typeGalgas_lchar *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lchar (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lbool'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lbool::cPtr_typeGalgas_lbool (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "lbool") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_bool::constructor_new (HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_lbool::message_messageGalgasType (void) const {
  return "a 'lbool' type" ;
}

const char * cPtr_typeGalgas_lbool::static_string_message_messageGalgasType (void) {
  return "a 'lbool' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_lbool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lbool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_lbool * GGS_typeGalgas_lbool::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_lbool * ptr_ = (cPtr_typeGalgas_lbool *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lbool (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_luint'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_luint::cPtr_typeGalgas_luint (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "luint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_uint::constructor_new (HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
methode_acceptToBeKeyForMap (C_Lexique & /* lexique_var_ */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_luint::message_messageGalgasType (void) const {
  return "a 'luint' type" ;
}

const char * cPtr_typeGalgas_luint::static_string_message_messageGalgasType (void) {
  return "a 'luint' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_luint:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_luint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_luint * GGS_typeGalgas_luint::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_luint * ptr_ = (cPtr_typeGalgas_luint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_luint (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lsint'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lsint::cPtr_typeGalgas_lsint (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "lsint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_sint::constructor_new (HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
methode_acceptToBeKeyForMap (C_Lexique & /* lexique_var_ */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_lsint::message_messageGalgasType (void) const {
  return "a 'lsint' type" ;
}

const char * cPtr_typeGalgas_lsint::static_string_message_messageGalgasType (void) {
  return "a 'lsint' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_lsint:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lsint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_lsint * GGS_typeGalgas_lsint::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_lsint * ptr_ = (cPtr_typeGalgas_lsint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lsint (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_ldouble'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_ldouble::cPtr_typeGalgas_ldouble (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "ldouble") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_double::constructor_new (HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_ldouble::message_messageGalgasType (void) const {
  return "a 'ldouble' type" ;
}

const char * cPtr_typeGalgas_ldouble::static_string_message_messageGalgasType (void) {
  return "a 'ldouble' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_ldouble:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_ldouble'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_ldouble * GGS_typeGalgas_ldouble::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_ldouble * ptr_ = (cPtr_typeGalgas_ldouble *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_ldouble (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgas_stringset'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_stringset::cPtr_typeGalgas_stringset (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "stringset") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
methode_handleAddAssignOperatorCall (C_Lexique & lexique_var_,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList,
                                GGS_bool& var_cas_outAccept_uint_assignment) {
  var_cas_outParametersList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
  GGS_AC_galgasType  var_cas_t ;
  var_cas_t = GGS_typeGalgas_string::constructor_new (HERE) ;
  var_cas_outParametersList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
  var_cas_outAccept_uint_assignment = GGS_bool (true, true) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
methode_acceptForeachInstruction (C_Lexique & lexique_var_,
                                GGS_lstring  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle) {
  GGS_AC_galgasType  var_cas_keyType ;
  var_cas_keyType = GGS_typeGalgas_string::constructor_new (HERE) ;
  var_cas_outForeachList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
  var_cas_outForeachList.addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (GGS_string (true, "mKey"), GGS_location (lexique_var_) COMMA_HERE)) ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (HERE) ;
}


const char * cPtr_typeGalgas_stringset::message_messageGalgasType (void) const {
  return "a 'stringset' type" ;
}

const char * cPtr_typeGalgas_stringset::static_string_message_messageGalgasType (void) {
  return "a 'stringset' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_stringset:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgas_stringset'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_stringset * GGS_typeGalgas_stringset::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeGalgas_stringset * ptr_ = (cPtr_typeGalgas_stringset *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_stringset (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map element 'e_typeTableMethodes'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cClassMethodsMap.hh"

//---------------------------------------------------------------------------*

template class cClassMethodsMap <e_typeTableMethodes> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         Map 'typeTableMethodes'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodes t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0) {
  GGS_typeTableMethodes::element_type * info = searchKey (inLexique, inKey, inKey, "there is no reader named '%'") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.aListeTypesParametres ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_L_EXsignature   & outParameter0) {
  GGS_typeTableMethodes::element_type * info = searchKey (inLexique, inKey, inKey, "there is no reader named '%'") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.aListeTypesParametres ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_searchForOverride (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0) {
  GGS_typeTableMethodes::element_type * info = searchForOverride (inLexique, inKey, inKey, "the reader '%' cannot be overriden : it is not declared in superclass") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.aListeTypesParametres ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_searchForOverrideGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_L_EXsignature   & outParameter0) {
  GGS_typeTableMethodes::element_type * info = searchForOverride (inLexique, inKey, inKey, "the reader '%' cannot be overriden : it is not declared in superclass") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.aListeTypesParametres ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_insertAbstract (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0) {
  e_typeTableMethodes info ;
  info.aListeTypesParametres = inParameter0 ;
  insertAbstract (lexique_var_, info, inKey, inKey, "a reader named '%' is already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_insertAbstractGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0) {
  e_typeTableMethodes info ;
  info.aListeTypesParametres = inParameter0 ;
  const sint32 index = insertAbstract (lexique_var_, info, inKey, inKey, "a reader named '%' is already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_insertNotAbstract (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0) {
  e_typeTableMethodes info ;
  info.aListeTypesParametres = inParameter0 ;
  insertNotAbstract (lexique_var_, info, inKey, inKey, "a reader named '%' is already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_insertNotAbstractGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0) {
  e_typeTableMethodes info ;
  info.aListeTypesParametres = inParameter0 ;
  const sint32 index = insertNotAbstract (lexique_var_, info, inKey, inKey, "a reader named '%' is already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMethodes::reader_description (void) const {
  C_String s ;
  s << "<map @typeTableMethodes " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeGalgasUndefinedExternType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedExternType::cPtr_typeGalgasUndefinedExternType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mGalgasClassName (argument_0),
mCppClassName (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedExternType::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mGalgasClassName.reader_value () ;
}


const char * cPtr_typeGalgasUndefinedExternType::message_messageGalgasType (void) const {
  return "an undefined extern type" ;
}

const char * cPtr_typeGalgasUndefinedExternType::static_string_message_messageGalgasType (void) {
  return "an undefined extern type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedExternType::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgasUndefinedExternType:" ;
mGalgasClassName.reader_description () ;
mCppClassName.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedExternType'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasUndefinedExternType * GGS_typeGalgasUndefinedExternType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasUndefinedExternType * ptr_ = (cPtr_typeGalgasUndefinedExternType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedExternType (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_externTypeConstructorMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_externTypeConstructorMap::
elementOf_GGS_M_externTypeConstructorMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_externTypeConstructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_externTypeConstructorMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.aListeDesAttributs.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_externTypeConstructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_externTypeConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_externTypeConstructorMap * info = (e_M_externTypeConstructorMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_externTypeConstructorMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeListeAttributsSemantiques &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_externTypeConstructorMap info  ;
    info.aListeDesAttributs = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDesAttributs ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0) {
  searchElement (inLexique,
                 "the '%K' constructor is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0) {
  insertElement (lexique_var_,
                 "the '%K' constructor is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_M_externTypeConstructorMap::reader_description (void) const {
  C_String s ;
  s << "<map @M_externTypeConstructorMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgasExternType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasExternType::cPtr_typeGalgasExternType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_M_externTypeConstructorMap & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodes & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_typeListeAttributsSemantiques & argument_6 COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedExternType (argument_0, argument_1 COMMA_THERE),
mConstructorMap (argument_2),
mModifiersMap (argument_3),
mReadersInInstructionMap (argument_4),
mAcceptAddAssignOperatorCall (argument_5),
mAddAssignOperatorCallTypeList (argument_6) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  GGS_M_externTypeConstructorMap  var_cas_constructorMap ;
  var_cas_constructorMap = mConstructorMap ;
  var_cas_constructorMap.methode_searchKey (lexique_var_, var_cas_inClassMethodName, var_cas_outAccessorTypesList) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
methode_handleModifierCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature) {
  GGS_typeTableMethodes  var_cas_methodMap ;
  var_cas_methodMap = mModifiersMap ;
  var_cas_methodMap.methode_searchKey (lexique_var_, var_cas_inModifierName, var_cas_outModifierSignature) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
methode_handleReaderInstructionCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_EXsignature & var_cas_outReaderSignature) {
  GGS_typeTableMethodes  var_cas_methodMap ;
  var_cas_methodMap = mReadersInInstructionMap ;
  var_cas_methodMap.methode_searchKey (lexique_var_, var_cas_inReaderName, var_cas_outReaderSignature) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
methode_handleAddAssignOperatorCall (C_Lexique & lexique_var_,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList,
                                GGS_bool& var_cas_outAccept_uint_assignment) {
  if (((! mAcceptAddAssignOperatorCall)).isBuiltAndTrue ()) {
    inherited::methode_handleAddAssignOperatorCall (lexique_var_, var_cas_inErrorLocation, var_cas_outParametersList, var_cas_outAccept_uint_assignment) ;
  }else{
    var_cas_outParametersList = mAddAssignOperatorCallTypeList ;
    var_cas_outAccept_uint_assignment = GGS_bool (true, false) ;
  }
}


const char * cPtr_typeGalgasExternType::message_messageGalgasType (void) const {
  return "an extern type" ;
}

const char * cPtr_typeGalgasExternType::static_string_message_messageGalgasType (void) {
  return "an extern type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgasExternType:" ;
mGalgasClassName.reader_description () ;
mCppClassName.reader_description () ;
mConstructorMap.reader_description () ;
mModifiersMap.reader_description () ;
mReadersInInstructionMap.reader_description () ;
mAcceptAddAssignOperatorCall.reader_description () ;
mAddAssignOperatorCallTypeList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgasExternType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasExternType * GGS_typeGalgasExternType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_M_externTypeConstructorMap & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodes & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_typeListeAttributsSemantiques & argument_6 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasExternType * ptr_ = (cPtr_typeGalgasExternType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasExternType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_terminalSymbolsMapForUse'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_terminalSymbolsMapForUse::
elementOf_GGS_M_terminalSymbolsMapForUse (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_terminalSymbolsMapForUse & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_terminalSymbolsMapForUse::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.aListeDesAttributs.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_terminalSymbolsMapForUse::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_terminalSymbolsMapForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_terminalSymbolsMapForUse * info = (e_M_terminalSymbolsMapForUse *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_terminalSymbolsMapForUse result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeListeAttributsSemantiques &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_terminalSymbolsMapForUse info  ;
    info.aListeDesAttributs = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDesAttributs ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0) {
  searchElement (inLexique,
                 "the terminal symbol '$%K$' is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0) {
  insertElement (lexique_var_,
                 "the terminal symbol '$%K$' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_M_terminalSymbolsMapForUse::reader_description (void) const {
  C_String s ;
  s << "<map @M_terminalSymbolsMapForUse " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'M_lexiqueComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_lexiqueComponents::
elementOf_GGS_M_lexiqueComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_lexiqueComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_lexiqueComponents::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mTerminalSymbolMap.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_lexiqueComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_lexiqueComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_lexiqueComponents * info = (e_M_lexiqueComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_lexiqueComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_terminalSymbolsMapForUse &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_lexiqueComponents info  ;
    info.mTerminalSymbolMap = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_terminalSymbolsMapForUse   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mTerminalSymbolMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_terminalSymbolsMapForUse   & outParameter0) {
  searchElement (inLexique,
                 "the '%K' lexique is not defined",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_M_terminalSymbolsMapForUse & inParameter0) {
  insertElement (lexique_var_,
                 "the '%K' lexique is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_M_lexiqueComponents::reader_description (void) const {
  C_String s ;
  s << "<map @M_lexiqueComponents " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'typeTableEnAvant'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableEnAvant::
elementOf_GGS_typeTableEnAvant (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableEnAvant & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableEnAvant::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mType.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableEnAvant::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableEnAvant *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableEnAvant * info = (e_typeTableEnAvant *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeTableEnAvant result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_galgasType &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableEnAvant info  ;
    info.mType = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0) {
  searchElement (inLexique,
                 "the type '%K' is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0) {
  insertElement (lexique_var_,
                 "the type '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_typeTableEnAvant::reader_description (void) const {
  C_String s ;
  s << "<map @typeTableEnAvant " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map 'M_nonterminalSymbolAlts'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonterminalSymbolAlts::
elementOf_GGS_M_nonterminalSymbolAlts (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonterminalSymbolAlts & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonterminalSymbolAlts::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mFormalParametersList.reader_description () ;
  ioString << mInfo.mReturnedEntity.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonterminalSymbolAlts::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonterminalSymbolAlts *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonterminalSymbolAlts * info = (e_M_nonterminalSymbolAlts *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAlts result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_EXsignature &  inParameter0,
               const GGS_lstring &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_nonterminalSymbolAlts info  ;
    info.mFormalParametersList = inParameter0 ;
    info.mReturnedEntity = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalParametersList ;
    outParameter1 = node->mInfo.mReturnedEntity ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_lstring   & outParameter1) {
  searchElement (inLexique,
                 "the label '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_lstring & inParameter1) {
  insertElement (lexique_var_,
                 "the label '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

GGS_string GGS_M_nonterminalSymbolAlts::reader_description (void) const {
  C_String s ;
  s << "<map @M_nonterminalSymbolAlts " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_AC_semanticsEntity'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_semanticsEntity::
cPtr_AC_semanticsEntity (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity
::static_string_message_messageTypeEntite (void) {
  return "any entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity::
message_messageTypeEntite (void) const {
  return "any entity" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_AC_semanticsEntity'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (void) {
  mPointer = (cPtr_AC_semanticsEntity *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (const GGS_AC_semanticsEntity & inOperand) {
  mPointer = (cPtr_AC_semanticsEntity *) NULL ;
  macroTransfertPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
~GGS_AC_semanticsEntity (void) {
  macroDetachPointer (mPointer, cPtr_AC_semanticsEntity) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_semanticsEntity::
operator = (const GGS_AC_semanticsEntity & inOperand) {
  macroTransfertPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_semanticsEntity::
operator = (cPtr_AC_semanticsEntity * inSource) {
  macroTransfertPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (cPtr_AC_semanticsEntity * inSource) {
  mPointer = (cPtr_AC_semanticsEntity *) NULL ;
  macroTransfertPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_AC_semanticsEntity * GGS_AC_semanticsEntity
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_AC_semanticsEntity::reader_messageTypeEntite (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageTypeEntite ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_semanticsEntity
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_semanticsEntity) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_semanticsEntity
::reader_description (void) const {
  C_String s ;
  s << "<class @AC_semanticsEntity" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_grammarForSemantics'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarForSemantics::cPtr_C_grammarForSemantics (const GGS_M_nonterminalSymbolAlts & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
mGrammarAltMap (argument_0) {
}


const char * cPtr_C_grammarForSemantics::message_messageTypeEntite (void) const {
  return "a grammar entity" ;
}

const char * cPtr_C_grammarForSemantics::static_string_message_messageTypeEntite (void) {
  return "a grammar entity" ;
}

//---------------------------------------------------------------------------*

void cPtr_C_grammarForSemantics::appendForDescription (C_String & ioString) const {
  ioString << "->@C_grammarForSemantics:" ;
mGrammarAltMap.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarForSemantics'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_grammarForSemantics * GGS_C_grammarForSemantics::
    constructor_new (const GGS_M_nonterminalSymbolAlts & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_C_grammarForSemantics * ptr_ = (cPtr_C_grammarForSemantics *) NULL ;
    macroMyNew (ptr_, cPtr_C_grammarForSemantics (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_semanticsEntitiesForUse'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_semanticsEntitiesForUse::
elementOf_GGS_M_semanticsEntitiesForUse (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_semanticsEntitiesForUse & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_semanticsEntitiesForUse::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.aDefEntite.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_semanticsEntitiesForUse::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_semanticsEntitiesForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_semanticsEntitiesForUse * info = (e_M_semanticsEntitiesForUse *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsEntitiesForUse result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_semanticsEntity &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_semanticsEntitiesForUse info  ;
    info.aDefEntite = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_semanticsEntity   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aDefEntite ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_semanticsEntity   & outParameter0) {
  searchElement (inLexique,
                 "there is no semantics entity named '%K'",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_semanticsEntity & inParameter0) {
  insertElement (lexique_var_,
                 "a semantics entity named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_M_semanticsEntitiesForUse::reader_description (void) const {
  C_String s ;
  s << "<map @M_semanticsEntitiesForUse " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_AC_typeForGrammarComponent'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_typeForGrammarComponent::
cPtr_AC_typeForGrammarComponent (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent
::static_string_message_typeForGrammarComponentMessage (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent::
message_typeForGrammarComponentMessage (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_AC_typeForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (void) {
  mPointer = (cPtr_AC_typeForGrammarComponent *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (const GGS_AC_typeForGrammarComponent & inOperand) {
  mPointer = (cPtr_AC_typeForGrammarComponent *) NULL ;
  macroTransfertPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
~GGS_AC_typeForGrammarComponent (void) {
  macroDetachPointer (mPointer, cPtr_AC_typeForGrammarComponent) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_typeForGrammarComponent::
operator = (const GGS_AC_typeForGrammarComponent & inOperand) {
  macroTransfertPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_typeForGrammarComponent::
operator = (cPtr_AC_typeForGrammarComponent * inSource) {
  macroTransfertPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (cPtr_AC_typeForGrammarComponent * inSource) {
  mPointer = (cPtr_AC_typeForGrammarComponent *) NULL ;
  macroTransfertPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_AC_typeForGrammarComponent * GGS_AC_typeForGrammarComponent
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_AC_typeForGrammarComponent::reader_typeForGrammarComponentMessage (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_typeForGrammarComponentMessage ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_typeForGrammarComponent
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_typeForGrammarComponent) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_typeForGrammarComponent
::reader_description (void) const {
  C_String s ;
  s << "<class @AC_typeForGrammarComponent" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_typesForGrammarComponent'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_typesForGrammarComponent::
elementOf_GGS_M_typesForGrammarComponent (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_typesForGrammarComponent & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_typesForGrammarComponent::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mType.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_typesForGrammarComponent::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_typesForGrammarComponent *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_typesForGrammarComponent * info = (e_M_typesForGrammarComponent *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_typesForGrammarComponent result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_typeForGrammarComponent &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_typesForGrammarComponent info  ;
    info.mType = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_typeForGrammarComponent   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_typeForGrammarComponent   & outParameter0) {
  searchElement (inLexique,
                 "the '@%K' type is not defined",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_typeForGrammarComponent & inParameter0) {
  insertElement (lexique_var_,
                 "the '@%K' type is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_M_typesForGrammarComponent::reader_description (void) const {
  C_String s ;
  s << "<map @M_typesForGrammarComponent " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "checkSignature_ForGrammarComponent"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkSignature_ForGrammarComponent (C_Lexique & lexique_var_,
                                const GGS_L_signature  & var_cas_inFormalReferenceSignature,
                                const GGS_L_signature  & var_cas_inFormalTestedSignature,
                                const GGS_location  & var_cas_inEndOfListLocation) {
  if (((var_cas_inFormalReferenceSignature.reader_length ()) < (var_cas_inFormalTestedSignature.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inEndOfListLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "too much formal parameters")) ;
  }else if (((var_cas_inFormalReferenceSignature.reader_length ()) > (var_cas_inFormalTestedSignature.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inEndOfListLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "one or more formal parameters missing")) ;
  }else{
    GGS_L_signature::element_type * operand_50928 = var_cas_inFormalReferenceSignature.firstObject () ;
    GGS_L_signature::element_type * operand_51027 = var_cas_inFormalTestedSignature.firstObject () ;
    while ((operand_50928 != NULL)
        && (operand_51027 != NULL)) {
      macroValidPointer (operand_50928) ;
      macroValidPointer (operand_51027) ;
      if (((operand_50928->mFormalArgumentPassingMode) != (operand_51027->mFormalArgumentPassingMode)).isBuiltAndTrue ()) {
          operand_51027->mGalgasTypeName.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "Prototype has ")) + (operand_50928->mFormalArgumentPassingMode.reader_formalArgumentMessage ()))) + (GGS_string (true, ", and ")))) + (operand_50928->mFormalArgumentPassingMode.reader_formalArgumentMessage ()))) + (GGS_string (true, " has been found")))) ;
      }
      if (((operand_50928->mGalgasTypeName.reader_value ()) != (operand_51027->mGalgasTypeName.reader_value ())).isBuiltAndTrue ()) {
          operand_51027->mGalgasTypeName.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting the '@")) + (operand_50928->mGalgasTypeName.reader_value ()))) + (GGS_string (true, "' type, I have got the '@")))) + (operand_51027->mGalgasTypeName.reader_value ()))) + (GGS_string (true, "' type")))) ;
      }
      operand_50928 = operand_50928->nextObject () ;
      operand_51027 = operand_51027->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_AC_instruction_ForGrammar'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_instruction_ForGrammar::
cPtr_AC_instruction_ForGrammar (const GGS_location & argument_0 COMMA_LOCATION_ARGS)
:C_GGS_Object (THERE),
mStartLocation (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_AC_instruction_ForGrammar'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (void) {
  mPointer = (cPtr_AC_instruction_ForGrammar *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (const GGS_AC_instruction_ForGrammar & inOperand) {
  mPointer = (cPtr_AC_instruction_ForGrammar *) NULL ;
  macroTransfertPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
~GGS_AC_instruction_ForGrammar (void) {
  macroDetachPointer (mPointer, cPtr_AC_instruction_ForGrammar) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_instruction_ForGrammar::
operator = (const GGS_AC_instruction_ForGrammar & inOperand) {
  macroTransfertPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_instruction_ForGrammar::
operator = (cPtr_AC_instruction_ForGrammar * inSource) {
  macroTransfertPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (cPtr_AC_instruction_ForGrammar * inSource) {
  mPointer = (cPtr_AC_instruction_ForGrammar *) NULL ;
  macroTransfertPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_AC_instruction_ForGrammar * GGS_AC_instruction_ForGrammar
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_AC_instruction_ForGrammar
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_instruction_ForGrammar) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_instruction_ForGrammar
::reader_description (void) const {
  C_String s ;
  s << "<class @AC_instruction_ForGrammar" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@L_ruleSyntaxSignature'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_ruleSyntaxSignature::
elementOf_GGS_L_ruleSyntaxSignature (const GGS_AC_instruction_ForGrammar & argument_0) {
  mNextItem = (elementOf_GGS_L_ruleSyntaxSignature *) NULL ;
  mInstruction = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_ruleSyntaxSignature::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mInstruction.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@L_ruleSyntaxSignature'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature
::GGS_L_ruleSyntaxSignature (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_L_ruleSyntaxSignature
::GGS_L_ruleSyntaxSignature (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::~GGS_L_ruleSyntaxSignature (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::GGS_L_ruleSyntaxSignature (const GGS_L_ruleSyntaxSignature & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature
::operator = (const GGS_L_ruleSyntaxSignature & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
internalAppendItem (const GGS_AC_instruction_ForGrammar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
addAssign_operation (const GGS_AC_instruction_ForGrammar & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mInstruction) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature  GGS_L_ruleSyntaxSignature::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_ruleSyntaxSignature result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_ruleSyntaxSignature::reader_description (void) const {
  C_String s ;
  s << "<list @L_ruleSyntaxSignature" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_ruleSyntaxSignature
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'L_grammarsMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_grammarsMap::
elementOf_GGS_L_grammarsMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_L_grammarsMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_grammarsMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mStartSymbolParametersMap.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_L_grammarsMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_L_grammarsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_L_grammarsMap * info = (e_L_grammarsMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_grammarsMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAlts &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_L_grammarsMap info  ;
    info.mStartSymbolParametersMap = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAlts   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mStartSymbolParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   & outParameter0) {
  searchElement (inLexique,
                 "the '%K' grammar is not defined",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts & inParameter0) {
  insertElement (lexique_var_,
                 "the '%K' grammar is already defined in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_L_grammarsMap::reader_description (void) const {
  C_String s ;
  s << "<map @L_grammarsMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class map 'M_nonterminalSymbolAltsForGrammar'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonterminalSymbolAltsForGrammar::
elementOf_GGS_M_nonterminalSymbolAltsForGrammar (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonterminalSymbolAltsForGrammar & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonterminalSymbolAltsForGrammar::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mFormalParametersList.reader_description () ;
  ioString << mInfo.mReturnedEntityTypeName.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonterminalSymbolAltsForGrammar::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonterminalSymbolAltsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonterminalSymbolAltsForGrammar * info = (e_M_nonterminalSymbolAltsForGrammar *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAltsForGrammar GGS_M_nonterminalSymbolAltsForGrammar::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAltsForGrammar result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               const GGS_lstring &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_nonterminalSymbolAltsForGrammar info  ;
    info.mFormalParametersList = inParameter0 ;
    info.mReturnedEntityTypeName = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalParametersList ;
    outParameter1 = node->mInfo.mReturnedEntityTypeName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0,
                                GGS_lstring   & outParameter1) {
  searchElement (inLexique,
                 "the rule label '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0,
                                const GGS_lstring & inParameter1) {
  insertElement (lexique_var_,
                 "the rule label '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

GGS_string GGS_M_nonterminalSymbolAltsForGrammar::reader_description (void) const {
  C_String s ;
  s << "<map @M_nonterminalSymbolAltsForGrammar " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@L_productionRules_ForGrammarComponent'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_productionRules_ForGrammarComponent::
elementOf_GGS_L_productionRules_ForGrammarComponent (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) {
  mNextItem = (elementOf_GGS_L_productionRules_ForGrammarComponent *) NULL ;
  mLeftNonterminalSymbol = argument_0 ;
  mLeftNonterminalSymbolIndex = argument_1 ;
  mInstructionsList = argument_2 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_productionRules_ForGrammarComponent::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mLeftNonterminalSymbol.reader_description () ;
  ioString << mLeftNonterminalSymbolIndex.reader_description () ;
  ioString << mInstructionsList.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@L_productionRules_ForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent
::GGS_L_productionRules_ForGrammarComponent (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_L_productionRules_ForGrammarComponent
::GGS_L_productionRules_ForGrammarComponent (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::~GGS_L_productionRules_ForGrammarComponent (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::GGS_L_productionRules_ForGrammarComponent (const GGS_L_productionRules_ForGrammarComponent & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent
::operator = (const GGS_L_productionRules_ForGrammarComponent & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mLeftNonterminalSymbol,
                                p->mLeftNonterminalSymbolIndex,
                                p->mInstructionsList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent  GGS_L_productionRules_ForGrammarComponent::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_productionRules_ForGrammarComponent result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_productionRules_ForGrammarComponent::reader_description (void) const {
  C_String s ;
  s << "<list @L_productionRules_ForGrammarComponent" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_productionRules_ForGrammarComponent
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'M_nonTerminalSymbolsForGrammar'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonTerminalSymbolsForGrammar::
elementOf_GGS_M_nonTerminalSymbolsForGrammar (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonTerminalSymbolsForGrammar & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonTerminalSymbolsForGrammar::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mNonterminalSymbolParametersMap.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonTerminalSymbolsForGrammar::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonTerminalSymbolsForGrammar * info = (e_M_nonTerminalSymbolsForGrammar *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolsForGrammar GGS_M_nonTerminalSymbolsForGrammar::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolsForGrammar result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAltsForGrammar &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_nonTerminalSymbolsForGrammar info  ;
    info.mNonterminalSymbolParametersMap = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0) {
  searchElement (inLexique,
                 "internal search error",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0) {
  searchElement (inLexique,
                 "internal search error",
                 inKey,
                 outParameter0,
                 & outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0) {
  insertElement (lexique_var_,
                 "internal insert error",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_M_nonTerminalSymbolsForGrammar::reader_description (void) const {
  C_String s ;
  s << "<map @M_nonTerminalSymbolsForGrammar " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'M_syntaxComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_syntaxComponents::
elementOf_GGS_M_syntaxComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_syntaxComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_syntaxComponents::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mNonterminalSymbolsMap.reader_description () ;
  ioString << mInfo.mProductionRulesList.reader_description () ;
  ioString << mInfo.mLexiqueComponentName.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_syntaxComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_syntaxComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_syntaxComponents * info = (e_M_syntaxComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_syntaxComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonTerminalSymbolsForGrammar &  inParameter0,
               const GGS_L_productionRules_ForGrammarComponent &  inParameter1,
               const GGS_lstring &  inParameter2,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_syntaxComponents info  ;
    info.mNonterminalSymbolsMap = inParameter0 ;
    info.mProductionRulesList = inParameter1 ;
    info.mLexiqueComponentName = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonTerminalSymbolsForGrammar   & outParameter0,
               GGS_L_productionRules_ForGrammarComponent   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolsMap ;
    outParameter1 = node->mInfo.mProductionRulesList ;
    outParameter2 = node->mInfo.mLexiqueComponentName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonTerminalSymbolsForGrammar   & outParameter0,
                                GGS_L_productionRules_ForGrammarComponent   & outParameter1,
                                GGS_lstring   & outParameter2) {
  searchElement (inLexique,
                 "there is no syntax component named '%K'",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_M_nonTerminalSymbolsForGrammar & inParameter0,
                                const GGS_L_productionRules_ForGrammarComponent & inParameter1,
                                const GGS_lstring & inParameter2) {
  insertElement (lexique_var_,
                 "a syntax component named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL) ;
}

GGS_string GGS_M_syntaxComponents::reader_description (void) const {
  C_String s ;
  s << "<map @M_syntaxComponents " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'T_terminalInstruction_forGrammarComponent'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_terminalInstruction_forGrammarComponent::cPtr_T_terminalInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mTerminalSymbolName (argument_1),
mTerminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_T_terminalInstruction_forGrammarComponent::appendForDescription (C_String & ioString) const {
  ioString << "->@T_terminalInstruction_forGrammarComponent:" ;
mStartLocation.reader_description () ;
mTerminalSymbolName.reader_description () ;
mTerminalSymbolIndex.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_T_terminalInstruction_forGrammarComponent'        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_T_terminalInstruction_forGrammarComponent * GGS_T_terminalInstruction_forGrammarComponent::
    constructor_new (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_T_terminalInstruction_forGrammarComponent * ptr_ = (cPtr_T_terminalInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_terminalInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'T_nonterminalInstruction_forGrammarComponent'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_nonterminalInstruction_forGrammarComponent::cPtr_T_nonterminalInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mNonterminalSymbolName (argument_1),
mNonterminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_T_nonterminalInstruction_forGrammarComponent::appendForDescription (C_String & ioString) const {
  ioString << "->@T_nonterminalInstruction_forGrammarComponent:" ;
mStartLocation.reader_description () ;
mNonterminalSymbolName.reader_description () ;
mNonterminalSymbolIndex.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_T_nonterminalInstruction_forGrammarComponent'       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_T_nonterminalInstruction_forGrammarComponent * GGS_T_nonterminalInstruction_forGrammarComponent::
    constructor_new (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_T_nonterminalInstruction_forGrammarComponent * ptr_ = (cPtr_T_nonterminalInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_nonterminalInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@L_branchList_ForGrammarComponent'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_branchList_ForGrammarComponent::
elementOf_GGS_L_branchList_ForGrammarComponent (const GGS_L_ruleSyntaxSignature & argument_0) {
  mNextItem = (elementOf_GGS_L_branchList_ForGrammarComponent *) NULL ;
  mInstructionsList = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_branchList_ForGrammarComponent::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mInstructionsList.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@L_branchList_ForGrammarComponent'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent
::GGS_L_branchList_ForGrammarComponent (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_L_branchList_ForGrammarComponent
::GGS_L_branchList_ForGrammarComponent (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::~GGS_L_branchList_ForGrammarComponent (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::GGS_L_branchList_ForGrammarComponent (const GGS_L_branchList_ForGrammarComponent & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent
::operator = (const GGS_L_branchList_ForGrammarComponent & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
internalAppendItem (const GGS_L_ruleSyntaxSignature & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
addAssign_operation (const GGS_L_ruleSyntaxSignature & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mInstructionsList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent  GGS_L_branchList_ForGrammarComponent::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_branchList_ForGrammarComponent result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_branchList_ForGrammarComponent::reader_description (void) const {
  C_String s ;
  s << "<list @L_branchList_ForGrammarComponent" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_branchList_ForGrammarComponent
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'T_selectInstruction_forGrammarComponent'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_selectInstruction_forGrammarComponent::cPtr_T_selectInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mSelectList (argument_1),
mAddedNonterminalmSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_T_selectInstruction_forGrammarComponent::appendForDescription (C_String & ioString) const {
  ioString << "->@T_selectInstruction_forGrammarComponent:" ;
mStartLocation.reader_description () ;
mSelectList.reader_description () ;
mAddedNonterminalmSymbolIndex.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_T_selectInstruction_forGrammarComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_T_selectInstruction_forGrammarComponent * GGS_T_selectInstruction_forGrammarComponent::
    constructor_new (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_T_selectInstruction_forGrammarComponent * ptr_ = (cPtr_T_selectInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_selectInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'T_repeatInstruction_forGrammarComponent'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_repeatInstruction_forGrammarComponent::cPtr_T_repeatInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mRepeatList (argument_1),
mAddedNonterminalmSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_T_repeatInstruction_forGrammarComponent::appendForDescription (C_String & ioString) const {
  ioString << "->@T_repeatInstruction_forGrammarComponent:" ;
mStartLocation.reader_description () ;
mRepeatList.reader_description () ;
mAddedNonterminalmSymbolIndex.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_T_repeatInstruction_forGrammarComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_T_repeatInstruction_forGrammarComponent * GGS_T_repeatInstruction_forGrammarComponent::
    constructor_new (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_T_repeatInstruction_forGrammarComponent * ptr_ = (cPtr_T_repeatInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_repeatInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_syntaxComponents_ForGrammar'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_syntaxComponents_ForGrammar::
elementOf_GGS_L_syntaxComponents_ForGrammar (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_lstring & argument_2) {
  mNextItem = (elementOf_GGS_L_syntaxComponents_ForGrammar *) NULL ;
  mNonterminalSymbolsMap = argument_0 ;
  mProductionRulesList = argument_1 ;
  mSyntaxComponentName = argument_2 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_syntaxComponents_ForGrammar::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mNonterminalSymbolsMap.reader_description () ;
  ioString << mProductionRulesList.reader_description () ;
  ioString << mSyntaxComponentName.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_syntaxComponents_ForGrammar'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar
::GGS_L_syntaxComponents_ForGrammar (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_L_syntaxComponents_ForGrammar
::GGS_L_syntaxComponents_ForGrammar (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::~GGS_L_syntaxComponents_ForGrammar (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::GGS_L_syntaxComponents_ForGrammar (const GGS_L_syntaxComponents_ForGrammar & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar
::operator = (const GGS_L_syntaxComponents_ForGrammar & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
internalAppendItem (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_lstring & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
addAssign_operation (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mNonterminalSymbolsMap,
                                p->mProductionRulesList,
                                p->mSyntaxComponentName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar  GGS_L_syntaxComponents_ForGrammar::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_syntaxComponents_ForGrammar result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_syntaxComponents_ForGrammar::reader_description (void) const {
  C_String s ;
  s << "<list @L_syntaxComponents_ForGrammar" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_syntaxComponents_ForGrammar
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class map 'M_startSymbolEntityAndMetamodel'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_startSymbolEntityAndMetamodel::
elementOf_GGS_M_startSymbolEntityAndMetamodel (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_startSymbolEntityAndMetamodel & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_startSymbolEntityAndMetamodel::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mReturnedEntityName.reader_description () ;
  ioString << mInfo.mReturnedMetamodelName.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_startSymbolEntityAndMetamodel::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_startSymbolEntityAndMetamodel *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_startSymbolEntityAndMetamodel * info = (e_M_startSymbolEntityAndMetamodel *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_startSymbolEntityAndMetamodel GGS_M_startSymbolEntityAndMetamodel::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_startSymbolEntityAndMetamodel result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               const GGS_lstring &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_startSymbolEntityAndMetamodel info  ;
    info.mReturnedEntityName = inParameter0 ;
    info.mReturnedMetamodelName = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mReturnedEntityName ;
    outParameter1 = node->mInfo.mReturnedMetamodelName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstring   & outParameter1) {
  searchElement (inLexique,
                 "the label '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_lstring & inParameter1) {
  insertElement (lexique_var_,
                 "the label '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

GGS_string GGS_M_startSymbolEntityAndMetamodel::reader_description (void) const {
  C_String s ;
  s << "<map @M_startSymbolEntityAndMetamodel " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_identifiers'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_identifiers::
elementOf_GGS_L_identifiers (const GGS_lstring & argument_0) {
  mNextItem = (elementOf_GGS_L_identifiers *) NULL ;
  aIdentificateur = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_identifiers::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << aIdentificateur.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_identifiers'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_identifiers
::GGS_L_identifiers (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_L_identifiers
::GGS_L_identifiers (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_identifiers::~GGS_L_identifiers (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_identifiers::GGS_L_identifiers (const GGS_L_identifiers & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers
::operator = (const GGS_L_identifiers & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aIdentificateur) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_identifiers  GGS_L_identifiers::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_identifiers result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_identifiers::reader_description (void) const {
  C_String s ;
  s << "<list @L_identifiers" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_identifiers
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'typeSuperClassesMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSuperClassesMap::
elementOf_GGS_typeSuperClassesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeSuperClassesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSuperClassesMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeSuperClassesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeSuperClassesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeSuperClassesMap * info = (e_typeSuperClassesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeSuperClassesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeSuperClassesMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey) {
  insertElement (lexique_var_,
                 "the class '%K' is already a super class of the current class",
                 inKey,
                 NULL) ;
}

GGS_string GGS_typeSuperClassesMap::reader_description (void) const {
  C_String s ;
  s << "<map @typeSuperClassesMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeClassInheritedMessagesMap'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeClassInheritedMessagesMap::
elementOf_GGS_typeClassInheritedMessagesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeClassInheritedMessagesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeClassInheritedMessagesMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassInheritedMessagesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeClassInheritedMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeClassInheritedMessagesMap * info = (e_typeClassInheritedMessagesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeClassInheritedMessagesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeClassInheritedMessagesMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey) {
  searchElement (inLexique,
                 "the message '%K' is not declared",
                 inKey,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey) {
  insertElement (lexique_var_,
                 "the message '%K' is already declared in %L",
                 inKey,
                 NULL) ;
}

GGS_string GGS_typeClassInheritedMessagesMap::reader_description (void) const {
  C_String s ;
  s << "<map @typeClassInheritedMessagesMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'typeSemanticAttributesMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSemanticAttributesMap::
elementOf_GGS_typeSemanticAttributesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeSemanticAttributesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSemanticAttributesMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mAttributType.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeSemanticAttributesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeSemanticAttributesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeSemanticAttributesMap * info = (e_typeSemanticAttributesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticAttributesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_galgasType &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeSemanticAttributesMap info  ;
    info.mAttributType = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0) {
  searchElement (inLexique,
                 "there is no attribut named '%K'",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0) {
  insertElement (lexique_var_,
                 "an attribut named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_typeSemanticAttributesMap::reader_description (void) const {
  C_String s ;
  s << "<map @typeSemanticAttributesMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Class for 'lastStateEnum' Enumeration                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_lastStateEnum::
operator == (const GGS_lastStateEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lastStateEnum::
operator != (const GGS_lastStateEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lastStateEnum::
operator <= (const GGS_lastStateEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lastStateEnum::
operator >= (const GGS_lastStateEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lastStateEnum::
operator < (const GGS_lastStateEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lastStateEnum::
operator > (const GGS_lastStateEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lastStateEnum::
reader_description (void) const {
  C_String s ;
  s << "<enum @lastStateEnum" ;
  switch (mValue) {
case enum_acceptedState:
  s << " acceptedState" ;
    break ;
case enum_warningState:
  s << " warningState" ;
    break ;
case enum_errorState:
  s << " errorState" ;
    break ;
  case kNotBuilt:
    s << " (not built)" ;
    break ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@lastStateList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lastStateList::
elementOf_GGS_lastStateList (const GGS_lstring & argument_0,
                                const GGS_lastStateEnum& argument_1,
                                const GGS_L_stringList & argument_2) {
  mNextItem = (elementOf_GGS_lastStateList *) NULL ;
  mLastState = argument_0 ;
  mStatus = argument_1 ;
  mMessageList = argument_2 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lastStateList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mLastState.reader_description () ;
  ioString << mStatus.reader_description () ;
  ioString << mMessageList.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@lastStateList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lastStateList
::GGS_lastStateList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_lastStateList
::GGS_lastStateList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_lastStateList::~GGS_lastStateList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_lastStateList::GGS_lastStateList (const GGS_lastStateList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_lastStateList
::operator = (const GGS_lastStateList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lastStateList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lastStateList::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lastStateEnum& argument_1,
                                const GGS_L_stringList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lastStateList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lastStateEnum& argument_1,
                                const GGS_L_stringList & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lastStateList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mLastState,
                                p->mStatus,
                                p->mMessageList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lastStateList  GGS_lastStateList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_lastStateList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lastStateList::reader_description (void) const {
  C_String s ;
  s << "<list @lastStateList" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_lastStateList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'transitionStatusMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_transitionStatusMap::
elementOf_GGS_transitionStatusMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_transitionStatusMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_transitionStatusMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mStatus.reader_description () ;
  ioString << mInfo.mMessageList.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_transitionStatusMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_transitionStatusMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_transitionStatusMap * info = (e_transitionStatusMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_transitionStatusMap GGS_transitionStatusMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_transitionStatusMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_transitionStatusMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_transitionStatusMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lastStateEnum&  inParameter0,
               const GGS_L_stringList &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_transitionStatusMap info  ;
    info.mStatus = inParameter0 ;
    info.mMessageList = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_transitionStatusMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lastStateEnum  & outParameter0,
               GGS_L_stringList   & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mStatus ;
    outParameter1 = node->mInfo.mMessageList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_transitionStatusMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_lastStateEnum& inParameter0,
                                const GGS_L_stringList & inParameter1) {
  insertElement (lexique_var_,
                 "a transition named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

GGS_string GGS_transitionStatusMap::reader_description (void) const {
  C_String s ;
  s << "<map @transitionStatusMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@insertOrSearchMethodList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_insertOrSearchMethodList::
elementOf_GGS_insertOrSearchMethodList (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_lastStateList & argument_3,
                                const GGS_transitionStatusMap & argument_4,
                                const GGS_bool& argument_5) {
  mNextItem = (elementOf_GGS_insertOrSearchMethodList *) NULL ;
  mMethodName = argument_0 ;
  mErrorMessage = argument_1 ;
  mFirstState = argument_2 ;
  mLastStateList = argument_3 ;
  mTransitionStatusMap = argument_4 ;
  mIsGetIndexMethod = argument_5 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_insertOrSearchMethodList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mMethodName.reader_description () ;
  ioString << mErrorMessage.reader_description () ;
  ioString << mFirstState.reader_description () ;
  ioString << mLastStateList.reader_description () ;
  ioString << mTransitionStatusMap.reader_description () ;
  ioString << mIsGetIndexMethod.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@insertOrSearchMethodList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList
::GGS_insertOrSearchMethodList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_insertOrSearchMethodList
::GGS_insertOrSearchMethodList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList::~GGS_insertOrSearchMethodList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList::GGS_insertOrSearchMethodList (const GGS_insertOrSearchMethodList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList
::operator = (const GGS_insertOrSearchMethodList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_lastStateList & argument_3,
                                const GGS_transitionStatusMap & argument_4,
                                const GGS_bool& argument_5) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_lastStateList & argument_3,
                                const GGS_transitionStatusMap & argument_4,
                                const GGS_bool& argument_5) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mMethodName,
                                p->mErrorMessage,
                                p->mFirstState,
                                p->mLastStateList,
                                p->mTransitionStatusMap,
                                p->mIsGetIndexMethod) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_insertOrSearchMethodList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_insertOrSearchMethodList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertOrSearchMethodList::reader_description (void) const {
  C_String s ;
  s << "<list @insertOrSearchMethodList" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_insertOrSearchMethodList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeDefEntiteUtilisable'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefEntiteUtilisable::
cPtr_typeDefEntiteUtilisable (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable
::static_string_message_messageTypeEntite (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable::
message_messageTypeEntite (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeDefEntiteUtilisable'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (void) {
  mPointer = (cPtr_typeDefEntiteUtilisable *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (const GGS_typeDefEntiteUtilisable & inOperand) {
  mPointer = (cPtr_typeDefEntiteUtilisable *) NULL ;
  macroTransfertPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
~GGS_typeDefEntiteUtilisable (void) {
  macroDetachPointer (mPointer, cPtr_typeDefEntiteUtilisable) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefEntiteUtilisable::
operator = (const GGS_typeDefEntiteUtilisable & inOperand) {
  macroTransfertPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefEntiteUtilisable::
operator = (cPtr_typeDefEntiteUtilisable * inSource) {
  macroTransfertPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (cPtr_typeDefEntiteUtilisable * inSource) {
  mPointer = (cPtr_typeDefEntiteUtilisable *) NULL ;
  macroTransfertPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDefEntiteUtilisable * GGS_typeDefEntiteUtilisable
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDefEntiteUtilisable::reader_messageTypeEntite (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageTypeEntite ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefEntiteUtilisable
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeDefEntiteUtilisable) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDefEntiteUtilisable
::reader_description (void) const {
  C_String s ;
  s << "<class @typeDefEntiteUtilisable" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeGalgasUndefinedListType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedListType::cPtr_typeGalgasUndefinedListType (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mListTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedListType::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mListTypeName.reader_value () ;
}


const char * cPtr_typeGalgasUndefinedListType::message_messageGalgasType (void) const {
  return "undefined 'list' type" ;
}

const char * cPtr_typeGalgasUndefinedListType::static_string_message_messageGalgasType (void) {
  return "undefined 'list' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedListType::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgasUndefinedListType:" ;
mListTypeName.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedListType'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasUndefinedListType * GGS_typeGalgasUndefinedListType::
    constructor_new (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasUndefinedListType * ptr_ = (cPtr_typeGalgasUndefinedListType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedListType (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgasListType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasListType::cPtr_typeGalgasListType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedListType (argument_0 COMMA_THERE),
mNonExternAttributesList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
methode_acceptForeachInstruction (C_Lexique & /* lexique_var_ */,
                                GGS_lstring  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle) {
  var_cas_outForeachList = mNonExternAttributesList ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_listStyle (HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
methode_handleAddAssignOperatorCall (C_Lexique & /* lexique_var_ */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList,
                                GGS_bool& var_cas_outAccept_uint_assignment) {
  var_cas_outParametersList = mNonExternAttributesList ;
  var_cas_outAccept_uint_assignment = GGS_bool (true, false) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}


const char * cPtr_typeGalgasListType::message_messageGalgasType (void) const {
  return "'list' type" ;
}

const char * cPtr_typeGalgasListType::static_string_message_messageGalgasType (void) {
  return "'list' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgasListType:" ;
mListTypeName.reader_description () ;
mNonExternAttributesList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasListType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasListType * GGS_typeGalgasListType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasListType * ptr_ = (cPtr_typeGalgasListType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasListType (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'typeTableBlocsDeTable'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableBlocsDeTable::
elementOf_GGS_typeTableBlocsDeTable (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableBlocsDeTable & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableBlocsDeTable::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.aSignatureDebut.reader_description () ;
  ioString << mInfo.aSignatureFin.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableBlocsDeTable::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableBlocsDeTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableBlocsDeTable * info = (e_typeTableBlocsDeTable *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeTableBlocsDeTable result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_EXsignature &  inParameter0,
               const GGS_L_EXsignature &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableBlocsDeTable info  ;
    info.aSignatureDebut = inParameter0 ;
    info.aSignatureFin = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aSignatureDebut ;
    outParameter1 = node->mInfo.aSignatureFin ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_L_EXsignature   & outParameter1) {
  searchElement (inLexique,
                 "there is no block method named '%K'",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_L_EXsignature & inParameter1) {
  insertElement (lexique_var_,
                 "a block method named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

GGS_string GGS_typeTableBlocsDeTable::reader_description (void) const {
  C_String s ;
  s << "<map @typeTableBlocsDeTable " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeGalgasUndefinedMapType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedMapType::cPtr_typeGalgasUndefinedMapType (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mMapTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapType::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mMapTypeName.reader_value () ;
}


const char * cPtr_typeGalgasUndefinedMapType::message_messageGalgasType (void) const {
  return "undefined 'map' type" ;
}

const char * cPtr_typeGalgasUndefinedMapType::static_string_message_messageGalgasType (void) {
  return "undefined 'map' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapType::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgasUndefinedMapType:" ;
mMapTypeName.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedMapType'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasUndefinedMapType * GGS_typeGalgasUndefinedMapType::
    constructor_new (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasUndefinedMapType * ptr_ = (cPtr_typeGalgasUndefinedMapType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedMapType (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'mapMethodMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapMethodMap::
elementOf_GGS_mapMethodMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapMethodMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mMethodSignature.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapMethodMap * info = (e_mapMethodMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_mapMethodMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_EXsignature &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_mapMethodMap info  ;
    info.mMethodSignature = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMethodSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0) {
  searchElement (inLexique,
                 "there is no insert nor search method named '%K'",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0) {
  insertElement (lexique_var_,
                 "an insert or a search method named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_mapMethodMap::reader_description (void) const {
  C_String s ;
  s << "<map @mapMethodMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgasMapType'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasMapType::cPtr_typeGalgasMapType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableBlocsDeTable & argument_2,
                                const GGS_mapMethodMap & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedMapType (argument_0 COMMA_THERE),
mNonExternAttributesList (argument_1),
aTableMethodesSurcharger (argument_2),
mMethodMap (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
methode_handleModifierCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature) {
  GGS_mapMethodMap  var_cas_methodMap ;
  var_cas_methodMap = mMethodMap ;
  var_cas_methodMap.methode_searchKey (lexique_var_, var_cas_inModifierName, var_cas_outModifierSignature) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
methode_acceptForeachInstruction (C_Lexique & lexique_var_,
                                GGS_lstring  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle) {
  GGS_AC_galgasType  var_cas_keyType ;
  var_cas_keyType = GGS_typeGalgas_lstring::constructor_new (HERE) ;
  var_cas_outForeachList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
  var_cas_outForeachList.addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (GGS_string (true, "\?\?\?"), GGS_location (lexique_var_) COMMA_HERE)) ;
  GGS_typeListeAttributsSemantiques::element_type * operand_68826 = mNonExternAttributesList.firstObject () ;
  while ((operand_68826 != NULL)) {
    macroValidPointer (operand_68826) ;
    var_cas_outForeachList.addAssign_operation (operand_68826->mAttributType, operand_68826->aNomAttribut) ;
    operand_68826 = operand_68826->nextObject () ;
  }
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}


const char * cPtr_typeGalgasMapType::message_messageGalgasType (void) const {
  return "'map' type" ;
}

const char * cPtr_typeGalgasMapType::static_string_message_messageGalgasType (void) {
  return "'map' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgasMapType:" ;
mMapTypeName.reader_description () ;
mNonExternAttributesList.reader_description () ;
aTableMethodesSurcharger.reader_description () ;
mMethodMap.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgasMapType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasMapType * GGS_typeGalgasMapType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableBlocsDeTable & argument_2,
                                const GGS_mapMethodMap & argument_3 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasMapType * ptr_ = (cPtr_typeGalgasMapType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasMapType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeGalgasUndefinedClassType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedClassType::cPtr_typeGalgasUndefinedClassType (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mClassTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedClassType::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mClassTypeName.reader_value () ;
}


const char * cPtr_typeGalgasUndefinedClassType::message_messageGalgasType (void) const {
  return "undefined 'class' type" ;
}

const char * cPtr_typeGalgasUndefinedClassType::static_string_message_messageGalgasType (void) {
  return "undefined 'class' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedClassType::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgasUndefinedClassType:" ;
mClassTypeName.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedClassType'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasUndefinedClassType * GGS_typeGalgasUndefinedClassType::
    constructor_new (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasUndefinedClassType * ptr_ = (cPtr_typeGalgasUndefinedClassType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedClassType (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgasClassType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasClassType::cPtr_typeGalgasClassType (const GGS_lstring & argument_0,
                                const GGS_typeTableMethodes & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeSuperClassesMap & argument_3,
                                const GGS_typeClassInheritedMessagesMap & argument_4,
                                const GGS_typeSemanticAttributesMap & argument_5,
                                const GGS_bool& argument_6 COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedClassType (argument_0 COMMA_THERE),
mMethodsMap (argument_1),
mNonExternAttributesList (argument_2),
mAncestorClassesMap (argument_3),
mMessagesMap (argument_4),
mNonExternAttributesMap (argument_5),
mClassIsAbstract (argument_6) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
methode_typeCanBeUsedInObjectDeclaration (C_Lexique & lexique_var_) {
  if (((! mClassIsAbstract)).isBuiltAndTrue ()) {
      GGS_location (lexique_var_).reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "non abstract class object cannot be declared (only instancied by 'new')")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
methode_handleReaderInstructionCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_L_EXsignature & var_cas_outMethodSignature) {
  GGS_typeTableMethodes  var_cas_methodMap ;
  var_cas_methodMap = mMethodsMap ;
  var_cas_methodMap.methode_searchKey (lexique_var_, var_cas_inMethodName, var_cas_outMethodSignature) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if ((mClassIsAbstract).isBuiltAndTrue ()) {
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "an abstract class cannot be instancied")) ;
  }else if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = mNonExternAttributesList ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}


const char * cPtr_typeGalgasClassType::message_messageGalgasType (void) const {
  return "'class' type" ;
}

const char * cPtr_typeGalgasClassType::static_string_message_messageGalgasType (void) {
  return "'class' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgasClassType:" ;
mClassTypeName.reader_description () ;
mMethodsMap.reader_description () ;
mNonExternAttributesList.reader_description () ;
mAncestorClassesMap.reader_description () ;
mMessagesMap.reader_description () ;
mNonExternAttributesMap.reader_description () ;
mClassIsAbstract.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasClassType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasClassType * GGS_typeGalgasClassType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeTableMethodes & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeSuperClassesMap & argument_3,
                                const GGS_typeClassInheritedMessagesMap & argument_4,
                                const GGS_typeSemanticAttributesMap & argument_5,
                                const GGS_bool& argument_6 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasClassType * ptr_ = (cPtr_typeGalgasClassType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasClassType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEntiteType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteType::cPtr_typeEntiteType (const GGS_AC_galgasType & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aDefType (argument_0) {
}


const char * cPtr_typeEntiteType::message_messageTypeEntite (void) const {
  return "a type" ;
}

const char * cPtr_typeEntiteType::static_string_message_messageTypeEntite (void) {
  return "a type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteType::appendForDescription (C_String & ioString) const {
  ioString << "->@typeEntiteType:" ;
aDefType.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEntiteType * GGS_typeEntiteType::
    constructor_new (const GGS_AC_galgasType & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeEntiteType * ptr_ = (cPtr_typeEntiteType *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteType (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeEntiteRoutine'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteRoutine::cPtr_typeEntiteRoutine (const GGS_L_EXsignature & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aListeArgumentsFormels (argument_0) {
}


const char * cPtr_typeEntiteRoutine::message_messageTypeEntite (void) const {
  return "a routine" ;
}

const char * cPtr_typeEntiteRoutine::static_string_message_messageTypeEntite (void) {
  return "a routine" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteRoutine::appendForDescription (C_String & ioString) const {
  ioString << "->@typeEntiteRoutine:" ;
aListeArgumentsFormels.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeEntiteRoutine'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEntiteRoutine * GGS_typeEntiteRoutine::
    constructor_new (const GGS_L_EXsignature & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeEntiteRoutine * ptr_ = (cPtr_typeEntiteRoutine *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteRoutine (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'typeEnumMessageMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumMessageMap::
elementOf_GGS_typeEnumMessageMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEnumMessageMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mMessageStringList.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeEnumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumMessageMap * info = (e_typeEnumMessageMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeEnumMessageMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_lstringList &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeEnumMessageMap info  ;
    info.mMessageStringList = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_lstringList   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessageStringList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_lstringList   & outParameter0) {
  searchElement (inLexique,
                 "the '%K' message name is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_lstringList & inParameter0) {
  insertElement (lexique_var_,
                 "the '%K' message name is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL) ;
}

GGS_string GGS_typeEnumMessageMap::reader_description (void) const {
  C_String s ;
  s << "<map @typeEnumMessageMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_enum'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_enum::cPtr_typeGalgas_enum (const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEnumTypeName (argument_0),
mEnumConstantesMap (argument_1),
mMessagesMap (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mEnumTypeName.reader_value () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  GGS_enumConstantMap  var_cas_enumConstantesMap ;
  var_cas_enumConstantesMap = mEnumConstantesMap ;
  var_cas_enumConstantesMap.methode_searchKey (lexique_var_, var_cas_inClassMethodName) ;
  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
}


const char * cPtr_typeGalgas_enum::message_messageGalgasType (void) const {
  return "a 'enum' type" ;
}

const char * cPtr_typeGalgas_enum::static_string_message_messageGalgasType (void) {
  return "a 'enum' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::appendForDescription (C_String & ioString) const {
  ioString << "->@typeGalgas_enum:" ;
mEnumTypeName.reader_description () ;
mEnumConstantesMap.reader_description () ;
mMessagesMap.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_enum'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_enum * GGS_typeGalgas_enum::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_enum * ptr_ = (cPtr_typeGalgas_enum *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_enum (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//    Implementation of routine "verifierCompatibiliteTypesSemantiques"      *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteTypesSemantiques (C_Lexique & lexique_var_,
                                const GGS_AC_galgasType  & var_cas_inFormalType,
                                const GGS_AC_galgasType  & var_cas_inEffectiveType,
                                const GGS_location  & var_cas_inErrorLocation) {
  if (var_cas_inFormalType.isBuilt () && var_cas_inEffectiveType.isBuilt ()) {
    cPtr_AC_galgasType * ptr_74599 = var_cas_inFormalType (HERE) ;
    cPtr_AC_galgasType * ptr_74618 = var_cas_inEffectiveType (HERE) ;
    cPtr_typeGalgas_stringset * operand_74599 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_74599) ;
    cPtr_typeGalgas_stringset * operand_74618 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_74618) ;
    if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
    }else{
      cPtr_typeGalgas_uint * operand_74599 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_74599) ;
      cPtr_typeGalgas_uint * operand_74618 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_74618) ;
      if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
      }else{
        cPtr_typeGalgas_sint * operand_74599 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_74599) ;
        cPtr_typeGalgas_sint * operand_74618 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_74618) ;
        if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
        }else{
          cPtr_typeGalgas_char * operand_74599 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_74599) ;
          cPtr_typeGalgas_char * operand_74618 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_74618) ;
          if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
          }else{
            cPtr_typeGalgas_string * operand_74599 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_74599) ;
            cPtr_typeGalgas_string * operand_74618 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_74618) ;
            if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
            }else{
              cPtr_typeGalgas_bool * operand_74599 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_74599) ;
              cPtr_typeGalgas_bool * operand_74618 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_74618) ;
              if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
              }else{
                cPtr_typeGalgas_double * operand_74599 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_74599) ;
                cPtr_typeGalgas_double * operand_74618 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_74618) ;
                if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
                }else{
                  cPtr_typeGalgas_lbool * operand_74599 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_74599) ;
                  cPtr_typeGalgas_lbool * operand_74618 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_74618) ;
                  if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
                  }else{
                    cPtr_typeGalgas_lchar * operand_74599 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_74599) ;
                    cPtr_typeGalgas_lchar * operand_74618 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_74618) ;
                    if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
                    }else{
                      cPtr_typeGalgas_luint * operand_74599 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_74599) ;
                      cPtr_typeGalgas_luint * operand_74618 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_74618) ;
                      if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
                      }else{
                        cPtr_typeGalgas_lsint * operand_74599 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_74599) ;
                        cPtr_typeGalgas_lsint * operand_74618 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_74618) ;
                        if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
                        }else{
                          cPtr_typeGalgas_ldouble * operand_74599 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_74599) ;
                          cPtr_typeGalgas_ldouble * operand_74618 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_74618) ;
                          if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
                          }else{
                            cPtr_typeGalgas_lstring * operand_74599 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_74599) ;
                            cPtr_typeGalgas_lstring * operand_74618 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_74618) ;
                            if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
                            }else{
                              cPtr_typeGalgas_location * operand_74599 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_74599) ;
                              cPtr_typeGalgas_location * operand_74618 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_74618) ;
                              if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
                              }else{
                                cPtr_typeGalgasUndefinedListType * operand_74599 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_74599) ;
                                cPtr_typeGalgasUndefinedListType * operand_74618 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_74618) ;
                                if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
                                  if (((operand_74599->mListTypeName.reader_value ()) != (operand_74618->mListTypeName.reader_value ())).isBuiltAndTrue ()) {
                                      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting the list type '")) + (operand_74599->mListTypeName.reader_value ()))) + (GGS_string (true, "', I have got the list type '")))) + (operand_74618->mListTypeName.reader_value ()))) + (GGS_string (true, "\"")))) ;
                                  }
                                }else{
                                  cPtr_typeGalgasUndefinedMapType * operand_74599 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_74599) ;
                                  cPtr_typeGalgasUndefinedMapType * operand_74618 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_74618) ;
                                  if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
                                    if (((operand_74599->mMapTypeName.reader_value ()) != (operand_74618->mMapTypeName.reader_value ())).isBuiltAndTrue ()) {
                                        var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting the map type '")) + (operand_74599->mMapTypeName.reader_value ()))) + (GGS_string (true, "', I have got the map type '")))) + (operand_74618->mMapTypeName.reader_value ()))) + (GGS_string (true, "\"")))) ;
                                    }
                                  }else{
                                    cPtr_typeGalgasUndefinedClassType * operand_74599 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_74599) ;
                                    cPtr_typeGalgasUndefinedClassType * operand_74618 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_74618) ;
                                    if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
                                      if (((operand_74599->mClassTypeName.reader_value ()) != (operand_74618->mClassTypeName.reader_value ())).isBuiltAndTrue ()) {
                                          var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting the class type '")) + (operand_74599->mClassTypeName.reader_value ()))) + (GGS_string (true, "', I have got the class type '")))) + (operand_74618->mClassTypeName.reader_value ()))) + (GGS_string (true, "\"")))) ;
                                      }
                                    }else{
                                      cPtr_typeGalgasUndefinedExternType * operand_74599 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_74599) ;
                                      cPtr_typeGalgasUndefinedExternType * operand_74618 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_74618) ;
                                      if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
                                        if (((operand_74599->mGalgasClassName.reader_value ()) != (operand_74618->mGalgasClassName.reader_value ())).isBuiltAndTrue ()) {
                                            var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting an extern variable of extern '")) + (operand_74599->mGalgasClassName.reader_value ()))) + (GGS_string (true, "' type variable, and I got an extern '")))) + (operand_74618->mGalgasClassName.reader_value ()))) + (GGS_string (true, "' type variable")))) ;
                                        }
                                      }else{
                                        cPtr_typeGalgas_enum * operand_74599 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_74599) ;
                                        cPtr_typeGalgas_enum * operand_74618 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_74618) ;
                                        if ((operand_74599 != NULL) && (operand_74618 != NULL)) {
                                          if (((operand_74599->mEnumTypeName.reader_value ()) != (operand_74618->mEnumTypeName.reader_value ())).isBuiltAndTrue ()) {
                                              var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting an enum variable of  '")) + (operand_74599->mEnumTypeName.reader_value ()))) + (GGS_string (true, "' type variable, and I got an enum '")))) + (operand_74618->mEnumTypeName.reader_value ()))) + (GGS_string (true, "' type variable")))) ;
                                          }
                                        }else{
                                            var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((var_cas_inFormalType.reader_messageGalgasType ()) + (GGS_string (true, " is not compatible with ")))) + (var_cas_inEffectiveType.reader_messageGalgasType ()))) ;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of routine "verifierCompatibiliteSignatures"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteSignatures (C_Lexique & lexique_var_,
                                GGS_L_EXsignature   var_cas_signatureReference,
                                GGS_L_EXsignature   var_cas_signatureTestee,
                                GGS_location   var_cas_ouSignalerErreur) {
  if (((var_cas_signatureReference.reader_length ()) < (var_cas_signatureTestee.reader_length ())).isBuiltAndTrue ()) {
      var_cas_ouSignalerErreur.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "there are too much parameters")) ;
  }else if (((var_cas_signatureReference.reader_length ()) > (var_cas_signatureTestee.reader_length ())).isBuiltAndTrue ()) {
      var_cas_ouSignalerErreur.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "one or more parameters missing")) ;
  }else{
    GGS_L_EXsignature::element_type * operand_78404 = var_cas_signatureReference.firstObject () ;
    GGS_L_EXsignature::element_type * operand_78503 = var_cas_signatureTestee.firstObject () ;
    while ((operand_78404 != NULL)
        && (operand_78503 != NULL)) {
      macroValidPointer (operand_78404) ;
      macroValidPointer (operand_78503) ;
      ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  operand_78404->mType,  operand_78503->mType,  var_cas_ouSignalerErreur) ;
      if (((operand_78404->mFormalArgumentPassingMode) != (operand_78503->mFormalArgumentPassingMode)).isBuiltAndTrue ()) {
          var_cas_ouSignalerErreur.reader_location ().signalGGSSemanticError (lexique_var_, ((((operand_78503->mFormalArgumentPassingMode.reader_formalArgumentMessage ()) + (GGS_string (true, " is not compatible with ")))) + (operand_78503->mFormalArgumentPassingMode.reader_formalArgumentMessage ()))) ;
      }
      operand_78404 = operand_78404->nextObject () ;
      operand_78503 = operand_78503->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'M_cli_options'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_cli_options::
elementOf_GGS_M_cli_options (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_cli_options & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_cli_options::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mOptionChar.reader_description () ;
  ioString << mInfo.mOptionString.reader_description () ;
  ioString << mInfo.mComment.reader_description () ;
  ioString << mInfo.mDefaultValue.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_cli_options::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_cli_options *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_cli_options * info = (e_M_cli_options *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_cli_options result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lchar &  inParameter0,
               const GGS_lstring &  inParameter1,
               const GGS_lstring &  inParameter2,
               const GGS_uint &  inParameter3,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_cli_options info  ;
    info.mOptionChar = inParameter0 ;
    info.mOptionString = inParameter1 ;
    info.mComment = inParameter2 ;
    info.mDefaultValue = inParameter3 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lchar   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_uint   & outParameter3,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mOptionChar ;
    outParameter1 = node->mInfo.mOptionString ;
    outParameter2 = node->mInfo.mComment ;
    outParameter3 = node->mInfo.mDefaultValue ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lchar   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_lstring   & outParameter2,
                                GGS_uint   & outParameter3) {
  searchElement (inLexique,
                 "the '%K' command line option is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_lchar & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_lstring & inParameter2,
                                const GGS_uint & inParameter3) {
  insertElement (lexique_var_,
                 "the '%K' command line option has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL) ;
}

GGS_string GGS_M_cli_options::reader_description (void) const {
  C_String s ;
  s << "<map @M_cli_options " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'M_optionComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_optionComponents::
elementOf_GGS_M_optionComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_optionComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_optionComponents::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mBoolOptionsMap.reader_description () ;
  ioString << mInfo.mUintOptionsMap.reader_description () ;
  ioString << mInfo.mStringOptionsMap.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_optionComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_optionComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_optionComponents * info = (e_M_optionComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_optionComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_cli_options &  inParameter0,
               const GGS_M_cli_options &  inParameter1,
               const GGS_M_cli_options &  inParameter2,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_optionComponents info  ;
    info.mBoolOptionsMap = inParameter0 ;
    info.mUintOptionsMap = inParameter1 ;
    info.mStringOptionsMap = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_cli_options   & outParameter0,
               GGS_M_cli_options   & outParameter1,
               GGS_M_cli_options   & outParameter2,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mBoolOptionsMap ;
    outParameter1 = node->mInfo.mUintOptionsMap ;
    outParameter2 = node->mInfo.mStringOptionsMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_cli_options   & outParameter0,
                                GGS_M_cli_options   & outParameter1,
                                GGS_M_cli_options   & outParameter2) {
  searchElement (inLexique,
                 "there is no '%K' option component",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_M_cli_options & inParameter0,
                                const GGS_M_cli_options & inParameter1,
                                const GGS_M_cli_options & inParameter2) {
  insertElement (lexique_var_,
                 "the '%K' option component named is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL) ;
}

GGS_string GGS_M_optionComponents::reader_description (void) const {
  C_String s ;
  s << "<map @M_optionComponents " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'M_grammarComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_grammarComponents::
elementOf_GGS_M_grammarComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_grammarComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_grammarComponents::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mNonterminalSymbolParametersMap.reader_description () ;
  ioString << mInfo.mLexiqueName.reader_description () ;
  ioString << mInfo.mOptionsMap.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_grammarComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_grammarComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_grammarComponents * info = (e_M_grammarComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_grammarComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAltsForGrammar &  inParameter0,
               const GGS_lstring &  inParameter1,
               const GGS_M_optionComponents &  inParameter2,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_grammarComponents info  ;
    info.mNonterminalSymbolParametersMap = inParameter0 ;
    info.mLexiqueName = inParameter1 ;
    info.mOptionsMap = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_M_optionComponents   & outParameter2,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolParametersMap ;
    outParameter1 = node->mInfo.mLexiqueName ;
    outParameter2 = node->mInfo.mOptionsMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_M_optionComponents   & outParameter2) {
  searchElement (inLexique,
                 "the '%K' grammar component is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_M_optionComponents & inParameter2) {
  insertElement (lexique_var_,
                 "the '%K' grammar component has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL) ;
}

GGS_string GGS_M_grammarComponents::reader_description (void) const {
  C_String s ;
  s << "<map @M_grammarComponents " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'M_semanticsComponents'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_semanticsComponents::
elementOf_GGS_M_semanticsComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_semanticsComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_semanticsComponents::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mModelMap.reader_description () ;
  ioString << mInfo.mActionMap.reader_description () ;
  ioString << mInfo.mImportedSemanticsComponents.reader_description () ;
  ioString << mInfo.mImportedMetamodelComponents.reader_description () ;
  ioString << mInfo.mImportedOptionsComponents.reader_description () ;
  ioString << mInfo.mOptionsComponents.reader_description () ;
  ioString << mInfo.mSemanticsEntitiesMap.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_semanticsComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_semanticsComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_semanticsComponents * info = (e_M_semanticsComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_ModelMap &  inParameter0,
               const GGS_ActionMap &  inParameter1,
               const GGS_stringset &  inParameter2,
               const GGS_stringset &  inParameter3,
               const GGS_stringset &  inParameter4,
               const GGS_M_optionComponents &  inParameter5,
               const GGS_M_semanticsEntitiesForUse &  inParameter6,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_semanticsComponents info  ;
    info.mModelMap = inParameter0 ;
    info.mActionMap = inParameter1 ;
    info.mImportedSemanticsComponents = inParameter2 ;
    info.mImportedMetamodelComponents = inParameter3 ;
    info.mImportedOptionsComponents = inParameter4 ;
    info.mOptionsComponents = inParameter5 ;
    info.mSemanticsEntitiesMap = inParameter6 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_ModelMap   & outParameter0,
               GGS_ActionMap   & outParameter1,
               GGS_stringset   & outParameter2,
               GGS_stringset   & outParameter3,
               GGS_stringset   & outParameter4,
               GGS_M_optionComponents   & outParameter5,
               GGS_M_semanticsEntitiesForUse   & outParameter6,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    outParameter4.drop_operation () ;
    outParameter5.drop_operation () ;
    outParameter6.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mModelMap ;
    outParameter1 = node->mInfo.mActionMap ;
    outParameter2 = node->mInfo.mImportedSemanticsComponents ;
    outParameter3 = node->mInfo.mImportedMetamodelComponents ;
    outParameter4 = node->mInfo.mImportedOptionsComponents ;
    outParameter5 = node->mInfo.mOptionsComponents ;
    outParameter6 = node->mInfo.mSemanticsEntitiesMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_ModelMap   & outParameter0,
                                GGS_ActionMap   & outParameter1,
                                GGS_stringset   & outParameter2,
                                GGS_stringset   & outParameter3,
                                GGS_stringset   & outParameter4,
                                GGS_M_optionComponents   & outParameter5,
                                GGS_M_semanticsEntitiesForUse   & outParameter6) {
  searchElement (inLexique,
                 "there is no semantics component named '%K'",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_ModelMap & inParameter0,
                                const GGS_ActionMap & inParameter1,
                                const GGS_stringset & inParameter2,
                                const GGS_stringset & inParameter3,
                                const GGS_stringset & inParameter4,
                                const GGS_M_optionComponents & inParameter5,
                                const GGS_M_semanticsEntitiesForUse & inParameter6) {
  insertElement (lexique_var_,
                 "a semantics component named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 NULL) ;
}

GGS_string GGS_M_semanticsComponents::reader_description (void) const {
  C_String s ;
  s << "<map @M_semanticsComponents " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'M_metamodelsComponents'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_metamodelsComponents::
elementOf_GGS_M_metamodelsComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_metamodelsComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_metamodelsComponents::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mRootEntity.reader_description () ;
  ioString << mInfo.mSemanticsEntitiesMap.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_metamodelsComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_metamodelsComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_metamodelsComponents * info = (e_M_metamodelsComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_metamodelsComponents GGS_M_metamodelsComponents::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_metamodelsComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               const GGS_M_semanticsEntitiesForUse &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_metamodelsComponents info  ;
    info.mRootEntity = inParameter0 ;
    info.mSemanticsEntitiesMap = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_M_semanticsEntitiesForUse   & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mRootEntity ;
    outParameter1 = node->mInfo.mSemanticsEntitiesMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_M_semanticsEntitiesForUse   & outParameter1) {
  searchElement (inLexique,
                 "there is no metamodel component named '%K'",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_M_semanticsEntitiesForUse & inParameter1) {
  insertElement (lexique_var_,
                 "a metamodel component named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

GGS_string GGS_M_metamodelsComponents::reader_description (void) const {
  C_String s ;
  s << "<map @M_metamodelsComponents " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@typeListeAttributsAxiome'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeAttributsAxiome::
elementOf_GGS_typeListeAttributsAxiome (const GGS_lstring & argument_0) {
  mNextItem = (elementOf_GGS_typeListeAttributsAxiome *) NULL ;
  aAttributAxiome = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeAttributsAxiome::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << aAttributAxiome.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeListeAttributsAxiome'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome
::GGS_typeListeAttributsAxiome (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_typeListeAttributsAxiome
::GGS_typeListeAttributsAxiome (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome::~GGS_typeListeAttributsAxiome (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome::GGS_typeListeAttributsAxiome (const GGS_typeListeAttributsAxiome & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome
::operator = (const GGS_typeListeAttributsAxiome & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aAttributAxiome) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome  GGS_typeListeAttributsAxiome::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeListeAttributsAxiome result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeAttributsAxiome::reader_description (void) const {
  C_String s ;
  s << "<list @typeListeAttributsAxiome" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeListeAttributsAxiome
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_grammarDescriptorForProgram'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_grammarDescriptorForProgram::
elementOf_GGS_L_grammarDescriptorForProgram (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_signature & argument_2,
                                const GGS_typeListeAttributsAxiome & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_lstring & argument_6) {
  mNextItem = (elementOf_GGS_L_grammarDescriptorForProgram *) NULL ;
  mGrammarPostfix = argument_0 ;
  mGrammarName = argument_1 ;
  mStartSymbolSignature = argument_2 ;
  mStartSymbolAttributesList = argument_3 ;
  mLexiqueClassName = argument_4 ;
  mReturnedMetamodelName = argument_5 ;
  mReturnedRootEntityName = argument_6 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_grammarDescriptorForProgram::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mGrammarPostfix.reader_description () ;
  ioString << mGrammarName.reader_description () ;
  ioString << mStartSymbolSignature.reader_description () ;
  ioString << mStartSymbolAttributesList.reader_description () ;
  ioString << mLexiqueClassName.reader_description () ;
  ioString << mReturnedMetamodelName.reader_description () ;
  ioString << mReturnedRootEntityName.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_grammarDescriptorForProgram'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram
::GGS_L_grammarDescriptorForProgram (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  GGS_L_grammarDescriptorForProgram
::GGS_L_grammarDescriptorForProgram (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::~GGS_L_grammarDescriptorForProgram (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::GGS_L_grammarDescriptorForProgram (const GGS_L_grammarDescriptorForProgram & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram
::operator = (const GGS_L_grammarDescriptorForProgram & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
internalAppendItem (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_signature & argument_2,
                                const GGS_typeListeAttributsAxiome & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_lstring & argument_6) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_signature & argument_2,
                                const GGS_typeListeAttributsAxiome & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_lstring & argument_6) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mGrammarPostfix,
                                p->mGrammarName,
                                p->mStartSymbolSignature,
                                p->mStartSymbolAttributesList,
                                p->mLexiqueClassName,
                                p->mReturnedMetamodelName,
                                p->mReturnedRootEntityName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram  GGS_L_grammarDescriptorForProgram::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_grammarDescriptorForProgram result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_grammarDescriptorForProgram::reader_description (void) const {
  C_String s ;
  s << "<list @L_grammarDescriptorForProgram" ;
  if (isBuilt ()) {
    s << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_grammarDescriptorForProgram
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of routine "handleReaderCall"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleReaderCall (C_Lexique & lexique_var_,
                                const GGS_AC_galgasType  & var_cas_inReceiverType,
                                const GGS_lstring  & var_cas_inMethodName,
                                GGS_typeListeAttributsSemantiques  & var_cas_outAccessorTypesList,
                                GGS_AC_galgasType  & var_cas_outReturnedType) {
  if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "description"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (HERE) ;
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
  }else{
    if (var_cas_inReceiverType.isBuilt ()) {
      if (dynamic_cast <cPtr_typeGalgas_string *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "fileExists"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "pathExtension"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "lastPathComponent"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "stringByDeletingPathExtension"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "stringByCapitalizingFirstCharacter"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "stringByDeletingLastPathComponent"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "stringByReplacingStringByString"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (HERE) ;
          var_cas_outAccessorTypesList.addAssign_operation (var_cas_outReturnedType, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
          var_cas_outAccessorTypesList.addAssign_operation (var_cas_outReturnedType, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
        }else{
            var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_uint *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "sint"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_sint::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (HERE) ;
        }else{
            var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_lstring *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (HERE) ;
        }else{
            var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_lchar *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_char::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (HERE) ;
        }else{
            var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_lbool *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (HERE) ;
        }else{
            var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_luint *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (HERE) ;
        }else{
            var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_lsint *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_sint::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (HERE) ;
        }else{
            var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_ldouble *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_double::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (HERE) ;
        }else{
            var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
        }
      }else if (dynamic_cast <cPtr_typeGalgasListType *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "length"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (HERE) ;
        }else{
            var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "list supports only 'length' reader call")) ;
        }
      }else if (dynamic_cast <cPtr_typeGalgasMapType *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "hasKey"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          GGS_AC_galgasType  var_cas_keyType ;
          var_cas_keyType = GGS_typeGalgas_string::constructor_new (HERE) ;
          var_cas_outAccessorTypesList.addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
          var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "count"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "allKeys"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_stringset::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "unreadKeys"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_stringset::constructor_new (HERE) ;
        }else{
            var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_stringset *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "hasKey"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          GGS_AC_galgasType  var_cas_keyType ;
          var_cas_keyType = GGS_typeGalgas_string::constructor_new (HERE) ;
          var_cas_outAccessorTypesList.addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_) COMMA_HERE)) ;
          var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new (HERE) ;
        }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "count"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (HERE) ;
        }else{
            var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
        }
      }else if (dynamic_cast <cPtr_typeGalgasClassType *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        cPtr_typeGalgasClassType * operand_92834 = dynamic_cast <cPtr_typeGalgasClassType *> (var_cas_inReceiverType.getPtr ()) ;
        macroValidPointer (operand_92834) ; 
        GGS_typeClassInheritedMessagesMap  var_cas_messagesMap ;
        var_cas_messagesMap = operand_92834->mMessagesMap ;
        var_cas_messagesMap.methode_searchKey (lexique_var_, var_cas_inMethodName) ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (HERE) ;
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
      }else if (dynamic_cast <cPtr_typeGalgas_enum *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        cPtr_typeGalgas_enum * operand_93177 = dynamic_cast <cPtr_typeGalgas_enum *> (var_cas_inReceiverType.getPtr ()) ;
        macroValidPointer (operand_93177) ; 
        GGS_typeEnumMessageMap  var_cas_messagesMap ;
        var_cas_messagesMap = operand_93177->mMessagesMap ;
        GGS_L_lstringList  var_cas_93346 ;
        var_cas_messagesMap.methode_searchKey (lexique_var_, var_cas_inMethodName, var_cas_93346) ;
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty (HERE) ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (HERE) ;
      }else{ // Else part
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support reader call")) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "importSemanticsComponent"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_importSemanticsComponent (C_Lexique & lexique_var_,
                                GGS_M_semanticsComponents  & var_cas_ioSemanticsComponentsMap,
                                GGS_M_metamodelsComponents  & var_cas_ioMetamodelComponentMap,
                                GGS_ModelMap  & var_cas_ioModelMap,
                                GGS_ActionMap  & var_cas_ioActionMap,
                                GGS_stringset  & var_cas_ioAlreadyImportedSemanticsComponents,
                                GGS_stringset  & var_cas_ioAlreadyImportedMetamodelComponents,
                                GGS_lstring   var_cas_inSemanticsComponentName) {
  if (((! var_cas_ioAlreadyImportedSemanticsComponents.reader_hasKey (var_cas_inSemanticsComponentName.reader_value ()))).isBuiltAndTrue ()) {
    GGS_ModelMap  var_cas_modelMap ;
    GGS_ActionMap  var_cas_actionMap ;
    GGS_stringset  var_cas_importedSemanticsComponents ;
    GGS_stringset  var_cas_importedMetamodelComponents ;
    GGS_stringset  var_cas_importedOptionsComponents ;
    GGS_M_optionComponents  var_cas_95142 ;
    GGS_M_semanticsEntitiesForUse  var_cas_95151 ;
    var_cas_ioSemanticsComponentsMap.methode_searchKey (lexique_var_, var_cas_inSemanticsComponentName, var_cas_modelMap, var_cas_actionMap, var_cas_importedSemanticsComponents, var_cas_importedMetamodelComponents, var_cas_importedOptionsComponents, var_cas_95142, var_cas_95151) ;
    var_cas_ioAlreadyImportedMetamodelComponents = ((var_cas_ioAlreadyImportedMetamodelComponents) || (var_cas_importedMetamodelComponents)) ;
    GGS_stringset::element_type * operand_95396 = var_cas_importedSemanticsComponents.firstObject () ;
    while ((operand_95396 != NULL)) {
      macroValidPointer (operand_95396) ;
      ::routine_importSemanticsComponent (lexique_var_,  var_cas_ioSemanticsComponentsMap,  var_cas_ioMetamodelComponentMap,  var_cas_ioModelMap,  var_cas_ioActionMap,  var_cas_ioAlreadyImportedSemanticsComponents,  var_cas_ioAlreadyImportedMetamodelComponents,  GGS_lstring::constructor_new (operand_95396->mKey, GGS_location (lexique_var_) COMMA_HERE)) ;
      operand_95396 = operand_95396->nextObject () ;
    }
    GGS_ModelMap::element_type * operand_95761 = var_cas_modelMap.firstObject () ;
    while ((operand_95761 != NULL)) {
      macroValidPointer (operand_95761) ;
      if (((! var_cas_ioModelMap.reader_hasKey (operand_95761->mKey.reader_value ()))).isBuiltAndTrue ()) {
        var_cas_ioModelMap.methode_insertKey (lexique_var_, operand_95761->mKey, operand_95761->mInfo.mType) ;
      }
      operand_95761 = operand_95761->nextObject () ;
    }
    GGS_ActionMap::element_type * operand_95974 = var_cas_actionMap.firstObject () ;
    while ((operand_95974 != NULL)) {
      macroValidPointer (operand_95974) ;
      if (((! var_cas_ioActionMap.reader_hasKey (operand_95974->mKey.reader_value ()))).isBuiltAndTrue ()) {
        var_cas_ioActionMap.methode_insertKey (lexique_var_, operand_95974->mKey, operand_95974->mInfo.mSignature, operand_95974->mInfo.mIsExtern) ;
      }
      operand_95974 = operand_95974->nextObject () ;
    }
    var_cas_ioAlreadyImportedSemanticsComponents.addAssign_operation (var_cas_inSemanticsComponentName.reader_value ()) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildSuperEntitySet"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildSuperEntitySet (C_Lexique & lexique_var_,
                                GGS_entityToImplementMap  & var_cas_ioEntityMap,
                                const GGS_lstring  & var_cas_inSuperEntityName,
                                GGS_stringset  & var_cas_ioSuperEntitySet) {
  if (((((var_cas_inSuperEntityName.reader_value ()) != (GGS_string (true, ""))) && ((! var_cas_ioSuperEntitySet.reader_hasKey (var_cas_inSuperEntityName.reader_value ()))))).isBuiltAndTrue ()) {
    var_cas_ioSuperEntitySet.addAssign_operation (var_cas_inSuperEntityName.reader_value ()) ;
    GGS_lstring  var_cas_superEntityName ;
    GGS_entityPropertyMap  var_cas_96777 ;
    GGS_bool var_cas_96780 ;
    GGS_entityPropertyMap  var_cas_96783 ;
    GGS_mapPropertyMap  var_cas_96803 ;
    GGS_contextPropertyMap  var_cas_96806 ;
    GGS_fetchedPropertyMap  var_cas_96809 ;
    GGS_fetchedPropertyMap  var_cas_96812 ;
    var_cas_ioEntityMap.methode_searchKey (lexique_var_, var_cas_inSuperEntityName, var_cas_96777, var_cas_96780, var_cas_96783, var_cas_superEntityName, var_cas_96803, var_cas_96806, var_cas_96809, var_cas_96812) ;
    ::routine_buildSuperEntitySet (lexique_var_,  var_cas_ioEntityMap,  var_cas_superEntityName,  var_cas_ioSuperEntitySet) ;
  }
}

//---------------------------------------------------------------------------*

