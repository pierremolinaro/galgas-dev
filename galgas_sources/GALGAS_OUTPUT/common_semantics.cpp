//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'common_semantics.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                    november 13th, 2008, at 18h16'29"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "common_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "common_semantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//          Class for 'EXactualParametersPassingMode' Enumeration            *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_EXactualParametersPassingMode::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXactualParametersPassingMode::
_operator_isEqual (const GGS_EXactualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXactualParametersPassingMode::
_operator_isNotEqual (const GGS_EXactualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXactualParametersPassingMode::
_operator_infOrEqual (const GGS_EXactualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXactualParametersPassingMode::
_operator_supOrEqual (const GGS_EXactualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXactualParametersPassingMode::
_operator_strictInf (const GGS_EXactualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXactualParametersPassingMode::
_operator_strictSup (const GGS_EXactualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXactualParametersPassingMode::
reader_actualArgumentMessage (C_Compiler & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [4] = {"",
    "an input (\?) actual parameter",
    "an output (!) actual parameter",
    "an output/input (!\?) actual parameter"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXactualParametersPassingMode::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @EXactualParametersPassingMode" ;
  switch (mValue) {
  case enum_parameterIn:
    s << " parameterIn>" ;
    break ;
  case enum_parameterOut:
    s << " parameterOut>" ;
    break ;
  case enum_parameterOutIn:
    s << " parameterOutIn>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Class for 'EXformalArgumentPassingMode' Enumeration             *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_EXformalArgumentPassingMode::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXformalArgumentPassingMode::
_operator_isEqual (const GGS_EXformalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXformalArgumentPassingMode::
_operator_isNotEqual (const GGS_EXformalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXformalArgumentPassingMode::
_operator_infOrEqual (const GGS_EXformalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXformalArgumentPassingMode::
_operator_supOrEqual (const GGS_EXformalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXformalArgumentPassingMode::
_operator_strictInf (const GGS_EXformalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXformalArgumentPassingMode::
_operator_strictSup (const GGS_EXformalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXformalArgumentPassingMode::
reader_formalArgumentMessage (C_Compiler & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "a constant input (\?\?) formal argument",
    "an input (\?) formal argument",
    "an input/output (\?!) argument",
    "an output (!) formal argument"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXformalArgumentPassingMode::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @EXformalArgumentPassingMode" ;
  switch (mValue) {
  case enum_argumentConstantIn:
    s << " argumentConstantIn>" ;
    break ;
  case enum_argumentIn:
    s << " argumentIn>" ;
    break ;
  case enum_argumentInOut:
    s << " argumentInOut>" ;
    break ;
  case enum_argumentOut:
    s << " argumentOut>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstruction::
cPtr_typeInstruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstruction * GGS_typeInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstruction (& typeid (cPtr_typeInstruction), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeInstruction GGS_typeInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstruction::actualTypeName (void) const {
  return "typeInstruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_typeInstruction::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__typeInstruction ("typeInstruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeInstructionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeInstructionList::
elementOf_GGS_typeInstructionList (const GGS_typeInstruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeInstructionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeInstructionList * _p = dynamic_cast <const elementOf_GGS_typeInstructionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeInstructionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@typeInstructionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
_internalAppendValues (const GGS_typeInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
_internalPrependValues (const GGS_typeInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
_addAssign_operation (const GGS_typeInstruction & argument_0) {
  if (_isBuilt ()&& argument_0._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList GGS_typeInstructionList::
_operator_concat (const GGS_typeInstructionList & inOperand) const {
  GGS_typeInstructionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
_dotAssign_operation (const GGS_typeInstructionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_typeInstructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeInstruction  p_0 = p->mInstruction ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeInstruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeInstructionList::
constructor_emptyList (void) {
  GGS_typeInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeInstructionList::
constructor_listWithValue (const GGS_typeInstruction & argument_0) {
  GGS_typeInstructionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
internalSubListWithRange (GGS_typeInstructionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList GGS_typeInstructionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList GGS_typeInstructionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_typeInstruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_typeInstruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_typeInstruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_typeInstruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstruction  GGS_typeInstructionList::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstruction  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstruction  & GGS_typeInstructionList::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@L_signature'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_signature::
elementOf_GGS_L_signature (const GGS_EXformalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mFormalArgumentPassingMode (argument_0),
mGalgasTypeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_signature::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_signature * _p = dynamic_cast <const elementOf_GGS_L_signature *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFormalArgumentPassingMode._operator_isEqual (_p->mFormalArgumentPassingMode).boolValue ()
         && mGalgasTypeName._operator_isEqual (_p->mGalgasTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_signature::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGalgasTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@L_signature'                             *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_signature::
_internalAppendValues (const GGS_EXformalArgumentPassingMode& argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
_internalPrependValues (const GGS_EXformalArgumentPassingMode& argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
_addAssign_operation (const GGS_EXformalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_signature GGS_L_signature::
_operator_concat (const GGS_L_signature & inOperand) const {
  GGS_L_signature result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
_dotAssign_operation (const GGS_L_signature inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_L_signature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_EXformalArgumentPassingMode p_0 = p->mFormalArgumentPassingMode ;
          GGS_lstring  p_1 = p->mGalgasTypeName ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_EXformalArgumentPassingMode& argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mFormalArgumentPassingMode,
                                _p->mGalgasTypeName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_signature  GGS_L_signature::
constructor_emptyList (void) {
  GGS_L_signature result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_signature  GGS_L_signature::
constructor_listWithValue (const GGS_EXformalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) {
  GGS_L_signature result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
internalSubListWithRange (GGS_L_signature & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mFormalArgumentPassingMode, _p->mGalgasTypeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_signature GGS_L_signature::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_signature result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_signature GGS_L_signature::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_signature result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_signature::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_signature", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
method_first (C_Compiler & _inLexique,
              GGS_EXformalArgumentPassingMode& _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalArgumentPassingMode ;
    _out_1 = _p->mGalgasTypeName ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
method_last (C_Compiler & _inLexique,
             GGS_EXformalArgumentPassingMode& _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalArgumentPassingMode ;
    _out_1 = _p->mGalgasTypeName ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_EXformalArgumentPassingMode& _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalArgumentPassingMode ;
    _out_1 = _p->mGalgasTypeName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
modifier_popLast (C_Compiler & _inLexique,
                GGS_EXformalArgumentPassingMode& _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalArgumentPassingMode ;
    _out_1 = _p->mGalgasTypeName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_EXformalArgumentPassingMode GGS_L_signature::
reader_mFormalArgumentPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_EXformalArgumentPassingMode result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_signature::
reader_mGalgasTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mGalgasTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
modifier_setMFormalArgumentPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_EXformalArgumentPassingMode & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
modifier_setMGalgasTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mGalgasTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_EXformalArgumentPassingMode & GGS_L_signature::cEnumerator::_mFormalArgumentPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mFormalArgumentPassingMode ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_L_signature::cEnumerator::_mGalgasTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mGalgasTypeName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@typeListModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListModel::
elementOf_GGS_typeListModel (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListModel::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListModel * _p = dynamic_cast <const elementOf_GGS_typeListModel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListModel::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@typeListModel'                            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeListModel::
_internalAppendValues (const GGS_lstring & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
_internalPrependValues (const GGS_lstring & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
_addAssign_operation (const GGS_lstring & argument_0) {
  if (_isBuilt ()&& argument_0._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListModel GGS_typeListModel::
_operator_concat (const GGS_typeListModel & inOperand) const {
  GGS_typeListModel result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
_dotAssign_operation (const GGS_typeListModel inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_typeListModel * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTypeName ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTypeName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_typeListModel::
constructor_emptyList (void) {
  GGS_typeListModel result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_typeListModel::
constructor_listWithValue (const GGS_lstring & argument_0) {
  GGS_typeListModel result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
internalSubListWithRange (GGS_typeListModel & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mTypeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListModel GGS_typeListModel::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListModel result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel GGS_typeListModel::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListModel result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListModel::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListModel", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeListModel::
reader_mTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
modifier_setMTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeListModel::cEnumerator::_mTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mTypeName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_TypeModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_TypeModel::
cPtr_TypeModel (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_TypeModel * GGS_TypeModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_TypeModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_TypeModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_TypeModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@TypeModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_TypeModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_TypeModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_TypeModel (& typeid (cPtr_TypeModel), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_TypeModel::galgasRTTI (void) const {
  return & gClassInfoFor__TypeModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_TypeModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_TypeModel GGS_TypeModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_TypeModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_TypeModel *> (inPointer) != NULL)
      : (typeid (cPtr_TypeModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_TypeModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_TypeModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_TypeModel::actualTypeName (void) const {
  return "TypeModel" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_TypeModel::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__TypeModel ("TypeModel") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_BoolModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_BoolModel::
cPtr_BoolModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_BoolModel * GGS_BoolModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_BoolModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_BoolModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_BoolModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_BoolModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@BoolModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_BoolModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_BoolModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_BoolModel (& typeid (cPtr_BoolModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_BoolModel::galgasRTTI (void) const {
  return & gClassInfoFor__BoolModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_BoolModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_BoolModel::
GGS_BoolModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_BoolModel::
GGS_BoolModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_BoolModel GGS_BoolModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_BoolModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_BoolModel *> (inPointer) != NULL)
      : (typeid (cPtr_BoolModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_BoolModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_BoolModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_BoolModel * gSingleton_BoolModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_BoolModel (void) {
  macroDetachPointer (gSingleton_BoolModel, cPtr_BoolModel) ;
}

//---------------------------------------------------------------------------*

GGS_BoolModel GGS_BoolModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_BoolModel result ;
  if (NULL == gSingleton_BoolModel) {
    macroMyNew (gSingleton_BoolModel, cPtr_BoolModel (THERE)) ;
    registerReleaseRoutine (cleanUp_BoolModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_BoolModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_BoolModel::actualTypeName (void) const {
  return "BoolModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__BoolModel ("BoolModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_CharModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_CharModel::
cPtr_CharModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_CharModel * GGS_CharModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_CharModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_CharModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_CharModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_CharModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@CharModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_CharModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_CharModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_CharModel (& typeid (cPtr_CharModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_CharModel::galgasRTTI (void) const {
  return & gClassInfoFor__CharModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_CharModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_CharModel::
GGS_CharModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_CharModel::
GGS_CharModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_CharModel GGS_CharModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_CharModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_CharModel *> (inPointer) != NULL)
      : (typeid (cPtr_CharModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_CharModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_CharModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_CharModel * gSingleton_CharModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_CharModel (void) {
  macroDetachPointer (gSingleton_CharModel, cPtr_CharModel) ;
}

//---------------------------------------------------------------------------*

GGS_CharModel GGS_CharModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_CharModel result ;
  if (NULL == gSingleton_CharModel) {
    macroMyNew (gSingleton_CharModel, cPtr_CharModel (THERE)) ;
    registerReleaseRoutine (cleanUp_CharModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_CharModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_CharModel::actualTypeName (void) const {
  return "CharModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__CharModel ("CharModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_UIntModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_UIntModel::
cPtr_UIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_UIntModel * GGS_UIntModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_UIntModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_UIntModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_UIntModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_UIntModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@UIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_UIntModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_UIntModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_UIntModel (& typeid (cPtr_UIntModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_UIntModel::galgasRTTI (void) const {
  return & gClassInfoFor__UIntModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_UIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_UIntModel::
GGS_UIntModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_UIntModel::
GGS_UIntModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_UIntModel GGS_UIntModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_UIntModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_UIntModel *> (inPointer) != NULL)
      : (typeid (cPtr_UIntModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_UIntModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_UIntModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_UIntModel * gSingleton_UIntModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_UIntModel (void) {
  macroDetachPointer (gSingleton_UIntModel, cPtr_UIntModel) ;
}

//---------------------------------------------------------------------------*

GGS_UIntModel GGS_UIntModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_UIntModel result ;
  if (NULL == gSingleton_UIntModel) {
    macroMyNew (gSingleton_UIntModel, cPtr_UIntModel (THERE)) ;
    registerReleaseRoutine (cleanUp_UIntModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_UIntModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_UIntModel::actualTypeName (void) const {
  return "UIntModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__UIntModel ("UIntModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_SIntModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_SIntModel::
cPtr_SIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_SIntModel * GGS_SIntModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_SIntModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_SIntModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_SIntModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_SIntModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@SIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_SIntModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_SIntModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_SIntModel (& typeid (cPtr_SIntModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_SIntModel::galgasRTTI (void) const {
  return & gClassInfoFor__SIntModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_SIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_SIntModel::
GGS_SIntModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_SIntModel::
GGS_SIntModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_SIntModel GGS_SIntModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_SIntModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_SIntModel *> (inPointer) != NULL)
      : (typeid (cPtr_SIntModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_SIntModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_SIntModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_SIntModel * gSingleton_SIntModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_SIntModel (void) {
  macroDetachPointer (gSingleton_SIntModel, cPtr_SIntModel) ;
}

//---------------------------------------------------------------------------*

GGS_SIntModel GGS_SIntModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_SIntModel result ;
  if (NULL == gSingleton_SIntModel) {
    macroMyNew (gSingleton_SIntModel, cPtr_SIntModel (THERE)) ;
    registerReleaseRoutine (cleanUp_SIntModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_SIntModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_SIntModel::actualTypeName (void) const {
  return "SIntModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__SIntModel ("SIntModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_UInt64Model'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_UInt64Model::
cPtr_UInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_UInt64Model * GGS_UInt64Model::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_UInt64Model *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_UInt64Model *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_UInt64Model::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_UInt64Model::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@UInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_UInt64Model::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_UInt64Model::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_UInt64Model (& typeid (cPtr_UInt64Model), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_UInt64Model::galgasRTTI (void) const {
  return & gClassInfoFor__UInt64Model ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_UInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_UInt64Model::
GGS_UInt64Model (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_UInt64Model::
GGS_UInt64Model (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_UInt64Model GGS_UInt64Model::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_UInt64Model _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_UInt64Model *> (inPointer) != NULL)
      : (typeid (cPtr_UInt64Model) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_UInt64Model (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_UInt64Model),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_UInt64Model * gSingleton_UInt64Model = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_UInt64Model (void) {
  macroDetachPointer (gSingleton_UInt64Model, cPtr_UInt64Model) ;
}

//---------------------------------------------------------------------------*

GGS_UInt64Model GGS_UInt64Model::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_UInt64Model result ;
  if (NULL == gSingleton_UInt64Model) {
    macroMyNew (gSingleton_UInt64Model, cPtr_UInt64Model (THERE)) ;
    registerReleaseRoutine (cleanUp_UInt64Model) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_UInt64Model) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_UInt64Model::actualTypeName (void) const {
  return "UInt64Model" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__UInt64Model ("UInt64Model", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_SInt64Model'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_SInt64Model::
cPtr_SInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_SInt64Model * GGS_SInt64Model::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_SInt64Model *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_SInt64Model *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_SInt64Model::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_SInt64Model::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@SInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_SInt64Model::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_SInt64Model::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_SInt64Model (& typeid (cPtr_SInt64Model), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_SInt64Model::galgasRTTI (void) const {
  return & gClassInfoFor__SInt64Model ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_SInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_SInt64Model::
GGS_SInt64Model (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_SInt64Model::
GGS_SInt64Model (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_SInt64Model GGS_SInt64Model::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_SInt64Model _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_SInt64Model *> (inPointer) != NULL)
      : (typeid (cPtr_SInt64Model) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_SInt64Model (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_SInt64Model),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_SInt64Model * gSingleton_SInt64Model = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_SInt64Model (void) {
  macroDetachPointer (gSingleton_SInt64Model, cPtr_SInt64Model) ;
}

//---------------------------------------------------------------------------*

GGS_SInt64Model GGS_SInt64Model::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_SInt64Model result ;
  if (NULL == gSingleton_SInt64Model) {
    macroMyNew (gSingleton_SInt64Model, cPtr_SInt64Model (THERE)) ;
    registerReleaseRoutine (cleanUp_SInt64Model) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_SInt64Model) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_SInt64Model::actualTypeName (void) const {
  return "SInt64Model" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__SInt64Model ("SInt64Model", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_DoubleModel'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_DoubleModel::
cPtr_DoubleModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_DoubleModel * GGS_DoubleModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_DoubleModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_DoubleModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_DoubleModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_DoubleModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@DoubleModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_DoubleModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_DoubleModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_DoubleModel (& typeid (cPtr_DoubleModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_DoubleModel::galgasRTTI (void) const {
  return & gClassInfoFor__DoubleModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_DoubleModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_DoubleModel::
GGS_DoubleModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_DoubleModel::
GGS_DoubleModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_DoubleModel GGS_DoubleModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_DoubleModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_DoubleModel *> (inPointer) != NULL)
      : (typeid (cPtr_DoubleModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_DoubleModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_DoubleModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_DoubleModel * gSingleton_DoubleModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_DoubleModel (void) {
  macroDetachPointer (gSingleton_DoubleModel, cPtr_DoubleModel) ;
}

//---------------------------------------------------------------------------*

GGS_DoubleModel GGS_DoubleModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_DoubleModel result ;
  if (NULL == gSingleton_DoubleModel) {
    macroMyNew (gSingleton_DoubleModel, cPtr_DoubleModel (THERE)) ;
    registerReleaseRoutine (cleanUp_DoubleModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_DoubleModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_DoubleModel::actualTypeName (void) const {
  return "DoubleModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__DoubleModel ("DoubleModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_StringModel'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_StringModel::
cPtr_StringModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_StringModel * GGS_StringModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_StringModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_StringModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_StringModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_StringModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@StringModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_StringModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_StringModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_StringModel (& typeid (cPtr_StringModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_StringModel::galgasRTTI (void) const {
  return & gClassInfoFor__StringModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_StringModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_StringModel::
GGS_StringModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_StringModel::
GGS_StringModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_StringModel GGS_StringModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_StringModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_StringModel *> (inPointer) != NULL)
      : (typeid (cPtr_StringModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_StringModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_StringModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_StringModel * gSingleton_StringModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_StringModel (void) {
  macroDetachPointer (gSingleton_StringModel, cPtr_StringModel) ;
}

//---------------------------------------------------------------------------*

GGS_StringModel GGS_StringModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_StringModel result ;
  if (NULL == gSingleton_StringModel) {
    macroMyNew (gSingleton_StringModel, cPtr_StringModel (THERE)) ;
    registerReleaseRoutine (cleanUp_StringModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_StringModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_StringModel::actualTypeName (void) const {
  return "StringModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__StringModel ("StringModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_LBoolModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LBoolModel::
cPtr_LBoolModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LBoolModel * GGS_LBoolModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LBoolModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LBoolModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LBoolModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LBoolModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LBoolModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LBoolModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LBoolModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LBoolModel (& typeid (cPtr_LBoolModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_LBoolModel::galgasRTTI (void) const {
  return & gClassInfoFor__LBoolModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LBoolModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LBoolModel::
GGS_LBoolModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LBoolModel::
GGS_LBoolModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_LBoolModel GGS_LBoolModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LBoolModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LBoolModel *> (inPointer) != NULL)
      : (typeid (cPtr_LBoolModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_LBoolModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LBoolModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_LBoolModel * gSingleton_LBoolModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LBoolModel (void) {
  macroDetachPointer (gSingleton_LBoolModel, cPtr_LBoolModel) ;
}

//---------------------------------------------------------------------------*

GGS_LBoolModel GGS_LBoolModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LBoolModel result ;
  if (NULL == gSingleton_LBoolModel) {
    macroMyNew (gSingleton_LBoolModel, cPtr_LBoolModel (THERE)) ;
    registerReleaseRoutine (cleanUp_LBoolModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LBoolModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LBoolModel::actualTypeName (void) const {
  return "LBoolModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__LBoolModel ("LBoolModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_LCharModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LCharModel::
cPtr_LCharModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LCharModel * GGS_LCharModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LCharModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LCharModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LCharModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LCharModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LCharModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LCharModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LCharModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LCharModel (& typeid (cPtr_LCharModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_LCharModel::galgasRTTI (void) const {
  return & gClassInfoFor__LCharModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LCharModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LCharModel::
GGS_LCharModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LCharModel::
GGS_LCharModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_LCharModel GGS_LCharModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LCharModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LCharModel *> (inPointer) != NULL)
      : (typeid (cPtr_LCharModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_LCharModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LCharModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_LCharModel * gSingleton_LCharModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LCharModel (void) {
  macroDetachPointer (gSingleton_LCharModel, cPtr_LCharModel) ;
}

//---------------------------------------------------------------------------*

GGS_LCharModel GGS_LCharModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LCharModel result ;
  if (NULL == gSingleton_LCharModel) {
    macroMyNew (gSingleton_LCharModel, cPtr_LCharModel (THERE)) ;
    registerReleaseRoutine (cleanUp_LCharModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LCharModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LCharModel::actualTypeName (void) const {
  return "LCharModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__LCharModel ("LCharModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_LUIntModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LUIntModel::
cPtr_LUIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LUIntModel * GGS_LUIntModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LUIntModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LUIntModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LUIntModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LUIntModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LUIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LUIntModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LUIntModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LUIntModel (& typeid (cPtr_LUIntModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_LUIntModel::galgasRTTI (void) const {
  return & gClassInfoFor__LUIntModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LUIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LUIntModel::
GGS_LUIntModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LUIntModel::
GGS_LUIntModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_LUIntModel GGS_LUIntModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LUIntModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LUIntModel *> (inPointer) != NULL)
      : (typeid (cPtr_LUIntModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_LUIntModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LUIntModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_LUIntModel * gSingleton_LUIntModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LUIntModel (void) {
  macroDetachPointer (gSingleton_LUIntModel, cPtr_LUIntModel) ;
}

//---------------------------------------------------------------------------*

GGS_LUIntModel GGS_LUIntModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LUIntModel result ;
  if (NULL == gSingleton_LUIntModel) {
    macroMyNew (gSingleton_LUIntModel, cPtr_LUIntModel (THERE)) ;
    registerReleaseRoutine (cleanUp_LUIntModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LUIntModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LUIntModel::actualTypeName (void) const {
  return "LUIntModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__LUIntModel ("LUIntModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_LSIntModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LSIntModel::
cPtr_LSIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LSIntModel * GGS_LSIntModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LSIntModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LSIntModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LSIntModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LSIntModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LSIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LSIntModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LSIntModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LSIntModel (& typeid (cPtr_LSIntModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_LSIntModel::galgasRTTI (void) const {
  return & gClassInfoFor__LSIntModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LSIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LSIntModel::
GGS_LSIntModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LSIntModel::
GGS_LSIntModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_LSIntModel GGS_LSIntModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LSIntModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LSIntModel *> (inPointer) != NULL)
      : (typeid (cPtr_LSIntModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_LSIntModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LSIntModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_LSIntModel * gSingleton_LSIntModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LSIntModel (void) {
  macroDetachPointer (gSingleton_LSIntModel, cPtr_LSIntModel) ;
}

//---------------------------------------------------------------------------*

GGS_LSIntModel GGS_LSIntModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LSIntModel result ;
  if (NULL == gSingleton_LSIntModel) {
    macroMyNew (gSingleton_LSIntModel, cPtr_LSIntModel (THERE)) ;
    registerReleaseRoutine (cleanUp_LSIntModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LSIntModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LSIntModel::actualTypeName (void) const {
  return "LSIntModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__LSIntModel ("LSIntModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_LUInt64Model'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LUInt64Model::
cPtr_LUInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LUInt64Model * GGS_LUInt64Model::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LUInt64Model *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LUInt64Model *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LUInt64Model::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LUInt64Model::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LUInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LUInt64Model::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LUInt64Model::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LUInt64Model (& typeid (cPtr_LUInt64Model), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_LUInt64Model::galgasRTTI (void) const {
  return & gClassInfoFor__LUInt64Model ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LUInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LUInt64Model::
GGS_LUInt64Model (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LUInt64Model::
GGS_LUInt64Model (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_LUInt64Model GGS_LUInt64Model::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LUInt64Model _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LUInt64Model *> (inPointer) != NULL)
      : (typeid (cPtr_LUInt64Model) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_LUInt64Model (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LUInt64Model),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_LUInt64Model * gSingleton_LUInt64Model = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LUInt64Model (void) {
  macroDetachPointer (gSingleton_LUInt64Model, cPtr_LUInt64Model) ;
}

//---------------------------------------------------------------------------*

GGS_LUInt64Model GGS_LUInt64Model::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LUInt64Model result ;
  if (NULL == gSingleton_LUInt64Model) {
    macroMyNew (gSingleton_LUInt64Model, cPtr_LUInt64Model (THERE)) ;
    registerReleaseRoutine (cleanUp_LUInt64Model) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LUInt64Model) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LUInt64Model::actualTypeName (void) const {
  return "LUInt64Model" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__LUInt64Model ("LUInt64Model", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_LSInt64Model'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LSInt64Model::
cPtr_LSInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LSInt64Model * GGS_LSInt64Model::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LSInt64Model *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LSInt64Model *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LSInt64Model::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LSInt64Model::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LSInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LSInt64Model::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LSInt64Model::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LSInt64Model (& typeid (cPtr_LSInt64Model), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_LSInt64Model::galgasRTTI (void) const {
  return & gClassInfoFor__LSInt64Model ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LSInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LSInt64Model::
GGS_LSInt64Model (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LSInt64Model::
GGS_LSInt64Model (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_LSInt64Model GGS_LSInt64Model::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LSInt64Model _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LSInt64Model *> (inPointer) != NULL)
      : (typeid (cPtr_LSInt64Model) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_LSInt64Model (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LSInt64Model),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_LSInt64Model * gSingleton_LSInt64Model = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LSInt64Model (void) {
  macroDetachPointer (gSingleton_LSInt64Model, cPtr_LSInt64Model) ;
}

//---------------------------------------------------------------------------*

GGS_LSInt64Model GGS_LSInt64Model::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LSInt64Model result ;
  if (NULL == gSingleton_LSInt64Model) {
    macroMyNew (gSingleton_LSInt64Model, cPtr_LSInt64Model (THERE)) ;
    registerReleaseRoutine (cleanUp_LSInt64Model) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LSInt64Model) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LSInt64Model::actualTypeName (void) const {
  return "LSInt64Model" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__LSInt64Model ("LSInt64Model", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_LDoubleModel'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LDoubleModel::
cPtr_LDoubleModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LDoubleModel * GGS_LDoubleModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LDoubleModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LDoubleModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LDoubleModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LDoubleModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LDoubleModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LDoubleModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LDoubleModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LDoubleModel (& typeid (cPtr_LDoubleModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_LDoubleModel::galgasRTTI (void) const {
  return & gClassInfoFor__LDoubleModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LDoubleModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LDoubleModel::
GGS_LDoubleModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LDoubleModel::
GGS_LDoubleModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_LDoubleModel GGS_LDoubleModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LDoubleModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LDoubleModel *> (inPointer) != NULL)
      : (typeid (cPtr_LDoubleModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_LDoubleModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LDoubleModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_LDoubleModel * gSingleton_LDoubleModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LDoubleModel (void) {
  macroDetachPointer (gSingleton_LDoubleModel, cPtr_LDoubleModel) ;
}

//---------------------------------------------------------------------------*

GGS_LDoubleModel GGS_LDoubleModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LDoubleModel result ;
  if (NULL == gSingleton_LDoubleModel) {
    macroMyNew (gSingleton_LDoubleModel, cPtr_LDoubleModel (THERE)) ;
    registerReleaseRoutine (cleanUp_LDoubleModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LDoubleModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LDoubleModel::actualTypeName (void) const {
  return "LDoubleModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__LDoubleModel ("LDoubleModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_LStringModel'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LStringModel::
cPtr_LStringModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LStringModel * GGS_LStringModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LStringModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LStringModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LStringModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LStringModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LStringModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LStringModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LStringModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LStringModel (& typeid (cPtr_LStringModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_LStringModel::galgasRTTI (void) const {
  return & gClassInfoFor__LStringModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LStringModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LStringModel::
GGS_LStringModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LStringModel::
GGS_LStringModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_LStringModel GGS_LStringModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LStringModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LStringModel *> (inPointer) != NULL)
      : (typeid (cPtr_LStringModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_LStringModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LStringModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_LStringModel * gSingleton_LStringModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LStringModel (void) {
  macroDetachPointer (gSingleton_LStringModel, cPtr_LStringModel) ;
}

//---------------------------------------------------------------------------*

GGS_LStringModel GGS_LStringModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LStringModel result ;
  if (NULL == gSingleton_LStringModel) {
    macroMyNew (gSingleton_LStringModel, cPtr_LStringModel (THERE)) ;
    registerReleaseRoutine (cleanUp_LStringModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LStringModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LStringModel::actualTypeName (void) const {
  return "LStringModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__LStringModel ("LStringModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_StringsetModel'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_StringsetModel::
cPtr_StringsetModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_StringsetModel * GGS_StringsetModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_StringsetModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_StringsetModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_StringsetModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_StringsetModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@StringsetModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_StringsetModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_StringsetModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_StringsetModel (& typeid (cPtr_StringsetModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_StringsetModel::galgasRTTI (void) const {
  return & gClassInfoFor__StringsetModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_StringsetModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_StringsetModel::
GGS_StringsetModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_StringsetModel::
GGS_StringsetModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_StringsetModel GGS_StringsetModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_StringsetModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_StringsetModel *> (inPointer) != NULL)
      : (typeid (cPtr_StringsetModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_StringsetModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_StringsetModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_StringsetModel * gSingleton_StringsetModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_StringsetModel (void) {
  macroDetachPointer (gSingleton_StringsetModel, cPtr_StringsetModel) ;
}

//---------------------------------------------------------------------------*

GGS_StringsetModel GGS_StringsetModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_StringsetModel result ;
  if (NULL == gSingleton_StringsetModel) {
    macroMyNew (gSingleton_StringsetModel, cPtr_StringsetModel (THERE)) ;
    registerReleaseRoutine (cleanUp_StringsetModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_StringsetModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_StringsetModel::actualTypeName (void) const {
  return "StringsetModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__StringsetModel ("StringsetModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_LocationModel'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LocationModel::
cPtr_LocationModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LocationModel * GGS_LocationModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LocationModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LocationModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LocationModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LocationModel::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LocationModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_LocationModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_LocationModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_LocationModel (& typeid (cPtr_LocationModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_LocationModel::galgasRTTI (void) const {
  return & gClassInfoFor__LocationModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LocationModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LocationModel::
GGS_LocationModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LocationModel::
GGS_LocationModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_LocationModel GGS_LocationModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_LocationModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_LocationModel *> (inPointer) != NULL)
      : (typeid (cPtr_LocationModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_LocationModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_LocationModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_LocationModel * gSingleton_LocationModel = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_LocationModel (void) {
  macroDetachPointer (gSingleton_LocationModel, cPtr_LocationModel) ;
}

//---------------------------------------------------------------------------*

GGS_LocationModel GGS_LocationModel::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_LocationModel result ;
  if (NULL == gSingleton_LocationModel) {
    macroMyNew (gSingleton_LocationModel, cPtr_LocationModel (THERE)) ;
    registerReleaseRoutine (cleanUp_LocationModel) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_LocationModel) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_LocationModel::actualTypeName (void) const {
  return "LocationModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__LocationModel ("LocationModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_ListModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ListModel::
cPtr_ListModel (const GGS_typeListModel & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mAttributeList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ListModel * GGS_ListModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ListModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ListModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ListModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ListModel * _p = dynamic_cast <const cPtr_ListModel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeList._operator_isEqual (_p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ListModel::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ListModel:"
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ListModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ListModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ListModel (& typeid (cPtr_ListModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ListModel::galgasRTTI (void) const {
  return & gClassInfoFor__ListModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_ListModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ListModel::
GGS_ListModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ListModel::
GGS_ListModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ListModel GGS_ListModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ListModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ListModel *> (inPointer) != NULL)
      : (typeid (cPtr_ListModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ListModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ListModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ListModel GGS_ListModel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeListModel & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ListModel result ;
  macroMyNew (result.mPointer, cPtr_ListModel (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_ListModel::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListModel   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ListModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ListModel *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ListModel::actualTypeName (void) const {
  return "ListModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ListModel ("ListModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_MapModel'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_MapModel::
cPtr_MapModel (const GGS_typeListModel & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mAttributeList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_MapModel * GGS_MapModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_MapModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_MapModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_MapModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_MapModel * _p = dynamic_cast <const cPtr_MapModel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeList._operator_isEqual (_p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_MapModel::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@MapModel:"
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_MapModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_MapModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_MapModel (& typeid (cPtr_MapModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_MapModel::galgasRTTI (void) const {
  return & gClassInfoFor__MapModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_MapModel'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_MapModel::
GGS_MapModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_MapModel::
GGS_MapModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_MapModel GGS_MapModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_MapModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_MapModel *> (inPointer) != NULL)
      : (typeid (cPtr_MapModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_MapModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_MapModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_MapModel GGS_MapModel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeListModel & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_MapModel result ;
  macroMyNew (result.mPointer, cPtr_MapModel (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_MapModel::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListModel   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_MapModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_MapModel *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_MapModel::actualTypeName (void) const {
  return "MapModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__MapModel ("MapModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_enumConstantMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_enumConstantMap::e_enumConstantMap (void) :
mHasConstructor () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@enumConstantMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumConstantMap::
elementOf_GGS_enumConstantMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_enumConstantMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumConstantMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mHasConstructor.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumConstantMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_enumConstantMap * _p = dynamic_cast <const elementOf_GGS_enumConstantMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mHasConstructor._operator_isEqual (_p->mInfo.mHasConstructor)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumConstantMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumConstantMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumConstantMap * info = (e_enumConstantMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_enumConstantMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_enumConstantMap * info = (e_enumConstantMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap GGS_enumConstantMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumConstantMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_enumConstantMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumConstantMap::
_operator_isEqual (const GGS_enumConstantMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumConstantMap::
_operator_isNotEqual (const GGS_enumConstantMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_bool& inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_enumConstantMap info  ;
    info.mHasConstructor = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_bool  & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mHasConstructor ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
modifier_setMHasConstructorForKey (C_Compiler & inLexique,
                        const GGS_bool& inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMHasConstructorForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mHasConstructor = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_bool  & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' constant is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
method_searchKeyAndGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_bool  & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' constant is not declared",
                  inKey,
                  outParameter0,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_bool& inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' constant is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap GGS_enumConstantMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_enumConstantMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumConstantMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap GGS_enumConstantMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumConstantMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumConstantMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @enumConstantMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_enumConstantMap::cEnumerator::_mHasConstructor (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasConstructor ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@enumUsedConstantMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumUsedConstantMap::
elementOf_GGS_enumUsedConstantMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_enumUsedConstantMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumUsedConstantMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumUsedConstantMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumUsedConstantMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumUsedConstantMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumUsedConstantMap * info = (e_enumUsedConstantMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_enumUsedConstantMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_enumUsedConstantMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_enumUsedConstantMap * info = (e_enumUsedConstantMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_enumUsedConstantMap GGS_enumUsedConstantMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumUsedConstantMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumUsedConstantMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_enumUsedConstantMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumUsedConstantMap::
_operator_isEqual (const GGS_enumUsedConstantMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumUsedConstantMap::
_operator_isNotEqual (const GGS_enumUsedConstantMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumUsedConstantMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumUsedConstantMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_enumUsedConstantMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumUsedConstantMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumUsedConstantMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' constant is already used in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumUsedConstantMap GGS_enumUsedConstantMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_enumUsedConstantMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumUsedConstantMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumUsedConstantMap GGS_enumUsedConstantMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumUsedConstantMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumUsedConstantMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @enumUsedConstantMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@enumMessageMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageMap::
elementOf_GGS_enumMessageMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_enumMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumMessageMap * info = (e_enumMessageMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_enumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_enumMessageMap * info = (e_enumMessageMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap GGS_enumMessageMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_enumMessageMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumMessageMap::
_operator_isEqual (const GGS_enumMessageMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumMessageMap::
_operator_isNotEqual (const GGS_enumMessageMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_enumMessageMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' message name is not declared",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' message name is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap GGS_enumMessageMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_enumMessageMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap GGS_enumMessageMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @enumMessageMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_EnumModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_EnumModel::
cPtr_EnumModel (const GGS_enumConstantMap & argument_0,
                                const GGS_enumMessageMap & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mEnumConstantesMap (argument_0),
mMessagesMap (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_EnumModel * GGS_EnumModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_EnumModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_EnumModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_EnumModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_EnumModel * _p = dynamic_cast <const cPtr_EnumModel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumConstantesMap._operator_isEqual (_p->mEnumConstantesMap).boolValue ()
         && mMessagesMap._operator_isEqual (_p->mMessagesMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_EnumModel::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@EnumModel:"
           << mEnumConstantesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMessagesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_EnumModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_EnumModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_EnumModel (& typeid (cPtr_EnumModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_EnumModel::galgasRTTI (void) const {
  return & gClassInfoFor__EnumModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_EnumModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_EnumModel::
GGS_EnumModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_EnumModel::
GGS_EnumModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_EnumModel GGS_EnumModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_EnumModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_EnumModel *> (inPointer) != NULL)
      : (typeid (cPtr_EnumModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_EnumModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_EnumModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_EnumModel GGS_EnumModel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_enumConstantMap & argument_0,
                 const GGS_enumMessageMap & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_EnumModel result ;
  macroMyNew (result.mPointer, cPtr_EnumModel (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap  GGS_EnumModel::
reader_mEnumConstantesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumConstantMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_EnumModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_EnumModel *) mPointer)->mEnumConstantesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap  GGS_EnumModel::
reader_mMessagesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_EnumModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_EnumModel *) mPointer)->mMessagesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_EnumModel::actualTypeName (void) const {
  return "EnumModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__EnumModel ("EnumModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_constructorMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_constructorMap::e_constructorMap (void) :
mFormalInputArgumentList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@constructorMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_constructorMap::
elementOf_GGS_constructorMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_constructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constructorMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mFormalInputArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_constructorMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_constructorMap * _p = dynamic_cast <const elementOf_GGS_constructorMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mFormalInputArgumentList._operator_isEqual (_p->mInfo.mFormalInputArgumentList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_constructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constructorMap * info = (e_constructorMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_constructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_constructorMap * info = (e_constructorMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constructorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_constructorMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constructorMap::
_operator_isEqual (const GGS_constructorMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constructorMap::
_operator_isNotEqual (const GGS_constructorMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeListModel & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_constructorMap info  ;
    info.mFormalInputArgumentList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListModel   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalInputArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
modifier_setMFormalInputArgumentListForKey (C_Compiler & inLexique,
                        const GGS_typeListModel & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMFormalInputArgumentListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mFormalInputArgumentList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListModel   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' constructor is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListModel & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' constructor is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_constructorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constructorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constructorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constructorMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @constructorMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListModel  & GGS_constructorMap::cEnumerator::_mFormalInputArgumentList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFormalInputArgumentList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_readerMap'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_readerMap::e_readerMap (void) :
mReaderFormalArgumentList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@readerMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_readerMap::
elementOf_GGS_readerMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_readerMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_readerMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mReaderFormalArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_readerMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_readerMap * _p = dynamic_cast <const elementOf_GGS_readerMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mReaderFormalArgumentList._operator_isEqual (_p->mInfo.mReaderFormalArgumentList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_readerMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_readerMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_readerMap * info = (e_readerMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_readerMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_readerMap * info = (e_readerMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_readerMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_readerMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerMap::
_operator_isEqual (const GGS_readerMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerMap::
_operator_isNotEqual (const GGS_readerMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_signature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_readerMap info  ;
    info.mReaderFormalArgumentList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mReaderFormalArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
modifier_setMReaderFormalArgumentListForKey (C_Compiler & inLexique,
                        const GGS_L_signature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMReaderFormalArgumentListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mReaderFormalArgumentList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' reader is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' reader is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_readerMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_readerMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_readerMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readerMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @readerMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_signature  & GGS_readerMap::cEnumerator::_mReaderFormalArgumentList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReaderFormalArgumentList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_modifierMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_modifierMap::e_modifierMap (void) :
mModifierFormalArgumentList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@modifierMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_modifierMap::
elementOf_GGS_modifierMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_modifierMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_modifierMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mModifierFormalArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_modifierMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_modifierMap * _p = dynamic_cast <const elementOf_GGS_modifierMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mModifierFormalArgumentList._operator_isEqual (_p->mInfo.mModifierFormalArgumentList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_modifierMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_modifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_modifierMap * info = (e_modifierMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_modifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_modifierMap * info = (e_modifierMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_modifierMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_modifierMap::
_operator_isEqual (const GGS_modifierMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_modifierMap::
_operator_isNotEqual (const GGS_modifierMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_signature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_modifierMap info  ;
    info.mModifierFormalArgumentList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mModifierFormalArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
modifier_setMModifierFormalArgumentListForKey (C_Compiler & inLexique,
                        const GGS_L_signature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMModifierFormalArgumentListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mModifierFormalArgumentList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' modifier is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' modifier is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_modifierMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_modifierMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_modifierMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @modifierMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_signature  & GGS_modifierMap::cEnumerator::_mModifierFormalArgumentList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mModifierFormalArgumentList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_ExternTypeModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ExternTypeModel::
cPtr_ExternTypeModel (const GGS_constructorMap & argument_0,
                                const GGS_readerMap & argument_1,
                                const GGS_modifierMap & argument_2,
                                const GGS_typeListModel & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mExternTypeConstructorMap (argument_0),
mReaderMap (argument_1),
mModifierMap (argument_2),
mAddAssignFormalInputArgumentList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ExternTypeModel * GGS_ExternTypeModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ExternTypeModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ExternTypeModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ExternTypeModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ExternTypeModel * _p = dynamic_cast <const cPtr_ExternTypeModel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExternTypeConstructorMap._operator_isEqual (_p->mExternTypeConstructorMap).boolValue ()
         && mReaderMap._operator_isEqual (_p->mReaderMap).boolValue ()
         && mModifierMap._operator_isEqual (_p->mModifierMap).boolValue ()
         && mAddAssignFormalInputArgumentList._operator_isEqual (_p->mAddAssignFormalInputArgumentList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ExternTypeModel::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ExternTypeModel:"
           << mExternTypeConstructorMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReaderMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModifierMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAddAssignFormalInputArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ExternTypeModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ExternTypeModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ExternTypeModel (& typeid (cPtr_ExternTypeModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ExternTypeModel::galgasRTTI (void) const {
  return & gClassInfoFor__ExternTypeModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_ExternTypeModel'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ExternTypeModel::
GGS_ExternTypeModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ExternTypeModel::
GGS_ExternTypeModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ExternTypeModel GGS_ExternTypeModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ExternTypeModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ExternTypeModel *> (inPointer) != NULL)
      : (typeid (cPtr_ExternTypeModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ExternTypeModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ExternTypeModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ExternTypeModel GGS_ExternTypeModel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_constructorMap & argument_0,
                 const GGS_readerMap & argument_1,
                 const GGS_modifierMap & argument_2,
                 const GGS_typeListModel & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ExternTypeModel result ;
  macroMyNew (result.mPointer, cPtr_ExternTypeModel (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap  GGS_ExternTypeModel::
reader_mExternTypeConstructorMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constructorMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ExternTypeModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ExternTypeModel *) mPointer)->mExternTypeConstructorMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerMap  GGS_ExternTypeModel::
reader_mReaderMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_readerMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ExternTypeModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ExternTypeModel *) mPointer)->mReaderMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap  GGS_ExternTypeModel::
reader_mModifierMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_modifierMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ExternTypeModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ExternTypeModel *) mPointer)->mModifierMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_ExternTypeModel::
reader_mAddAssignFormalInputArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListModel   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ExternTypeModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ExternTypeModel *) mPointer)->mAddAssignFormalInputArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ExternTypeModel::actualTypeName (void) const {
  return "ExternTypeModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ExternTypeModel ("ExternTypeModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@classMessageMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_classMessageMap::
elementOf_GGS_classMessageMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_classMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classMessageMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_classMessageMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_classMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_classMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_classMessageMap * info = (e_classMessageMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_classMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_classMessageMap * info = (e_classMessageMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap GGS_classMessageMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMessageMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_classMessageMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMessageMap::
_operator_isEqual (const GGS_classMessageMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMessageMap::
_operator_isNotEqual (const GGS_classMessageMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_classMessageMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' message is not declared",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' message is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap GGS_classMessageMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_classMessageMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMessageMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap GGS_classMessageMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classMessageMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classMessageMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @classMessageMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_ClassModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ClassModel::
cPtr_ClassModel (const GGS_bool& argument_0,
                                const GGS_stringset & argument_1,
                                const GGS_typeListModel & argument_2,
                                const GGS_classMessageMap & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mIsAbstract (argument_0),
mSuperClasses (argument_1),
mAttributeList (argument_2),
mMessageMap (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ClassModel * GGS_ClassModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ClassModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ClassModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ClassModel::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ClassModel * _p = dynamic_cast <const cPtr_ClassModel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIsAbstract._operator_isEqual (_p->mIsAbstract).boolValue ()
         && mSuperClasses._operator_isEqual (_p->mSuperClasses).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mMessageMap._operator_isEqual (_p->mMessageMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ClassModel::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ClassModel:"
           << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSuperClasses.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMessageMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ClassModel::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ClassModel::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ClassModel (& typeid (cPtr_ClassModel), & typeid (cPtr_TypeModel), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_ClassModel::galgasRTTI (void) const {
  return & gClassInfoFor__ClassModel ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_ClassModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ClassModel::
GGS_ClassModel (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ClassModel::
GGS_ClassModel (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_ClassModel GGS_ClassModel::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ClassModel _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ClassModel *> (inPointer) != NULL)
      : (typeid (cPtr_ClassModel) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_ClassModel (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ClassModel),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_ClassModel GGS_ClassModel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_stringset & argument_1,
                 const GGS_typeListModel & argument_2,
                 const GGS_classMessageMap & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ClassModel result ;
  macroMyNew (result.mPointer, cPtr_ClassModel (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ClassModel::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ClassModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ClassModel *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset  GGS_ClassModel::
reader_mSuperClasses (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringset   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ClassModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ClassModel *) mPointer)->mSuperClasses ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_ClassModel::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListModel   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ClassModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ClassModel *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap  GGS_ClassModel::
reader_mMessageMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classMessageMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ClassModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ClassModel *) mPointer)->mMessageMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ClassModel::actualTypeName (void) const {
  return "ClassModel" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__ClassModel ("ClassModel", gClassInfoFor__TypeModel) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'e_ModelMap'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_ModelMap::e_ModelMap (void) :
mType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@ModelMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ModelMap::
elementOf_GGS_ModelMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_ModelMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ModelMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ModelMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_ModelMap * _p = dynamic_cast <const elementOf_GGS_ModelMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mType._operator_isEqual (_p->mInfo.mType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ModelMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_ModelMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ModelMap * info = (e_ModelMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_ModelMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_ModelMap * info = (e_ModelMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ModelMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_ModelMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ModelMap::
_operator_isEqual (const GGS_ModelMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ModelMap::
_operator_isNotEqual (const GGS_ModelMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_TypeModel & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_ModelMap info  ;
    info.mType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_TypeModel   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
modifier_setMTypeForKey (C_Compiler & inLexique,
                        const GGS_TypeModel & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMTypeForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mType = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_TypeModel   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '@%K' type is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_TypeModel & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '@%K' type has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_ModelMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ModelMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ModelMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ModelMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @ModelMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_TypeModel  & GGS_ModelMap::cEnumerator::_mType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_ActionMap'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_ActionMap::e_ActionMap (void) :
mSignature (),
mIsExtern () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@ActionMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ActionMap::
elementOf_GGS_ActionMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_ActionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ActionMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mIsExtern.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ActionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_ActionMap * _p = dynamic_cast <const elementOf_GGS_ActionMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mSignature._operator_isEqual (_p->mInfo.mSignature)).boolValue ()
           && (mInfo.mIsExtern._operator_isEqual (_p->mInfo.mIsExtern)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ActionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_ActionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ActionMap * info = (e_ActionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_ActionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_ActionMap * info = (e_ActionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_ActionMap GGS_ActionMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ActionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_ActionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ActionMap::
_operator_isEqual (const GGS_ActionMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ActionMap::
_operator_isNotEqual (const GGS_ActionMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_signature & inParameter0,
                const GGS_bool& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_ActionMap info  ;
    info.mSignature = inParameter0 ;
    info.mIsExtern = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mSignature ;
    outParameter1 = node->mInfo.mIsExtern ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
modifier_setMSignatureForKey (C_Compiler & inLexique,
                        const GGS_L_signature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMSignatureForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mSignature = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
modifier_setMIsExternForKey (C_Compiler & inLexique,
                        const GGS_bool& inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMIsExternForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mIsExtern = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' extern routine is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' extern extern routine has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_ActionMap GGS_ActionMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_ActionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ActionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ActionMap GGS_ActionMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ActionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ActionMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @ActionMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_signature  & GGS_ActionMap::cEnumerator::_mSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_ActionMap::cEnumerator::_mIsExtern (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIsExtern ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Class for 'localConstantBuildStyleEnum' Enumeration             *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_localConstantBuildStyleEnum::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
_operator_isEqual (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
_operator_isNotEqual (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
_operator_infOrEqual (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
_operator_supOrEqual (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
_operator_strictInf (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
_operator_strictSup (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localConstantBuildStyleEnum::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @localConstantBuildStyleEnum" ;
  switch (mValue) {
  case enum_firstIsKeyOtherMapStyle:
    s << " firstIsKeyOtherMapStyle>" ;
    break ;
  case enum_listStyle:
    s << " listStyle>" ;
    break ;
  case enum_mapStyle:
    s << " mapStyle>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_AC_galgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_galgasType::
cPtr_AC_galgasType (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_galgasType * GGS_AC_galgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_galgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_AC_galgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this attribute cannot be used for sorting") COMMA_SOURCE_FILE_AT_LINE (438)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_acceptAssignmentFromHere (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "assignment from 'here' is not allowed for variables of this type") COMMA_SOURCE_FILE_AT_LINE (444)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_acceptForeachInstruction (C_Compiler & _inLexique,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle,
                                GGS_bool& var_cas_outNewStyle COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type cannot be enumerated by in 'foreach' instruction") COMMA_SOURCE_FILE_AT_LINE (457)) ;
  var_cas_outForeachList._drop () ;
  var_cas_outStyle._drop () ;
  var_cas_outNewStyle._drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (466)) ;
  var_cas_outModifierSignature._drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleMethodInstructionCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outMethodSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support method call instruction") COMMA_SOURCE_FILE_AT_LINE (478)) ;
  var_cas_outMethodSignature._drop () ;
  var_cas_outCategoryMethodClassBaseName._drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (490)) ;
  var_cas_outAccessorTypesList._drop () ;
  var_cas_outHasLexiqueAndLocationArguments._drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleClassMethodCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inTypeMethodName,
                                GGS_L_EXsignature & var_cas_outTypeMethodSignature COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inTypeMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This type method is not defined") COMMA_SOURCE_FILE_AT_LINE (498)) ;
  var_cas_outTypeMethodSignature._drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleMinusAssignOperatorCall (C_Compiler & _inLexique,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support call of '-=' operator") COMMA_SOURCE_FILE_AT_LINE (508)) ;
  var_cas_outParametersList._drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleAddAssignOperatorCall (C_Compiler & _inLexique,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support call of '+=' operator") COMMA_SOURCE_FILE_AT_LINE (519)) ;
  var_cas_outParametersList._drop () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleIncrementOperatorCall (C_Compiler & _inLexique,
                                GGS_location  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support call of '++' operator") COMMA_SOURCE_FILE_AT_LINE (527)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleDecrementOperatorCall (C_Compiler & _inLexique,
                                GGS_location  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support call of '--' operator") COMMA_SOURCE_FILE_AT_LINE (535)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & _inLexique COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type cannot be silently converted to @location value") COMMA_SOURCE_FILE_AT_LINE (541)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_galgasType:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType::
static_string_message_messageGalgasType (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType::
message_messageGalgasType (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType::
_message (void) const {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType::
_static_message (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_galgasType (& typeid (cPtr_AC_galgasType), NULL
, "any type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_AC_galgasType::galgasRTTI (void) const {
  return & gClassInfoFor__AC_galgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_galgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_AC_galgasType GGS_AC_galgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_galgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_galgasType *> (inPointer) != NULL)
      : (typeid (cPtr_AC_galgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_AC_galgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_galgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_galgasType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_galgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_AC_galgasType * p = (cPtr_AC_galgasType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_galgasType::actualTypeName (void) const {
  return "AC_galgasType" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_AC_galgasType::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__AC_galgasType ("AC_galgasType") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeCplusPlusName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCplusPlusName::
cPtr_typeCplusPlusName (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mVariableLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCplusPlusName * GGS_typeCplusPlusName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCplusPlusName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCplusPlusName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeCplusPlusName::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCplusPlusName:"
           << mVariableLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCplusPlusName::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCplusPlusName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCplusPlusName (& typeid (cPtr_typeCplusPlusName), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeCplusPlusName::galgasRTTI (void) const {
  return & gClassInfoFor__typeCplusPlusName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCplusPlusName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeCplusPlusName GGS_typeCplusPlusName::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCplusPlusName _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCplusPlusName *> (inPointer) != NULL)
      : (typeid (cPtr_typeCplusPlusName) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeCplusPlusName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCplusPlusName),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeCplusPlusName::
reader_mVariableLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCplusPlusName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCplusPlusName *) mPointer)->mVariableLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCplusPlusName::actualTypeName (void) const {
  return "typeCplusPlusName" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_typeCplusPlusName::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__typeCplusPlusName ("typeCplusPlusName") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeDirectName'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectName::
cPtr_typeDirectName (const GGS_location & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectName * GGS_typeDirectName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDirectName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDirectName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDirectName * _p = dynamic_cast <const cPtr_typeDirectName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableLocation._operator_isEqual (_p->mVariableLocation).boolValue ()
         && mName._operator_isEqual (_p->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectName::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDirectName:"
           << mVariableLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDirectName::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDirectName (& typeid (cPtr_typeDirectName), & typeid (cPtr_typeCplusPlusName), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeDirectName::galgasRTTI (void) const {
  return & gClassInfoFor__typeDirectName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeDirectName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDirectName::
GGS_typeDirectName (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectName::
GGS_typeDirectName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeDirectName GGS_typeDirectName::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDirectName _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDirectName *> (inPointer) != NULL)
      : (typeid (cPtr_typeDirectName) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeDirectName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDirectName),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectName GGS_typeDirectName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeDirectName result ;
  macroMyNew (result.mPointer, cPtr_typeDirectName (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDirectName::
reader_mName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectName *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDirectName::actualTypeName (void) const {
  return "typeDirectName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeDirectName ("typeDirectName", gClassInfoFor__typeCplusPlusName) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeCurrentObjectName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCurrentObjectName::
cPtr_typeCurrentObjectName (const GGS_location & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCurrentObjectName * GGS_typeCurrentObjectName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCurrentObjectName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCurrentObjectName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCurrentObjectName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCurrentObjectName * _p = dynamic_cast <const cPtr_typeCurrentObjectName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableLocation._operator_isEqual (_p->mVariableLocation).boolValue ()
         && mName._operator_isEqual (_p->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCurrentObjectName::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCurrentObjectName:"
           << mVariableLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCurrentObjectName::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCurrentObjectName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCurrentObjectName (& typeid (cPtr_typeCurrentObjectName), & typeid (cPtr_typeCplusPlusName), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeCurrentObjectName::galgasRTTI (void) const {
  return & gClassInfoFor__typeCurrentObjectName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCurrentObjectName'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCurrentObjectName::
GGS_typeCurrentObjectName (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCurrentObjectName::
GGS_typeCurrentObjectName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeCurrentObjectName GGS_typeCurrentObjectName::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCurrentObjectName _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCurrentObjectName *> (inPointer) != NULL)
      : (typeid (cPtr_typeCurrentObjectName) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeCurrentObjectName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCurrentObjectName),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeCurrentObjectName GGS_typeCurrentObjectName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeCurrentObjectName result ;
  macroMyNew (result.mPointer, cPtr_typeCurrentObjectName (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCurrentObjectName::
reader_mName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCurrentObjectName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCurrentObjectName *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCurrentObjectName::actualTypeName (void) const {
  return "typeCurrentObjectName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeCurrentObjectName ("typeCurrentObjectName", gClassInfoFor__typeCplusPlusName) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeCppThisName'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCppThisName::
cPtr_typeCppThisName (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCppThisName * GGS_typeCppThisName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCppThisName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCppThisName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCppThisName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCppThisName * _p = dynamic_cast <const cPtr_typeCppThisName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableLocation._operator_isEqual (_p->mVariableLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCppThisName::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCppThisName:"
           << mVariableLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCppThisName::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCppThisName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCppThisName (& typeid (cPtr_typeCppThisName), & typeid (cPtr_typeCplusPlusName), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeCppThisName::galgasRTTI (void) const {
  return & gClassInfoFor__typeCppThisName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeCppThisName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCppThisName::
GGS_typeCppThisName (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCppThisName::
GGS_typeCppThisName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeCppThisName GGS_typeCppThisName::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCppThisName _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCppThisName *> (inPointer) != NULL)
      : (typeid (cPtr_typeCppThisName) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeCppThisName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCppThisName),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeCppThisName GGS_typeCppThisName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeCppThisName result ;
  macroMyNew (result.mPointer, cPtr_typeCppThisName (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCppThisName::actualTypeName (void) const {
  return "typeCppThisName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeCppThisName ("typeCppThisName", gClassInfoFor__typeCplusPlusName) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeCppThisInCategoryName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCppThisInCategoryName::
cPtr_typeCppThisInCategoryName (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCppThisInCategoryName * GGS_typeCppThisInCategoryName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCppThisInCategoryName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCppThisInCategoryName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCppThisInCategoryName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCppThisInCategoryName * _p = dynamic_cast <const cPtr_typeCppThisInCategoryName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableLocation._operator_isEqual (_p->mVariableLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCppThisInCategoryName::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCppThisInCategoryName:"
           << mVariableLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCppThisInCategoryName::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCppThisInCategoryName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCppThisInCategoryName (& typeid (cPtr_typeCppThisInCategoryName), & typeid (cPtr_typeCplusPlusName), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeCppThisInCategoryName::galgasRTTI (void) const {
  return & gClassInfoFor__typeCppThisInCategoryName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeCppThisInCategoryName'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCppThisInCategoryName::
GGS_typeCppThisInCategoryName (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCppThisInCategoryName::
GGS_typeCppThisInCategoryName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeCppThisInCategoryName GGS_typeCppThisInCategoryName::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCppThisInCategoryName _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCppThisInCategoryName *> (inPointer) != NULL)
      : (typeid (cPtr_typeCppThisInCategoryName) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeCppThisInCategoryName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCppThisInCategoryName),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeCppThisInCategoryName GGS_typeCppThisInCategoryName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeCppThisInCategoryName result ;
  macroMyNew (result.mPointer, cPtr_typeCppThisInCategoryName (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCppThisInCategoryName::actualTypeName (void) const {
  return "typeCppThisInCategoryName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeCppThisInCategoryName ("typeCppThisInCategoryName", gClassInfoFor__typeCplusPlusName) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeCppInheritedName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCppInheritedName::
cPtr_typeCppInheritedName (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCppInheritedName * GGS_typeCppInheritedName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCppInheritedName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCppInheritedName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCppInheritedName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCppInheritedName * _p = dynamic_cast <const cPtr_typeCppInheritedName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableLocation._operator_isEqual (_p->mVariableLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCppInheritedName::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCppInheritedName:"
           << mVariableLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCppInheritedName::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCppInheritedName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCppInheritedName (& typeid (cPtr_typeCppInheritedName), & typeid (cPtr_typeCplusPlusName), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeCppInheritedName::galgasRTTI (void) const {
  return & gClassInfoFor__typeCppInheritedName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCppInheritedName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCppInheritedName::
GGS_typeCppInheritedName (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCppInheritedName::
GGS_typeCppInheritedName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeCppInheritedName GGS_typeCppInheritedName::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCppInheritedName _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCppInheritedName *> (inPointer) != NULL)
      : (typeid (cPtr_typeCppInheritedName) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeCppInheritedName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCppInheritedName),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeCppInheritedName GGS_typeCppInheritedName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeCppInheritedName result ;
  macroMyNew (result.mPointer, cPtr_typeCppInheritedName (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCppInheritedName::actualTypeName (void) const {
  return "typeCppInheritedName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeCppInheritedName ("typeCppInheritedName", gClassInfoFor__typeCplusPlusName) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeAutomaticName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAutomaticName::
cPtr_typeAutomaticName (const GGS_location & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAutomaticName * GGS_typeAutomaticName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAutomaticName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAutomaticName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAutomaticName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAutomaticName * _p = dynamic_cast <const cPtr_typeAutomaticName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableLocation._operator_isEqual (_p->mVariableLocation).boolValue ()
         && mName._operator_isEqual (_p->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAutomaticName::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAutomaticName:"
           << mVariableLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeAutomaticName::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeAutomaticName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeAutomaticName (& typeid (cPtr_typeAutomaticName), & typeid (cPtr_typeCplusPlusName), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeAutomaticName::galgasRTTI (void) const {
  return & gClassInfoFor__typeAutomaticName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAutomaticName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAutomaticName::
GGS_typeAutomaticName (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAutomaticName::
GGS_typeAutomaticName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeAutomaticName GGS_typeAutomaticName::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeAutomaticName _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeAutomaticName *> (inPointer) != NULL)
      : (typeid (cPtr_typeAutomaticName) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeAutomaticName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeAutomaticName),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeAutomaticName GGS_typeAutomaticName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeAutomaticName result ;
  macroMyNew (result.mPointer, cPtr_typeAutomaticName (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeAutomaticName::
reader_mName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAutomaticName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAutomaticName *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeAutomaticName::actualTypeName (void) const {
  return "typeAutomaticName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeAutomaticName ("typeAutomaticName", gClassInfoFor__typeCplusPlusName) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeLocationAutomaticName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLocationAutomaticName::
cPtr_typeLocationAutomaticName (const GGS_location & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE),
mSequenceNumber (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLocationAutomaticName * GGS_typeLocationAutomaticName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLocationAutomaticName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLocationAutomaticName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLocationAutomaticName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLocationAutomaticName * _p = dynamic_cast <const cPtr_typeLocationAutomaticName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableLocation._operator_isEqual (_p->mVariableLocation).boolValue ()
         && mSequenceNumber._operator_isEqual (_p->mSequenceNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLocationAutomaticName::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLocationAutomaticName:"
           << mVariableLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSequenceNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLocationAutomaticName::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLocationAutomaticName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLocationAutomaticName (& typeid (cPtr_typeLocationAutomaticName), & typeid (cPtr_typeCplusPlusName), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeLocationAutomaticName::galgasRTTI (void) const {
  return & gClassInfoFor__typeLocationAutomaticName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLocationAutomaticName'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLocationAutomaticName::
GGS_typeLocationAutomaticName (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLocationAutomaticName::
GGS_typeLocationAutomaticName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeLocationAutomaticName GGS_typeLocationAutomaticName::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLocationAutomaticName _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLocationAutomaticName *> (inPointer) != NULL)
      : (typeid (cPtr_typeLocationAutomaticName) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeLocationAutomaticName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLocationAutomaticName),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeLocationAutomaticName GGS_typeLocationAutomaticName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeLocationAutomaticName result ;
  macroMyNew (result.mPointer, cPtr_typeLocationAutomaticName (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_typeLocationAutomaticName::
reader_mSequenceNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLocationAutomaticName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLocationAutomaticName *) mPointer)->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLocationAutomaticName::actualTypeName (void) const {
  return "typeLocationAutomaticName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLocationAutomaticName ("typeLocationAutomaticName", gClassInfoFor__typeCplusPlusName) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeOperandName'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOperandName::
cPtr_typeOperandName (const GGS_location & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE),
mName (argument_1),
mFieldKind (argument_2),
mIteratorNewStyle (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOperandName * GGS_typeOperandName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOperandName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeOperandName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeOperandName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeOperandName * _p = dynamic_cast <const cPtr_typeOperandName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableLocation._operator_isEqual (_p->mVariableLocation).boolValue ()
         && mName._operator_isEqual (_p->mName).boolValue ()
         && mFieldKind._operator_isEqual (_p->mFieldKind).boolValue ()
         && mIteratorNewStyle._operator_isEqual (_p->mIteratorNewStyle).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeOperandName::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeOperandName:"
           << mVariableLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFieldKind.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIteratorNewStyle.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeOperandName::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeOperandName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeOperandName (& typeid (cPtr_typeOperandName), & typeid (cPtr_typeCplusPlusName), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeOperandName::galgasRTTI (void) const {
  return & gClassInfoFor__typeOperandName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOperandName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeOperandName::
GGS_typeOperandName (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeOperandName::
GGS_typeOperandName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeOperandName GGS_typeOperandName::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeOperandName _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeOperandName *> (inPointer) != NULL)
      : (typeid (cPtr_typeOperandName) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeOperandName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeOperandName),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeOperandName GGS_typeOperandName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1,
                 const GGS_bool& argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeOperandName result ;
  macroMyNew (result.mPointer, cPtr_typeOperandName (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeOperandName::
reader_mName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOperandName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOperandName *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeOperandName::
reader_mFieldKind (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOperandName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOperandName *) mPointer)->mFieldKind ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeOperandName::
reader_mIteratorNewStyle (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOperandName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOperandName *) mPointer)->mIteratorNewStyle ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeOperandName::actualTypeName (void) const {
  return "typeOperandName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeOperandName ("typeOperandName", gClassInfoFor__typeCplusPlusName) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_typeKeyName'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeKeyName::
cPtr_typeKeyName (const GGS_location & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE),
mIteratorNewStyle (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeKeyName * GGS_typeKeyName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeKeyName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeKeyName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeKeyName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeKeyName * _p = dynamic_cast <const cPtr_typeKeyName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableLocation._operator_isEqual (_p->mVariableLocation).boolValue ()
         && mIteratorNewStyle._operator_isEqual (_p->mIteratorNewStyle).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeKeyName::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeKeyName:"
           << mVariableLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIteratorNewStyle.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeKeyName::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeKeyName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeKeyName (& typeid (cPtr_typeKeyName), & typeid (cPtr_typeCplusPlusName), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeKeyName::galgasRTTI (void) const {
  return & gClassInfoFor__typeKeyName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeKeyName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeKeyName::
GGS_typeKeyName (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeKeyName::
GGS_typeKeyName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeKeyName GGS_typeKeyName::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeKeyName _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeKeyName *> (inPointer) != NULL)
      : (typeid (cPtr_typeKeyName) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeKeyName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeKeyName),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeKeyName GGS_typeKeyName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeKeyName result ;
  macroMyNew (result.mPointer, cPtr_typeKeyName (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKeyName::
reader_mIteratorNewStyle (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeKeyName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeKeyName *) mPointer)->mIteratorNewStyle ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeKeyName::actualTypeName (void) const {
  return "typeKeyName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeKeyName ("typeKeyName", gClassInfoFor__typeCplusPlusName) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_typeNullName'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNullName::
cPtr_typeNullName (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNullName * GGS_typeNullName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNullName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeNullName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeNullName::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeNullName * _p = dynamic_cast <const cPtr_typeNullName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableLocation._operator_isEqual (_p->mVariableLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeNullName::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeNullName:"
           << mVariableLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeNullName::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeNullName::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeNullName (& typeid (cPtr_typeNullName), & typeid (cPtr_typeCplusPlusName), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeNullName::galgasRTTI (void) const {
  return & gClassInfoFor__typeNullName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeNullName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeNullName::
GGS_typeNullName (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeNullName::
GGS_typeNullName (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeNullName GGS_typeNullName::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeNullName _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeNullName *> (inPointer) != NULL)
      : (typeid (cPtr_typeNullName) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeNullName (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeNullName),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeNullName GGS_typeNullName::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeNullName result ;
  macroMyNew (result.mPointer, cPtr_typeNullName (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeNullName::actualTypeName (void) const {
  return "typeNullName" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeNullName ("typeNullName", gClassInfoFor__typeCplusPlusName) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeListeTypesEtNomsArgMethode'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeTypesEtNomsArgMethode::
elementOf_GGS_typeListeTypesEtNomsArgMethode (const GGS_AC_galgasType & argument_0,
                                const GGS_EXformalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mFormalArgumentPassingMode (argument_1),
mCppName (argument_2),
mModeIn (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeTypesEtNomsArgMethode::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeTypesEtNomsArgMethode * _p = dynamic_cast <const elementOf_GGS_typeListeTypesEtNomsArgMethode *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mType._operator_isEqual (_p->mType).boolValue ()
         && mFormalArgumentPassingMode._operator_isEqual (_p->mFormalArgumentPassingMode).boolValue ()
         && mCppName._operator_isEqual (_p->mCppName).boolValue ()
         && mModeIn._operator_isEqual (_p->mModeIn).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeTypesEtNomsArgMethode::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mModeIn.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeTypesEtNomsArgMethode'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_EXformalArgumentPassingMode& argument_1,
                    const GGS_typeCplusPlusName & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_EXformalArgumentPassingMode& argument_1,
                    const GGS_typeCplusPlusName & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
_addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_EXformalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()&& argument_3._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode GGS_typeListeTypesEtNomsArgMethode::
_operator_concat (const GGS_typeListeTypesEtNomsArgMethode & inOperand) const {
  GGS_typeListeTypesEtNomsArgMethode result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
_dotAssign_operation (const GGS_typeListeTypesEtNomsArgMethode inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_typeListeTypesEtNomsArgMethode * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_EXformalArgumentPassingMode p_1 = p->mFormalArgumentPassingMode ;
          GGS_typeCplusPlusName  p_2 = p->mCppName ;
          GGS_bool p_3 = p->mModeIn ;
          _internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_EXformalArgumentPassingMode& argument_1,
                     const GGS_typeCplusPlusName & argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mFormalArgumentPassingMode,
                                _p->mCppName,
                                _p->mModeIn
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_typeListeTypesEtNomsArgMethode::
constructor_emptyList (void) {
  GGS_typeListeTypesEtNomsArgMethode result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_typeListeTypesEtNomsArgMethode::
constructor_listWithValue (const GGS_AC_galgasType & argument_0,
                                const GGS_EXformalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) {
  GGS_typeListeTypesEtNomsArgMethode result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
internalSubListWithRange (GGS_typeListeTypesEtNomsArgMethode & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mType, _p->mFormalArgumentPassingMode, _p->mCppName, _p->mModeIn) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode GGS_typeListeTypesEtNomsArgMethode::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeTypesEtNomsArgMethode result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode GGS_typeListeTypesEtNomsArgMethode::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeTypesEtNomsArgMethode result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeTypesEtNomsArgMethode::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeTypesEtNomsArgMethode", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
method_first (C_Compiler & _inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_EXformalArgumentPassingMode& _out_1,
              GGS_typeCplusPlusName & _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _out_2 = _p->mCppName ;
    _out_3 = _p->mModeIn ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
method_last (C_Compiler & _inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_EXformalArgumentPassingMode& _out_1,
             GGS_typeCplusPlusName & _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _out_2 = _p->mCppName ;
    _out_3 = _p->mModeIn ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_EXformalArgumentPassingMode& _out_1,
                 GGS_typeCplusPlusName & _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _out_2 = _p->mCppName ;
    _out_3 = _p->mModeIn ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_popLast (C_Compiler & _inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_EXformalArgumentPassingMode& _out_1,
                GGS_typeCplusPlusName & _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _out_2 = _p->mCppName ;
    _out_3 = _p->mModeIn ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeListeTypesEtNomsArgMethode::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_galgasType  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXformalArgumentPassingMode GGS_typeListeTypesEtNomsArgMethode::
reader_mFormalArgumentPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_EXformalArgumentPassingMode result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeListeTypesEtNomsArgMethode::
reader_mCppNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusName  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCppName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeTypesEtNomsArgMethode::
reader_mModeInAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mModeIn ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_AC_galgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_setMFormalArgumentPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_EXformalArgumentPassingMode & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_setMCppNameAtIndex (C_Compiler & inLexique,
                              const GGS_typeCplusPlusName  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCppName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_setMModeInAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mModeIn = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeListeTypesEtNomsArgMethode::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_EXformalArgumentPassingMode & GGS_typeListeTypesEtNomsArgMethode::cEnumerator::_mFormalArgumentPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mFormalArgumentPassingMode ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCplusPlusName  & GGS_typeListeTypesEtNomsArgMethode::cEnumerator::_mCppName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mCppName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_typeListeTypesEtNomsArgMethode::cEnumerator::_mModeIn (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mModeIn ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@typeSuperClassesMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSuperClassesMap::
elementOf_GGS_typeSuperClassesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeSuperClassesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSuperClassesMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeSuperClassesMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeSuperClassesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeSuperClassesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeSuperClassesMap * info = (e_typeSuperClassesMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeSuperClassesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeSuperClassesMap * info = (e_typeSuperClassesMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSuperClassesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeSuperClassesMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSuperClassesMap::
_operator_isEqual (const GGS_typeSuperClassesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSuperClassesMap::
_operator_isNotEqual (const GGS_typeSuperClassesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeSuperClassesMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the class '%K' is already a super class of the current class",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeSuperClassesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSuperClassesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSuperClassesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSuperClassesMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeSuperClassesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeAttributsSemantiques'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeAttributsSemantiques::
elementOf_GGS_typeListeAttributsSemantiques (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributType (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeAttributsSemantiques::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeAttributsSemantiques * _p = dynamic_cast <const elementOf_GGS_typeListeAttributsSemantiques *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributType._operator_isEqual (_p->mAttributType).boolValue ()
         && mAttributeName._operator_isEqual (_p->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeAttributsSemantiques::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeAttributsSemantiques'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
_addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques GGS_typeListeAttributsSemantiques::
_operator_concat (const GGS_typeListeAttributsSemantiques & inOperand) const {
  GGS_typeListeAttributsSemantiques result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
_dotAssign_operation (const GGS_typeListeAttributsSemantiques inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_typeListeAttributsSemantiques * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mAttributType ;
          GGS_lstring  p_1 = p->mAttributeName ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributType,
                                _p->mAttributeName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeListeAttributsSemantiques::
constructor_emptyList (void) {
  GGS_typeListeAttributsSemantiques result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeListeAttributsSemantiques::
constructor_listWithValue (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_typeListeAttributsSemantiques result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
internalSubListWithRange (GGS_typeListeAttributsSemantiques & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mAttributType, _p->mAttributeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques GGS_typeListeAttributsSemantiques::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques GGS_typeListeAttributsSemantiques::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeAttributsSemantiques::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeAttributsSemantiques", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
method_first (C_Compiler & _inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributType ;
    _out_1 = _p->mAttributeName ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
method_last (C_Compiler & _inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributType ;
    _out_1 = _p->mAttributeName ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributType ;
    _out_1 = _p->mAttributeName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
modifier_popLast (C_Compiler & _inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributType ;
    _out_1 = _p->mAttributeName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeListeAttributsSemantiques::
reader_mAttributTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_galgasType  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeListeAttributsSemantiques::
reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
modifier_setMAttributTypeAtIndex (C_Compiler & inLexique,
                              const GGS_AC_galgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeListeAttributsSemantiques::cEnumerator::_mAttributType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mAttributType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeListeAttributsSemantiques::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@typeTypesList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTypesList::
elementOf_GGS_typeTypesList (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mEndOfExpressionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTypesList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeTypesList * _p = dynamic_cast <const elementOf_GGS_typeTypesList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mType._operator_isEqual (_p->mType).boolValue ()
         && mEndOfExpressionLocation._operator_isEqual (_p->mEndOfExpressionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTypesList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfExpressionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@typeTypesList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeTypesList::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
_addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeTypesList GGS_typeTypesList::
_operator_concat (const GGS_typeTypesList & inOperand) const {
  GGS_typeTypesList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
_dotAssign_operation (const GGS_typeTypesList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_typeTypesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_location  p_1 = p->mEndOfExpressionLocation ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mEndOfExpressionLocation
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeTypesList  GGS_typeTypesList::
constructor_emptyList (void) {
  GGS_typeTypesList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTypesList  GGS_typeTypesList::
constructor_listWithValue (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  GGS_typeTypesList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
internalSubListWithRange (GGS_typeTypesList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mType, _p->mEndOfExpressionLocation) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeTypesList GGS_typeTypesList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeTypesList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTypesList GGS_typeTypesList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeTypesList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTypesList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeTypesList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
method_first (C_Compiler & _inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_location & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mEndOfExpressionLocation ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
method_last (C_Compiler & _inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_location & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mEndOfExpressionLocation ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_location & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mEndOfExpressionLocation ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_location & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mEndOfExpressionLocation ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeTypesList::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_galgasType  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeTypesList::
reader_mEndOfExpressionLocationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfExpressionLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_AC_galgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
modifier_setMEndOfExpressionLocationAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfExpressionLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeTypesList::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_typeTypesList::cEnumerator::_mEndOfExpressionLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mEndOfExpressionLocation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_EXsignature'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_EXsignature::
elementOf_GGS_L_EXsignature (const GGS_AC_galgasType & argument_0,
                                const GGS_EXformalArgumentPassingMode& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mFormalArgumentPassingMode (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_EXsignature::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_EXsignature * _p = dynamic_cast <const elementOf_GGS_L_EXsignature *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mType._operator_isEqual (_p->mType).boolValue ()
         && mFormalArgumentPassingMode._operator_isEqual (_p->mFormalArgumentPassingMode).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_EXsignature::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_EXsignature'                            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_EXformalArgumentPassingMode& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_EXformalArgumentPassingMode& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
_addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_EXformalArgumentPassingMode& argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature GGS_L_EXsignature::
_operator_concat (const GGS_L_EXsignature & inOperand) const {
  GGS_L_EXsignature result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
_dotAssign_operation (const GGS_L_EXsignature inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_L_EXsignature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_EXformalArgumentPassingMode p_1 = p->mFormalArgumentPassingMode ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_EXformalArgumentPassingMode& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mFormalArgumentPassingMode
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_L_EXsignature::
constructor_emptyList (void) {
  GGS_L_EXsignature result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_L_EXsignature::
constructor_listWithValue (const GGS_AC_galgasType & argument_0,
                                const GGS_EXformalArgumentPassingMode& argument_1) {
  GGS_L_EXsignature result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
internalSubListWithRange (GGS_L_EXsignature & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mType, _p->mFormalArgumentPassingMode) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature GGS_L_EXsignature::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_EXsignature result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature GGS_L_EXsignature::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_EXsignature result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_EXsignature::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_EXsignature", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
method_first (C_Compiler & _inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_EXformalArgumentPassingMode& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
method_last (C_Compiler & _inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_EXformalArgumentPassingMode& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_EXformalArgumentPassingMode& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
modifier_popLast (C_Compiler & _inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_EXformalArgumentPassingMode& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_L_EXsignature::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_galgasType  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXformalArgumentPassingMode GGS_L_EXsignature::
reader_mFormalArgumentPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_EXformalArgumentPassingMode result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_AC_galgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
modifier_setMFormalArgumentPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_EXformalArgumentPassingMode & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_L_EXsignature::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_EXformalArgumentPassingMode & GGS_L_EXsignature::cEnumerator::_mFormalArgumentPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mFormalArgumentPassingMode ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Class for 'categoryMethodKind' Enumeration                 *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_categoryMethodKind::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodKind::
_operator_isEqual (const GGS_categoryMethodKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodKind::
_operator_isNotEqual (const GGS_categoryMethodKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodKind::
_operator_infOrEqual (const GGS_categoryMethodKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodKind::
_operator_supOrEqual (const GGS_categoryMethodKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodKind::
_operator_strictInf (const GGS_categoryMethodKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodKind::
_operator_strictSup (const GGS_categoryMethodKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryMethodKind::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @categoryMethodKind" ;
  switch (mValue) {
  case enum_abstractMethod:
    s << " abstractMethod>" ;
    break ;
  case enum_baseMethod:
    s << " baseMethod>" ;
    break ;
  case enum_overridingMethod:
    s << " overridingMethod>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_EXcategoryMethodMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_EXcategoryMethodMap::e_EXcategoryMethodMap (void) :
mCategoryMethodKind (),
aListeArgumentsFormels () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@EXcategoryMethodMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_EXcategoryMethodMap::
elementOf_GGS_EXcategoryMethodMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_EXcategoryMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_EXcategoryMethodMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mCategoryMethodKind.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aListeArgumentsFormels.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_EXcategoryMethodMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_EXcategoryMethodMap * _p = dynamic_cast <const elementOf_GGS_EXcategoryMethodMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mCategoryMethodKind._operator_isEqual (_p->mInfo.mCategoryMethodKind)).boolValue ()
           && (mInfo.aListeArgumentsFormels._operator_isEqual (_p->mInfo.aListeArgumentsFormels)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_EXcategoryMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_EXcategoryMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_EXcategoryMethodMap * info = (e_EXcategoryMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_EXcategoryMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_EXcategoryMethodMap * info = (e_EXcategoryMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryMethodMap GGS_EXcategoryMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXcategoryMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_EXcategoryMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXcategoryMethodMap::
_operator_isEqual (const GGS_EXcategoryMethodMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXcategoryMethodMap::
_operator_isNotEqual (const GGS_EXcategoryMethodMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_categoryMethodKind& inParameter0,
                const GGS_L_EXsignature & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_EXcategoryMethodMap info  ;
    info.mCategoryMethodKind = inParameter0 ;
    info.aListeArgumentsFormels = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_categoryMethodKind  & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mCategoryMethodKind ;
    outParameter1 = node->mInfo.aListeArgumentsFormels ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
modifier_setMCategoryMethodKindForKey (C_Compiler & inLexique,
                        const GGS_categoryMethodKind& inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMCategoryMethodKindForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mCategoryMethodKind = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
modifier_setAListeArgumentsFormelsForKey (C_Compiler & inLexique,
                        const GGS_L_EXsignature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setAListeArgumentsFormelsForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.aListeArgumentsFormels = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_categoryMethodKind  & outParameter0,
                                GGS_L_EXsignature   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' method is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
method_searchKeyAndGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_categoryMethodKind  & outParameter0,
                                GGS_L_EXsignature   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' method is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_EXcategoryMethodMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_categoryMethodKind& inParameter0,
                                const GGS_L_EXsignature & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' method is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryMethodMap GGS_EXcategoryMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_EXcategoryMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXcategoryMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXcategoryMethodMap GGS_EXcategoryMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_EXcategoryMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXcategoryMethodMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @EXcategoryMethodMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_categoryMethodKind & GGS_EXcategoryMethodMap::cEnumerator::_mCategoryMethodKind (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mCategoryMethodKind ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_EXcategoryMethodMap::cEnumerator::_aListeArgumentsFormels (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aListeArgumentsFormels ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_actualParametersSignature'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_actualParametersSignature::
elementOf_GGS_L_actualParametersSignature (const GGS_AC_galgasType & argument_0,
                                const GGS_EXactualParametersPassingMode& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mFormalArgumentPassingMode (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_actualParametersSignature::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_actualParametersSignature * _p = dynamic_cast <const elementOf_GGS_L_actualParametersSignature *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mType._operator_isEqual (_p->mType).boolValue ()
         && mFormalArgumentPassingMode._operator_isEqual (_p->mFormalArgumentPassingMode).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_actualParametersSignature::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@L_actualParametersSignature'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_EXactualParametersPassingMode& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_EXactualParametersPassingMode& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
_addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_EXactualParametersPassingMode& argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature GGS_L_actualParametersSignature::
_operator_concat (const GGS_L_actualParametersSignature & inOperand) const {
  GGS_L_actualParametersSignature result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
_dotAssign_operation (const GGS_L_actualParametersSignature inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_L_actualParametersSignature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_EXactualParametersPassingMode p_1 = p->mFormalArgumentPassingMode ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_EXactualParametersPassingMode& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mFormalArgumentPassingMode
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature  GGS_L_actualParametersSignature::
constructor_emptyList (void) {
  GGS_L_actualParametersSignature result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature  GGS_L_actualParametersSignature::
constructor_listWithValue (const GGS_AC_galgasType & argument_0,
                                const GGS_EXactualParametersPassingMode& argument_1) {
  GGS_L_actualParametersSignature result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
internalSubListWithRange (GGS_L_actualParametersSignature & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mType, _p->mFormalArgumentPassingMode) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature GGS_L_actualParametersSignature::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_actualParametersSignature result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature GGS_L_actualParametersSignature::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_actualParametersSignature result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_actualParametersSignature::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_actualParametersSignature", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
method_first (C_Compiler & _inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_EXactualParametersPassingMode& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
method_last (C_Compiler & _inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_EXactualParametersPassingMode& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_EXactualParametersPassingMode& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
modifier_popLast (C_Compiler & _inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_EXactualParametersPassingMode& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_L_actualParametersSignature::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_galgasType  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXactualParametersPassingMode GGS_L_actualParametersSignature::
reader_mFormalArgumentPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_EXactualParametersPassingMode result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_AC_galgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
modifier_setMFormalArgumentPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_EXactualParametersPassingMode & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_L_actualParametersSignature::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_EXactualParametersPassingMode & GGS_L_actualParametersSignature::cEnumerator::_mFormalArgumentPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mFormalArgumentPassingMode ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_M_accessors_map'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_accessors_map::e_M_accessors_map (void) :
mAccessorSignature (),
mReturnedType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@M_accessors_map'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_accessors_map::
elementOf_GGS_M_accessors_map (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_accessors_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_accessors_map::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAccessorSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mReturnedType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_accessors_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_accessors_map * _p = dynamic_cast <const elementOf_GGS_M_accessors_map *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mAccessorSignature._operator_isEqual (_p->mInfo.mAccessorSignature)).boolValue ()
           && (mInfo.mReturnedType._operator_isEqual (_p->mInfo.mReturnedType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_accessors_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_accessors_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_accessors_map * info = (e_M_accessors_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_accessors_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_accessors_map * info = (e_M_accessors_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_accessors_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_accessors_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_accessors_map::
_operator_isEqual (const GGS_M_accessors_map & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_accessors_map::
_operator_isNotEqual (const GGS_M_accessors_map & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                const GGS_AC_galgasType & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_accessors_map info  ;
    info.mAccessorSignature = inParameter0 ;
    info.mReturnedType = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mAccessorSignature ;
    outParameter1 = node->mInfo.mReturnedType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
modifier_setMAccessorSignatureForKey (C_Compiler & inLexique,
                        const GGS_L_EXsignature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMAccessorSignatureForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mAccessorSignature = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
modifier_setMReturnedTypeForKey (C_Compiler & inLexique,
                        const GGS_AC_galgasType & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMReturnedTypeForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mReturnedType = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_AC_galgasType   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' accessor is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_AC_galgasType & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' accessor has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_accessors_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_accessors_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_accessors_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_accessors_map::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_accessors_map " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_M_accessors_map::cEnumerator::_mAccessorSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAccessorSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_M_accessors_map::cEnumerator::_mReturnedType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReturnedType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeGalgas_jokerInParameterList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_jokerInParameterList::
cPtr_typeGalgas_jokerInParameterList (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_jokerInParameterList * GGS_typeGalgas_jokerInParameterList::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_jokerInParameterList *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_jokerInParameterList::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_jokerInParameterList::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_jokerInParameterList::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_jokerInParameterList:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_jokerInParameterList::
static_string_message_messageGalgasType (void) {
  return "\?\?" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_jokerInParameterList::
message_messageGalgasType (void) const {
  return "\?\?" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_jokerInParameterList::
_message (void) const {
  return "a joker" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_jokerInParameterList::
_static_message (void) {
  return "a joker" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_jokerInParameterList (& typeid (cPtr_typeGalgas_jokerInParameterList), & typeid (cPtr_AC_galgasType), "a joker") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_jokerInParameterList::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_jokerInParameterList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeGalgas_jokerInParameterList'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_jokerInParameterList::
GGS_typeGalgas_jokerInParameterList (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_jokerInParameterList::
GGS_typeGalgas_jokerInParameterList (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_jokerInParameterList GGS_typeGalgas_jokerInParameterList::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_jokerInParameterList _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_jokerInParameterList) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_jokerInParameterList (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_jokerInParameterList),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_jokerInParameterList * gSingleton_typeGalgas_jokerInParameterList = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_jokerInParameterList (void) {
  macroDetachPointer (gSingleton_typeGalgas_jokerInParameterList, cPtr_typeGalgas_jokerInParameterList) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_jokerInParameterList GGS_typeGalgas_jokerInParameterList::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_jokerInParameterList result ;
  if (NULL == gSingleton_typeGalgas_jokerInParameterList) {
    macroMyNew (gSingleton_typeGalgas_jokerInParameterList, cPtr_typeGalgas_jokerInParameterList (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_jokerInParameterList) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_jokerInParameterList) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_jokerInParameterList::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_jokerInParameterList * p = (cPtr_typeGalgas_jokerInParameterList *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_jokerInParameterList::actualTypeName (void) const {
  return "typeGalgas_jokerInParameterList" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_jokerInParameterList ("typeGalgas_jokerInParameterList", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeGalgas_bool'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_bool::
cPtr_typeGalgas_bool (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_bool * GGS_typeGalgas_bool::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_bool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_bool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_bool::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "bool") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_bool:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_bool::
static_string_message_messageGalgasType (void) {
  return "a '@bool' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_bool::
message_messageGalgasType (void) const {
  return "a '@bool' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_bool::
_message (void) const {
  return "a '@bool' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_bool::
_static_message (void) {
  return "a '@bool' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_bool (& typeid (cPtr_typeGalgas_bool), & typeid (cPtr_AC_galgasType), "a '@bool' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_bool::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_bool ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_bool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_bool::
GGS_typeGalgas_bool (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_bool::
GGS_typeGalgas_bool (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_bool GGS_typeGalgas_bool::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_bool _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_bool *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_bool) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_bool (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_bool),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_bool * gSingleton_typeGalgas_bool = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_bool (void) {
  macroDetachPointer (gSingleton_typeGalgas_bool, cPtr_typeGalgas_bool) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_bool GGS_typeGalgas_bool::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_bool result ;
  if (NULL == gSingleton_typeGalgas_bool) {
    macroMyNew (gSingleton_typeGalgas_bool, cPtr_typeGalgas_bool (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_bool) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_bool) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_bool::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_bool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_bool * p = (cPtr_typeGalgas_bool *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_bool::actualTypeName (void) const {
  return "typeGalgas_bool" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_bool ("typeGalgas_bool", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeGalgas_uint'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_uint::
cPtr_typeGalgas_uint (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_uint * GGS_typeGalgas_uint::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_uint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_uint *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_uint::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "uint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_handleIncrementOperatorCall (C_Compiler & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_handleDecrementOperatorCall (C_Compiler & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if ((((((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (792)))._operator_isEqual (GGS_string (true, "max")))._operator_or ((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (793)))._operator_isEqual (GGS_string (true, "sequenceNumber"))))._operator_or ((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (794)))._operator_isEqual (GGS_string (true, "errorCount"))))._operator_or ((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (795)))._operator_isEqual (GGS_string (true, "warningCount")))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (797)))._operator_isEqual (GGS_string (true, "valueWithMask"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (803)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_uint:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint::
static_string_message_messageGalgasType (void) {
  return "a '@uint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint::
message_messageGalgasType (void) const {
  return "a '@uint' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint::
_message (void) const {
  return "a '@uint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint::
_static_message (void) {
  return "a '@uint' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_uint (& typeid (cPtr_typeGalgas_uint), & typeid (cPtr_AC_galgasType), "a '@uint' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_uint::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_uint ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_uint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_uint::
GGS_typeGalgas_uint (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint::
GGS_typeGalgas_uint (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_uint GGS_typeGalgas_uint::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_uint _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_uint *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_uint) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_uint (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_uint),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_uint * gSingleton_typeGalgas_uint = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_uint (void) {
  macroDetachPointer (gSingleton_typeGalgas_uint, cPtr_typeGalgas_uint) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint GGS_typeGalgas_uint::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_uint result ;
  if (NULL == gSingleton_typeGalgas_uint) {
    macroMyNew (gSingleton_typeGalgas_uint, cPtr_typeGalgas_uint (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_uint) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_uint) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_uint::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_uint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_uint * p = (cPtr_typeGalgas_uint *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_uint::actualTypeName (void) const {
  return "typeGalgas_uint" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_uint ("typeGalgas_uint", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeGalgas_char'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_char::
cPtr_typeGalgas_char (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_char * GGS_typeGalgas_char::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_char *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_char *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_char::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "char") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_char:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_char::
static_string_message_messageGalgasType (void) {
  return "a '@char' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_char::
message_messageGalgasType (void) const {
  return "a '@char' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_char::
_message (void) const {
  return "a '@char' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_char::
_static_message (void) {
  return "a '@char' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_char (& typeid (cPtr_typeGalgas_char), & typeid (cPtr_AC_galgasType), "a '@char' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_char::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_char ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_char'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_char::
GGS_typeGalgas_char (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_char::
GGS_typeGalgas_char (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_char GGS_typeGalgas_char::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_char _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_char *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_char) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_char (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_char),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_char * gSingleton_typeGalgas_char = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_char (void) {
  macroDetachPointer (gSingleton_typeGalgas_char, cPtr_typeGalgas_char) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_char GGS_typeGalgas_char::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_char result ;
  if (NULL == gSingleton_typeGalgas_char) {
    macroMyNew (gSingleton_typeGalgas_char, cPtr_typeGalgas_char (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_char) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_char) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_char::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_char *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_char * p = (cPtr_typeGalgas_char *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_char::actualTypeName (void) const {
  return "typeGalgas_char" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_char ("typeGalgas_char", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_string'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_string::
cPtr_typeGalgas_string (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_string * GGS_typeGalgas_string::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_string *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_string *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_string::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "string") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_handleMethodInstructionCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outReaderSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string (true, "") ;
  if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (855)))._operator_isEqual (GGS_string (true, "writeToFile"))).isBuiltAndTrue ()) {
    var_cas_outReaderSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outReaderSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (858)))._operator_isEqual (GGS_string (true, "writeToFileWhenDifferentContents"))).isBuiltAndTrue ()) {
    var_cas_outReaderSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outReaderSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
    var_cas_outReaderSignature._addAssign_operation (GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (862)))._operator_isEqual (GGS_string (true, "writeToExecutableFile"))).isBuiltAndTrue ()) {
    var_cas_outReaderSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outReaderSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (865)))._operator_isEqual (GGS_string (true, "makeDirectoryAndWriteToFile"))).isBuiltAndTrue ()) {
    var_cas_outReaderSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outReaderSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (868)))._operator_isEqual (GGS_string (true, "makeDirectory"))).isBuiltAndTrue ()) {
    var_cas_outReaderSignature = GGS_L_EXsignature ::constructor_emptyList () ;
  }else{
    var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (GGS_string (true, "this method is not defined (writeToFile, makeDirectoryAndWriteToFile"))._operator_concat (GGS_string (true, " and makeDirectory methods are defined on @string objects) ")) COMMA_SOURCE_FILE_AT_LINE (873)) ;
    var_cas_outReaderSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (883)))._operator_isEqual (GGS_string (true, "stringWithVersionString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (885)))._operator_isEqual (GGS_string (true, "stringWithSourceFilePath"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (887)))._operator_isEqual (GGS_string (true, "retrieveAndResetTemplateString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (889)))._operator_isEqual (GGS_string (true, "stringWithCurrentDirectory"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (891)))._operator_isEqual (GGS_string (true, "stringWithSequenceOfCharacters"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_char ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (895)))._operator_isEqual (GGS_string (true, "stringWithMainFirstArgument"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (897)))._operator_isEqual (GGS_string (true, "stringWithContentsOfFile"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (900)))._operator_isEqual (GGS_string (true, "stringWithCurrentDateTime"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (902)))._operator_isEqual (GGS_string (true, "stringWithEnvironmentVariable"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (905)))._operator_isEqual (GGS_string (true, "stringWithEnvironmentVariableOrEmpty"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (908)))._operator_isEqual (GGS_string (true, "CppLineComment"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (910)))._operator_isEqual (GGS_string (true, "CppTitleComment"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (913)))._operator_isEqual (GGS_string (true, "CppChar"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_char ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (916)))._operator_isEqual (GGS_string (true, "CppString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (919)))._operator_isEqual (GGS_string (true, "componentsJoinedByString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_stringlistType ;
    ::routine_extern_build_stringlist_type (_inLexique,  var_cas_stringlistType COMMA_SOURCE_FILE_AT_LINE (921)) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_stringlistType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (926)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (935)))._operator_isEqual (GGS_string (true, "setCapacity"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (938)))._operator_isEqual (GGS_string (true, "setCharacterAtIndex"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_char ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this modifier is not defined") COMMA_SOURCE_FILE_AT_LINE (945)) ;
    var_cas_outModifierSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_handleClassMethodCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inTypeMethodName,
                                GGS_L_EXsignature & var_cas_outTypeMethodSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if (((var_cas_inTypeMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (954)))._operator_isEqual (GGS_string (true, "deleteFile"))).isBuiltAndTrue ()) {
    var_cas_outTypeMethodSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outTypeMethodSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inTypeMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (957)))._operator_isEqual (GGS_string (true, "removeEmptyDirectory"))).isBuiltAndTrue ()) {
    var_cas_outTypeMethodSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outTypeMethodSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inTypeMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (960)))._operator_isEqual (GGS_string (true, "removeDirectoryRecursively"))).isBuiltAndTrue ()) {
    var_cas_outTypeMethodSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outTypeMethodSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inTypeMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (963)))._operator_isEqual (GGS_string (true, "generateFile"))).isBuiltAndTrue ()) {
    var_cas_outTypeMethodSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outTypeMethodSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
    var_cas_outTypeMethodSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
    var_cas_outTypeMethodSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
    var_cas_outTypeMethodSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
    var_cas_outTypeMethodSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
    var_cas_outTypeMethodSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
    var_cas_outTypeMethodSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inTypeMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This type method is not defined") COMMA_SOURCE_FILE_AT_LINE (974)) ;
    var_cas_outTypeMethodSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_string:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_string::
static_string_message_messageGalgasType (void) {
  return "a '@string' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_string::
message_messageGalgasType (void) const {
  return "a '@string' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_string::
_message (void) const {
  return "a '@string' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_string::
_static_message (void) {
  return "a '@string' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_string (& typeid (cPtr_typeGalgas_string), & typeid (cPtr_AC_galgasType), "a '@string' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_string::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_string ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_string'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_string::
GGS_typeGalgas_string (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_string::
GGS_typeGalgas_string (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_string GGS_typeGalgas_string::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_string _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_string *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_string) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_string (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_string),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_string * gSingleton_typeGalgas_string = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_string (void) {
  macroDetachPointer (gSingleton_typeGalgas_string, cPtr_typeGalgas_string) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_string GGS_typeGalgas_string::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_string result ;
  if (NULL == gSingleton_typeGalgas_string) {
    macroMyNew (gSingleton_typeGalgas_string, cPtr_typeGalgas_string (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_string) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_string) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_string::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_string *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_string * p = (cPtr_typeGalgas_string *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_string::actualTypeName (void) const {
  return "typeGalgas_string" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_string ("typeGalgas_string", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeGalgas_sint'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_sint::
cPtr_typeGalgas_sint (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_sint * GGS_typeGalgas_sint::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_sint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_sint *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_sint::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "sint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_handleIncrementOperatorCall (C_Compiler & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_handleDecrementOperatorCall (C_Compiler & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, false) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1014)))._operator_isEqual (GGS_string (true, "min"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1016)))._operator_isEqual (GGS_string (true, "max"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1020)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_sint:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint::
static_string_message_messageGalgasType (void) {
  return "a '@sint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint::
message_messageGalgasType (void) const {
  return "a '@sint' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint::
_message (void) const {
  return "a '@sint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint::
_static_message (void) {
  return "a '@sint' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_sint (& typeid (cPtr_typeGalgas_sint), & typeid (cPtr_AC_galgasType), "a '@sint' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_sint::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_sint ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_sint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_sint::
GGS_typeGalgas_sint (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint::
GGS_typeGalgas_sint (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_sint GGS_typeGalgas_sint::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_sint _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_sint *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_sint) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_sint (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_sint),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_sint * gSingleton_typeGalgas_sint = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_sint (void) {
  macroDetachPointer (gSingleton_typeGalgas_sint, cPtr_typeGalgas_sint) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint GGS_typeGalgas_sint::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_sint result ;
  if (NULL == gSingleton_typeGalgas_sint) {
    macroMyNew (gSingleton_typeGalgas_sint, cPtr_typeGalgas_sint (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_sint) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_sint) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_sint::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_sint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_sint * p = (cPtr_typeGalgas_sint *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_sint::actualTypeName (void) const {
  return "typeGalgas_sint" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_sint ("typeGalgas_sint", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_sint64'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_sint64::
cPtr_typeGalgas_sint64 (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_sint64 * GGS_typeGalgas_sint64::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_sint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_sint64 *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_sint64::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "sint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_handleIncrementOperatorCall (C_Compiler & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_handleDecrementOperatorCall (C_Compiler & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, false) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1060)))._operator_isEqual (GGS_string (true, "min"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1062)))._operator_isEqual (GGS_string (true, "max"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1066)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_sint64:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint64::
static_string_message_messageGalgasType (void) {
  return "a '@sint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint64::
message_messageGalgasType (void) const {
  return "a '@sint64' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint64::
_message (void) const {
  return "a '@sint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint64::
_static_message (void) {
  return "a '@sint64' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_sint64 (& typeid (cPtr_typeGalgas_sint64), & typeid (cPtr_AC_galgasType), "a '@sint64' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_sint64::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_sint64 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_sint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_sint64::
GGS_typeGalgas_sint64 (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint64::
GGS_typeGalgas_sint64 (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_sint64 GGS_typeGalgas_sint64::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_sint64 _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_sint64 *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_sint64) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_sint64 (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_sint64),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_sint64 * gSingleton_typeGalgas_sint64 = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_sint64 (void) {
  macroDetachPointer (gSingleton_typeGalgas_sint64, cPtr_typeGalgas_sint64) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint64 GGS_typeGalgas_sint64::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_sint64 result ;
  if (NULL == gSingleton_typeGalgas_sint64) {
    macroMyNew (gSingleton_typeGalgas_sint64, cPtr_typeGalgas_sint64 (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_sint64) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_sint64) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_sint64::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_sint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_sint64 * p = (cPtr_typeGalgas_sint64 *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_sint64::actualTypeName (void) const {
  return "typeGalgas_sint64" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_sint64 ("typeGalgas_sint64", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_uint64'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_uint64::
cPtr_typeGalgas_uint64 (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_uint64 * GGS_typeGalgas_uint64::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_uint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_uint64 *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_uint64::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "uint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_handleIncrementOperatorCall (C_Compiler & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_handleDecrementOperatorCall (C_Compiler & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1106)))._operator_isEqual (GGS_string (true, "max"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1108)))._operator_isEqual (GGS_string (true, "uint64MaskWithCompressedBitString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1111)))._operator_isEqual (GGS_string (true, "uint64BaseValueWithCompressedBitString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1114)))._operator_isEqual (GGS_string (true, "uint64WithBitString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1119)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_uint64:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint64::
static_string_message_messageGalgasType (void) {
  return "a '@uint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint64::
message_messageGalgasType (void) const {
  return "a '@uint64' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint64::
_message (void) const {
  return "a '@uint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint64::
_static_message (void) {
  return "a '@uint64' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_uint64 (& typeid (cPtr_typeGalgas_uint64), & typeid (cPtr_AC_galgasType), "a '@uint64' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_uint64::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_uint64 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_uint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_uint64::
GGS_typeGalgas_uint64 (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint64::
GGS_typeGalgas_uint64 (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_uint64 GGS_typeGalgas_uint64::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_uint64 _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_uint64 *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_uint64) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_uint64 (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_uint64),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_uint64 * gSingleton_typeGalgas_uint64 = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_uint64 (void) {
  macroDetachPointer (gSingleton_typeGalgas_uint64, cPtr_typeGalgas_uint64) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint64 GGS_typeGalgas_uint64::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_uint64 result ;
  if (NULL == gSingleton_typeGalgas_uint64) {
    macroMyNew (gSingleton_typeGalgas_uint64, cPtr_typeGalgas_uint64 (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_uint64) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_uint64) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_uint64::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_uint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_uint64 * p = (cPtr_typeGalgas_uint64 *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_uint64::actualTypeName (void) const {
  return "typeGalgas_uint64" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_uint64 ("typeGalgas_uint64", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_double'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_double::
cPtr_typeGalgas_double (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_double * GGS_typeGalgas_double::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_double *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_double *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_double::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_double::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "double") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_double::
method_acceptToBeSortKeyInSortedListDefinition (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_double::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_double:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_double::
static_string_message_messageGalgasType (void) {
  return "a '@double' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_double::
message_messageGalgasType (void) const {
  return "a '@double' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_double::
_message (void) const {
  return "a '@double' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_double::
_static_message (void) {
  return "a '@double' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_double (& typeid (cPtr_typeGalgas_double), & typeid (cPtr_AC_galgasType), "a '@double' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_double::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_double ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_double'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_double::
GGS_typeGalgas_double (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_double::
GGS_typeGalgas_double (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_double GGS_typeGalgas_double::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_double _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_double *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_double) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_double (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_double),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_double * gSingleton_typeGalgas_double = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_double (void) {
  macroDetachPointer (gSingleton_typeGalgas_double, cPtr_typeGalgas_double) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_double GGS_typeGalgas_double::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_double result ;
  if (NULL == gSingleton_typeGalgas_double) {
    macroMyNew (gSingleton_typeGalgas_double, cPtr_typeGalgas_double (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_double) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_double) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_double::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_double *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_double * p = (cPtr_typeGalgas_double *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_double::actualTypeName (void) const {
  return "typeGalgas_double" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_double ("typeGalgas_double", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeGalgas_binaryset'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_binaryset::
cPtr_typeGalgas_binaryset (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_binaryset * GGS_typeGalgas_binaryset::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_binaryset *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_binaryset *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_binaryset::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_binaryset::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "binaryset") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_binaryset::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1164)))._operator_isEqual (GGS_string (true, "binarySetWithBit"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1167)))._operator_isEqual (GGS_string (true, "emptyBinarySet"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1169)))._operator_isEqual (GGS_string (true, "fullBinarySet"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1171)))._operator_isEqual (GGS_string (true, "binarySetWithPredicateString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1174)))._operator_isEqual (GGS_string (true, "binarySetWithEqualComparison"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1179)))._operator_isEqual (GGS_string (true, "binarySetWithNotEqualComparison"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1184)))._operator_isEqual (GGS_string (true, "binarySetWithStrictLowerComparison"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1189)))._operator_isEqual (GGS_string (true, "binarySetWithStrictGreaterComparison"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1194)))._operator_isEqual (GGS_string (true, "binarySetWithLowerOrEqualComparison"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1199)))._operator_isEqual (GGS_string (true, "binarySetWithGreaterOrEqualComparison"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1204)))._operator_isEqual (GGS_string (true, "binarySetWithEqualToConstant"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1209)))._operator_isEqual (GGS_string (true, "binarySetWithNotEqualToConstant"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1214)))._operator_isEqual (GGS_string (true, "binarySetWithStrictLowerThanConstant"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1219)))._operator_isEqual (GGS_string (true, "binarySetWithStrictGreaterThanConstant"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1224)))._operator_isEqual (GGS_string (true, "binarySetWithLowerOrEqualToConstant"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1229)))._operator_isEqual (GGS_string (true, "binarySetWithGreaterOrEqualToConstant"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1234)))._operator_isEqual (GGS_string (true, "binarySetWithITE"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_binaryset ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_binaryset ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_binaryset ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1241)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_binaryset::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_binaryset:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_binaryset::
static_string_message_messageGalgasType (void) {
  return "a '@binaryset' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_binaryset::
message_messageGalgasType (void) const {
  return "a '@binaryset' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_binaryset::
_message (void) const {
  return "a '@binaryset' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_binaryset::
_static_message (void) {
  return "a '@binaryset' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_binaryset (& typeid (cPtr_typeGalgas_binaryset), & typeid (cPtr_AC_galgasType), "a '@binaryset' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_binaryset::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_binaryset ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgas_binaryset'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_binaryset::
GGS_typeGalgas_binaryset (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_binaryset::
GGS_typeGalgas_binaryset (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_binaryset GGS_typeGalgas_binaryset::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_binaryset _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_binaryset *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_binaryset) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_binaryset (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_binaryset),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_binaryset * gSingleton_typeGalgas_binaryset = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_binaryset (void) {
  macroDetachPointer (gSingleton_typeGalgas_binaryset, cPtr_typeGalgas_binaryset) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_binaryset GGS_typeGalgas_binaryset::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_binaryset result ;
  if (NULL == gSingleton_typeGalgas_binaryset) {
    macroMyNew (gSingleton_typeGalgas_binaryset, cPtr_typeGalgas_binaryset (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_binaryset) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_binaryset) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_binaryset::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_binaryset *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_binaryset * p = (cPtr_typeGalgas_binaryset *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_binaryset::actualTypeName (void) const {
  return "typeGalgas_binaryset" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_binaryset ("typeGalgas_binaryset", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_galgasPrimitiveType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_galgasPrimitiveType::
cPtr_C_galgasPrimitiveType (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_galgasPrimitiveType * GGS_C_galgasPrimitiveType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_galgasPrimitiveType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_galgasPrimitiveType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_C_galgasPrimitiveType::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@C_galgasPrimitiveType:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType::
static_string_message_messageGalgasType (void) {
  return "any primitive type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType::
message_messageGalgasType (void) const {
  return "any primitive type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType::
_message (void) const {
  return "any primitive type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType::
_static_message (void) {
  return "any primitive type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_galgasPrimitiveType (& typeid (cPtr_C_galgasPrimitiveType), & typeid (cPtr_AC_galgasType), "any primitive type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_galgasPrimitiveType::galgasRTTI (void) const {
  return & gClassInfoFor__C_galgasPrimitiveType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_galgasPrimitiveType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_galgasPrimitiveType GGS_C_galgasPrimitiveType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_galgasPrimitiveType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_galgasPrimitiveType *> (inPointer) != NULL)
      : (typeid (cPtr_C_galgasPrimitiveType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_galgasPrimitiveType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_galgasPrimitiveType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_galgasPrimitiveType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_galgasPrimitiveType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_C_galgasPrimitiveType * p = (cPtr_C_galgasPrimitiveType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_galgasPrimitiveType::actualTypeName (void) const {
  return "C_galgasPrimitiveType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_galgasPrimitiveType ("C_galgasPrimitiveType", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgas_location'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_location::
cPtr_typeGalgas_location (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_location * GGS_typeGalgas_location::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_location *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_location *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_location::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "location") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
method_acceptAssignmentFromHere (C_Compiler & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_location:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_location::
static_string_message_messageGalgasType (void) {
  return "a '@location' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_location::
message_messageGalgasType (void) const {
  return "a '@location' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_location::
_message (void) const {
  return "a '@location' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_location::
_static_message (void) {
  return "a '@location' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_location (& typeid (cPtr_typeGalgas_location), & typeid (cPtr_C_galgasPrimitiveType), "a '@location' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_location::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_location ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_location'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_location::
GGS_typeGalgas_location (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_location::
GGS_typeGalgas_location (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_location GGS_typeGalgas_location::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_location _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_location *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_location) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_location (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_location),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_location * gSingleton_typeGalgas_location = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_location (void) {
  macroDetachPointer (gSingleton_typeGalgas_location, cPtr_typeGalgas_location) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_location GGS_typeGalgas_location::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_location result ;
  if (NULL == gSingleton_typeGalgas_location) {
    macroMyNew (gSingleton_typeGalgas_location, cPtr_typeGalgas_location (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_location) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_location) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_location::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_location *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_location * p = (cPtr_typeGalgas_location *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_location::actualTypeName (void) const {
  return "typeGalgas_location" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_location ("typeGalgas_location", gClassInfoFor__C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgas_lstring'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lstring::
cPtr_typeGalgas_lstring (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lstring * GGS_typeGalgas_lstring::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lstring *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lstring *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lstring::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "lstring") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1299)))._operator_isEqual (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1305)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1314)))._operator_isEqual (GGS_string (true, "setString"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1317)))._operator_isEqual (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1323)) ;
    var_cas_outModifierSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lstring:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lstring::
static_string_message_messageGalgasType (void) {
  return "a '@lstring' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lstring::
message_messageGalgasType (void) const {
  return "a '@lstring' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lstring::
_message (void) const {
  return "a '@lstring' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lstring::
_static_message (void) {
  return "a '@lstring' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_lstring (& typeid (cPtr_typeGalgas_lstring), & typeid (cPtr_C_galgasPrimitiveType), "a '@lstring' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_lstring::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_lstring ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_lstring'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_lstring::
GGS_typeGalgas_lstring (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lstring::
GGS_typeGalgas_lstring (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_lstring GGS_typeGalgas_lstring::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lstring _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_lstring *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_lstring) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_lstring (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_lstring),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_lstring * gSingleton_typeGalgas_lstring = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_lstring (void) {
  macroDetachPointer (gSingleton_typeGalgas_lstring, cPtr_typeGalgas_lstring) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lstring GGS_typeGalgas_lstring::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lstring result ;
  if (NULL == gSingleton_typeGalgas_lstring) {
    macroMyNew (gSingleton_typeGalgas_lstring, cPtr_typeGalgas_lstring (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_lstring) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_lstring) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lstring::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lstring *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_lstring * p = (cPtr_typeGalgas_lstring *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_lstring::actualTypeName (void) const {
  return "typeGalgas_lstring" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_lstring ("typeGalgas_lstring", gClassInfoFor__C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_lchar'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lchar::
cPtr_typeGalgas_lchar (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lchar * GGS_typeGalgas_lchar::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lchar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lchar *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lchar::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "lchar") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1349)))._operator_isEqual (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_char ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1357)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1366)))._operator_isEqual (GGS_string (true, "setChar"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_char ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1369)))._operator_isEqual (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1375)) ;
    var_cas_outModifierSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lchar:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lchar::
static_string_message_messageGalgasType (void) {
  return "a '@lchar' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lchar::
message_messageGalgasType (void) const {
  return "a '@lchar' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lchar::
_message (void) const {
  return "a '@lchar' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lchar::
_static_message (void) {
  return "a '@lchar' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_lchar (& typeid (cPtr_typeGalgas_lchar), & typeid (cPtr_C_galgasPrimitiveType), "a '@lchar' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_lchar::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_lchar ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lchar'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_lchar::
GGS_typeGalgas_lchar (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lchar::
GGS_typeGalgas_lchar (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_lchar GGS_typeGalgas_lchar::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lchar _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_lchar *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_lchar) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_lchar (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_lchar),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_lchar * gSingleton_typeGalgas_lchar = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_lchar (void) {
  macroDetachPointer (gSingleton_typeGalgas_lchar, cPtr_typeGalgas_lchar) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lchar GGS_typeGalgas_lchar::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lchar result ;
  if (NULL == gSingleton_typeGalgas_lchar) {
    macroMyNew (gSingleton_typeGalgas_lchar, cPtr_typeGalgas_lchar (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_lchar) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_lchar) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lchar::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lchar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_lchar * p = (cPtr_typeGalgas_lchar *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_lchar::actualTypeName (void) const {
  return "typeGalgas_lchar" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_lchar ("typeGalgas_lchar", gClassInfoFor__C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_lbool'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lbool::
cPtr_typeGalgas_lbool (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lbool * GGS_typeGalgas_lbool::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lbool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lbool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lbool::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "lbool") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1401)))._operator_isEqual (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1409)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1418)))._operator_isEqual (GGS_string (true, "setBool"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1421)))._operator_isEqual (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1427)) ;
    var_cas_outModifierSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lbool:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lbool::
static_string_message_messageGalgasType (void) {
  return "a '@lbool' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lbool::
message_messageGalgasType (void) const {
  return "a '@lbool' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lbool::
_message (void) const {
  return "a '@lbool' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lbool::
_static_message (void) {
  return "a '@lbool' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_lbool (& typeid (cPtr_typeGalgas_lbool), & typeid (cPtr_C_galgasPrimitiveType), "a '@lbool' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_lbool::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_lbool ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lbool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_lbool::
GGS_typeGalgas_lbool (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lbool::
GGS_typeGalgas_lbool (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_lbool GGS_typeGalgas_lbool::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lbool _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_lbool *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_lbool) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_lbool (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_lbool),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_lbool * gSingleton_typeGalgas_lbool = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_lbool (void) {
  macroDetachPointer (gSingleton_typeGalgas_lbool, cPtr_typeGalgas_lbool) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lbool GGS_typeGalgas_lbool::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lbool result ;
  if (NULL == gSingleton_typeGalgas_lbool) {
    macroMyNew (gSingleton_typeGalgas_lbool, cPtr_typeGalgas_lbool (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_lbool) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_lbool) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lbool::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lbool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_lbool * p = (cPtr_typeGalgas_lbool *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_lbool::actualTypeName (void) const {
  return "typeGalgas_lbool" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_lbool ("typeGalgas_lbool", gClassInfoFor__C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_luint'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_luint::
cPtr_typeGalgas_luint (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_luint * GGS_typeGalgas_luint::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_luint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_luint *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_luint::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "luint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1452)))._operator_isEqual (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1460)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1469)))._operator_isEqual (GGS_string (true, "setUint"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1472)))._operator_isEqual (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1478)) ;
    var_cas_outModifierSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_luint:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint::
static_string_message_messageGalgasType (void) {
  return "a '@luint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint::
message_messageGalgasType (void) const {
  return "a '@luint' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint::
_message (void) const {
  return "a '@luint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint::
_static_message (void) {
  return "a '@luint' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_luint (& typeid (cPtr_typeGalgas_luint), & typeid (cPtr_C_galgasPrimitiveType), "a '@luint' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_luint::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_luint ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_luint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_luint::
GGS_typeGalgas_luint (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint::
GGS_typeGalgas_luint (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_luint GGS_typeGalgas_luint::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_luint _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_luint *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_luint) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_luint (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_luint),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_luint * gSingleton_typeGalgas_luint = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_luint (void) {
  macroDetachPointer (gSingleton_typeGalgas_luint, cPtr_typeGalgas_luint) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint GGS_typeGalgas_luint::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_luint result ;
  if (NULL == gSingleton_typeGalgas_luint) {
    macroMyNew (gSingleton_typeGalgas_luint, cPtr_typeGalgas_luint (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_luint) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_luint) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_luint::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_luint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_luint * p = (cPtr_typeGalgas_luint *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_luint::actualTypeName (void) const {
  return "typeGalgas_luint" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_luint ("typeGalgas_luint", gClassInfoFor__C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgas_luint64'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_luint64::
cPtr_typeGalgas_luint64 (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_luint64 * GGS_typeGalgas_luint64::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_luint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_luint64 *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_luint64::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "luint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1503)))._operator_isEqual (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1511)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1520)))._operator_isEqual (GGS_string (true, "setUint64"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1523)))._operator_isEqual (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1529)) ;
    var_cas_outModifierSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_luint64:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint64::
static_string_message_messageGalgasType (void) {
  return "a '@luint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint64::
message_messageGalgasType (void) const {
  return "a '@luint64' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint64::
_message (void) const {
  return "a '@luint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint64::
_static_message (void) {
  return "a '@luint64' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_luint64 (& typeid (cPtr_typeGalgas_luint64), & typeid (cPtr_C_galgasPrimitiveType), "a '@luint64' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_luint64::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_luint64 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_luint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_luint64::
GGS_typeGalgas_luint64 (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint64::
GGS_typeGalgas_luint64 (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_luint64 GGS_typeGalgas_luint64::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_luint64 _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_luint64 *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_luint64) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_luint64 (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_luint64),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_luint64 * gSingleton_typeGalgas_luint64 = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_luint64 (void) {
  macroDetachPointer (gSingleton_typeGalgas_luint64, cPtr_typeGalgas_luint64) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint64 GGS_typeGalgas_luint64::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_luint64 result ;
  if (NULL == gSingleton_typeGalgas_luint64) {
    macroMyNew (gSingleton_typeGalgas_luint64, cPtr_typeGalgas_luint64 (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_luint64) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_luint64) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_luint64::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_luint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_luint64 * p = (cPtr_typeGalgas_luint64 *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_luint64::actualTypeName (void) const {
  return "typeGalgas_luint64" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_luint64 ("typeGalgas_luint64", gClassInfoFor__C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgas_lsint'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lsint::
cPtr_typeGalgas_lsint (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lsint * GGS_typeGalgas_lsint::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lsint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lsint *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lsint::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "lsint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1554)))._operator_isEqual (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_sint ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1562)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1571)))._operator_isEqual (GGS_string (true, "setSint"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_sint ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1574)))._operator_isEqual (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1580)) ;
    var_cas_outModifierSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lsint:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint::
static_string_message_messageGalgasType (void) {
  return "a '@lsint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint::
message_messageGalgasType (void) const {
  return "a '@lsint' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint::
_message (void) const {
  return "a '@lsint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint::
_static_message (void) {
  return "a '@lsint' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_lsint (& typeid (cPtr_typeGalgas_lsint), & typeid (cPtr_C_galgasPrimitiveType), "a '@lsint' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_lsint::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_lsint ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lsint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint::
GGS_typeGalgas_lsint (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint::
GGS_typeGalgas_lsint (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_lsint GGS_typeGalgas_lsint::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lsint _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_lsint *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_lsint) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_lsint (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_lsint),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_lsint * gSingleton_typeGalgas_lsint = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_lsint (void) {
  macroDetachPointer (gSingleton_typeGalgas_lsint, cPtr_typeGalgas_lsint) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint GGS_typeGalgas_lsint::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lsint result ;
  if (NULL == gSingleton_typeGalgas_lsint) {
    macroMyNew (gSingleton_typeGalgas_lsint, cPtr_typeGalgas_lsint (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_lsint) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_lsint) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lsint::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lsint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_lsint * p = (cPtr_typeGalgas_lsint *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_lsint::actualTypeName (void) const {
  return "typeGalgas_lsint" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_lsint ("typeGalgas_lsint", gClassInfoFor__C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgas_lsint64'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lsint64::
cPtr_typeGalgas_lsint64 (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lsint64 * GGS_typeGalgas_lsint64::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lsint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lsint64 *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lsint64::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "lsint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1605)))._operator_isEqual (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_sint64 ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1613)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1622)))._operator_isEqual (GGS_string (true, "setSint64"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_sint64 ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1625)))._operator_isEqual (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1631)) ;
    var_cas_outModifierSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lsint64:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint64::
static_string_message_messageGalgasType (void) {
  return "a '@lsint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint64::
message_messageGalgasType (void) const {
  return "a '@lsint64' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint64::
_message (void) const {
  return "a '@lsint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint64::
_static_message (void) {
  return "a '@lsint64' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_lsint64 (& typeid (cPtr_typeGalgas_lsint64), & typeid (cPtr_C_galgasPrimitiveType), "a '@lsint64' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_lsint64::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_lsint64 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_lsint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint64::
GGS_typeGalgas_lsint64 (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint64::
GGS_typeGalgas_lsint64 (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_lsint64 GGS_typeGalgas_lsint64::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lsint64 _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_lsint64 *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_lsint64) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_lsint64 (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_lsint64),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_lsint64 * gSingleton_typeGalgas_lsint64 = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_lsint64 (void) {
  macroDetachPointer (gSingleton_typeGalgas_lsint64, cPtr_typeGalgas_lsint64) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint64 GGS_typeGalgas_lsint64::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_lsint64 result ;
  if (NULL == gSingleton_typeGalgas_lsint64) {
    macroMyNew (gSingleton_typeGalgas_lsint64, cPtr_typeGalgas_lsint64 (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_lsint64) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_lsint64) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lsint64::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lsint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_lsint64 * p = (cPtr_typeGalgas_lsint64 *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_lsint64::actualTypeName (void) const {
  return "typeGalgas_lsint64" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_lsint64 ("typeGalgas_lsint64", gClassInfoFor__C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgas_ldouble'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_ldouble::
cPtr_typeGalgas_ldouble (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_ldouble * GGS_typeGalgas_ldouble::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_ldouble *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_ldouble *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_ldouble::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "ldouble") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1656)))._operator_isEqual (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_double ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1664)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1673)))._operator_isEqual (GGS_string (true, "setDouble"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_double ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1676)))._operator_isEqual (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") COMMA_SOURCE_FILE_AT_LINE (1682)) ;
    var_cas_outModifierSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Compiler & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_ldouble:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_ldouble::
static_string_message_messageGalgasType (void) {
  return "a '@ldouble' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_ldouble::
message_messageGalgasType (void) const {
  return "a '@ldouble' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_ldouble::
_message (void) const {
  return "a '@ldouble' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_ldouble::
_static_message (void) {
  return "a '@ldouble' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_ldouble (& typeid (cPtr_typeGalgas_ldouble), & typeid (cPtr_C_galgasPrimitiveType), "a '@ldouble' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_ldouble::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_ldouble ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_ldouble'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_ldouble::
GGS_typeGalgas_ldouble (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_ldouble::
GGS_typeGalgas_ldouble (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_ldouble GGS_typeGalgas_ldouble::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_ldouble _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_ldouble *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_ldouble) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_ldouble (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_ldouble),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_ldouble * gSingleton_typeGalgas_ldouble = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_ldouble (void) {
  macroDetachPointer (gSingleton_typeGalgas_ldouble, cPtr_typeGalgas_ldouble) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_ldouble GGS_typeGalgas_ldouble::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_ldouble result ;
  if (NULL == gSingleton_typeGalgas_ldouble) {
    macroMyNew (gSingleton_typeGalgas_ldouble, cPtr_typeGalgas_ldouble (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_ldouble) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_ldouble) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_ldouble::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_ldouble *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_ldouble * p = (cPtr_typeGalgas_ldouble *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_ldouble::actualTypeName (void) const {
  return "typeGalgas_ldouble" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_ldouble ("typeGalgas_ldouble", gClassInfoFor__C_galgasPrimitiveType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeGalgas_stringset'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_stringset::
cPtr_typeGalgas_stringset (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_stringset * GGS_typeGalgas_stringset::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_stringset *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_stringset *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_stringset::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "stringset") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, false) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1711)))._operator_isEqual (GGS_string (true, "emptySet"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1713)))._operator_isEqual (GGS_string (true, "setWithString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (1719)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_handleAddAssignOperatorCall (C_Compiler & _inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outParametersList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_outParametersList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_handleMinusAssignOperatorCall (C_Compiler & _inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outParametersList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  GGS_AC_galgasType  var_cas_t ;
  var_cas_t = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_outParametersList._addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_acceptForeachInstruction (C_Compiler & _inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle,
                                GGS_bool& var_cas_outNewStyle COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outNewStyle = GGS_bool (true, true) ;
  var_cas_outForeachList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_outForeachList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "key"), GGS_location (_inLexique) COMMA_HERE)) ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (_inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_stringset:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_stringset::
static_string_message_messageGalgasType (void) {
  return "a '@stringset' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_stringset::
message_messageGalgasType (void) const {
  return "a '@stringset' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_stringset::
_message (void) const {
  return "a '@stringset' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_stringset::
_static_message (void) {
  return "a '@stringset' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_stringset (& typeid (cPtr_typeGalgas_stringset), & typeid (cPtr_AC_galgasType), "a '@stringset' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_stringset::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_stringset ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgas_stringset'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_stringset::
GGS_typeGalgas_stringset (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_stringset::
GGS_typeGalgas_stringset (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_stringset GGS_typeGalgas_stringset::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_stringset _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_stringset *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_stringset) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_stringset (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_stringset),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_stringset * gSingleton_typeGalgas_stringset = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_stringset (void) {
  macroDetachPointer (gSingleton_typeGalgas_stringset, cPtr_typeGalgas_stringset) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_stringset GGS_typeGalgas_stringset::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_stringset result ;
  if (NULL == gSingleton_typeGalgas_stringset) {
    macroMyNew (gSingleton_typeGalgas_stringset, cPtr_typeGalgas_stringset (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_stringset) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_stringset) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_stringset::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_stringset *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_stringset * p = (cPtr_typeGalgas_stringset *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_stringset::actualTypeName (void) const {
  return "typeGalgas_stringset" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_stringset ("typeGalgas_stringset", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeGalgas_filewrapper'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_filewrapper::
cPtr_typeGalgas_filewrapper (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_filewrapper * GGS_typeGalgas_filewrapper::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_filewrapper *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_filewrapper *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_filewrapper::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_filewrapper::
method_getTypeName (C_Compiler & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = GGS_string (true, "filewrapper") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_filewrapper::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1780)))._operator_isEqual (GGS_string (true, "setCurrentDirectory"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this modifier is not defined") COMMA_SOURCE_FILE_AT_LINE (1786)) ;
    var_cas_outModifierSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_filewrapper::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_filewrapper:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_filewrapper::
static_string_message_messageGalgasType (void) {
  return "a '@filewrapper' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_filewrapper::
message_messageGalgasType (void) const {
  return "a '@filewrapper' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_filewrapper::
_message (void) const {
  return "a '@filewrapper' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_filewrapper::
_static_message (void) {
  return "a '@filewrapper' type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_filewrapper (& typeid (cPtr_typeGalgas_filewrapper), & typeid (cPtr_AC_galgasType), "a '@filewrapper' type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_filewrapper::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_filewrapper ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeGalgas_filewrapper'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_filewrapper::
GGS_typeGalgas_filewrapper (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_filewrapper::
GGS_typeGalgas_filewrapper (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_filewrapper GGS_typeGalgas_filewrapper::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_filewrapper _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_filewrapper *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_filewrapper) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_filewrapper (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_filewrapper),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeGalgas_filewrapper * gSingleton_typeGalgas_filewrapper = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeGalgas_filewrapper (void) {
  macroDetachPointer (gSingleton_typeGalgas_filewrapper, cPtr_typeGalgas_filewrapper) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_filewrapper GGS_typeGalgas_filewrapper::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_filewrapper result ;
  if (NULL == gSingleton_typeGalgas_filewrapper) {
    macroMyNew (gSingleton_typeGalgas_filewrapper, cPtr_typeGalgas_filewrapper (THERE)) ;
    registerReleaseRoutine (cleanUp_typeGalgas_filewrapper) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeGalgas_filewrapper) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_filewrapper::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_filewrapper *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_filewrapper * p = (cPtr_typeGalgas_filewrapper *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_filewrapper::actualTypeName (void) const {
  return "typeGalgas_filewrapper" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_filewrapper ("typeGalgas_filewrapper", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_typeTableMethodes'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableMethodes::e_typeTableMethodes (void) :
aListeTypesParametres () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@typeTableMethodes'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableMethodes::
elementOf_GGS_typeTableMethodes (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableMethodes & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableMethodes::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aListeTypesParametres.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableMethodes::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableMethodes * _p = dynamic_cast <const elementOf_GGS_typeTableMethodes *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aListeTypesParametres._operator_isEqual (_p->mInfo.aListeTypesParametres)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableMethodes::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableMethodes *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableMethodes * info = (e_typeTableMethodes *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableMethodes *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableMethodes * info = (e_typeTableMethodes *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodes result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableMethodes info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMethodes::
_operator_isEqual (const GGS_typeTableMethodes & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMethodes::
_operator_isNotEqual (const GGS_typeTableMethodes & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableMethodes info  ;
    info.aListeTypesParametres = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeTypesParametres ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
modifier_setAListeTypesParametresForKey (C_Compiler & inLexique,
                        const GGS_L_EXsignature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setAListeTypesParametresForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.aListeTypesParametres = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no method named '%K'",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a method named '%K' is already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableMethodes & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodes result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMethodes::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableMethodes " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_typeTableMethodes::cEnumerator::_aListeTypesParametres (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aListeTypesParametres ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeGalgasUndefinedExternType'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedExternType::
cPtr_typeGalgasUndefinedExternType (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mGalgasClassName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedExternType * GGS_typeGalgasUndefinedExternType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedExternType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedExternType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedExternType * _p = dynamic_cast <const cPtr_typeGalgasUndefinedExternType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mGalgasClassName._operator_isEqual (_p->mGalgasClassName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedExternType::
method_getTypeName (C_Compiler & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mGalgasClassName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1818)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedExternType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedExternType:"
           << mGalgasClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedExternType::
static_string_message_messageGalgasType (void) {
  return "an undefined extern type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedExternType::
message_messageGalgasType (void) const {
  return "an undefined extern type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedExternType::
_message (void) const {
  return "an undefined extern type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedExternType::
_static_message (void) {
  return "an undefined extern type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasUndefinedExternType (& typeid (cPtr_typeGalgasUndefinedExternType), & typeid (cPtr_AC_galgasType), "an undefined extern type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasUndefinedExternType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasUndefinedExternType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedExternType'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedExternType::
GGS_typeGalgasUndefinedExternType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedExternType::
GGS_typeGalgasUndefinedExternType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasUndefinedExternType GGS_typeGalgasUndefinedExternType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedExternType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasUndefinedExternType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasUndefinedExternType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasUndefinedExternType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedExternType GGS_typeGalgasUndefinedExternType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedExternType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasUndefinedExternType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedExternType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasUndefinedExternType * p = (cPtr_typeGalgasUndefinedExternType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasUndefinedExternType::
reader_mGalgasClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasUndefinedExternType *) mPointer)->mGalgasClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasUndefinedExternType::actualTypeName (void) const {
  return "typeGalgasUndefinedExternType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasUndefinedExternType ("typeGalgasUndefinedExternType", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'e_M_externTypeConstructorMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_externTypeConstructorMap::e_M_externTypeConstructorMap (void) :
aListeDesAttributs () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map '@M_externTypeConstructorMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_externTypeConstructorMap::
elementOf_GGS_M_externTypeConstructorMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_externTypeConstructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_externTypeConstructorMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aListeDesAttributs.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_externTypeConstructorMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_externTypeConstructorMap * _p = dynamic_cast <const elementOf_GGS_M_externTypeConstructorMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aListeDesAttributs._operator_isEqual (_p->mInfo.aListeDesAttributs)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_externTypeConstructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_externTypeConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_externTypeConstructorMap * info = (e_M_externTypeConstructorMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_externTypeConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_externTypeConstructorMap * info = (e_M_externTypeConstructorMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_externTypeConstructorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_externTypeConstructorMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_externTypeConstructorMap::
_operator_isEqual (const GGS_M_externTypeConstructorMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_externTypeConstructorMap::
_operator_isNotEqual (const GGS_M_externTypeConstructorMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeListeAttributsSemantiques & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_externTypeConstructorMap info  ;
    info.aListeDesAttributs = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDesAttributs ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
modifier_setAListeDesAttributsForKey (C_Compiler & inLexique,
                        const GGS_typeListeAttributsSemantiques & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setAListeDesAttributsForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.aListeDesAttributs = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' constructor is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' constructor is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_externTypeConstructorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_externTypeConstructorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_externTypeConstructorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_externTypeConstructorMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_externTypeConstructorMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeAttributsSemantiques  & GGS_M_externTypeConstructorMap::cEnumerator::_aListeDesAttributs (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aListeDesAttributs ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeGalgasExternType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasExternType::
cPtr_typeGalgasExternType (const GGS_lstring & argument_0,
                                const GGS_M_externTypeConstructorMap & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_bool& argument_4,
                                const GGS_typeListeAttributsSemantiques & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedExternType (argument_0 COMMA_THERE),
mConstructorMap (argument_1),
mModifiersMap (argument_2),
mReadersInInstructionMap (argument_3),
mAcceptAddAssignOperatorCall (argument_4),
mAddAssignOperatorCallTypeList (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasExternType * GGS_typeGalgasExternType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasExternType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasExternType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasExternType * _p = dynamic_cast <const cPtr_typeGalgasExternType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mGalgasClassName._operator_isEqual (_p->mGalgasClassName).boolValue ()
         && mConstructorMap._operator_isEqual (_p->mConstructorMap).boolValue ()
         && mModifiersMap._operator_isEqual (_p->mModifiersMap).boolValue ()
         && mReadersInInstructionMap._operator_isEqual (_p->mReadersInInstructionMap).boolValue ()
         && mAcceptAddAssignOperatorCall._operator_isEqual (_p->mAcceptAddAssignOperatorCall).boolValue ()
         && mAddAssignOperatorCallTypeList._operator_isEqual (_p->mAddAssignOperatorCallTypeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  const GGS_M_externTypeConstructorMap  _temp_79164 = mConstructorMap ;
  if (_temp_79164._isBuilt ()) {
    _temp_79164 (HERE)->method_searchKey (_inLexique, var_cas_inClassMethodName, var_cas_outAccessorTypesList COMMA_SOURCE_FILE_AT_LINE (1865)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_typeTableMethodes  _temp_79419 = mModifiersMap ;
  if (_temp_79419._isBuilt ()) {
    _temp_79419 (HERE)->method_searchKey (_inLexique, var_cas_inModifierName, var_cas_outModifierSignature COMMA_SOURCE_FILE_AT_LINE (1873)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleMethodInstructionCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outReaderSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string (true, "") ;
  const GGS_typeTableMethodes  _temp_79838 = mReadersInInstructionMap ;
  if (_temp_79838._isBuilt ()) {
    _temp_79838 (HERE)->method_searchKey (_inLexique, var_cas_inReaderName, var_cas_outReaderSignature COMMA_SOURCE_FILE_AT_LINE (1884)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleAddAssignOperatorCall (C_Compiler & _inLexique,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  method_handleAddAssignOperatorCall (_inLexique, var_cas_inErrorLocation, var_cas_outParametersList COMMA_SOURCE_FILE_AT_LINE (1892)) ;
  if (((mAcceptAddAssignOperatorCall)._operator_not ()).isBuiltAndTrue ()) {
    inherited::method_handleAddAssignOperatorCall (_inLexique, var_cas_inErrorLocation, var_cas_outParametersList COMMA_SOURCE_FILE_AT_LINE (1894)) ;
  }else{
    var_cas_outParametersList = mAddAssignOperatorCallTypeList ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasExternType:"
           << mGalgasClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstructorMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModifiersMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReadersInInstructionMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAcceptAddAssignOperatorCall.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAddAssignOperatorCallTypeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasExternType::
static_string_message_messageGalgasType (void) {
  return "an extern type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasExternType::
message_messageGalgasType (void) const {
  return "an extern type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasExternType::
_message (void) const {
  return "an extern type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasExternType::
_static_message (void) {
  return "an extern type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasExternType (& typeid (cPtr_typeGalgasExternType), & typeid (cPtr_typeGalgasUndefinedExternType), "an extern type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasExternType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasExternType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgasExternType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasExternType::
GGS_typeGalgasExternType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasExternType::
GGS_typeGalgasExternType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasExternType GGS_typeGalgasExternType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasExternType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasExternType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasExternType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasExternType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasExternType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasExternType GGS_typeGalgasExternType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_M_externTypeConstructorMap & argument_1,
                 const GGS_typeTableMethodes & argument_2,
                 const GGS_typeTableMethodes & argument_3,
                 const GGS_bool& argument_4,
                 const GGS_typeListeAttributsSemantiques & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasExternType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasExternType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasExternType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasExternType * p = (cPtr_typeGalgasExternType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap  GGS_typeGalgasExternType::
reader_mConstructorMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_externTypeConstructorMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasExternType *) mPointer)->mConstructorMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes  GGS_typeGalgasExternType::
reader_mModifiersMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasExternType *) mPointer)->mModifiersMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes  GGS_typeGalgasExternType::
reader_mReadersInInstructionMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasExternType *) mPointer)->mReadersInInstructionMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasExternType::
reader_mAcceptAddAssignOperatorCall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasExternType *) mPointer)->mAcceptAddAssignOperatorCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasExternType::
reader_mAddAssignOperatorCallTypeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasExternType *) mPointer)->mAddAssignOperatorCallTypeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasExternType::actualTypeName (void) const {
  return "typeGalgasExternType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasExternType ("typeGalgasExternType", gClassInfoFor__typeGalgasUndefinedExternType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'e_M_terminalSymbolsMapForUse'                    *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_terminalSymbolsMapForUse::e_M_terminalSymbolsMapForUse (void) :
aListeDesAttributs () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map '@M_terminalSymbolsMapForUse'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_terminalSymbolsMapForUse::
elementOf_GGS_M_terminalSymbolsMapForUse (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_terminalSymbolsMapForUse & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_terminalSymbolsMapForUse::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aListeDesAttributs.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_terminalSymbolsMapForUse::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_terminalSymbolsMapForUse * _p = dynamic_cast <const elementOf_GGS_M_terminalSymbolsMapForUse *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aListeDesAttributs._operator_isEqual (_p->mInfo.aListeDesAttributs)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_terminalSymbolsMapForUse::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_terminalSymbolsMapForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_terminalSymbolsMapForUse * info = (e_M_terminalSymbolsMapForUse *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_terminalSymbolsMapForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_terminalSymbolsMapForUse * info = (e_M_terminalSymbolsMapForUse *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_terminalSymbolsMapForUse result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_terminalSymbolsMapForUse info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_terminalSymbolsMapForUse::
_operator_isEqual (const GGS_M_terminalSymbolsMapForUse & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_terminalSymbolsMapForUse::
_operator_isNotEqual (const GGS_M_terminalSymbolsMapForUse & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeListeAttributsSemantiques & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_terminalSymbolsMapForUse info  ;
    info.aListeDesAttributs = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDesAttributs ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
modifier_setAListeDesAttributsForKey (C_Compiler & inLexique,
                        const GGS_typeListeAttributsSemantiques & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setAListeDesAttributsForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.aListeDesAttributs = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the terminal symbol '$%K$' is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
method_searchKeyGetID (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_typeListeAttributsSemantiques   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the terminal symbol '$%K$' is not declared",
                  inKey,
                  outParameter0,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the terminal symbol '$%K$' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_terminalSymbolsMapForUse & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_terminalSymbolsMapForUse result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_terminalSymbolsMapForUse result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_terminalSymbolsMapForUse::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_terminalSymbolsMapForUse " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeAttributsSemantiques  & GGS_M_terminalSymbolsMapForUse::cEnumerator::_aListeDesAttributs (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aListeDesAttributs ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_M_lexiqueComponents'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_lexiqueComponents::e_M_lexiqueComponents (void) :
mTerminalSymbolMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@M_lexiqueComponents'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_lexiqueComponents::
elementOf_GGS_M_lexiqueComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_lexiqueComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_lexiqueComponents::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mTerminalSymbolMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_lexiqueComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_lexiqueComponents * _p = dynamic_cast <const elementOf_GGS_M_lexiqueComponents *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mTerminalSymbolMap._operator_isEqual (_p->mInfo.mTerminalSymbolMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_lexiqueComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_lexiqueComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_lexiqueComponents * info = (e_M_lexiqueComponents *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_lexiqueComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_lexiqueComponents * info = (e_M_lexiqueComponents *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_lexiqueComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_lexiqueComponents info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_lexiqueComponents::
_operator_isEqual (const GGS_M_lexiqueComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_lexiqueComponents::
_operator_isNotEqual (const GGS_M_lexiqueComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_terminalSymbolsMapForUse & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_lexiqueComponents info  ;
    info.mTerminalSymbolMap = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_terminalSymbolsMapForUse   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mTerminalSymbolMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
modifier_setMTerminalSymbolMapForKey (C_Compiler & inLexique,
                        const GGS_M_terminalSymbolsMapForUse & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMTerminalSymbolMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mTerminalSymbolMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_terminalSymbolsMapForUse   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' lexique is not defined",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_terminalSymbolsMapForUse & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' lexique is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_lexiqueComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_lexiqueComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_lexiqueComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_lexiqueComponents::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_lexiqueComponents " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_terminalSymbolsMapForUse  & GGS_M_lexiqueComponents::cEnumerator::_mTerminalSymbolMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTerminalSymbolMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_typeTableEnAvant'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableEnAvant::e_typeTableEnAvant (void) :
mType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@typeTableEnAvant'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableEnAvant::
elementOf_GGS_typeTableEnAvant (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableEnAvant & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableEnAvant::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableEnAvant::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableEnAvant * _p = dynamic_cast <const elementOf_GGS_typeTableEnAvant *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mType._operator_isEqual (_p->mInfo.mType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableEnAvant::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableEnAvant *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableEnAvant * info = (e_typeTableEnAvant *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableEnAvant *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableEnAvant * info = (e_typeTableEnAvant *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableEnAvant result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableEnAvant info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableEnAvant::
_operator_isEqual (const GGS_typeTableEnAvant & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableEnAvant::
_operator_isNotEqual (const GGS_typeTableEnAvant & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_galgasType & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableEnAvant info  ;
    info.mType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
modifier_setMTypeForKey (C_Compiler & inLexique,
                        const GGS_AC_galgasType & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMTypeForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mType = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the type '%K' is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the type '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableEnAvant & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableEnAvant result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableEnAvant result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableEnAvant::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableEnAvant " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeTableEnAvant::cEnumerator::_mType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'e_M_nonterminalSymbolAlts'                      *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_nonterminalSymbolAlts::e_M_nonterminalSymbolAlts (void) :
mFormalParametersList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@M_nonterminalSymbolAlts'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonterminalSymbolAlts::
elementOf_GGS_M_nonterminalSymbolAlts (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonterminalSymbolAlts & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonterminalSymbolAlts::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mFormalParametersList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_nonterminalSymbolAlts::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_nonterminalSymbolAlts * _p = dynamic_cast <const elementOf_GGS_M_nonterminalSymbolAlts *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mFormalParametersList._operator_isEqual (_p->mInfo.mFormalParametersList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonterminalSymbolAlts::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonterminalSymbolAlts *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonterminalSymbolAlts * info = (e_M_nonterminalSymbolAlts *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_nonterminalSymbolAlts *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_nonterminalSymbolAlts * info = (e_M_nonterminalSymbolAlts *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAlts result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_nonterminalSymbolAlts info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonterminalSymbolAlts::
_operator_isEqual (const GGS_M_nonterminalSymbolAlts & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonterminalSymbolAlts::
_operator_isNotEqual (const GGS_M_nonterminalSymbolAlts & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_nonterminalSymbolAlts info  ;
    info.mFormalParametersList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalParametersList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
modifier_setMFormalParametersListForKey (C_Compiler & inLexique,
                        const GGS_L_EXsignature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMFormalParametersListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mFormalParametersList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the label '%K' is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the label '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_nonterminalSymbolAlts & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAlts result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonterminalSymbolAlts result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonterminalSymbolAlts::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_nonterminalSymbolAlts " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_M_nonterminalSymbolAlts::cEnumerator::_mFormalParametersList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFormalParametersList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_AC_semanticsEntity'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_semanticsEntity::
cPtr_AC_semanticsEntity (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_semanticsEntity * GGS_AC_semanticsEntity::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_semanticsEntity *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_AC_semanticsEntity *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_semanticsEntity::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_semanticsEntity:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity::
static_string_message_messageTypeEntite (void) {
  return "any entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity::
message_messageTypeEntite (void) const {
  return "any entity" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity::
_message (void) const {
  return "any entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity::
_static_message (void) {
  return "any entity" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_semanticsEntity (& typeid (cPtr_AC_semanticsEntity), NULL
, "any entity") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_AC_semanticsEntity::galgasRTTI (void) const {
  return & gClassInfoFor__AC_semanticsEntity ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_AC_semanticsEntity'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_AC_semanticsEntity GGS_AC_semanticsEntity::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_semanticsEntity _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_semanticsEntity *> (inPointer) != NULL)
      : (typeid (cPtr_AC_semanticsEntity) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_AC_semanticsEntity (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_semanticsEntity),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_semanticsEntity::
reader_messageTypeEntite (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_semanticsEntity *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_AC_semanticsEntity * p = (cPtr_AC_semanticsEntity *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_semanticsEntity::actualTypeName (void) const {
  return "AC_semanticsEntity" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_AC_semanticsEntity::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__AC_semanticsEntity ("AC_semanticsEntity") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_grammarForSemantics'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarForSemantics::
cPtr_C_grammarForSemantics (const GGS_M_nonterminalSymbolAlts & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
mGrammarAltMap (argument_0),
mLexiqueClassName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_grammarForSemantics * GGS_C_grammarForSemantics::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarForSemantics *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_grammarForSemantics *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_grammarForSemantics::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_grammarForSemantics * _p = dynamic_cast <const cPtr_C_grammarForSemantics *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mGrammarAltMap._operator_isEqual (_p->mGrammarAltMap).boolValue ()
         && mLexiqueClassName._operator_isEqual (_p->mLexiqueClassName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_grammarForSemantics::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_grammarForSemantics:"
           << mGrammarAltMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLexiqueClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_grammarForSemantics::
static_string_message_messageTypeEntite (void) {
  return "a grammar entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_grammarForSemantics::
message_messageTypeEntite (void) const {
  return "a grammar entity" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_grammarForSemantics::
_message (void) const {
  return "a grammar entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_grammarForSemantics::
_static_message (void) {
  return "a grammar entity" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_grammarForSemantics (& typeid (cPtr_C_grammarForSemantics), & typeid (cPtr_AC_semanticsEntity), "a grammar entity") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_grammarForSemantics::galgasRTTI (void) const {
  return & gClassInfoFor__C_grammarForSemantics ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarForSemantics'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_grammarForSemantics::
GGS_C_grammarForSemantics (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarForSemantics::
GGS_C_grammarForSemantics (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_grammarForSemantics GGS_C_grammarForSemantics::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_grammarForSemantics _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_grammarForSemantics *> (inPointer) != NULL)
      : (typeid (cPtr_C_grammarForSemantics) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_grammarForSemantics (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_grammarForSemantics),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarForSemantics GGS_C_grammarForSemantics::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_M_nonterminalSymbolAlts & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_grammarForSemantics result ;
  macroMyNew (result.mPointer, cPtr_C_grammarForSemantics (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_grammarForSemantics::
reader_messageTypeEntite (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarForSemantics *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_C_grammarForSemantics * p = (cPtr_C_grammarForSemantics *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts  GGS_C_grammarForSemantics::
reader_mGrammarAltMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonterminalSymbolAlts   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarForSemantics *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarForSemantics *) mPointer)->mGrammarAltMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarForSemantics::
reader_mLexiqueClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarForSemantics *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarForSemantics *) mPointer)->mLexiqueClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_grammarForSemantics::actualTypeName (void) const {
  return "C_grammarForSemantics" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_grammarForSemantics ("C_grammarForSemantics", gClassInfoFor__AC_semanticsEntity) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'e_M_semanticsEntitiesForUse'                     *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_semanticsEntitiesForUse::e_M_semanticsEntitiesForUse (void) :
aDefEntite () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map '@M_semanticsEntitiesForUse'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_semanticsEntitiesForUse::
elementOf_GGS_M_semanticsEntitiesForUse (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_semanticsEntitiesForUse & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_semanticsEntitiesForUse::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aDefEntite.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_semanticsEntitiesForUse::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_semanticsEntitiesForUse * _p = dynamic_cast <const elementOf_GGS_M_semanticsEntitiesForUse *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aDefEntite._operator_isEqual (_p->mInfo.aDefEntite)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_semanticsEntitiesForUse::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_semanticsEntitiesForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_semanticsEntitiesForUse * info = (e_M_semanticsEntitiesForUse *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_semanticsEntitiesForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_semanticsEntitiesForUse * info = (e_M_semanticsEntitiesForUse *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsEntitiesForUse result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_semanticsEntitiesForUse info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_semanticsEntitiesForUse::
_operator_isEqual (const GGS_M_semanticsEntitiesForUse & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_semanticsEntitiesForUse::
_operator_isNotEqual (const GGS_M_semanticsEntitiesForUse & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_semanticsEntity & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_semanticsEntitiesForUse info  ;
    info.aDefEntite = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_semanticsEntity   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.aDefEntite ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
modifier_setADefEntiteForKey (C_Compiler & inLexique,
                        const GGS_AC_semanticsEntity & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setADefEntiteForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.aDefEntite = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_semanticsEntity   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no semantics entity named '%K'",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_semanticsEntity & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a semantics entity named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_semanticsEntitiesForUse & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsEntitiesForUse result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_semanticsEntitiesForUse result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_semanticsEntitiesForUse::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_semanticsEntitiesForUse " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_semanticsEntity  & GGS_M_semanticsEntitiesForUse::cEnumerator::_aDefEntite (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aDefEntite ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_AC_typeForGrammarComponent'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_typeForGrammarComponent::
cPtr_AC_typeForGrammarComponent (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_typeForGrammarComponent * GGS_AC_typeForGrammarComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_typeForGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_AC_typeForGrammarComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_typeForGrammarComponent::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_typeForGrammarComponent:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent::
static_string_message_typeForGrammarComponentMessage (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent::
message_typeForGrammarComponentMessage (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_typeForGrammarComponent (& typeid (cPtr_AC_typeForGrammarComponent), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_AC_typeForGrammarComponent::galgasRTTI (void) const {
  return & gClassInfoFor__AC_typeForGrammarComponent ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_AC_typeForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_AC_typeForGrammarComponent GGS_AC_typeForGrammarComponent::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_typeForGrammarComponent _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_typeForGrammarComponent *> (inPointer) != NULL)
      : (typeid (cPtr_AC_typeForGrammarComponent) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_AC_typeForGrammarComponent (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_typeForGrammarComponent),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_typeForGrammarComponent::
reader_typeForGrammarComponentMessage (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_typeForGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_AC_typeForGrammarComponent * p = (cPtr_AC_typeForGrammarComponent *) mPointer ;
    result = GGS_string (true, p->message_typeForGrammarComponentMessage ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_typeForGrammarComponent::actualTypeName (void) const {
  return "AC_typeForGrammarComponent" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_AC_typeForGrammarComponent::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__AC_typeForGrammarComponent ("AC_typeForGrammarComponent") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'e_M_typesForGrammarComponent'                    *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_typesForGrammarComponent::e_M_typesForGrammarComponent (void) :
mType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map '@M_typesForGrammarComponent'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_typesForGrammarComponent::
elementOf_GGS_M_typesForGrammarComponent (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_typesForGrammarComponent & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_typesForGrammarComponent::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_typesForGrammarComponent::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_typesForGrammarComponent * _p = dynamic_cast <const elementOf_GGS_M_typesForGrammarComponent *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mType._operator_isEqual (_p->mInfo.mType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_typesForGrammarComponent::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_typesForGrammarComponent *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_typesForGrammarComponent * info = (e_M_typesForGrammarComponent *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_typesForGrammarComponent *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_typesForGrammarComponent * info = (e_M_typesForGrammarComponent *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_typesForGrammarComponent result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_typesForGrammarComponent info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_typesForGrammarComponent::
_operator_isEqual (const GGS_M_typesForGrammarComponent & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_typesForGrammarComponent::
_operator_isNotEqual (const GGS_M_typesForGrammarComponent & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_typeForGrammarComponent & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_typesForGrammarComponent info  ;
    info.mType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_typeForGrammarComponent   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
modifier_setMTypeForKey (C_Compiler & inLexique,
                        const GGS_AC_typeForGrammarComponent & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMTypeForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mType = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_typeForGrammarComponent   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '@%K' type is not defined",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_typeForGrammarComponent & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '@%K' type is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_typesForGrammarComponent & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_typesForGrammarComponent result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_typesForGrammarComponent result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_typesForGrammarComponent::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_typesForGrammarComponent " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_typeForGrammarComponent  & GGS_M_typesForGrammarComponent::cEnumerator::_mType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "checkSignature_ForGrammarComponent"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkSignature_ForGrammarComponent (C_Compiler & _inLexique,
                                const GGS_L_signature   var_cas_inFormalReferenceSignature,
                                const GGS_L_signature   var_cas_inFormalTestedSignature,
                                const GGS_location   var_cas_inFormalTestedLocation,
                                const GGS_location   var_cas_inFormalReferenceLocation COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkSignature_ForGrammarComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (((var_cas_inFormalReferenceSignature.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (2017)))._operator_strictInf (var_cas_inFormalTestedSignature.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (2017)))).isBuiltAndTrue ()) {
    var_cas_inFormalTestedLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "too much formal parameters (from prototype in "))._operator_concat (var_cas_inFormalReferenceLocation.reader_locationString (_inLexique COMMA_SOURCE_FILE_AT_LINE (2018))))._operator_concat (GGS_string (true, ")")) COMMA_SOURCE_FILE_AT_LINE (2019)) ;
  }else if (((var_cas_inFormalReferenceSignature.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (2019)))._operator_strictSup (var_cas_inFormalTestedSignature.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (2019)))).isBuiltAndTrue ()) {
    var_cas_inFormalTestedLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "too much formal parameters (from prototype in "))._operator_concat (var_cas_inFormalReferenceLocation.reader_locationString (_inLexique COMMA_SOURCE_FILE_AT_LINE (2020))))._operator_concat (GGS_string (true, ")")) COMMA_SOURCE_FILE_AT_LINE (2021)) ;
  }else{
    {
      GGS_L_signature::cEnumerator enumerator_86300 (var_cas_inFormalReferenceSignature, true) ;
      const GGS_L_signature::cElement * operand_86300 = NULL ;
      GGS_L_signature::cEnumerator enumerator_86397 (var_cas_inFormalTestedSignature, true) ;
      const GGS_L_signature::cElement * operand_86397 = NULL ;
      while (((operand_86300 = enumerator_86300.nextObject ()))
          && ((operand_86397 = enumerator_86397.nextObject ()))) {
        macroValidPointer (operand_86300) ;
        macroValidPointer (operand_86397) ;
        if (((operand_86300->mFormalArgumentPassingMode)._operator_isNotEqual (operand_86397->mFormalArgumentPassingMode)).isBuiltAndTrue ()) {
          operand_86397->mGalgasTypeName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "Prototype has "))._operator_concat (operand_86300->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique COMMA_SOURCE_FILE_AT_LINE (2025))))._operator_concat (GGS_string (true, ", and ")))._operator_concat (operand_86300->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique COMMA_SOURCE_FILE_AT_LINE (2026))))._operator_concat (GGS_string (true, " has been found")) COMMA_SOURCE_FILE_AT_LINE (2027)) ;
        }
        if (((operand_86300->mGalgasTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2028)))._operator_isNotEqual (operand_86397->mGalgasTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2028)))).isBuiltAndTrue ()) {
          operand_86397->mGalgasTypeName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "I was expecting the '@"))._operator_concat (operand_86300->mGalgasTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2029))))._operator_concat (GGS_string (true, "' type, I have got the '@")))._operator_concat (operand_86397->mGalgasTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2029))))._operator_concat (GGS_string (true, "' type")) COMMA_SOURCE_FILE_AT_LINE (2030)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkSignature_ForGrammarComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_AC_instruction_ForGrammar'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_instruction_ForGrammar::
cPtr_AC_instruction_ForGrammar (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mStartLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_instruction_ForGrammar * GGS_AC_instruction_ForGrammar::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_instruction_ForGrammar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_AC_instruction_ForGrammar *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_instruction_ForGrammar::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@AC_instruction_ForGrammar:"
           << mStartLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_instruction_ForGrammar::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_instruction_ForGrammar::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_instruction_ForGrammar (& typeid (cPtr_AC_instruction_ForGrammar), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_AC_instruction_ForGrammar::galgasRTTI (void) const {
  return & gClassInfoFor__AC_instruction_ForGrammar ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_AC_instruction_ForGrammar'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_AC_instruction_ForGrammar GGS_AC_instruction_ForGrammar::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_instruction_ForGrammar _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_instruction_ForGrammar *> (inPointer) != NULL)
      : (typeid (cPtr_AC_instruction_ForGrammar) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_AC_instruction_ForGrammar (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_instruction_ForGrammar),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_AC_instruction_ForGrammar::
reader_mStartLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_instruction_ForGrammar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_AC_instruction_ForGrammar *) mPointer)->mStartLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_instruction_ForGrammar::actualTypeName (void) const {
  return "AC_instruction_ForGrammar" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_AC_instruction_ForGrammar::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__AC_instruction_ForGrammar ("AC_instruction_ForGrammar") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@L_ruleSyntaxSignature'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_ruleSyntaxSignature::
elementOf_GGS_L_ruleSyntaxSignature (const GGS_AC_instruction_ForGrammar & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_ruleSyntaxSignature::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_ruleSyntaxSignature * _p = dynamic_cast <const elementOf_GGS_L_ruleSyntaxSignature *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_ruleSyntaxSignature::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@L_ruleSyntaxSignature'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
_internalAppendValues (const GGS_AC_instruction_ForGrammar & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
_internalPrependValues (const GGS_AC_instruction_ForGrammar & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
_addAssign_operation (const GGS_AC_instruction_ForGrammar & argument_0) {
  if (_isBuilt ()&& argument_0._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature GGS_L_ruleSyntaxSignature::
_operator_concat (const GGS_L_ruleSyntaxSignature & inOperand) const {
  GGS_L_ruleSyntaxSignature result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
_dotAssign_operation (const GGS_L_ruleSyntaxSignature inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_L_ruleSyntaxSignature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_instruction_ForGrammar  p_0 = p->mInstruction ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_instruction_ForGrammar & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature  GGS_L_ruleSyntaxSignature::
constructor_emptyList (void) {
  GGS_L_ruleSyntaxSignature result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature  GGS_L_ruleSyntaxSignature::
constructor_listWithValue (const GGS_AC_instruction_ForGrammar & argument_0) {
  GGS_L_ruleSyntaxSignature result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
internalSubListWithRange (GGS_L_ruleSyntaxSignature & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature GGS_L_ruleSyntaxSignature::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_ruleSyntaxSignature result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature GGS_L_ruleSyntaxSignature::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_ruleSyntaxSignature result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_ruleSyntaxSignature::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_ruleSyntaxSignature", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
method_first (C_Compiler & _inLexique,
              GGS_AC_instruction_ForGrammar & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
method_last (C_Compiler & _inLexique,
             GGS_AC_instruction_ForGrammar & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_AC_instruction_ForGrammar & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
modifier_popLast (C_Compiler & _inLexique,
                GGS_AC_instruction_ForGrammar & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar  GGS_L_ruleSyntaxSignature::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_instruction_ForGrammar  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_AC_instruction_ForGrammar  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_instruction_ForGrammar  & GGS_L_ruleSyntaxSignature::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_L_grammarsMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_L_grammarsMap::e_L_grammarsMap (void) :
mStartSymbolParametersMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@L_grammarsMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_grammarsMap::
elementOf_GGS_L_grammarsMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_L_grammarsMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_grammarsMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mStartSymbolParametersMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_grammarsMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_L_grammarsMap * _p = dynamic_cast <const elementOf_GGS_L_grammarsMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mStartSymbolParametersMap._operator_isEqual (_p->mInfo.mStartSymbolParametersMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_L_grammarsMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_L_grammarsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_L_grammarsMap * info = (e_L_grammarsMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_L_grammarsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_L_grammarsMap * info = (e_L_grammarsMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_grammarsMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_L_grammarsMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_grammarsMap::
_operator_isEqual (const GGS_L_grammarsMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_grammarsMap::
_operator_isNotEqual (const GGS_L_grammarsMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_nonterminalSymbolAlts & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_L_grammarsMap info  ;
    info.mStartSymbolParametersMap = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAlts   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mStartSymbolParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
modifier_setMStartSymbolParametersMapForKey (C_Compiler & inLexique,
                        const GGS_M_nonterminalSymbolAlts & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMStartSymbolParametersMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mStartSymbolParametersMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' grammar is not defined",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' grammar is already defined in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_L_grammarsMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_grammarsMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_grammarsMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_grammarsMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @L_grammarsMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_nonterminalSymbolAlts  & GGS_L_grammarsMap::cEnumerator::_mStartSymbolParametersMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mStartSymbolParametersMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'e_M_nonterminalSymbolAltsForGrammar'                 *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_nonterminalSymbolAltsForGrammar::e_M_nonterminalSymbolAltsForGrammar (void) :
mFormalParametersList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class map '@M_nonterminalSymbolAltsForGrammar'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonterminalSymbolAltsForGrammar::
elementOf_GGS_M_nonterminalSymbolAltsForGrammar (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonterminalSymbolAltsForGrammar & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonterminalSymbolAltsForGrammar::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mFormalParametersList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_nonterminalSymbolAltsForGrammar::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_nonterminalSymbolAltsForGrammar * _p = dynamic_cast <const elementOf_GGS_M_nonterminalSymbolAltsForGrammar *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mFormalParametersList._operator_isEqual (_p->mInfo.mFormalParametersList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonterminalSymbolAltsForGrammar::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonterminalSymbolAltsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonterminalSymbolAltsForGrammar * info = (e_M_nonterminalSymbolAltsForGrammar *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_nonterminalSymbolAltsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_nonterminalSymbolAltsForGrammar * info = (e_M_nonterminalSymbolAltsForGrammar *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAltsForGrammar GGS_M_nonterminalSymbolAltsForGrammar::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAltsForGrammar result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_nonterminalSymbolAltsForGrammar info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonterminalSymbolAltsForGrammar::
_operator_isEqual (const GGS_M_nonterminalSymbolAltsForGrammar & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonterminalSymbolAltsForGrammar::
_operator_isNotEqual (const GGS_M_nonterminalSymbolAltsForGrammar & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_signature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_nonterminalSymbolAltsForGrammar info  ;
    info.mFormalParametersList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalParametersList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
modifier_setMFormalParametersListForKey (C_Compiler & inLexique,
                        const GGS_L_signature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMFormalParametersListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mFormalParametersList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the rule label '%K' is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the rule label '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAltsForGrammar GGS_M_nonterminalSymbolAltsForGrammar::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_nonterminalSymbolAltsForGrammar & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAltsForGrammar result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAltsForGrammar GGS_M_nonterminalSymbolAltsForGrammar::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonterminalSymbolAltsForGrammar result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonterminalSymbolAltsForGrammar::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_nonterminalSymbolAltsForGrammar " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_signature  & GGS_M_nonterminalSymbolAltsForGrammar::cEnumerator::_mFormalParametersList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFormalParametersList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@L_productionRules_ForGrammarComponent'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_productionRules_ForGrammarComponent::
elementOf_GGS_L_productionRules_ForGrammarComponent (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLeftNonterminalSymbol (argument_0),
mLeftNonterminalSymbolIndex (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_productionRules_ForGrammarComponent::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_productionRules_ForGrammarComponent * _p = dynamic_cast <const elementOf_GGS_L_productionRules_ForGrammarComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLeftNonterminalSymbol._operator_isEqual (_p->mLeftNonterminalSymbol).boolValue ()
         && mLeftNonterminalSymbolIndex._operator_isEqual (_p->mLeftNonterminalSymbolIndex).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_productionRules_ForGrammarComponent::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftNonterminalSymbol.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftNonterminalSymbolIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@L_productionRules_ForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1,
                    const GGS_L_ruleSyntaxSignature & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1,
                    const GGS_L_ruleSyntaxSignature & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent GGS_L_productionRules_ForGrammarComponent::
_operator_concat (const GGS_L_productionRules_ForGrammarComponent & inOperand) const {
  GGS_L_productionRules_ForGrammarComponent result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
_dotAssign_operation (const GGS_L_productionRules_ForGrammarComponent inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_L_productionRules_ForGrammarComponent * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLeftNonterminalSymbol ;
          GGS_uint  p_1 = p->mLeftNonterminalSymbolIndex ;
          GGS_L_ruleSyntaxSignature  p_2 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_uint & argument_1,
                     const GGS_L_ruleSyntaxSignature & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLeftNonterminalSymbol,
                                _p->mLeftNonterminalSymbolIndex,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent  GGS_L_productionRules_ForGrammarComponent::
constructor_emptyList (void) {
  GGS_L_productionRules_ForGrammarComponent result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent  GGS_L_productionRules_ForGrammarComponent::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) {
  GGS_L_productionRules_ForGrammarComponent result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
internalSubListWithRange (GGS_L_productionRules_ForGrammarComponent & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mLeftNonterminalSymbol, _p->mLeftNonterminalSymbolIndex, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent GGS_L_productionRules_ForGrammarComponent::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_productionRules_ForGrammarComponent result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent GGS_L_productionRules_ForGrammarComponent::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_productionRules_ForGrammarComponent result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_productionRules_ForGrammarComponent::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_productionRules_ForGrammarComponent", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_uint & _out_1,
              GGS_L_ruleSyntaxSignature & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftNonterminalSymbol ;
    _out_1 = _p->mLeftNonterminalSymbolIndex ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_uint & _out_1,
             GGS_L_ruleSyntaxSignature & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftNonterminalSymbol ;
    _out_1 = _p->mLeftNonterminalSymbolIndex ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_uint & _out_1,
                 GGS_L_ruleSyntaxSignature & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftNonterminalSymbol ;
    _out_1 = _p->mLeftNonterminalSymbolIndex ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_uint & _out_1,
                GGS_L_ruleSyntaxSignature & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftNonterminalSymbol ;
    _out_1 = _p->mLeftNonterminalSymbolIndex ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_productionRules_ForGrammarComponent::
reader_mLeftNonterminalSymbolAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLeftNonterminalSymbol ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_L_productionRules_ForGrammarComponent::
reader_mLeftNonterminalSymbolIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLeftNonterminalSymbolIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature  GGS_L_productionRules_ForGrammarComponent::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_L_ruleSyntaxSignature  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
modifier_setMLeftNonterminalSymbolAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLeftNonterminalSymbol = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
modifier_setMLeftNonterminalSymbolIndexAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLeftNonterminalSymbolIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_L_ruleSyntaxSignature  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_L_productionRules_ForGrammarComponent::cEnumerator::_mLeftNonterminalSymbol (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mLeftNonterminalSymbol ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_L_productionRules_ForGrammarComponent::cEnumerator::_mLeftNonterminalSymbolIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mLeftNonterminalSymbolIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_ruleSyntaxSignature  & GGS_L_productionRules_ForGrammarComponent::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'e_M_nonTerminalSymbolsForGrammar'                  *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_nonTerminalSymbolsForGrammar::e_M_nonTerminalSymbolsForGrammar (void) :
mNonterminalSymbolParametersMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class map '@M_nonTerminalSymbolsForGrammar'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonTerminalSymbolsForGrammar::
elementOf_GGS_M_nonTerminalSymbolsForGrammar (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonTerminalSymbolsForGrammar & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonTerminalSymbolsForGrammar::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mNonterminalSymbolParametersMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_nonTerminalSymbolsForGrammar::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_nonTerminalSymbolsForGrammar * _p = dynamic_cast <const elementOf_GGS_M_nonTerminalSymbolsForGrammar *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mNonterminalSymbolParametersMap._operator_isEqual (_p->mInfo.mNonterminalSymbolParametersMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonTerminalSymbolsForGrammar::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonTerminalSymbolsForGrammar * info = (e_M_nonTerminalSymbolsForGrammar *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_nonTerminalSymbolsForGrammar * info = (e_M_nonTerminalSymbolsForGrammar *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolsForGrammar GGS_M_nonTerminalSymbolsForGrammar::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolsForGrammar result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_nonTerminalSymbolsForGrammar info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonTerminalSymbolsForGrammar::
_operator_isEqual (const GGS_M_nonTerminalSymbolsForGrammar & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonTerminalSymbolsForGrammar::
_operator_isNotEqual (const GGS_M_nonTerminalSymbolsForGrammar & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_nonTerminalSymbolsForGrammar info  ;
    info.mNonterminalSymbolParametersMap = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
modifier_setMNonterminalSymbolParametersMapForKey (C_Compiler & inLexique,
                        const GGS_M_nonterminalSymbolAltsForGrammar & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMNonterminalSymbolParametersMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mNonterminalSymbolParametersMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '<%K>' non terminal symbol is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
method_searchKeyGetID (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '<%K>' non terminal symbol is not declared",
                  inKey,
                  outParameter0,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '<%K>' non terminal symbol has already been declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolsForGrammar GGS_M_nonTerminalSymbolsForGrammar::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_nonTerminalSymbolsForGrammar & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolsForGrammar result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolsForGrammar GGS_M_nonTerminalSymbolsForGrammar::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonTerminalSymbolsForGrammar result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonTerminalSymbolsForGrammar::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_nonTerminalSymbolsForGrammar " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_nonterminalSymbolAltsForGrammar  & GGS_M_nonTerminalSymbolsForGrammar::cEnumerator::_mNonterminalSymbolParametersMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mNonterminalSymbolParametersMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'e_M_unusedNonTerminalSymbolsForGrammar'               *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_unusedNonTerminalSymbolsForGrammar::e_M_unusedNonTerminalSymbolsForGrammar (void) :
mSymbolIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class map '@M_unusedNonTerminalSymbolsForGrammar'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_unusedNonTerminalSymbolsForGrammar::
elementOf_GGS_M_unusedNonTerminalSymbolsForGrammar (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_unusedNonTerminalSymbolsForGrammar & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_unusedNonTerminalSymbolsForGrammar::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSymbolIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_unusedNonTerminalSymbolsForGrammar::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_unusedNonTerminalSymbolsForGrammar * _p = dynamic_cast <const elementOf_GGS_M_unusedNonTerminalSymbolsForGrammar *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mSymbolIndex._operator_isEqual (_p->mInfo.mSymbolIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_unusedNonTerminalSymbolsForGrammar::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_unusedNonTerminalSymbolsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_unusedNonTerminalSymbolsForGrammar * info = (e_M_unusedNonTerminalSymbolsForGrammar *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_unusedNonTerminalSymbolsForGrammar::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_unusedNonTerminalSymbolsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_unusedNonTerminalSymbolsForGrammar * info = (e_M_unusedNonTerminalSymbolsForGrammar *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_unusedNonTerminalSymbolsForGrammar GGS_M_unusedNonTerminalSymbolsForGrammar::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_unusedNonTerminalSymbolsForGrammar result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_unusedNonTerminalSymbolsForGrammar::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_unusedNonTerminalSymbolsForGrammar info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_unusedNonTerminalSymbolsForGrammar::
_operator_isEqual (const GGS_M_unusedNonTerminalSymbolsForGrammar & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_unusedNonTerminalSymbolsForGrammar::
_operator_isNotEqual (const GGS_M_unusedNonTerminalSymbolsForGrammar & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_unusedNonTerminalSymbolsForGrammar::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_unusedNonTerminalSymbolsForGrammar::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_luint & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_unusedNonTerminalSymbolsForGrammar info  ;
    info.mSymbolIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_unusedNonTerminalSymbolsForGrammar::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mSymbolIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_unusedNonTerminalSymbolsForGrammar::
modifier_setMSymbolIndexForKey (C_Compiler & inLexique,
                        const GGS_luint & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMSymbolIndexForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mSymbolIndex = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_unusedNonTerminalSymbolsForGrammar::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '<%K>' non terminal symbol has already been declared as unused",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_unusedNonTerminalSymbolsForGrammar GGS_M_unusedNonTerminalSymbolsForGrammar::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_unusedNonTerminalSymbolsForGrammar & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_unusedNonTerminalSymbolsForGrammar result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_unusedNonTerminalSymbolsForGrammar GGS_M_unusedNonTerminalSymbolsForGrammar::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_unusedNonTerminalSymbolsForGrammar result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_unusedNonTerminalSymbolsForGrammar::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_unusedNonTerminalSymbolsForGrammar " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_unusedNonTerminalSymbolsForGrammar::cEnumerator::_mSymbolIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSymbolIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_M_syntaxComponents'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_syntaxComponents::e_M_syntaxComponents (void) :
mNonterminalSymbolsMap (),
mProductionRulesList (),
mLexiqueComponentName () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@M_syntaxComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_syntaxComponents::
elementOf_GGS_M_syntaxComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_syntaxComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_syntaxComponents::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mNonterminalSymbolsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mProductionRulesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mLexiqueComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_syntaxComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_syntaxComponents * _p = dynamic_cast <const elementOf_GGS_M_syntaxComponents *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mNonterminalSymbolsMap._operator_isEqual (_p->mInfo.mNonterminalSymbolsMap)).boolValue ()
           && (mInfo.mProductionRulesList._operator_isEqual (_p->mInfo.mProductionRulesList)).boolValue ()
           && (mInfo.mLexiqueComponentName._operator_isEqual (_p->mInfo.mLexiqueComponentName)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_syntaxComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_syntaxComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_syntaxComponents * info = (e_M_syntaxComponents *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_syntaxComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_syntaxComponents * info = (e_M_syntaxComponents *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_syntaxComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_syntaxComponents info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_syntaxComponents::
_operator_isEqual (const GGS_M_syntaxComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_syntaxComponents::
_operator_isNotEqual (const GGS_M_syntaxComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_nonTerminalSymbolsForGrammar & inParameter0,
                const GGS_L_productionRules_ForGrammarComponent & inParameter1,
                const GGS_lstring & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_syntaxComponents info  ;
    info.mNonterminalSymbolsMap = inParameter0 ;
    info.mProductionRulesList = inParameter1 ;
    info.mLexiqueComponentName = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonTerminalSymbolsForGrammar   & outParameter0,
               GGS_L_productionRules_ForGrammarComponent   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    outParameter2._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolsMap ;
    outParameter1 = node->mInfo.mProductionRulesList ;
    outParameter2 = node->mInfo.mLexiqueComponentName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
modifier_setMNonterminalSymbolsMapForKey (C_Compiler & inLexique,
                        const GGS_M_nonTerminalSymbolsForGrammar & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMNonterminalSymbolsMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mNonterminalSymbolsMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
modifier_setMProductionRulesListForKey (C_Compiler & inLexique,
                        const GGS_L_productionRules_ForGrammarComponent & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMProductionRulesListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mProductionRulesList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
modifier_setMLexiqueComponentNameForKey (C_Compiler & inLexique,
                        const GGS_lstring & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMLexiqueComponentNameForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mLexiqueComponentName = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonTerminalSymbolsForGrammar   & outParameter0,
                                GGS_L_productionRules_ForGrammarComponent   & outParameter1,
                                GGS_lstring   & outParameter2 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no syntax component named '%K'",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonTerminalSymbolsForGrammar & inParameter0,
                                const GGS_L_productionRules_ForGrammarComponent & inParameter1,
                                const GGS_lstring & inParameter2 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a syntax component named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_syntaxComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_syntaxComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_syntaxComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_syntaxComponents::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_syntaxComponents " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_nonTerminalSymbolsForGrammar  & GGS_M_syntaxComponents::cEnumerator::_mNonterminalSymbolsMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mNonterminalSymbolsMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_productionRules_ForGrammarComponent  & GGS_M_syntaxComponents::cEnumerator::_mProductionRulesList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mProductionRulesList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_M_syntaxComponents::cEnumerator::_mLexiqueComponentName (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mLexiqueComponentName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'cPtr_T_terminalInstruction_forGrammarComponent'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_terminalInstruction_forGrammarComponent::
cPtr_T_terminalInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mTerminalSymbolName (argument_1),
mTerminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_T_terminalInstruction_forGrammarComponent * GGS_T_terminalInstruction_forGrammarComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_terminalInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_T_terminalInstruction_forGrammarComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_T_terminalInstruction_forGrammarComponent::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_T_terminalInstruction_forGrammarComponent * _p = dynamic_cast <const cPtr_T_terminalInstruction_forGrammarComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mStartLocation._operator_isEqual (_p->mStartLocation).boolValue ()
         && mTerminalSymbolName._operator_isEqual (_p->mTerminalSymbolName).boolValue ()
         && mTerminalSymbolIndex._operator_isEqual (_p->mTerminalSymbolIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_T_terminalInstruction_forGrammarComponent::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@T_terminalInstruction_forGrammarComponent:"
           << mStartLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTerminalSymbolName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTerminalSymbolIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_T_terminalInstruction_forGrammarComponent::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_T_terminalInstruction_forGrammarComponent::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_T_terminalInstruction_forGrammarComponent (& typeid (cPtr_T_terminalInstruction_forGrammarComponent), & typeid (cPtr_AC_instruction_ForGrammar), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_T_terminalInstruction_forGrammarComponent::galgasRTTI (void) const {
  return & gClassInfoFor__T_terminalInstruction_forGrammarComponent ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_T_terminalInstruction_forGrammarComponent'        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_T_terminalInstruction_forGrammarComponent::
GGS_T_terminalInstruction_forGrammarComponent (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_T_terminalInstruction_forGrammarComponent::
GGS_T_terminalInstruction_forGrammarComponent (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_T_terminalInstruction_forGrammarComponent GGS_T_terminalInstruction_forGrammarComponent::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_T_terminalInstruction_forGrammarComponent _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_T_terminalInstruction_forGrammarComponent *> (inPointer) != NULL)
      : (typeid (cPtr_T_terminalInstruction_forGrammarComponent) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_T_terminalInstruction_forGrammarComponent (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_T_terminalInstruction_forGrammarComponent),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_T_terminalInstruction_forGrammarComponent GGS_T_terminalInstruction_forGrammarComponent::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_T_terminalInstruction_forGrammarComponent result ;
  macroMyNew (result.mPointer, cPtr_T_terminalInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_T_terminalInstruction_forGrammarComponent::
reader_mTerminalSymbolName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_terminalInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_terminalInstruction_forGrammarComponent *) mPointer)->mTerminalSymbolName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_T_terminalInstruction_forGrammarComponent::
reader_mTerminalSymbolIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_terminalInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_terminalInstruction_forGrammarComponent *) mPointer)->mTerminalSymbolIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_T_terminalInstruction_forGrammarComponent::actualTypeName (void) const {
  return "T_terminalInstruction_forGrammarComponent" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__T_terminalInstruction_forGrammarComponent ("T_terminalInstruction_forGrammarComponent", gClassInfoFor__AC_instruction_ForGrammar) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        class 'cPtr_T_nonterminalInstruction_forGrammarComponent'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_nonterminalInstruction_forGrammarComponent::
cPtr_T_nonterminalInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mNonterminalSymbolName (argument_1),
mNonterminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_T_nonterminalInstruction_forGrammarComponent * GGS_T_nonterminalInstruction_forGrammarComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_nonterminalInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_T_nonterminalInstruction_forGrammarComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_T_nonterminalInstruction_forGrammarComponent::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_T_nonterminalInstruction_forGrammarComponent * _p = dynamic_cast <const cPtr_T_nonterminalInstruction_forGrammarComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mStartLocation._operator_isEqual (_p->mStartLocation).boolValue ()
         && mNonterminalSymbolName._operator_isEqual (_p->mNonterminalSymbolName).boolValue ()
         && mNonterminalSymbolIndex._operator_isEqual (_p->mNonterminalSymbolIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_T_nonterminalInstruction_forGrammarComponent::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@T_nonterminalInstruction_forGrammarComponent:"
           << mStartLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonterminalSymbolName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonterminalSymbolIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_T_nonterminalInstruction_forGrammarComponent::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_T_nonterminalInstruction_forGrammarComponent::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_T_nonterminalInstruction_forGrammarComponent (& typeid (cPtr_T_nonterminalInstruction_forGrammarComponent), & typeid (cPtr_AC_instruction_ForGrammar), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_T_nonterminalInstruction_forGrammarComponent::galgasRTTI (void) const {
  return & gClassInfoFor__T_nonterminalInstruction_forGrammarComponent ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_T_nonterminalInstruction_forGrammarComponent'       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_T_nonterminalInstruction_forGrammarComponent::
GGS_T_nonterminalInstruction_forGrammarComponent (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_T_nonterminalInstruction_forGrammarComponent::
GGS_T_nonterminalInstruction_forGrammarComponent (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_T_nonterminalInstruction_forGrammarComponent GGS_T_nonterminalInstruction_forGrammarComponent::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_T_nonterminalInstruction_forGrammarComponent _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_T_nonterminalInstruction_forGrammarComponent *> (inPointer) != NULL)
      : (typeid (cPtr_T_nonterminalInstruction_forGrammarComponent) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_T_nonterminalInstruction_forGrammarComponent (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_T_nonterminalInstruction_forGrammarComponent),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_T_nonterminalInstruction_forGrammarComponent GGS_T_nonterminalInstruction_forGrammarComponent::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_T_nonterminalInstruction_forGrammarComponent result ;
  macroMyNew (result.mPointer, cPtr_T_nonterminalInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_T_nonterminalInstruction_forGrammarComponent::
reader_mNonterminalSymbolName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_nonterminalInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_nonterminalInstruction_forGrammarComponent *) mPointer)->mNonterminalSymbolName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_T_nonterminalInstruction_forGrammarComponent::
reader_mNonterminalSymbolIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_nonterminalInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_nonterminalInstruction_forGrammarComponent *) mPointer)->mNonterminalSymbolIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_T_nonterminalInstruction_forGrammarComponent::actualTypeName (void) const {
  return "T_nonterminalInstruction_forGrammarComponent" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__T_nonterminalInstruction_forGrammarComponent ("T_nonterminalInstruction_forGrammarComponent", gClassInfoFor__AC_instruction_ForGrammar) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@L_branchList_ForGrammarComponent'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_branchList_ForGrammarComponent::
elementOf_GGS_L_branchList_ForGrammarComponent (const GGS_L_ruleSyntaxSignature & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_branchList_ForGrammarComponent::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_branchList_ForGrammarComponent * _p = dynamic_cast <const elementOf_GGS_L_branchList_ForGrammarComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_branchList_ForGrammarComponent::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@L_branchList_ForGrammarComponent'                  *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
_internalAppendValues (const GGS_L_ruleSyntaxSignature & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
_internalPrependValues (const GGS_L_ruleSyntaxSignature & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
_addAssign_operation (const GGS_L_ruleSyntaxSignature & argument_0) {
  if (_isBuilt ()&& argument_0._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent GGS_L_branchList_ForGrammarComponent::
_operator_concat (const GGS_L_branchList_ForGrammarComponent & inOperand) const {
  GGS_L_branchList_ForGrammarComponent result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
_dotAssign_operation (const GGS_L_branchList_ForGrammarComponent inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_L_branchList_ForGrammarComponent * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_L_ruleSyntaxSignature  p_0 = p->mInstructionList ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_L_ruleSyntaxSignature & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent  GGS_L_branchList_ForGrammarComponent::
constructor_emptyList (void) {
  GGS_L_branchList_ForGrammarComponent result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent  GGS_L_branchList_ForGrammarComponent::
constructor_listWithValue (const GGS_L_ruleSyntaxSignature & argument_0) {
  GGS_L_branchList_ForGrammarComponent result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
internalSubListWithRange (GGS_L_branchList_ForGrammarComponent & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent GGS_L_branchList_ForGrammarComponent::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_branchList_ForGrammarComponent result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent GGS_L_branchList_ForGrammarComponent::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_branchList_ForGrammarComponent result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_branchList_ForGrammarComponent::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_branchList_ForGrammarComponent", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
method_first (C_Compiler & _inLexique,
              GGS_L_ruleSyntaxSignature & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
method_last (C_Compiler & _inLexique,
             GGS_L_ruleSyntaxSignature & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_L_ruleSyntaxSignature & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
modifier_popLast (C_Compiler & _inLexique,
                GGS_L_ruleSyntaxSignature & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature  GGS_L_branchList_ForGrammarComponent::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_L_ruleSyntaxSignature  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_L_ruleSyntaxSignature  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_ruleSyntaxSignature  & GGS_L_branchList_ForGrammarComponent::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_T_selectInstruction_forGrammarComponent'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_selectInstruction_forGrammarComponent::
cPtr_T_selectInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mSelectList (argument_1),
mAddedNonterminalmSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_T_selectInstruction_forGrammarComponent * GGS_T_selectInstruction_forGrammarComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_selectInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_T_selectInstruction_forGrammarComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_T_selectInstruction_forGrammarComponent::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_T_selectInstruction_forGrammarComponent * _p = dynamic_cast <const cPtr_T_selectInstruction_forGrammarComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mStartLocation._operator_isEqual (_p->mStartLocation).boolValue ()
         && mSelectList._operator_isEqual (_p->mSelectList).boolValue ()
         && mAddedNonterminalmSymbolIndex._operator_isEqual (_p->mAddedNonterminalmSymbolIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_T_selectInstruction_forGrammarComponent::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@T_selectInstruction_forGrammarComponent:"
           << mStartLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSelectList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAddedNonterminalmSymbolIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_T_selectInstruction_forGrammarComponent::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_T_selectInstruction_forGrammarComponent::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_T_selectInstruction_forGrammarComponent (& typeid (cPtr_T_selectInstruction_forGrammarComponent), & typeid (cPtr_AC_instruction_ForGrammar), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_T_selectInstruction_forGrammarComponent::galgasRTTI (void) const {
  return & gClassInfoFor__T_selectInstruction_forGrammarComponent ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_T_selectInstruction_forGrammarComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_T_selectInstruction_forGrammarComponent::
GGS_T_selectInstruction_forGrammarComponent (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_T_selectInstruction_forGrammarComponent::
GGS_T_selectInstruction_forGrammarComponent (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_T_selectInstruction_forGrammarComponent GGS_T_selectInstruction_forGrammarComponent::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_T_selectInstruction_forGrammarComponent _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_T_selectInstruction_forGrammarComponent *> (inPointer) != NULL)
      : (typeid (cPtr_T_selectInstruction_forGrammarComponent) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_T_selectInstruction_forGrammarComponent (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_T_selectInstruction_forGrammarComponent),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_T_selectInstruction_forGrammarComponent GGS_T_selectInstruction_forGrammarComponent::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_L_branchList_ForGrammarComponent & argument_1,
                 const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_T_selectInstruction_forGrammarComponent result ;
  macroMyNew (result.mPointer, cPtr_T_selectInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent  GGS_T_selectInstruction_forGrammarComponent::
reader_mSelectList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_branchList_ForGrammarComponent   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_selectInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_selectInstruction_forGrammarComponent *) mPointer)->mSelectList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_T_selectInstruction_forGrammarComponent::
reader_mAddedNonterminalmSymbolIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_selectInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_selectInstruction_forGrammarComponent *) mPointer)->mAddedNonterminalmSymbolIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_T_selectInstruction_forGrammarComponent::actualTypeName (void) const {
  return "T_selectInstruction_forGrammarComponent" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__T_selectInstruction_forGrammarComponent ("T_selectInstruction_forGrammarComponent", gClassInfoFor__AC_instruction_ForGrammar) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_T_repeatInstruction_forGrammarComponent'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_repeatInstruction_forGrammarComponent::
cPtr_T_repeatInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mRepeatList (argument_1),
mAddedNonterminalmSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_T_repeatInstruction_forGrammarComponent * GGS_T_repeatInstruction_forGrammarComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_repeatInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_T_repeatInstruction_forGrammarComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_T_repeatInstruction_forGrammarComponent::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_T_repeatInstruction_forGrammarComponent * _p = dynamic_cast <const cPtr_T_repeatInstruction_forGrammarComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mStartLocation._operator_isEqual (_p->mStartLocation).boolValue ()
         && mRepeatList._operator_isEqual (_p->mRepeatList).boolValue ()
         && mAddedNonterminalmSymbolIndex._operator_isEqual (_p->mAddedNonterminalmSymbolIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_T_repeatInstruction_forGrammarComponent::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@T_repeatInstruction_forGrammarComponent:"
           << mStartLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRepeatList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAddedNonterminalmSymbolIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_T_repeatInstruction_forGrammarComponent::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_T_repeatInstruction_forGrammarComponent::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_T_repeatInstruction_forGrammarComponent (& typeid (cPtr_T_repeatInstruction_forGrammarComponent), & typeid (cPtr_AC_instruction_ForGrammar), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_T_repeatInstruction_forGrammarComponent::galgasRTTI (void) const {
  return & gClassInfoFor__T_repeatInstruction_forGrammarComponent ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_T_repeatInstruction_forGrammarComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_T_repeatInstruction_forGrammarComponent::
GGS_T_repeatInstruction_forGrammarComponent (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_T_repeatInstruction_forGrammarComponent::
GGS_T_repeatInstruction_forGrammarComponent (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_T_repeatInstruction_forGrammarComponent GGS_T_repeatInstruction_forGrammarComponent::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_T_repeatInstruction_forGrammarComponent _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_T_repeatInstruction_forGrammarComponent *> (inPointer) != NULL)
      : (typeid (cPtr_T_repeatInstruction_forGrammarComponent) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_T_repeatInstruction_forGrammarComponent (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_T_repeatInstruction_forGrammarComponent),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_T_repeatInstruction_forGrammarComponent GGS_T_repeatInstruction_forGrammarComponent::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_L_branchList_ForGrammarComponent & argument_1,
                 const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_T_repeatInstruction_forGrammarComponent result ;
  macroMyNew (result.mPointer, cPtr_T_repeatInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent  GGS_T_repeatInstruction_forGrammarComponent::
reader_mRepeatList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_branchList_ForGrammarComponent   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_repeatInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_repeatInstruction_forGrammarComponent *) mPointer)->mRepeatList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_T_repeatInstruction_forGrammarComponent::
reader_mAddedNonterminalmSymbolIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_repeatInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_repeatInstruction_forGrammarComponent *) mPointer)->mAddedNonterminalmSymbolIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_T_repeatInstruction_forGrammarComponent::actualTypeName (void) const {
  return "T_repeatInstruction_forGrammarComponent" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__T_repeatInstruction_forGrammarComponent ("T_repeatInstruction_forGrammarComponent", gClassInfoFor__AC_instruction_ForGrammar) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_syntaxComponents_ForGrammar'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_syntaxComponents_ForGrammar::
elementOf_GGS_L_syntaxComponents_ForGrammar (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mNonterminalSymbolsMap (argument_0),
mProductionRulesList (argument_1),
mSyntaxComponentName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_syntaxComponents_ForGrammar::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_syntaxComponents_ForGrammar * _p = dynamic_cast <const elementOf_GGS_L_syntaxComponents_ForGrammar *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mNonterminalSymbolsMap._operator_isEqual (_p->mNonterminalSymbolsMap).boolValue ()
         && mProductionRulesList._operator_isEqual (_p->mProductionRulesList).boolValue ()
         && mSyntaxComponentName._operator_isEqual (_p->mSyntaxComponentName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_syntaxComponents_ForGrammar::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNonterminalSymbolsMap.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mProductionRulesList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_syntaxComponents_ForGrammar'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
_internalAppendValues (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                    const GGS_L_productionRules_ForGrammarComponent & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
_internalPrependValues (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                    const GGS_L_productionRules_ForGrammarComponent & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
_addAssign_operation (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_lstring & argument_2) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar GGS_L_syntaxComponents_ForGrammar::
_operator_concat (const GGS_L_syntaxComponents_ForGrammar & inOperand) const {
  GGS_L_syntaxComponents_ForGrammar result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
_dotAssign_operation (const GGS_L_syntaxComponents_ForGrammar inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_L_syntaxComponents_ForGrammar * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_M_nonTerminalSymbolsForGrammar  p_0 = p->mNonterminalSymbolsMap ;
          GGS_L_productionRules_ForGrammarComponent  p_1 = p->mProductionRulesList ;
          GGS_lstring  p_2 = p->mSyntaxComponentName ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                     const GGS_L_productionRules_ForGrammarComponent & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mNonterminalSymbolsMap,
                                _p->mProductionRulesList,
                                _p->mSyntaxComponentName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar  GGS_L_syntaxComponents_ForGrammar::
constructor_emptyList (void) {
  GGS_L_syntaxComponents_ForGrammar result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar  GGS_L_syntaxComponents_ForGrammar::
constructor_listWithValue (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_L_syntaxComponents_ForGrammar result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
internalSubListWithRange (GGS_L_syntaxComponents_ForGrammar & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mNonterminalSymbolsMap, _p->mProductionRulesList, _p->mSyntaxComponentName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar GGS_L_syntaxComponents_ForGrammar::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_syntaxComponents_ForGrammar result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar GGS_L_syntaxComponents_ForGrammar::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_syntaxComponents_ForGrammar result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_syntaxComponents_ForGrammar::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_syntaxComponents_ForGrammar", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
method_first (C_Compiler & _inLexique,
              GGS_M_nonTerminalSymbolsForGrammar & _out_0,
              GGS_L_productionRules_ForGrammarComponent & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mNonterminalSymbolsMap ;
    _out_1 = _p->mProductionRulesList ;
    _out_2 = _p->mSyntaxComponentName ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
method_last (C_Compiler & _inLexique,
             GGS_M_nonTerminalSymbolsForGrammar & _out_0,
             GGS_L_productionRules_ForGrammarComponent & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mNonterminalSymbolsMap ;
    _out_1 = _p->mProductionRulesList ;
    _out_2 = _p->mSyntaxComponentName ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_M_nonTerminalSymbolsForGrammar & _out_0,
                 GGS_L_productionRules_ForGrammarComponent & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mNonterminalSymbolsMap ;
    _out_1 = _p->mProductionRulesList ;
    _out_2 = _p->mSyntaxComponentName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
modifier_popLast (C_Compiler & _inLexique,
                GGS_M_nonTerminalSymbolsForGrammar & _out_0,
                GGS_L_productionRules_ForGrammarComponent & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mNonterminalSymbolsMap ;
    _out_1 = _p->mProductionRulesList ;
    _out_2 = _p->mSyntaxComponentName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolsForGrammar  GGS_L_syntaxComponents_ForGrammar::
reader_mNonterminalSymbolsMapAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_M_nonTerminalSymbolsForGrammar  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mNonterminalSymbolsMap ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent  GGS_L_syntaxComponents_ForGrammar::
reader_mProductionRulesListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_L_productionRules_ForGrammarComponent  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mProductionRulesList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_syntaxComponents_ForGrammar::
reader_mSyntaxComponentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSyntaxComponentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
modifier_setMNonterminalSymbolsMapAtIndex (C_Compiler & inLexique,
                              const GGS_M_nonTerminalSymbolsForGrammar  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mNonterminalSymbolsMap = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
modifier_setMProductionRulesListAtIndex (C_Compiler & inLexique,
                              const GGS_L_productionRules_ForGrammarComponent  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mProductionRulesList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
modifier_setMSyntaxComponentNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSyntaxComponentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_nonTerminalSymbolsForGrammar  & GGS_L_syntaxComponents_ForGrammar::cEnumerator::_mNonterminalSymbolsMap (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mNonterminalSymbolsMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_productionRules_ForGrammarComponent  & GGS_L_syntaxComponents_ForGrammar::cEnumerator::_mProductionRulesList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mProductionRulesList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_L_syntaxComponents_ForGrammar::cEnumerator::_mSyntaxComponentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mSyntaxComponentName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeClassInheritedMessagesMap'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeClassInheritedMessagesMap::
elementOf_GGS_typeClassInheritedMessagesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeClassInheritedMessagesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeClassInheritedMessagesMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeClassInheritedMessagesMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassInheritedMessagesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeClassInheritedMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeClassInheritedMessagesMap * info = (e_typeClassInheritedMessagesMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeClassInheritedMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeClassInheritedMessagesMap * info = (e_typeClassInheritedMessagesMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassInheritedMessagesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeClassInheritedMessagesMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassInheritedMessagesMap::
_operator_isEqual (const GGS_typeClassInheritedMessagesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassInheritedMessagesMap::
_operator_isNotEqual (const GGS_typeClassInheritedMessagesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeClassInheritedMessagesMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the message '%K' is not declared",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the message '%K' is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeClassInheritedMessagesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassInheritedMessagesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassInheritedMessagesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeClassInheritedMessagesMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeClassInheritedMessagesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'e_typeSemanticAttributesMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeSemanticAttributesMap::e_typeSemanticAttributesMap (void) :
mAttributType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map '@typeSemanticAttributesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSemanticAttributesMap::
elementOf_GGS_typeSemanticAttributesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeSemanticAttributesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSemanticAttributesMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAttributType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeSemanticAttributesMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeSemanticAttributesMap * _p = dynamic_cast <const elementOf_GGS_typeSemanticAttributesMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mAttributType._operator_isEqual (_p->mInfo.mAttributType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeSemanticAttributesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeSemanticAttributesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeSemanticAttributesMap * info = (e_typeSemanticAttributesMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeSemanticAttributesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeSemanticAttributesMap * info = (e_typeSemanticAttributesMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticAttributesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeSemanticAttributesMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSemanticAttributesMap::
_operator_isEqual (const GGS_typeSemanticAttributesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSemanticAttributesMap::
_operator_isNotEqual (const GGS_typeSemanticAttributesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_galgasType & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeSemanticAttributesMap info  ;
    info.mAttributType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
modifier_setMAttributTypeForKey (C_Compiler & inLexique,
                        const GGS_AC_galgasType & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMAttributTypeForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mAttributType = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no attribut named '%K'",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "an attribut named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeSemanticAttributesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticAttributesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSemanticAttributesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSemanticAttributesMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeSemanticAttributesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeSemanticAttributesMap::cEnumerator::_mAttributType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAttributType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@insertOrSearchMethodList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_insertOrSearchMethodList::
elementOf_GGS_insertOrSearchMethodList (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMethodName (argument_0),
mErrorMessage (argument_1),
mIsGetIndexMethod (argument_2),
mShadowErrorMessage (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_insertOrSearchMethodList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_insertOrSearchMethodList * _p = dynamic_cast <const elementOf_GGS_insertOrSearchMethodList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mErrorMessage._operator_isEqual (_p->mErrorMessage).boolValue ()
         && mIsGetIndexMethod._operator_isEqual (_p->mIsGetIndexMethod).boolValue ()
         && mShadowErrorMessage._operator_isEqual (_p->mShadowErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_insertOrSearchMethodList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsGetIndexMethod.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mShadowErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@insertOrSearchMethodList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_bool& argument_2,
                    const GGS_string& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_bool& argument_2,
                    const GGS_string& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2,
                                const GGS_string& argument_3) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()&& argument_3._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList GGS_insertOrSearchMethodList::
_operator_concat (const GGS_insertOrSearchMethodList & inOperand) const {
  GGS_insertOrSearchMethodList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
_dotAssign_operation (const GGS_insertOrSearchMethodList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_insertOrSearchMethodList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_string p_1 = p->mErrorMessage ;
          GGS_bool p_2 = p->mIsGetIndexMethod ;
          GGS_string p_3 = p->mShadowErrorMessage ;
          _internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_string& argument_1,
                     const GGS_bool& argument_2,
                     const GGS_string& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mErrorMessage,
                                _p->mIsGetIndexMethod,
                                _p->mShadowErrorMessage
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_insertOrSearchMethodList::
constructor_emptyList (void) {
  GGS_insertOrSearchMethodList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_insertOrSearchMethodList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2,
                                const GGS_string& argument_3) {
  GGS_insertOrSearchMethodList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
internalSubListWithRange (GGS_insertOrSearchMethodList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mMethodName, _p->mErrorMessage, _p->mIsGetIndexMethod, _p->mShadowErrorMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList GGS_insertOrSearchMethodList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_insertOrSearchMethodList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList GGS_insertOrSearchMethodList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_insertOrSearchMethodList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertOrSearchMethodList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@insertOrSearchMethodList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_string& _out_1,
              GGS_bool& _out_2,
              GGS_string& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mErrorMessage ;
    _out_2 = _p->mIsGetIndexMethod ;
    _out_3 = _p->mShadowErrorMessage ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_string& _out_1,
             GGS_bool& _out_2,
             GGS_string& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mErrorMessage ;
    _out_2 = _p->mIsGetIndexMethod ;
    _out_3 = _p->mShadowErrorMessage ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_string& _out_1,
                 GGS_bool& _out_2,
                 GGS_string& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mErrorMessage ;
    _out_2 = _p->mIsGetIndexMethod ;
    _out_3 = _p->mShadowErrorMessage ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_string& _out_1,
                GGS_bool& _out_2,
                GGS_string& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mErrorMessage ;
    _out_2 = _p->mIsGetIndexMethod ;
    _out_3 = _p->mShadowErrorMessage ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_insertOrSearchMethodList::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertOrSearchMethodList::
reader_mErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_insertOrSearchMethodList::
reader_mIsGetIndexMethodAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsGetIndexMethod ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertOrSearchMethodList::
reader_mShadowErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mShadowErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_setMErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_setMIsGetIndexMethodAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsGetIndexMethod = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_setMShadowErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mShadowErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_insertOrSearchMethodList::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_insertOrSearchMethodList::cEnumerator::_mErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mErrorMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_insertOrSearchMethodList::cEnumerator::_mIsGetIndexMethod (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mIsGetIndexMethod ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_insertOrSearchMethodList::cEnumerator::_mShadowErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mShadowErrorMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeDefEntiteUtilisable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefEntiteUtilisable::
cPtr_typeDefEntiteUtilisable (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefEntiteUtilisable * GGS_typeDefEntiteUtilisable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefEntiteUtilisable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDefEntiteUtilisable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeDefEntiteUtilisable::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeDefEntiteUtilisable:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable::
static_string_message_messageTypeEntite (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable::
message_messageTypeEntite (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDefEntiteUtilisable (& typeid (cPtr_typeDefEntiteUtilisable), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeDefEntiteUtilisable::galgasRTTI (void) const {
  return & gClassInfoFor__typeDefEntiteUtilisable ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeDefEntiteUtilisable'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeDefEntiteUtilisable GGS_typeDefEntiteUtilisable::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDefEntiteUtilisable _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDefEntiteUtilisable *> (inPointer) != NULL)
      : (typeid (cPtr_typeDefEntiteUtilisable) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeDefEntiteUtilisable (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDefEntiteUtilisable),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDefEntiteUtilisable::
reader_messageTypeEntite (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefEntiteUtilisable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeDefEntiteUtilisable * p = (cPtr_typeDefEntiteUtilisable *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDefEntiteUtilisable::actualTypeName (void) const {
  return "typeDefEntiteUtilisable" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_typeDefEntiteUtilisable::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__typeDefEntiteUtilisable ("typeDefEntiteUtilisable") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeGalgasUndefinedListType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedListType::
cPtr_typeGalgasUndefinedListType (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mListTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedListType * GGS_typeGalgasUndefinedListType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedListType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedListType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedListType * _p = dynamic_cast <const cPtr_typeGalgasUndefinedListType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListTypeName._operator_isEqual (_p->mListTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedListType::
method_getTypeName (C_Compiler & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mListTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2251)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedListType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedListType:"
           << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedListType::
static_string_message_messageGalgasType (void) {
  return "an undefined list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedListType::
message_messageGalgasType (void) const {
  return "an undefined list type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedListType::
_message (void) const {
  return "an undefined list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedListType::
_static_message (void) {
  return "an undefined list type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasUndefinedListType (& typeid (cPtr_typeGalgasUndefinedListType), & typeid (cPtr_AC_galgasType), "an undefined list type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasUndefinedListType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasUndefinedListType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedListType'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedListType::
GGS_typeGalgasUndefinedListType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedListType::
GGS_typeGalgasUndefinedListType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasUndefinedListType GGS_typeGalgasUndefinedListType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedListType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasUndefinedListType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasUndefinedListType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasUndefinedListType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasUndefinedListType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedListType GGS_typeGalgasUndefinedListType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedListType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasUndefinedListType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedListType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasUndefinedListType * p = (cPtr_typeGalgasUndefinedListType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasUndefinedListType::
reader_mListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasUndefinedListType *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasUndefinedListType::actualTypeName (void) const {
  return "typeGalgasUndefinedListType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasUndefinedListType ("typeGalgasUndefinedListType", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgasListType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasListType::
cPtr_typeGalgasListType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_EXsignature & argument_2,
                                const GGS_L_EXsignature & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedListType (argument_0 COMMA_THERE),
mAttributeList (argument_1),
mExtractSignature (argument_2),
mInputSignature (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasListType * GGS_typeGalgasListType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasListType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasListType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasListType * _p = dynamic_cast <const cPtr_typeGalgasListType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListTypeName._operator_isEqual (_p->mListTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mExtractSignature._operator_isEqual (_p->mExtractSignature).boolValue ()
         && mInputSignature._operator_isEqual (_p->mInputSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_acceptForeachInstruction (C_Compiler & _inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle,
                                GGS_bool& var_cas_outNewStyle COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outNewStyle = GGS_bool (true, false) ;
  var_cas_outForeachList = mAttributeList ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_listStyle (_inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if (((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2291)))._operator_isEqual (GGS_string (true, "prependValue"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = mInputSignature ;
  }else if ((((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2293)))._operator_isEqual (GGS_string (true, "popFirst")))._operator_or ((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2293)))._operator_isEqual (GGS_string (true, "popLast")))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = mExtractSignature ;
  }else{
    var_cas_outModifierSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    GGS_bool var_cas_found ;
    var_cas_found = GGS_bool (true, false) ;
    {
      GGS_typeListeAttributsSemantiques::cEnumerator enumerator_99411 (mAttributeList, true) ;
      const GGS_typeListeAttributsSemantiques::cElement * operand_99411 = NULL ;
      while (((operand_99411 = enumerator_99411.nextObject ()))
          && ((var_cas_found)._operator_not ().isBuiltAndTrue ())) {
        macroValidPointer (operand_99411) ;
        var_cas_found = (((GGS_string (true, "set"))._operator_concat (operand_99411->mAttributeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2299)).reader_stringByCapitalizingFirstCharacter (_inLexique COMMA_SOURCE_FILE_AT_LINE (2299))))._operator_concat (GGS_string (true, "AtIndex")))._operator_isEqual (var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2299))) ;
        if ((var_cas_found).isBuiltAndTrue ()) {
          var_cas_outModifierSignature._addAssign_operation (operand_99411->mAttributType, GGS_EXformalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
          var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
        }
      }
    }
    if (((var_cas_found)._operator_not ()).isBuiltAndTrue ()) {
      var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "the '"))._operator_concat (var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2307))))._operator_concat (GGS_string (true, "' modifier is not supported by the list")) COMMA_SOURCE_FILE_AT_LINE (2308)) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_handleMethodInstructionCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outReaderSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string (true, "") ;
  if ((((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2322)))._operator_isNotEqual (GGS_string (true, "first")))._operator_and ((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2322)))._operator_isNotEqual (GGS_string (true, "last")))).isBuiltAndTrue ()) {
    var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a list accepts only 'first' and 'last' methods") COMMA_SOURCE_FILE_AT_LINE (2324)) ;
  }
  var_cas_outReaderSignature = mExtractSignature ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_handleAddAssignOperatorCall (C_Compiler & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outParametersList = mAttributeList ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, false) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2343)))._operator_isEqual (GGS_string (true, "emptyList"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2345)))._operator_isEqual (GGS_string (true, "listWithValue"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = mAttributeList ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (2349)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasListType:"
           << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExtractSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInputSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListType::
static_string_message_messageGalgasType (void) {
  return "a list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListType::
message_messageGalgasType (void) const {
  return "a list type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListType::
_message (void) const {
  return "a list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListType::
_static_message (void) {
  return "a list type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasListType (& typeid (cPtr_typeGalgasListType), & typeid (cPtr_typeGalgasUndefinedListType), "a list type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasListType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasListType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasListType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasListType::
GGS_typeGalgasListType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListType::
GGS_typeGalgasListType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasListType GGS_typeGalgasListType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasListType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasListType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasListType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasListType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListType GGS_typeGalgasListType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_L_EXsignature & argument_2,
                 const GGS_L_EXsignature & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasListType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasListType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasListType * p = (cPtr_typeGalgasListType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasListType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasListType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeGalgasListType::
reader_mExtractSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasListType *) mPointer)->mExtractSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeGalgasListType::
reader_mInputSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasListType *) mPointer)->mInputSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasListType::actualTypeName (void) const {
  return "typeGalgasListType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasListType ("typeGalgasListType", gClassInfoFor__typeGalgasUndefinedListType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeGalgasStructType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasStructType::
cPtr_typeGalgasStructType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mStructTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasStructType * GGS_typeGalgasStructType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasStructType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasStructType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasStructType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasStructType * _p = dynamic_cast <const cPtr_typeGalgasStructType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mStructTypeName._operator_isEqual (_p->mStructTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasStructType::
method_getTypeName (C_Compiler & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mStructTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2368)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasStructType::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, false) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2378)))._operator_isEqual (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = mAttributeList ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "the '"))._operator_concat (var_cas_inClassMethodName))._operator_concat (GGS_string (true, "' constructor is not defined")) COMMA_SOURCE_FILE_AT_LINE (2382)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasStructType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasStructType:"
           << mStructTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasStructType::
static_string_message_messageGalgasType (void) {
  return "a struct type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasStructType::
message_messageGalgasType (void) const {
  return "a struct type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasStructType::
_message (void) const {
  return "a struct type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasStructType::
_static_message (void) {
  return "a struct type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasStructType (& typeid (cPtr_typeGalgasStructType), & typeid (cPtr_AC_galgasType), "a struct type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasStructType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasStructType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgasStructType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasStructType::
GGS_typeGalgasStructType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasStructType::
GGS_typeGalgasStructType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasStructType GGS_typeGalgasStructType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasStructType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasStructType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasStructType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasStructType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasStructType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasStructType GGS_typeGalgasStructType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasStructType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasStructType (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasStructType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasStructType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasStructType * p = (cPtr_typeGalgasStructType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasStructType::
reader_mStructTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasStructType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasStructType *) mPointer)->mStructTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasStructType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasStructType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasStructType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasStructType::actualTypeName (void) const {
  return "typeGalgasStructType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasStructType ("typeGalgasStructType", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeGalgasListmapType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasListmapType::
cPtr_typeGalgasListmapType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeGalgasListType & argument_2,
                                const GGS_typeListeAttributsSemantiques & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mListmapTypeName (argument_0),
mListTypename (argument_1),
mListType (argument_2),
mAttributeList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasListmapType * GGS_typeGalgasListmapType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListmapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasListmapType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasListmapType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasListmapType * _p = dynamic_cast <const cPtr_typeGalgasListmapType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListmapTypeName._operator_isEqual (_p->mListmapTypeName).boolValue ()
         && mListTypename._operator_isEqual (_p->mListTypename).boolValue ()
         && mListType._operator_isEqual (_p->mListType).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListmapType::
method_acceptForeachInstruction (C_Compiler & _inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle,
                                GGS_bool& var_cas_outNewStyle COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outNewStyle = GGS_bool (true, true) ;
  var_cas_outForeachList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_outForeachList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "key"), GGS_location (_inLexique) COMMA_HERE)) ;
  var_cas_outForeachList._addAssign_operation (mListType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "object"), GGS_location (_inLexique) COMMA_HERE)) ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_listStyle (_inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListmapType::
method_getTypeName (C_Compiler & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mListmapTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2420)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListmapType::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, false) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2430)))._operator_isEqual (GGS_string (true, "emptyMap"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "the '"))._operator_concat (var_cas_inClassMethodName))._operator_concat (GGS_string (true, "' constructor is not defined")) COMMA_SOURCE_FILE_AT_LINE (2434)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListmapType::
method_handleAddAssignOperatorCall (C_Compiler & _inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outParametersList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_outParametersList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "key"), GGS_location (_inLexique) COMMA_HERE)) ;
  var_cas_outParametersList = (var_cas_outParametersList)._operator_concat (mAttributeList) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListmapType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasListmapType:"
           << mListmapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mListTypename.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mListType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListmapType::
static_string_message_messageGalgasType (void) {
  return "a listmap type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListmapType::
message_messageGalgasType (void) const {
  return "a listmap type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListmapType::
_message (void) const {
  return "a listmap type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListmapType::
_static_message (void) {
  return "a listmap type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasListmapType (& typeid (cPtr_typeGalgasListmapType), & typeid (cPtr_AC_galgasType), "a listmap type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasListmapType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasListmapType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgasListmapType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasListmapType::
GGS_typeGalgasListmapType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListmapType::
GGS_typeGalgasListmapType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasListmapType GGS_typeGalgasListmapType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListmapType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasListmapType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasListmapType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasListmapType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasListmapType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListmapType GGS_typeGalgasListmapType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeGalgasListType & argument_2,
                 const GGS_typeListeAttributsSemantiques & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListmapType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasListmapType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasListmapType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListmapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasListmapType * p = (cPtr_typeGalgasListmapType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasListmapType::
reader_mListmapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListmapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasListmapType *) mPointer)->mListmapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasListmapType::
reader_mListTypename (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListmapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasListmapType *) mPointer)->mListTypename ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListType  GGS_typeGalgasListmapType::
reader_mListType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeGalgasListType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListmapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasListmapType *) mPointer)->mListType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasListmapType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListmapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasListmapType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasListmapType::actualTypeName (void) const {
  return "typeGalgasListmapType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasListmapType ("typeGalgasListmapType", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "build_uintlist_type"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_build_uintlist_type (C_Compiler & _inLexique,
                                GGS_AC_galgasType  & var_cas_outType COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_build_uintlist_type at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeListeAttributsSemantiques  var_cas_attributesList ;
  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_attributesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "mValue"), GGS_location (_inLexique) COMMA_HERE)) ;
  GGS_L_EXsignature  var_cas_extractSignature ;
  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
  var_cas_extractSignature._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
  GGS_L_EXsignature  var_cas_inputSignature ;
  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
  var_cas_inputSignature._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
  var_cas_outType = GGS_typeGalgasListType ::constructor_new (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "uintlist"), GGS_location (_inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_build_uintlist_type\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "build_luintlist_type"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_build_luintlist_type (C_Compiler & _inLexique,
                                GGS_AC_galgasType  & var_cas_outType COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_build_luintlist_type at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeListeAttributsSemantiques  var_cas_attributesList ;
  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_attributesList._addAssign_operation (GGS_typeGalgas_luint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "mValue"), GGS_location (_inLexique) COMMA_HERE)) ;
  GGS_L_EXsignature  var_cas_extractSignature ;
  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
  var_cas_extractSignature._addAssign_operation (GGS_typeGalgas_luint ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
  GGS_L_EXsignature  var_cas_inputSignature ;
  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
  var_cas_inputSignature._addAssign_operation (GGS_typeGalgas_luint ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
  var_cas_outType = GGS_typeGalgasListType ::constructor_new (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "luintlist"), GGS_location (_inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_build_luintlist_type\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "build_uint64list_type"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_build_uint64list_type (C_Compiler & _inLexique,
                                GGS_AC_galgasType  & var_cas_outType COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_build_uint64list_type at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeListeAttributsSemantiques  var_cas_attributesList ;
  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_attributesList._addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "mValue"), GGS_location (_inLexique) COMMA_HERE)) ;
  GGS_L_EXsignature  var_cas_extractSignature ;
  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
  var_cas_extractSignature._addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
  GGS_L_EXsignature  var_cas_inputSignature ;
  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
  var_cas_inputSignature._addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
  var_cas_outType = GGS_typeGalgasListType ::constructor_new (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "uint64list"), GGS_location (_inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_build_uint64list_type\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "build_stringlist_type"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_build_stringlist_type (C_Compiler & _inLexique,
                                GGS_AC_galgasType  & var_cas_outType COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_build_stringlist_type at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeListeAttributsSemantiques  var_cas_attributesList ;
  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_attributesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "mValue"), GGS_location (_inLexique) COMMA_HERE)) ;
  GGS_L_EXsignature  var_cas_extractSignature ;
  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
  var_cas_extractSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
  GGS_L_EXsignature  var_cas_inputSignature ;
  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
  var_cas_inputSignature._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
  var_cas_outType = GGS_typeGalgasListType ::constructor_new (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "stringlist"), GGS_location (_inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_build_stringlist_type\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "build_lstringlist_type"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_build_lstringlist_type (C_Compiler & _inLexique,
                                GGS_AC_galgasType  & var_cas_outType COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_build_lstringlist_type at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeListeAttributsSemantiques  var_cas_attributesList ;
  var_cas_attributesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_attributesList._addAssign_operation (GGS_typeGalgas_lstring ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "mValue"), GGS_location (_inLexique) COMMA_HERE)) ;
  GGS_L_EXsignature  var_cas_extractSignature ;
  var_cas_extractSignature = GGS_L_EXsignature ::constructor_emptyList () ;
  var_cas_extractSignature._addAssign_operation (GGS_typeGalgas_lstring ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
  GGS_L_EXsignature  var_cas_inputSignature ;
  var_cas_inputSignature = GGS_L_EXsignature ::constructor_emptyList () ;
  var_cas_inputSignature._addAssign_operation (GGS_typeGalgas_lstring ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
  var_cas_outType = GGS_typeGalgasListType ::constructor_new (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "lstringlist"), GGS_location (_inLexique) COMMA_HERE), var_cas_attributesList, var_cas_extractSignature, var_cas_inputSignature COMMA_HERE) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_build_lstringlist_type\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_domainModifierMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_domainModifierMap::e_domainModifierMap (void) :
mFormalParametersList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@domainModifierMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_domainModifierMap::
elementOf_GGS_domainModifierMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_domainModifierMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_domainModifierMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mFormalParametersList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_domainModifierMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_domainModifierMap * _p = dynamic_cast <const elementOf_GGS_domainModifierMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mFormalParametersList._operator_isEqual (_p->mInfo.mFormalParametersList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_domainModifierMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_domainModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_domainModifierMap * info = (e_domainModifierMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_domainModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_domainModifierMap * info = (e_domainModifierMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_domainModifierMap GGS_domainModifierMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_domainModifierMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_domainModifierMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_domainModifierMap::
_operator_isEqual (const GGS_domainModifierMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_domainModifierMap::
_operator_isNotEqual (const GGS_domainModifierMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_domainModifierMap info  ;
    info.mFormalParametersList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalParametersList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
modifier_setMFormalParametersListForKey (C_Compiler & inLexique,
                        const GGS_L_EXsignature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMFormalParametersListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mFormalParametersList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' domain modifier is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_domainModifierMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' domain modifier has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_domainModifierMap GGS_domainModifierMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_domainModifierMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_domainModifierMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainModifierMap GGS_domainModifierMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainModifierMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_domainModifierMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @domainModifierMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_domainModifierMap::cEnumerator::_mFormalParametersList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFormalParametersList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@domainAttributeMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_domainAttributeMap::
elementOf_GGS_domainAttributeMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_domainAttributeMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_domainAttributeMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_domainAttributeMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_domainAttributeMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_domainAttributeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_domainAttributeMap * info = (e_domainAttributeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_domainAttributeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_domainAttributeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_domainAttributeMap * info = (e_domainAttributeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_domainAttributeMap GGS_domainAttributeMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_domainAttributeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_domainAttributeMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_domainAttributeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_domainAttributeMap::
_operator_isEqual (const GGS_domainAttributeMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_domainAttributeMap::
_operator_isNotEqual (const GGS_domainAttributeMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_domainAttributeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_domainAttributeMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_domainAttributeMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_domainAttributeMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_domainAttributeMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no attribute named '%K'",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_domainAttributeMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "an attribute named '%K' is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_domainAttributeMap GGS_domainAttributeMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_domainAttributeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_domainAttributeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainAttributeMap GGS_domainAttributeMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainAttributeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_domainAttributeMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @domainAttributeMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeGalgasDomainType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasDomainType::
cPtr_typeGalgasDomainType (const GGS_lstring & argument_0,
                                const GGS_domainAttributeMap & argument_1,
                                const GGS_domainModifierMap & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mDomainTypeName (argument_0),
mAttributeMap (argument_1),
mDomainModifierMap (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasDomainType * GGS_typeGalgasDomainType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasDomainType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasDomainType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasDomainType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasDomainType * _p = dynamic_cast <const cPtr_typeGalgasDomainType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mDomainTypeName._operator_isEqual (_p->mDomainTypeName).boolValue ()
         && mAttributeMap._operator_isEqual (_p->mAttributeMap).boolValue ()
         && mDomainModifierMap._operator_isEqual (_p->mDomainModifierMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasDomainType::
method_getTypeName (C_Compiler & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mDomainTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2585)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasDomainType::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2595)))._operator_isEqual (GGS_string (true, "emptyDomain"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a domain only accepts 'emptyDomain' constructor") COMMA_SOURCE_FILE_AT_LINE (2599)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasDomainType::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if ((mDomainModifierMap.reader_hasKey (_inLexique, var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2608)) COMMA_SOURCE_FILE_AT_LINE (2608))).isBuiltAndTrue ()) {
    const GGS_domainModifierMap  _temp_112429 = mDomainModifierMap ;
    if (_temp_112429._isBuilt ()) {
      _temp_112429 (HERE)->method_searchKey (_inLexique, var_cas_inModifierName, var_cas_outModifierSignature COMMA_SOURCE_FILE_AT_LINE (2609)) ;
    }
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this modifier is not defined") COMMA_SOURCE_FILE_AT_LINE (2612)) ;
    var_cas_outModifierSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasDomainType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasDomainType:"
           << mDomainTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDomainModifierMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasDomainType::
static_string_message_messageGalgasType (void) {
  return "a domain type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasDomainType::
message_messageGalgasType (void) const {
  return "a domain type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasDomainType::
_message (void) const {
  return "a domain type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasDomainType::
_static_message (void) {
  return "a domain type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasDomainType (& typeid (cPtr_typeGalgasDomainType), & typeid (cPtr_AC_galgasType), "a domain type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasDomainType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasDomainType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgasDomainType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasDomainType::
GGS_typeGalgasDomainType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasDomainType::
GGS_typeGalgasDomainType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasDomainType GGS_typeGalgasDomainType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasDomainType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasDomainType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasDomainType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasDomainType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasDomainType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasDomainType GGS_typeGalgasDomainType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_domainAttributeMap & argument_1,
                 const GGS_domainModifierMap & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasDomainType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasDomainType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasDomainType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasDomainType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasDomainType * p = (cPtr_typeGalgasDomainType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasDomainType::
reader_mDomainTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasDomainType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasDomainType *) mPointer)->mDomainTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainAttributeMap  GGS_typeGalgasDomainType::
reader_mAttributeMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainAttributeMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasDomainType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasDomainType *) mPointer)->mAttributeMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainModifierMap  GGS_typeGalgasDomainType::
reader_mDomainModifierMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainModifierMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasDomainType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasDomainType *) mPointer)->mDomainModifierMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasDomainType::actualTypeName (void) const {
  return "typeGalgasDomainType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasDomainType ("typeGalgasDomainType", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_typeGalgasUndefinedSortedListType'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedSortedListType::
cPtr_typeGalgasUndefinedSortedListType (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mListTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedSortedListType * GGS_typeGalgasUndefinedSortedListType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedSortedListType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedSortedListType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedSortedListType * _p = dynamic_cast <const cPtr_typeGalgasUndefinedSortedListType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListTypeName._operator_isEqual (_p->mListTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedSortedListType::
method_getTypeName (C_Compiler & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mListTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2630)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedSortedListType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedSortedListType:"
           << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedSortedListType::
static_string_message_messageGalgasType (void) {
  return "a predeclared sorted list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedSortedListType::
message_messageGalgasType (void) const {
  return "a predeclared sorted list type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedSortedListType::
_message (void) const {
  return "a predeclared sorted list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedSortedListType::
_static_message (void) {
  return "a predeclared sorted list type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasUndefinedSortedListType (& typeid (cPtr_typeGalgasUndefinedSortedListType), & typeid (cPtr_AC_galgasType), "a predeclared sorted list type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasUndefinedSortedListType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasUndefinedSortedListType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeGalgasUndefinedSortedListType'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedSortedListType::
GGS_typeGalgasUndefinedSortedListType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedSortedListType::
GGS_typeGalgasUndefinedSortedListType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasUndefinedSortedListType GGS_typeGalgasUndefinedSortedListType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedSortedListType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasUndefinedSortedListType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasUndefinedSortedListType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasUndefinedSortedListType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedSortedListType GGS_typeGalgasUndefinedSortedListType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedSortedListType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasUndefinedSortedListType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedSortedListType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasUndefinedSortedListType * p = (cPtr_typeGalgasUndefinedSortedListType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasUndefinedSortedListType::
reader_mListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasUndefinedSortedListType *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasUndefinedSortedListType::actualTypeName (void) const {
  return "typeGalgasUndefinedSortedListType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasUndefinedSortedListType ("typeGalgasUndefinedSortedListType", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeGalgasSortedListType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasSortedListType::
cPtr_typeGalgasSortedListType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_EXsignature & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedSortedListType (argument_0 COMMA_THERE),
mAttributeList (argument_1),
mExtractSignature (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasSortedListType * GGS_typeGalgasSortedListType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasSortedListType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasSortedListType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasSortedListType * _p = dynamic_cast <const cPtr_typeGalgasSortedListType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListTypeName._operator_isEqual (_p->mListTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mExtractSignature._operator_isEqual (_p->mExtractSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_acceptForeachInstruction (C_Compiler & _inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle,
                                GGS_bool& var_cas_outNewStyle COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outNewStyle = GGS_bool (true, false) ;
  var_cas_outForeachList = mAttributeList ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_listStyle (_inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if ((((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2668)))._operator_isEqual (GGS_string (true, "popSmallest")))._operator_or ((var_cas_inModifierName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2668)))._operator_isEqual (GGS_string (true, "popGreatest")))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = mExtractSignature ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a sorted list accepts only 'popSmallest' and 'popGreatest' modifiers") COMMA_SOURCE_FILE_AT_LINE (2672)) ;
    var_cas_outModifierSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_handleMethodInstructionCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outReaderSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string (true, "") ;
  if ((((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2685)))._operator_isNotEqual (GGS_string (true, "smallest")))._operator_and ((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2685)))._operator_isNotEqual (GGS_string (true, "greatest")))).isBuiltAndTrue ()) {
    var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a sorted list accepts only 'smallest' and 'greatest' methods") COMMA_SOURCE_FILE_AT_LINE (2687)) ;
  }
  var_cas_outReaderSignature = mExtractSignature ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_handleAddAssignOperatorCall (C_Compiler & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outParametersList = mAttributeList ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, false) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2706)))._operator_isEqual (GGS_string (true, "emptySortedList"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2708)))._operator_isEqual (GGS_string (true, "sortedListWithValue"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = mAttributeList ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (2712)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasSortedListType:"
           << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExtractSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasSortedListType::
static_string_message_messageGalgasType (void) {
  return "a sorted list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasSortedListType::
message_messageGalgasType (void) const {
  return "a sorted list type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasSortedListType::
_message (void) const {
  return "a sorted list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasSortedListType::
_static_message (void) {
  return "a sorted list type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasSortedListType (& typeid (cPtr_typeGalgasSortedListType), & typeid (cPtr_typeGalgasUndefinedSortedListType), "a sorted list type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasSortedListType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasSortedListType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeGalgasSortedListType'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasSortedListType::
GGS_typeGalgasSortedListType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasSortedListType::
GGS_typeGalgasSortedListType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasSortedListType GGS_typeGalgasSortedListType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasSortedListType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasSortedListType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasSortedListType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasSortedListType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasSortedListType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasSortedListType GGS_typeGalgasSortedListType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_L_EXsignature & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasSortedListType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasSortedListType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasSortedListType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasSortedListType * p = (cPtr_typeGalgasSortedListType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasSortedListType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasSortedListType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeGalgasSortedListType::
reader_mExtractSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasSortedListType *) mPointer)->mExtractSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasSortedListType::actualTypeName (void) const {
  return "typeGalgasSortedListType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasSortedListType ("typeGalgasSortedListType", gClassInfoFor__typeGalgasUndefinedSortedListType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_typeTableBlocsDeTable'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableBlocsDeTable::e_typeTableBlocsDeTable (void) :
aSignatureDebut (),
aSignatureFin () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@typeTableBlocsDeTable'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableBlocsDeTable::
elementOf_GGS_typeTableBlocsDeTable (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableBlocsDeTable & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableBlocsDeTable::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aSignatureDebut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aSignatureFin.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableBlocsDeTable::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableBlocsDeTable * _p = dynamic_cast <const elementOf_GGS_typeTableBlocsDeTable *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aSignatureDebut._operator_isEqual (_p->mInfo.aSignatureDebut)).boolValue ()
           && (mInfo.aSignatureFin._operator_isEqual (_p->mInfo.aSignatureFin)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableBlocsDeTable::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableBlocsDeTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableBlocsDeTable * info = (e_typeTableBlocsDeTable *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableBlocsDeTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableBlocsDeTable * info = (e_typeTableBlocsDeTable *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableBlocsDeTable result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableBlocsDeTable info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableBlocsDeTable::
_operator_isEqual (const GGS_typeTableBlocsDeTable & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableBlocsDeTable::
_operator_isNotEqual (const GGS_typeTableBlocsDeTable & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                const GGS_L_EXsignature & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableBlocsDeTable info  ;
    info.aSignatureDebut = inParameter0 ;
    info.aSignatureFin = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.aSignatureDebut ;
    outParameter1 = node->mInfo.aSignatureFin ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
modifier_setASignatureDebutForKey (C_Compiler & inLexique,
                        const GGS_L_EXsignature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setASignatureDebutForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.aSignatureDebut = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
modifier_setASignatureFinForKey (C_Compiler & inLexique,
                        const GGS_L_EXsignature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setASignatureFinForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.aSignatureFin = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_L_EXsignature   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no block method named '%K'",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_L_EXsignature & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a block method named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableBlocsDeTable & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableBlocsDeTable result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableBlocsDeTable result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableBlocsDeTable::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableBlocsDeTable " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_typeTableBlocsDeTable::cEnumerator::_aSignatureDebut (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aSignatureDebut ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_typeTableBlocsDeTable::cEnumerator::_aSignatureFin (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aSignatureFin ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeGalgasUndefinedMapType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedMapType::
cPtr_typeGalgasUndefinedMapType (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mMapTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedMapType * GGS_typeGalgasUndefinedMapType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedMapType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedMapType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedMapType * _p = dynamic_cast <const cPtr_typeGalgasUndefinedMapType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapTypeName._operator_isEqual (_p->mMapTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapType::
method_getTypeName (C_Compiler & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mMapTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2743)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedMapType:"
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapType::
static_string_message_messageGalgasType (void) {
  return "an undefined map type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapType::
message_messageGalgasType (void) const {
  return "an undefined map type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapType::
_message (void) const {
  return "an undefined map type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapType::
_static_message (void) {
  return "an undefined map type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasUndefinedMapType (& typeid (cPtr_typeGalgasUndefinedMapType), & typeid (cPtr_AC_galgasType), "an undefined map type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasUndefinedMapType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasUndefinedMapType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedMapType'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapType::
GGS_typeGalgasUndefinedMapType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapType::
GGS_typeGalgasUndefinedMapType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasUndefinedMapType GGS_typeGalgasUndefinedMapType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedMapType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasUndefinedMapType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasUndefinedMapType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasUndefinedMapType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapType GGS_typeGalgasUndefinedMapType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedMapType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasUndefinedMapType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedMapType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasUndefinedMapType * p = (cPtr_typeGalgasUndefinedMapType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasUndefinedMapType::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasUndefinedMapType *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasUndefinedMapType::actualTypeName (void) const {
  return "typeGalgasUndefinedMapType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasUndefinedMapType ("typeGalgasUndefinedMapType", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_mapModifierMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_mapModifierMap::e_mapModifierMap (void) :
mMethodSignature () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@mapModifierMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapModifierMap::
elementOf_GGS_mapModifierMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapModifierMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapModifierMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMethodSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapModifierMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_mapModifierMap * _p = dynamic_cast <const elementOf_GGS_mapModifierMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mMethodSignature._operator_isEqual (_p->mInfo.mMethodSignature)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapModifierMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapModifierMap * info = (e_mapModifierMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_mapModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_mapModifierMap * info = (e_mapModifierMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_mapModifierMap GGS_mapModifierMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapModifierMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_mapModifierMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapModifierMap::
_operator_isEqual (const GGS_mapModifierMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapModifierMap::
_operator_isNotEqual (const GGS_mapModifierMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_mapModifierMap info  ;
    info.mMethodSignature = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mMethodSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
modifier_setMMethodSignatureForKey (C_Compiler & inLexique,
                        const GGS_L_EXsignature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMMethodSignatureForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mMethodSignature = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no modifier named '%K'",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "an insert or a remove modifier named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapModifierMap GGS_mapModifierMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_mapModifierMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapModifierMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapModifierMap GGS_mapModifierMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapModifierMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapModifierMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @mapModifierMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_mapModifierMap::cEnumerator::_mMethodSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMethodSignature ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_mapMethodMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_mapMethodMap::e_mapMethodMap (void) :
mMethodSignature () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@mapMethodMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapMethodMap::
elementOf_GGS_mapMethodMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapMethodMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMethodSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapMethodMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_mapMethodMap * _p = dynamic_cast <const elementOf_GGS_mapMethodMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mMethodSignature._operator_isEqual (_p->mInfo.mMethodSignature)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapMethodMap * info = (e_mapMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_mapMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_mapMethodMap * info = (e_mapMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_mapMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapMethodMap::
_operator_isEqual (const GGS_mapMethodMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapMethodMap::
_operator_isNotEqual (const GGS_mapMethodMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_mapMethodMap info  ;
    info.mMethodSignature = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mMethodSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
modifier_setMMethodSignatureForKey (C_Compiler & inLexique,
                        const GGS_L_EXsignature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMMethodSignatureForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mMethodSignature = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no search method named '%K'",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a search method named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_mapMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapMethodMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @mapMethodMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_mapMethodMap::cEnumerator::_mMethodSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMethodSignature ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeGalgasMapType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasMapType::
cPtr_typeGalgasMapType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableBlocsDeTable & argument_2,
                                const GGS_mapModifierMap & argument_3,
                                const GGS_mapMethodMap & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedMapType (argument_0 COMMA_THERE),
mAttributeList (argument_1),
aTableMethodesSurcharger (argument_2),
mModifierMethodMap (argument_3),
mReaderMethodMap (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasMapType * GGS_typeGalgasMapType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasMapType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasMapType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasMapType * _p = dynamic_cast <const cPtr_typeGalgasMapType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapTypeName._operator_isEqual (_p->mMapTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && aTableMethodesSurcharger._operator_isEqual (_p->aTableMethodesSurcharger).boolValue ()
         && mModifierMethodMap._operator_isEqual (_p->mModifierMethodMap).boolValue ()
         && mReaderMethodMap._operator_isEqual (_p->mReaderMethodMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_mapModifierMap  _temp_119233 = mModifierMethodMap ;
  if (_temp_119233._isBuilt ()) {
    _temp_119233 (HERE)->method_searchKey (_inLexique, var_cas_inModifierName, var_cas_outModifierSignature COMMA_SOURCE_FILE_AT_LINE (2787)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_handleMethodInstructionCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outReaderSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string (true, "") ;
  const GGS_mapMethodMap  _temp_119646 = mReaderMethodMap ;
  if (_temp_119646._isBuilt ()) {
    _temp_119646 (HERE)->method_searchKey (_inLexique, var_cas_inReaderName, var_cas_outReaderSignature COMMA_SOURCE_FILE_AT_LINE (2799)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_acceptForeachInstruction (C_Compiler & _inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle,
                                GGS_bool& var_cas_outNewStyle COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outNewStyle = GGS_bool (true, false) ;
  var_cas_outForeachList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  var_cas_outForeachList._addAssign_operation (GGS_typeGalgas_lstring ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "key"), GGS_location (_inLexique) COMMA_HERE)) ;
  var_cas_outForeachList = (var_cas_outForeachList)._operator_concat (mAttributeList) ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (_inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2825)))._operator_isEqual (GGS_string (true, "emptyMap"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2827)))._operator_isEqual (GGS_string (true, "mapWithMapToOverride"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgasUndefinedMapType ::constructor_new (_inLexique, mMapTypeName COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "\?\?\?"), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2830)))._operator_isEqual (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "in GALGAS 1.3.0 and later, use 'emptyMap' constructor instead of 'empty' constructor") COMMA_SOURCE_FILE_AT_LINE (2832)) ;
    var_cas_outAccessorTypesList._drop () ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (2834)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasMapType:"
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aTableMethodesSurcharger.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModifierMethodMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReaderMethodMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapType::
static_string_message_messageGalgasType (void) {
  return "a map type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapType::
message_messageGalgasType (void) const {
  return "a map type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapType::
_message (void) const {
  return "a map type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapType::
_static_message (void) {
  return "a map type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasMapType (& typeid (cPtr_typeGalgasMapType), & typeid (cPtr_typeGalgasUndefinedMapType), "a map type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasMapType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasMapType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgasMapType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasMapType::
GGS_typeGalgasMapType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasMapType::
GGS_typeGalgasMapType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasMapType GGS_typeGalgasMapType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasMapType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasMapType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasMapType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasMapType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasMapType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasMapType GGS_typeGalgasMapType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_typeTableBlocsDeTable & argument_2,
                 const GGS_mapModifierMap & argument_3,
                 const GGS_mapMethodMap & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasMapType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasMapType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasMapType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasMapType * p = (cPtr_typeGalgasMapType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasMapType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable  GGS_typeGalgasMapType::
reader_aTableMethodesSurcharger (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableBlocsDeTable   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapType *) mPointer)->aTableMethodesSurcharger ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapModifierMap  GGS_typeGalgasMapType::
reader_mModifierMethodMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapModifierMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapType *) mPointer)->mModifierMethodMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap  GGS_typeGalgasMapType::
reader_mReaderMethodMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapType *) mPointer)->mReaderMethodMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasMapType::actualTypeName (void) const {
  return "typeGalgasMapType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasMapType ("typeGalgasMapType", gClassInfoFor__typeGalgasUndefinedMapType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeGalgasUndefinedMapindexType'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedMapindexType::
cPtr_typeGalgasUndefinedMapindexType (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mMapindexTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedMapindexType * GGS_typeGalgasUndefinedMapindexType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedMapindexType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedMapindexType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedMapindexType * _p = dynamic_cast <const cPtr_typeGalgasUndefinedMapindexType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapindexTypeName._operator_isEqual (_p->mMapindexTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapindexType::
method_getTypeName (C_Compiler & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mMapindexTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2852)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapindexType::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2862)))._operator_isEqual (GGS_string (true, "null"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a map index only accepts 'null' constructor") COMMA_SOURCE_FILE_AT_LINE (2866)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapindexType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedMapindexType:"
           << mMapindexTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapindexType::
static_string_message_messageGalgasType (void) {
  return "a predeclared mapindex type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapindexType::
message_messageGalgasType (void) const {
  return "a predeclared mapindex type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapindexType::
_message (void) const {
  return "a predeclared mapindex type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapindexType::
_static_message (void) {
  return "a predeclared mapindex type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasUndefinedMapindexType (& typeid (cPtr_typeGalgasUndefinedMapindexType), & typeid (cPtr_AC_galgasType), "a predeclared mapindex type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasUndefinedMapindexType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasUndefinedMapindexType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeGalgasUndefinedMapindexType'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapindexType::
GGS_typeGalgasUndefinedMapindexType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapindexType::
GGS_typeGalgasUndefinedMapindexType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasUndefinedMapindexType GGS_typeGalgasUndefinedMapindexType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedMapindexType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasUndefinedMapindexType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasUndefinedMapindexType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasUndefinedMapindexType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasUndefinedMapindexType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapindexType GGS_typeGalgasUndefinedMapindexType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedMapindexType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasUndefinedMapindexType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedMapindexType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasUndefinedMapindexType * p = (cPtr_typeGalgasUndefinedMapindexType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasUndefinedMapindexType::
reader_mMapindexTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasUndefinedMapindexType *) mPointer)->mMapindexTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasUndefinedMapindexType::actualTypeName (void) const {
  return "typeGalgasUndefinedMapindexType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasUndefinedMapindexType ("typeGalgasUndefinedMapindexType", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'e_mapIndexSearchReaderMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

e_mapIndexSearchReaderMap::e_mapIndexSearchReaderMap (void) :
mRetrieveErrorMessage () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@mapIndexSearchReaderMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapIndexSearchReaderMap::
elementOf_GGS_mapIndexSearchReaderMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapIndexSearchReaderMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapIndexSearchReaderMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mRetrieveErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapIndexSearchReaderMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_mapIndexSearchReaderMap * _p = dynamic_cast <const elementOf_GGS_mapIndexSearchReaderMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mRetrieveErrorMessage._operator_isEqual (_p->mInfo.mRetrieveErrorMessage)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapIndexSearchReaderMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapIndexSearchReaderMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapIndexSearchReaderMap * info = (e_mapIndexSearchReaderMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_mapIndexSearchReaderMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_mapIndexSearchReaderMap * info = (e_mapIndexSearchReaderMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_mapIndexSearchReaderMap GGS_mapIndexSearchReaderMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapIndexSearchReaderMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_mapIndexSearchReaderMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapIndexSearchReaderMap::
_operator_isEqual (const GGS_mapIndexSearchReaderMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapIndexSearchReaderMap::
_operator_isNotEqual (const GGS_mapIndexSearchReaderMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_mapIndexSearchReaderMap info  ;
    info.mRetrieveErrorMessage = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mRetrieveErrorMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
modifier_setMRetrieveErrorMessageForKey (C_Compiler & inLexique,
                        const GGS_lstring & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMRetrieveErrorMessageForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mRetrieveErrorMessage = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is search reader named '%K'",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapIndexSearchReaderMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a search reader named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapIndexSearchReaderMap GGS_mapIndexSearchReaderMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_mapIndexSearchReaderMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapIndexSearchReaderMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapIndexSearchReaderMap GGS_mapIndexSearchReaderMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapIndexSearchReaderMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapIndexSearchReaderMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @mapIndexSearchReaderMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapIndexSearchReaderMap::cEnumerator::_mRetrieveErrorMessage (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRetrieveErrorMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeGalgasMapindexType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasMapindexType::
cPtr_typeGalgasMapindexType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_mapIndexSearchReaderMap & argument_3,
                                const GGS_typeTableBlocsDeTable & argument_4,
                                const GGS_mapModifierMap & argument_5,
                                const GGS_mapMethodMap & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedMapindexType (argument_0 COMMA_THERE),
mMapTypeName (argument_1),
mMapAttributesList (argument_2),
mMapIndexSearchReaderMap (argument_3),
aTableMethodesSurcharger (argument_4),
mModifierMethodMap (argument_5),
mReaderMethodMap (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasMapindexType * GGS_typeGalgasMapindexType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasMapindexType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasMapindexType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasMapindexType * _p = dynamic_cast <const cPtr_typeGalgasMapindexType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapindexTypeName._operator_isEqual (_p->mMapindexTypeName).boolValue ()
         && mMapTypeName._operator_isEqual (_p->mMapTypeName).boolValue ()
         && mMapAttributesList._operator_isEqual (_p->mMapAttributesList).boolValue ()
         && mMapIndexSearchReaderMap._operator_isEqual (_p->mMapIndexSearchReaderMap).boolValue ()
         && aTableMethodesSurcharger._operator_isEqual (_p->aTableMethodesSurcharger).boolValue ()
         && mModifierMethodMap._operator_isEqual (_p->mModifierMethodMap).boolValue ()
         && mReaderMethodMap._operator_isEqual (_p->mReaderMethodMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapindexType::
method_handleMethodInstructionCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outReaderSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string (true, "") ;
  GGS_lstring  automatic_var_5 ;
  const GGS_mapIndexSearchReaderMap  _temp_124064 = mMapIndexSearchReaderMap ;
  if (_temp_124064._isBuilt ()) {
    _temp_124064 (HERE)->method_searchKey (_inLexique, var_cas_inReaderName, automatic_var_5 COMMA_SOURCE_FILE_AT_LINE (2906)) ;
  }
  var_cas_outReaderSignature = GGS_L_EXsignature ::constructor_listWithValue (GGS_typeGalgas_lstring ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
  {
    GGS_typeListeAttributsSemantiques::cEnumerator enumerator_124262 (mMapAttributesList, true) ;
    const GGS_typeListeAttributsSemantiques::cElement * operand_124262 = NULL ;
    while (((operand_124262 = enumerator_124262.nextObject ()))) {
      macroValidPointer (operand_124262) ;
      var_cas_outReaderSignature._addAssign_operation (operand_124262->mAttributType, GGS_EXformalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapindexType::
method_handleClassMethodCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inTypeMethodName,
                                GGS_L_EXsignature & var_cas_outTypeMethodSignature COMMA_UNUSED_LOCATION_ARGS) const {
  if (((var_cas_inTypeMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2922)))._operator_isEqual (GGS_string (true, "makeRegularIndex"))).isBuiltAndTrue ()) {
    var_cas_outTypeMethodSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    var_cas_outTypeMethodSignature._addAssign_operation (GGS_typeGalgas_lstring ::constructor_new (_inLexique COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
    var_cas_outTypeMethodSignature._addAssign_operation (GGS_typeGalgasMapType ::constructor_new (_inLexique, mMapTypeName, mMapAttributesList, aTableMethodesSurcharger, mModifierMethodMap, mReaderMethodMap COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentInOut (_inLexique COMMA_HERE)) ;
    var_cas_outTypeMethodSignature._addAssign_operation (GGS_typeGalgasMapindexType ::constructor_new (_inLexique, mMapindexTypeName, mMapTypeName, mMapAttributesList, mMapIndexSearchReaderMap, aTableMethodesSurcharger, mModifierMethodMap, mReaderMethodMap COMMA_HERE), GGS_EXformalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inTypeMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a map index only accepts 'regularIndex' type method") COMMA_SOURCE_FILE_AT_LINE (2952)) ;
    var_cas_outTypeMethodSignature._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapindexType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasMapindexType:"
           << mMapindexTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapIndexSearchReaderMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aTableMethodesSurcharger.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModifierMethodMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReaderMethodMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapindexType::
static_string_message_messageGalgasType (void) {
  return "a mapindex type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapindexType::
message_messageGalgasType (void) const {
  return "a mapindex type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapindexType::
_message (void) const {
  return "a mapindex type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapindexType::
_static_message (void) {
  return "a mapindex type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasMapindexType (& typeid (cPtr_typeGalgasMapindexType), & typeid (cPtr_typeGalgasUndefinedMapindexType), "a mapindex type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasMapindexType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasMapindexType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeGalgasMapindexType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasMapindexType::
GGS_typeGalgasMapindexType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasMapindexType::
GGS_typeGalgasMapindexType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasMapindexType GGS_typeGalgasMapindexType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasMapindexType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasMapindexType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasMapindexType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasMapindexType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasMapindexType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasMapindexType GGS_typeGalgasMapindexType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_mapIndexSearchReaderMap & argument_3,
                 const GGS_typeTableBlocsDeTable & argument_4,
                 const GGS_mapModifierMap & argument_5,
                 const GGS_mapMethodMap & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasMapindexType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasMapindexType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasMapindexType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasMapindexType * p = (cPtr_typeGalgasMapindexType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasMapindexType::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapindexType *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasMapindexType::
reader_mMapAttributesList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapindexType *) mPointer)->mMapAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapIndexSearchReaderMap  GGS_typeGalgasMapindexType::
reader_mMapIndexSearchReaderMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapIndexSearchReaderMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapindexType *) mPointer)->mMapIndexSearchReaderMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable  GGS_typeGalgasMapindexType::
reader_aTableMethodesSurcharger (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableBlocsDeTable   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapindexType *) mPointer)->aTableMethodesSurcharger ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapModifierMap  GGS_typeGalgasMapindexType::
reader_mModifierMethodMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapModifierMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapindexType *) mPointer)->mModifierMethodMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap  GGS_typeGalgasMapindexType::
reader_mReaderMethodMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapindexType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapindexType *) mPointer)->mReaderMethodMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasMapindexType::actualTypeName (void) const {
  return "typeGalgasMapindexType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasMapindexType ("typeGalgasMapindexType", gClassInfoFor__typeGalgasUndefinedMapindexType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeGalgasUndefinedClassType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedClassType::
cPtr_typeGalgasUndefinedClassType (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mClassTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedClassType * GGS_typeGalgasUndefinedClassType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedClassType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedClassType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedClassType * _p = dynamic_cast <const cPtr_typeGalgasUndefinedClassType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mClassTypeName._operator_isEqual (_p->mClassTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedClassType::
method_getTypeName (C_Compiler & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mClassTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (2970)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedClassType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedClassType:"
           << mClassTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedClassType::
static_string_message_messageGalgasType (void) {
  return "an undefined class type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedClassType::
message_messageGalgasType (void) const {
  return "an undefined class type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedClassType::
_message (void) const {
  return "an undefined class type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedClassType::
_static_message (void) {
  return "an undefined class type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasUndefinedClassType (& typeid (cPtr_typeGalgasUndefinedClassType), & typeid (cPtr_AC_galgasType), "an undefined class type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasUndefinedClassType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasUndefinedClassType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedClassType'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedClassType::
GGS_typeGalgasUndefinedClassType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedClassType::
GGS_typeGalgasUndefinedClassType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasUndefinedClassType GGS_typeGalgasUndefinedClassType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedClassType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasUndefinedClassType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasUndefinedClassType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasUndefinedClassType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedClassType GGS_typeGalgasUndefinedClassType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasUndefinedClassType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasUndefinedClassType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedClassType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasUndefinedClassType * p = (cPtr_typeGalgasUndefinedClassType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasUndefinedClassType::
reader_mClassTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasUndefinedClassType *) mPointer)->mClassTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasUndefinedClassType::actualTypeName (void) const {
  return "typeGalgasUndefinedClassType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasUndefinedClassType ("typeGalgasUndefinedClassType", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_lazyAttributeList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_lazyAttributeList::
elementOf_GGS_L_lazyAttributeList (const GGS_location & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLocationMagicNumber (argument_0),
mComputedAttributeTypeAndNameList (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_lazyAttributeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_lazyAttributeList * _p = dynamic_cast <const elementOf_GGS_L_lazyAttributeList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLocationMagicNumber._operator_isEqual (_p->mLocationMagicNumber).boolValue ()
         && mComputedAttributeTypeAndNameList._operator_isEqual (_p->mComputedAttributeTypeAndNameList).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_lazyAttributeList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationMagicNumber.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mComputedAttributeTypeAndNameList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@L_lazyAttributeList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_typeListeAttributsSemantiques & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_typeListeAttributsSemantiques & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
_addAssign_operation (const GGS_location & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_lazyAttributeList GGS_L_lazyAttributeList::
_operator_concat (const GGS_L_lazyAttributeList & inOperand) const {
  GGS_L_lazyAttributeList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
_dotAssign_operation (const GGS_L_lazyAttributeList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_L_lazyAttributeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mLocationMagicNumber ;
          GGS_typeListeAttributsSemantiques  p_1 = p->mComputedAttributeTypeAndNameList ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_typeListeAttributsSemantiques & argument_1,
                     const GGS_typeInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLocationMagicNumber,
                                _p->mComputedAttributeTypeAndNameList,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_lazyAttributeList  GGS_L_lazyAttributeList::
constructor_emptyList (void) {
  GGS_L_lazyAttributeList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_lazyAttributeList  GGS_L_lazyAttributeList::
constructor_listWithValue (const GGS_location & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  GGS_L_lazyAttributeList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
internalSubListWithRange (GGS_L_lazyAttributeList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mLocationMagicNumber, _p->mComputedAttributeTypeAndNameList, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_lazyAttributeList GGS_L_lazyAttributeList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_lazyAttributeList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_lazyAttributeList GGS_L_lazyAttributeList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_lazyAttributeList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_lazyAttributeList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_lazyAttributeList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
method_first (C_Compiler & _inLexique,
              GGS_location & _out_0,
              GGS_typeListeAttributsSemantiques & _out_1,
              GGS_typeInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLocationMagicNumber ;
    _out_1 = _p->mComputedAttributeTypeAndNameList ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
method_last (C_Compiler & _inLexique,
             GGS_location & _out_0,
             GGS_typeListeAttributsSemantiques & _out_1,
             GGS_typeInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLocationMagicNumber ;
    _out_1 = _p->mComputedAttributeTypeAndNameList ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_location & _out_0,
                 GGS_typeListeAttributsSemantiques & _out_1,
                 GGS_typeInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLocationMagicNumber ;
    _out_1 = _p->mComputedAttributeTypeAndNameList ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_location & _out_0,
                GGS_typeListeAttributsSemantiques & _out_1,
                GGS_typeInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLocationMagicNumber ;
    _out_1 = _p->mComputedAttributeTypeAndNameList ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_location  GGS_L_lazyAttributeList::
reader_mLocationMagicNumberAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocationMagicNumber ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_L_lazyAttributeList::
reader_mComputedAttributeTypeAndNameListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mComputedAttributeTypeAndNameList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_L_lazyAttributeList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
modifier_setMLocationMagicNumberAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocationMagicNumber = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
modifier_setMComputedAttributeTypeAndNameListAtIndex (C_Compiler & inLexique,
                              const GGS_typeListeAttributsSemantiques  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mComputedAttributeTypeAndNameList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lazyAttributeList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_L_lazyAttributeList::cEnumerator::_mLocationMagicNumber (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mLocationMagicNumber ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeAttributsSemantiques  & GGS_L_lazyAttributeList::cEnumerator::_mComputedAttributeTypeAndNameList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mComputedAttributeTypeAndNameList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_L_lazyAttributeList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeGalgasClassType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasClassType::
cPtr_typeGalgasClassType (const GGS_lstring & argument_0,
                                const GGS_typeTableMethodes & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeSuperClassesMap & argument_3,
                                const GGS_typeClassInheritedMessagesMap & argument_4,
                                const GGS_typeSemanticAttributesMap & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_string& argument_7,
                                const GGS_bool& argument_8,
                                const GGS_L_lazyAttributeList & argument_9
                                COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedClassType (argument_0 COMMA_THERE),
mMethodMap (argument_1),
mAttributeList (argument_2),
mAncestorClassesMap (argument_3),
mMessagesMap (argument_4),
mNonExternAttributesMap (argument_5),
mClassIsAbstract (argument_6),
mClassMessage (argument_7),
mHasGeneratedInSeparateFileSetting (argument_8),
mLazyAttributeList (argument_9) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasClassType * GGS_typeGalgasClassType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasClassType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasClassType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasClassType * _p = dynamic_cast <const cPtr_typeGalgasClassType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mClassTypeName._operator_isEqual (_p->mClassTypeName).boolValue ()
         && mMethodMap._operator_isEqual (_p->mMethodMap).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mAncestorClassesMap._operator_isEqual (_p->mAncestorClassesMap).boolValue ()
         && mMessagesMap._operator_isEqual (_p->mMessagesMap).boolValue ()
         && mNonExternAttributesMap._operator_isEqual (_p->mNonExternAttributesMap).boolValue ()
         && mClassIsAbstract._operator_isEqual (_p->mClassIsAbstract).boolValue ()
         && mClassMessage._operator_isEqual (_p->mClassMessage).boolValue ()
         && mHasGeneratedInSeparateFileSetting._operator_isEqual (_p->mHasGeneratedInSeparateFileSetting).boolValue ()
         && mLazyAttributeList._operator_isEqual (_p->mLazyAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
method_handleMethodInstructionCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_EXcategoryMethodMap  var_cas_inCategoryMethodMap,
                                GGS_L_EXsignature & var_cas_outMethodSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string (true, "") ;
  if ((mMethodMap.reader_hasKey (_inLexique, var_cas_inMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3024)) COMMA_SOURCE_FILE_AT_LINE (3024))).isBuiltAndTrue ()) {
    const GGS_typeTableMethodes  _temp_128005 = mMethodMap ;
    if (_temp_128005._isBuilt ()) {
      _temp_128005 (HERE)->method_searchKey (_inLexique, var_cas_inMethodName, var_cas_outMethodSignature COMMA_SOURCE_FILE_AT_LINE (3025)) ;
    }
  }else{
    var_cas_outMethodSignature = GGS_L_EXsignature ::constructor_emptyList () ;
    GGS_lstring  var_cas_key ;
    var_cas_key = GGS_lstring ::constructor_new (_inLexique, ((mClassTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3028)))._operator_concat (GGS_string (true, ":")))._operator_concat (var_cas_inMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3028))), var_cas_inMethodName.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (3028)) COMMA_HERE) ;
    if ((var_cas_inCategoryMethodMap.reader_hasKey (_inLexique, var_cas_key.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3029)) COMMA_SOURCE_FILE_AT_LINE (3029))).isBuiltAndTrue ()) {
      GGS_categoryMethodKind var_cas_categoryMethodKind ;
      const GGS_EXcategoryMethodMap  _temp_128360 = var_cas_inCategoryMethodMap ;
      if (_temp_128360._isBuilt ()) {
        _temp_128360 (HERE)->method_searchKey (_inLexique, var_cas_key, var_cas_categoryMethodKind, var_cas_outMethodSignature COMMA_SOURCE_FILE_AT_LINE (3031)) ;
      }
      if (((var_cas_categoryMethodKind)._operator_isNotEqual (GGS_categoryMethodKind::constructor_overridingMethod (_inLexique COMMA_HERE))).isBuiltAndTrue ()) {
        var_cas_outCategoryMethodClassBaseName = mClassTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3033)) ;
      }
    }
    {
      GGS_typeSuperClassesMap::cEnumerator enumerator_128621 (mAncestorClassesMap, true) ;
      const GGS_typeSuperClassesMap::cElement * operand_128621 = NULL ;
      while (((operand_128621 = enumerator_128621.nextObject ()))
          && ((var_cas_outCategoryMethodClassBaseName)._operator_isEqual (GGS_string (true, "")).isBuiltAndTrue ())) {
        macroValidPointer (operand_128621) ;
        GGS_lstring  var_cas_superKey ;
        var_cas_superKey = GGS_lstring ::constructor_new (_inLexique, ((operand_128621->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3037)))._operator_concat (GGS_string (true, ":")))._operator_concat (var_cas_inMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3037))), var_cas_inMethodName.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (3037)) COMMA_HERE) ;
        if ((var_cas_inCategoryMethodMap.reader_hasKey (_inLexique, var_cas_superKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3038)) COMMA_SOURCE_FILE_AT_LINE (3038))).isBuiltAndTrue ()) {
          GGS_categoryMethodKind var_cas_categoryMethodKind ;
          const GGS_EXcategoryMethodMap  _temp_128926 = var_cas_inCategoryMethodMap ;
          if (_temp_128926._isBuilt ()) {
            _temp_128926 (HERE)->method_searchKey (_inLexique, var_cas_superKey, var_cas_categoryMethodKind, var_cas_outMethodSignature COMMA_SOURCE_FILE_AT_LINE (3040)) ;
          }
          if (((var_cas_categoryMethodKind)._operator_isNotEqual (GGS_categoryMethodKind::constructor_overridingMethod (_inLexique COMMA_HERE))).isBuiltAndTrue ()) {
            var_cas_outCategoryMethodClassBaseName = mClassTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3042)) ;
          }
        }
      }
    }
    if (((var_cas_outCategoryMethodClassBaseName)._operator_isEqual (GGS_string (true, ""))).isBuiltAndTrue ()) {
      var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "there is no '"))._operator_concat (var_cas_inMethodName))._operator_concat (GGS_string (true, "' method defined for '@")))._operator_concat (mClassTypeName))._operator_concat (GGS_string (true, "' class")) COMMA_SOURCE_FILE_AT_LINE (3049)) ;
      var_cas_outMethodSignature._drop () ;
    }
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  if ((mClassIsAbstract).isBuiltAndTrue ()) {
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "an abstract class cannot be instancied") COMMA_SOURCE_FILE_AT_LINE (3062)) ;
    var_cas_outAccessorTypesList._drop () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3062)))._operator_isEqual (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = mAttributeList ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") COMMA_SOURCE_FILE_AT_LINE (3066)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasClassType:"
           << mClassTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMethodMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAncestorClassesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMessagesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mClassIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mClassMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mHasGeneratedInSeparateFileSetting.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLazyAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasClassType::
static_string_message_messageGalgasType (void) {
  return "a class type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasClassType::
message_messageGalgasType (void) const {
  return "a class type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasClassType::
_message (void) const {
  return "a class type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasClassType::
_static_message (void) {
  return "a class type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasClassType (& typeid (cPtr_typeGalgasClassType), & typeid (cPtr_typeGalgasUndefinedClassType), "a class type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasClassType::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasClassType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasClassType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasClassType::
GGS_typeGalgasClassType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasClassType::
GGS_typeGalgasClassType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgasClassType GGS_typeGalgasClassType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasClassType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasClassType *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasClassType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgasClassType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasClassType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasClassType GGS_typeGalgasClassType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeTableMethodes & argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_typeSuperClassesMap & argument_3,
                 const GGS_typeClassInheritedMessagesMap & argument_4,
                 const GGS_typeSemanticAttributesMap & argument_5,
                 const GGS_bool& argument_6,
                 const GGS_string& argument_7,
                 const GGS_bool& argument_8,
                 const GGS_L_lazyAttributeList & argument_9
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasClassType result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasClassType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasClassType::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgasClassType * p = (cPtr_typeGalgasClassType *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes  GGS_typeGalgasClassType::
reader_mMethodMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mMethodMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasClassType::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap  GGS_typeGalgasClassType::
reader_mAncestorClassesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSuperClassesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mAncestorClassesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap  GGS_typeGalgasClassType::
reader_mMessagesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassInheritedMessagesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mMessagesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap  GGS_typeGalgasClassType::
reader_mNonExternAttributesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSemanticAttributesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mNonExternAttributesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasClassType::
reader_mClassIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mClassIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasClassType::
reader_mClassMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mClassMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasClassType::
reader_mHasGeneratedInSeparateFileSetting (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mHasGeneratedInSeparateFileSetting ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_lazyAttributeList  GGS_typeGalgasClassType::
reader_mLazyAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_lazyAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mLazyAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasClassType::actualTypeName (void) const {
  return "typeGalgasClassType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasClassType ("typeGalgasClassType", gClassInfoFor__typeGalgasUndefinedClassType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeEntiteType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteType::
cPtr_typeEntiteType (const GGS_AC_galgasType & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aDefType (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteType * GGS_typeEntiteType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteType * _p = dynamic_cast <const cPtr_typeEntiteType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aDefType._operator_isEqual (_p->aDefType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteType:"
           << aDefType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteType::
static_string_message_messageTypeEntite (void) {
  return "a type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteType::
message_messageTypeEntite (void) const {
  return "a type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteType::
_message (void) const {
  return "a type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteType::
_static_message (void) {
  return "a type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntiteType (& typeid (cPtr_typeEntiteType), & typeid (cPtr_AC_semanticsEntity), "a type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeEntiteType::galgasRTTI (void) const {
  return & gClassInfoFor__typeEntiteType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntiteType::
GGS_typeEntiteType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteType::
GGS_typeEntiteType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeEntiteType GGS_typeEntiteType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntiteType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntiteType *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntiteType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeEntiteType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntiteType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteType GGS_typeEntiteType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_galgasType & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteType result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteType (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteType::
reader_messageTypeEntite (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeEntiteType * p = (cPtr_typeEntiteType *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeEntiteType::
reader_aDefType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteType *) mPointer)->aDefType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntiteType::actualTypeName (void) const {
  return "typeEntiteType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeEntiteType ("typeEntiteType", gClassInfoFor__AC_semanticsEntity) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeEntiteRoutine'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteRoutine::
cPtr_typeEntiteRoutine (const GGS_L_EXsignature & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aListeArgumentsFormels (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteRoutine * GGS_typeEntiteRoutine::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteRoutine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteRoutine *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteRoutine::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteRoutine * _p = dynamic_cast <const cPtr_typeEntiteRoutine *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aListeArgumentsFormels._operator_isEqual (_p->aListeArgumentsFormels).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteRoutine::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteRoutine:"
           << aListeArgumentsFormels.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutine::
static_string_message_messageTypeEntite (void) {
  return "a routine" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutine::
message_messageTypeEntite (void) const {
  return "a routine" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutine::
_message (void) const {
  return "a routine" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutine::
_static_message (void) {
  return "a routine" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntiteRoutine (& typeid (cPtr_typeEntiteRoutine), & typeid (cPtr_AC_semanticsEntity), "a routine") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeEntiteRoutine::galgasRTTI (void) const {
  return & gClassInfoFor__typeEntiteRoutine ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeEntiteRoutine'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntiteRoutine::
GGS_typeEntiteRoutine (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutine::
GGS_typeEntiteRoutine (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeEntiteRoutine GGS_typeEntiteRoutine::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntiteRoutine _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntiteRoutine *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntiteRoutine) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeEntiteRoutine (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntiteRoutine),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutine GGS_typeEntiteRoutine::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_L_EXsignature & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteRoutine result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteRoutine (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteRoutine::
reader_messageTypeEntite (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteRoutine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeEntiteRoutine * p = (cPtr_typeEntiteRoutine *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeEntiteRoutine::
reader_aListeArgumentsFormels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteRoutine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteRoutine *) mPointer)->aListeArgumentsFormels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntiteRoutine::actualTypeName (void) const {
  return "typeEntiteRoutine" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeEntiteRoutine ("typeEntiteRoutine", gClassInfoFor__AC_semanticsEntity) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_typeEnumMessageMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeEnumMessageMap::e_typeEnumMessageMap (void) :
mMessageStringList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@typeEnumMessageMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumMessageMap::
elementOf_GGS_typeEnumMessageMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEnumMessageMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMessageStringList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeEnumMessageMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeEnumMessageMap * _p = dynamic_cast <const elementOf_GGS_typeEnumMessageMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mMessageStringList._operator_isEqual (_p->mInfo.mMessageStringList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeEnumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumMessageMap * info = (e_typeEnumMessageMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeEnumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeEnumMessageMap * info = (e_typeEnumMessageMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumMessageMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeEnumMessageMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumMessageMap::
_operator_isEqual (const GGS_typeEnumMessageMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumMessageMap::
_operator_isNotEqual (const GGS_typeEnumMessageMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstringlist & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeEnumMessageMap info  ;
    info.mMessageStringList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstringlist   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessageStringList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
modifier_setMMessageStringListForKey (C_Compiler & inLexique,
                        const GGS_lstringlist & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMMessageStringListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mMessageStringList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstringlist   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' message name is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstringlist & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' message name is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeEnumMessageMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumMessageMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumMessageMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEnumMessageMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeEnumMessageMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_typeEnumMessageMap::cEnumerator::_mMessageStringList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMessageStringList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@enumModifierDefinitionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumModifierDefinitionList::
elementOf_GGS_enumModifierDefinitionList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSourceState (argument_0),
mTargetState (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumModifierDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumModifierDefinitionList * _p = dynamic_cast <const elementOf_GGS_enumModifierDefinitionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSourceState._operator_isEqual (_p->mSourceState).boolValue ()
         && mTargetState._operator_isEqual (_p->mTargetState).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumModifierDefinitionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceState.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetState.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@enumModifierDefinitionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumModifierDefinitionList GGS_enumModifierDefinitionList::
_operator_concat (const GGS_enumModifierDefinitionList & inOperand) const {
  GGS_enumModifierDefinitionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
_dotAssign_operation (const GGS_enumModifierDefinitionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_enumModifierDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSourceState ;
          GGS_lstring  p_1 = p->mTargetState ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_typeInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSourceState,
                                _p->mTargetState,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumModifierDefinitionList  GGS_enumModifierDefinitionList::
constructor_emptyList (void) {
  GGS_enumModifierDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierDefinitionList  GGS_enumModifierDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  GGS_enumModifierDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
internalSubListWithRange (GGS_enumModifierDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mSourceState, _p->mTargetState, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumModifierDefinitionList GGS_enumModifierDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumModifierDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierDefinitionList GGS_enumModifierDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumModifierDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumModifierDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@enumModifierDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_typeInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceState ;
    _out_1 = _p->mTargetState ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_typeInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceState ;
    _out_1 = _p->mTargetState ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_typeInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceState ;
    _out_1 = _p->mTargetState ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_typeInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceState ;
    _out_1 = _p->mTargetState ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumModifierDefinitionList::
reader_mSourceStateAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceState ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumModifierDefinitionList::
reader_mTargetStateAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTargetState ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_enumModifierDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
modifier_setMSourceStateAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceState = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
modifier_setMTargetStateAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTargetState = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumModifierDefinitionList::cEnumerator::_mSourceState (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mSourceState ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumModifierDefinitionList::cEnumerator::_mTargetState (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mTargetState ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_enumModifierDefinitionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_enumModifierMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_enumModifierMap::e_enumModifierMap (void) :
mActionDefinitionList (),
mSignature (),
mArgumentTypeAndNameList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@enumModifierMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumModifierMap::
elementOf_GGS_enumModifierMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_enumModifierMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumModifierMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mActionDefinitionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mArgumentTypeAndNameList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumModifierMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_enumModifierMap * _p = dynamic_cast <const elementOf_GGS_enumModifierMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mActionDefinitionList._operator_isEqual (_p->mInfo.mActionDefinitionList)).boolValue ()
           && (mInfo.mSignature._operator_isEqual (_p->mInfo.mSignature)).boolValue ()
           && (mInfo.mArgumentTypeAndNameList._operator_isEqual (_p->mInfo.mArgumentTypeAndNameList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumModifierMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumModifierMap * info = (e_enumModifierMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_enumModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_enumModifierMap * info = (e_enumModifierMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierMap GGS_enumModifierMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumModifierMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_enumModifierMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumModifierMap::
_operator_isEqual (const GGS_enumModifierMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumModifierMap::
_operator_isNotEqual (const GGS_enumModifierMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_enumModifierDefinitionList & inParameter0,
                const GGS_L_EXsignature & inParameter1,
                const GGS_typeListeTypesEtNomsArgMethode & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_enumModifierMap info  ;
    info.mActionDefinitionList = inParameter0 ;
    info.mSignature = inParameter1 ;
    info.mArgumentTypeAndNameList = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_enumModifierDefinitionList   & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_typeListeTypesEtNomsArgMethode   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    outParameter2._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mActionDefinitionList ;
    outParameter1 = node->mInfo.mSignature ;
    outParameter2 = node->mInfo.mArgumentTypeAndNameList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
modifier_setMActionDefinitionListForKey (C_Compiler & inLexique,
                        const GGS_enumModifierDefinitionList & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMActionDefinitionListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mActionDefinitionList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
modifier_setMSignatureForKey (C_Compiler & inLexique,
                        const GGS_L_EXsignature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMSignatureForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mSignature = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
modifier_setMArgumentTypeAndNameListForKey (C_Compiler & inLexique,
                        const GGS_typeListeTypesEtNomsArgMethode & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMArgumentTypeAndNameListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mArgumentTypeAndNameList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_enumModifierDefinitionList   & outParameter0,
                                GGS_L_EXsignature   & outParameter1,
                                GGS_typeListeTypesEtNomsArgMethode   & outParameter2 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' modifier is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_enumModifierDefinitionList & inParameter0,
                                const GGS_L_EXsignature & inParameter1,
                                const GGS_typeListeTypesEtNomsArgMethode & inParameter2 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' modifier is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierMap GGS_enumModifierMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_enumModifierMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumModifierMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierMap GGS_enumModifierMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumModifierMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumModifierMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @enumModifierMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumModifierDefinitionList  & GGS_enumModifierMap::cEnumerator::_mActionDefinitionList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mActionDefinitionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_enumModifierMap::cEnumerator::_mSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeTypesEtNomsArgMethode  & GGS_enumModifierMap::cEnumerator::_mArgumentTypeAndNameList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mArgumentTypeAndNameList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@enumMethodDefinitionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMethodDefinitionList::
elementOf_GGS_enumMethodDefinitionList (const GGS_lstring & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSourceState (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMethodDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMethodDefinitionList * _p = dynamic_cast <const elementOf_GGS_enumMethodDefinitionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSourceState._operator_isEqual (_p->mSourceState).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMethodDefinitionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceState.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@enumMethodDefinitionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMethodDefinitionList GGS_enumMethodDefinitionList::
_operator_concat (const GGS_enumMethodDefinitionList & inOperand) const {
  GGS_enumMethodDefinitionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
_dotAssign_operation (const GGS_enumMethodDefinitionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_enumMethodDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSourceState ;
          GGS_typeInstructionList  p_1 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_typeInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSourceState,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMethodDefinitionList  GGS_enumMethodDefinitionList::
constructor_emptyList (void) {
  GGS_enumMethodDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodDefinitionList  GGS_enumMethodDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  GGS_enumMethodDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
internalSubListWithRange (GGS_enumMethodDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mSourceState, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMethodDefinitionList GGS_enumMethodDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMethodDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodDefinitionList GGS_enumMethodDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMethodDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMethodDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@enumMethodDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_typeInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceState ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_typeInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceState ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_typeInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceState ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_typeInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceState ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMethodDefinitionList::
reader_mSourceStateAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceState ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_enumMethodDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
modifier_setMSourceStateAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceState = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumMethodDefinitionList::cEnumerator::_mSourceState (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mSourceState ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_enumMethodDefinitionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_enumMethodMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_enumMethodMap::e_enumMethodMap (void) :
mActionDefinitionList (),
mSignature (),
mArgumentTypeAndNameList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@enumMethodMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMethodMap::
elementOf_GGS_enumMethodMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_enumMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMethodMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mActionDefinitionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mArgumentTypeAndNameList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMethodMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_enumMethodMap * _p = dynamic_cast <const elementOf_GGS_enumMethodMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mActionDefinitionList._operator_isEqual (_p->mInfo.mActionDefinitionList)).boolValue ()
           && (mInfo.mSignature._operator_isEqual (_p->mInfo.mSignature)).boolValue ()
           && (mInfo.mArgumentTypeAndNameList._operator_isEqual (_p->mInfo.mArgumentTypeAndNameList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumMethodMap * info = (e_enumMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_enumMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_enumMethodMap * info = (e_enumMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodMap GGS_enumMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_enumMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumMethodMap::
_operator_isEqual (const GGS_enumMethodMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumMethodMap::
_operator_isNotEqual (const GGS_enumMethodMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_enumMethodDefinitionList & inParameter0,
                const GGS_L_EXsignature & inParameter1,
                const GGS_typeListeTypesEtNomsArgMethode & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_enumMethodMap info  ;
    info.mActionDefinitionList = inParameter0 ;
    info.mSignature = inParameter1 ;
    info.mArgumentTypeAndNameList = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_enumMethodDefinitionList   & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_typeListeTypesEtNomsArgMethode   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    outParameter2._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mActionDefinitionList ;
    outParameter1 = node->mInfo.mSignature ;
    outParameter2 = node->mInfo.mArgumentTypeAndNameList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
modifier_setMActionDefinitionListForKey (C_Compiler & inLexique,
                        const GGS_enumMethodDefinitionList & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMActionDefinitionListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mActionDefinitionList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
modifier_setMSignatureForKey (C_Compiler & inLexique,
                        const GGS_L_EXsignature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMSignatureForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mSignature = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
modifier_setMArgumentTypeAndNameListForKey (C_Compiler & inLexique,
                        const GGS_typeListeTypesEtNomsArgMethode & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMArgumentTypeAndNameListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mArgumentTypeAndNameList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_enumMethodDefinitionList   & outParameter0,
                                GGS_L_EXsignature   & outParameter1,
                                GGS_typeListeTypesEtNomsArgMethode   & outParameter2 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' method is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_enumMethodDefinitionList & inParameter0,
                                const GGS_L_EXsignature & inParameter1,
                                const GGS_typeListeTypesEtNomsArgMethode & inParameter2 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' method is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodMap GGS_enumMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_enumMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodMap GGS_enumMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMethodMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @enumMethodMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumMethodDefinitionList  & GGS_enumMethodMap::cEnumerator::_mActionDefinitionList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mActionDefinitionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_enumMethodMap::cEnumerator::_mSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeTypesEtNomsArgMethode  & GGS_enumMethodMap::cEnumerator::_mArgumentTypeAndNameList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mArgumentTypeAndNameList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@enumOperatorDefinitionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumOperatorDefinitionList::
elementOf_GGS_enumOperatorDefinitionList (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_typeInstructionList & argument_6
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLeftSourceState (argument_0),
mLeftSourceStateIndex (argument_1),
mRightSourceState (argument_2),
mRightSourceStateIndex (argument_3),
mTargetState (argument_4),
mTargetStateIndex (argument_5),
mInstructionList (argument_6) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumOperatorDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumOperatorDefinitionList * _p = dynamic_cast <const elementOf_GGS_enumOperatorDefinitionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLeftSourceState._operator_isEqual (_p->mLeftSourceState).boolValue ()
         && mLeftSourceStateIndex._operator_isEqual (_p->mLeftSourceStateIndex).boolValue ()
         && mRightSourceState._operator_isEqual (_p->mRightSourceState).boolValue ()
         && mRightSourceStateIndex._operator_isEqual (_p->mRightSourceStateIndex).boolValue ()
         && mTargetState._operator_isEqual (_p->mTargetState).boolValue ()
         && mTargetStateIndex._operator_isEqual (_p->mTargetStateIndex).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumOperatorDefinitionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftSourceState.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftSourceStateIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightSourceState.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightSourceStateIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetState.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetStateIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@enumOperatorDefinitionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_luint & argument_3,
                    const GGS_lstring & argument_4,
                    const GGS_luint & argument_5,
                    const GGS_typeInstructionList & argument_6
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_luint & argument_3,
                    const GGS_lstring & argument_4,
                    const GGS_luint & argument_5,
                    const GGS_typeInstructionList & argument_6
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_typeInstructionList & argument_6) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()&& argument_3._isBuilt ()&& argument_4._isBuilt ()&& argument_5._isBuilt ()&& argument_6._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumOperatorDefinitionList GGS_enumOperatorDefinitionList::
_operator_concat (const GGS_enumOperatorDefinitionList & inOperand) const {
  GGS_enumOperatorDefinitionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
_dotAssign_operation (const GGS_enumOperatorDefinitionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_enumOperatorDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLeftSourceState ;
          GGS_luint  p_1 = p->mLeftSourceStateIndex ;
          GGS_lstring  p_2 = p->mRightSourceState ;
          GGS_luint  p_3 = p->mRightSourceStateIndex ;
          GGS_lstring  p_4 = p->mTargetState ;
          GGS_luint  p_5 = p->mTargetStateIndex ;
          GGS_typeInstructionList  p_6 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5, p_6 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_luint & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_luint & argument_3,
                     const GGS_lstring & argument_4,
                     const GGS_luint & argument_5,
                     const GGS_typeInstructionList & argument_6
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLeftSourceState,
                                _p->mLeftSourceStateIndex,
                                _p->mRightSourceState,
                                _p->mRightSourceStateIndex,
                                _p->mTargetState,
                                _p->mTargetStateIndex,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumOperatorDefinitionList  GGS_enumOperatorDefinitionList::
constructor_emptyList (void) {
  GGS_enumOperatorDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorDefinitionList  GGS_enumOperatorDefinitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_typeInstructionList & argument_6) {
  GGS_enumOperatorDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
internalSubListWithRange (GGS_enumOperatorDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mLeftSourceState, _p->mLeftSourceStateIndex, _p->mRightSourceState, _p->mRightSourceStateIndex, _p->mTargetState, _p->mTargetStateIndex, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumOperatorDefinitionList GGS_enumOperatorDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumOperatorDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorDefinitionList GGS_enumOperatorDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumOperatorDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumOperatorDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@enumOperatorDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_luint & _out_1,
              GGS_lstring & _out_2,
              GGS_luint & _out_3,
              GGS_lstring & _out_4,
              GGS_luint & _out_5,
              GGS_typeInstructionList & _out_6
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftSourceState ;
    _out_1 = _p->mLeftSourceStateIndex ;
    _out_2 = _p->mRightSourceState ;
    _out_3 = _p->mRightSourceStateIndex ;
    _out_4 = _p->mTargetState ;
    _out_5 = _p->mTargetStateIndex ;
    _out_6 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
    _out_4._drop () ;
    _out_5._drop () ;
    _out_6._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_luint & _out_1,
             GGS_lstring & _out_2,
             GGS_luint & _out_3,
             GGS_lstring & _out_4,
             GGS_luint & _out_5,
             GGS_typeInstructionList & _out_6
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftSourceState ;
    _out_1 = _p->mLeftSourceStateIndex ;
    _out_2 = _p->mRightSourceState ;
    _out_3 = _p->mRightSourceStateIndex ;
    _out_4 = _p->mTargetState ;
    _out_5 = _p->mTargetStateIndex ;
    _out_6 = _p->mInstructionList ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
    _out_4._drop () ;
    _out_5._drop () ;
    _out_6._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_luint & _out_1,
                 GGS_lstring & _out_2,
                 GGS_luint & _out_3,
                 GGS_lstring & _out_4,
                 GGS_luint & _out_5,
                 GGS_typeInstructionList & _out_6
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftSourceState ;
    _out_1 = _p->mLeftSourceStateIndex ;
    _out_2 = _p->mRightSourceState ;
    _out_3 = _p->mRightSourceStateIndex ;
    _out_4 = _p->mTargetState ;
    _out_5 = _p->mTargetStateIndex ;
    _out_6 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
    _out_4._drop () ;
    _out_5._drop () ;
    _out_6._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_luint & _out_1,
                GGS_lstring & _out_2,
                GGS_luint & _out_3,
                GGS_lstring & _out_4,
                GGS_luint & _out_5,
                GGS_typeInstructionList & _out_6
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftSourceState ;
    _out_1 = _p->mLeftSourceStateIndex ;
    _out_2 = _p->mRightSourceState ;
    _out_3 = _p->mRightSourceStateIndex ;
    _out_4 = _p->mTargetState ;
    _out_5 = _p->mTargetStateIndex ;
    _out_6 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
    _out_4._drop () ;
    _out_5._drop () ;
    _out_6._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumOperatorDefinitionList::
reader_mLeftSourceStateAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLeftSourceState ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_enumOperatorDefinitionList::
reader_mLeftSourceStateIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLeftSourceStateIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumOperatorDefinitionList::
reader_mRightSourceStateAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRightSourceState ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_enumOperatorDefinitionList::
reader_mRightSourceStateIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRightSourceStateIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumOperatorDefinitionList::
reader_mTargetStateAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTargetState ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_enumOperatorDefinitionList::
reader_mTargetStateIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTargetStateIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_enumOperatorDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_setMLeftSourceStateAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLeftSourceState = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_setMLeftSourceStateIndexAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLeftSourceStateIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_setMRightSourceStateAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRightSourceState = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_setMRightSourceStateIndexAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRightSourceStateIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_setMTargetStateAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTargetState = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_setMTargetStateIndexAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTargetStateIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumOperatorDefinitionList::cEnumerator::_mLeftSourceState (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mLeftSourceState ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_enumOperatorDefinitionList::cEnumerator::_mLeftSourceStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mLeftSourceStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumOperatorDefinitionList::cEnumerator::_mRightSourceState (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mRightSourceState ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_enumOperatorDefinitionList::cEnumerator::_mRightSourceStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mRightSourceStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumOperatorDefinitionList::cEnumerator::_mTargetState (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mTargetState ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_enumOperatorDefinitionList::cEnumerator::_mTargetStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mTargetStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_enumOperatorDefinitionList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_enumOperatorMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_enumOperatorMap::e_enumOperatorMap (void) :
mActionDefinitionList (),
mSignature (),
mArgumentTypeAndNameList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@enumOperatorMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumOperatorMap::
elementOf_GGS_enumOperatorMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_enumOperatorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumOperatorMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mActionDefinitionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mArgumentTypeAndNameList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumOperatorMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_enumOperatorMap * _p = dynamic_cast <const elementOf_GGS_enumOperatorMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mActionDefinitionList._operator_isEqual (_p->mInfo.mActionDefinitionList)).boolValue ()
           && (mInfo.mSignature._operator_isEqual (_p->mInfo.mSignature)).boolValue ()
           && (mInfo.mArgumentTypeAndNameList._operator_isEqual (_p->mInfo.mArgumentTypeAndNameList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumOperatorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumOperatorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumOperatorMap * info = (e_enumOperatorMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_enumOperatorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_enumOperatorMap * info = (e_enumOperatorMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorMap GGS_enumOperatorMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumOperatorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_enumOperatorMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumOperatorMap::
_operator_isEqual (const GGS_enumOperatorMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumOperatorMap::
_operator_isNotEqual (const GGS_enumOperatorMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_enumOperatorDefinitionList & inParameter0,
                const GGS_L_EXsignature & inParameter1,
                const GGS_typeListeTypesEtNomsArgMethode & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_enumOperatorMap info  ;
    info.mActionDefinitionList = inParameter0 ;
    info.mSignature = inParameter1 ;
    info.mArgumentTypeAndNameList = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_enumOperatorDefinitionList   & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_typeListeTypesEtNomsArgMethode   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    outParameter2._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mActionDefinitionList ;
    outParameter1 = node->mInfo.mSignature ;
    outParameter2 = node->mInfo.mArgumentTypeAndNameList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
modifier_setMActionDefinitionListForKey (C_Compiler & inLexique,
                        const GGS_enumOperatorDefinitionList & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMActionDefinitionListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mActionDefinitionList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
modifier_setMSignatureForKey (C_Compiler & inLexique,
                        const GGS_L_EXsignature & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMSignatureForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mSignature = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
modifier_setMArgumentTypeAndNameListForKey (C_Compiler & inLexique,
                        const GGS_typeListeTypesEtNomsArgMethode & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMArgumentTypeAndNameListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mArgumentTypeAndNameList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_enumOperatorDefinitionList   & outParameter0,
                                GGS_L_EXsignature   & outParameter1,
                                GGS_typeListeTypesEtNomsArgMethode   & outParameter2 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' method is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_enumOperatorDefinitionList & inParameter0,
                                const GGS_L_EXsignature & inParameter1,
                                const GGS_typeListeTypesEtNomsArgMethode & inParameter2 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' method is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorMap GGS_enumOperatorMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_enumOperatorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumOperatorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorMap GGS_enumOperatorMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumOperatorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumOperatorMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @enumOperatorMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumOperatorDefinitionList  & GGS_enumOperatorMap::cEnumerator::_mActionDefinitionList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mActionDefinitionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_EXsignature  & GGS_enumOperatorMap::cEnumerator::_mSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeTypesEtNomsArgMethode  & GGS_enumOperatorMap::cEnumerator::_mArgumentTypeAndNameList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mArgumentTypeAndNameList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeGalgas_enum'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_enum::
cPtr_typeGalgas_enum (const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2,
                                const GGS_enumModifierMap & argument_3,
                                const GGS_enumMethodMap & argument_4,
                                const GGS_enumOperatorMap & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEnumTypeName (argument_0),
mEnumConstantesMap (argument_1),
mMessagesMap (argument_2),
mModifierMap (argument_3),
mMethodMap (argument_4),
mOperatorMap (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_enum * GGS_typeGalgas_enum::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_enum *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_enum::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgas_enum * _p = dynamic_cast <const cPtr_typeGalgas_enum *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumTypeName._operator_isEqual (_p->mEnumTypeName).boolValue ()
         && mEnumConstantesMap._operator_isEqual (_p->mEnumConstantesMap).boolValue ()
         && mMessagesMap._operator_isEqual (_p->mMessagesMap).boolValue ()
         && mModifierMap._operator_isEqual (_p->mModifierMap).boolValue ()
         && mMethodMap._operator_isEqual (_p->mMethodMap).boolValue ()
         && mOperatorMap._operator_isEqual (_p->mOperatorMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
method_getTypeName (C_Compiler & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outTypeName = mEnumTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3184)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
method_handleConstructorCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList,
                                GGS_bool& var_cas_outHasLexiqueAndLocationArguments COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outHasLexiqueAndLocationArguments = GGS_bool (true, true) ;
  GGS_bool var_cas_hasConstructor ;
  const GGS_enumConstantMap  _temp_134322 = mEnumConstantesMap ;
  if (_temp_134322._isBuilt ()) {
    _temp_134322 (HERE)->method_searchKey (_inLexique, var_cas_inClassMethodName, var_cas_hasConstructor COMMA_SOURCE_FILE_AT_LINE (3195)) ;
  }
  if ((var_cas_hasConstructor).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "the '"))._operator_concat (var_cas_inClassMethodName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3200))))._operator_concat (GGS_string (true, "' is not declared as constructor")) COMMA_SOURCE_FILE_AT_LINE (3203)) ;
    var_cas_outAccessorTypesList._drop () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
method_handleModifierCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumModifierDefinitionList  automatic_var_6 ;
  GGS_typeListeTypesEtNomsArgMethode  automatic_var_7 ;
  const GGS_enumModifierMap  _temp_134810 = mModifierMap ;
  if (_temp_134810._isBuilt ()) {
    _temp_134810 (HERE)->method_searchKey (_inLexique, var_cas_inModifierName, automatic_var_6, var_cas_outModifierSignature, automatic_var_7 COMMA_SOURCE_FILE_AT_LINE (3212)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
method_handleMethodInstructionCall (C_Compiler & _inLexique,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_EXcategoryMethodMap  /* var_cas_inCategoryMethodMap */,
                                GGS_L_EXsignature & var_cas_outReaderSignature,
                                GGS_string& var_cas_outCategoryMethodClassBaseName COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outCategoryMethodClassBaseName = GGS_string (true, "") ;
  GGS_enumMethodDefinitionList  automatic_var_8 ;
  GGS_typeListeTypesEtNomsArgMethode  automatic_var_9 ;
  const GGS_enumMethodMap  _temp_135172 = mMethodMap ;
  if (_temp_135172._isBuilt ()) {
    _temp_135172 (HERE)->method_searchKey (_inLexique, var_cas_inMethodName, automatic_var_8, var_cas_outReaderSignature, automatic_var_9 COMMA_SOURCE_FILE_AT_LINE (3224)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_enum:"
           << mEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEnumConstantesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMessagesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModifierMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMethodMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperatorMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_enum::
static_string_message_messageGalgasType (void) {
  return "an enum type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_enum::
message_messageGalgasType (void) const {
  return "an enum type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_enum::
_message (void) const {
  return "an enum type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_enum::
_static_message (void) {
  return "an enum type" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgas_enum (& typeid (cPtr_typeGalgas_enum), & typeid (cPtr_AC_galgasType), "an enum type") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgas_enum::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgas_enum ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_enum'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_enum::
GGS_typeGalgas_enum (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_enum::
GGS_typeGalgas_enum (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeGalgas_enum GGS_typeGalgas_enum::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_enum _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgas_enum *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgas_enum) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeGalgas_enum (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgas_enum),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_enum GGS_typeGalgas_enum::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_enumConstantMap & argument_1,
                 const GGS_typeEnumMessageMap & argument_2,
                 const GGS_enumModifierMap & argument_3,
                 const GGS_enumMethodMap & argument_4,
                 const GGS_enumOperatorMap & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgas_enum result ;
  macroMyNew (result.mPointer, cPtr_typeGalgas_enum (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_enum::
reader_messageGalgasType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeGalgas_enum * p = (cPtr_typeGalgas_enum *) mPointer ;
    result = GGS_string (true, p->message_messageGalgasType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgas_enum::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_enum *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap  GGS_typeGalgas_enum::
reader_mEnumConstantesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumConstantMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_enum *) mPointer)->mEnumConstantesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap  GGS_typeGalgas_enum::
reader_mMessagesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumMessageMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_enum *) mPointer)->mMessagesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierMap  GGS_typeGalgas_enum::
reader_mModifierMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumModifierMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_enum *) mPointer)->mModifierMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodMap  GGS_typeGalgas_enum::
reader_mMethodMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMethodMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_enum *) mPointer)->mMethodMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorMap  GGS_typeGalgas_enum::
reader_mOperatorMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumOperatorMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_enum *) mPointer)->mOperatorMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgas_enum::actualTypeName (void) const {
  return "typeGalgas_enum" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgas_enum ("typeGalgas_enum", gClassInfoFor__AC_galgasType) ;

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "checkAssignmentTypesCompatibility"        *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkAssignmentTypesCompatibility (C_Compiler & _inLexique,
                                const GGS_AC_galgasType   var_cas_inFormalType,
                                const GGS_AC_galgasType   var_cas_inEffectiveType,
                                const GGS_location   var_cas_inErrorLocation,
                                const GGS_bool  var_cas_inAcceptPolymorphism COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkAssignmentTypesCompatibility at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (var_cas_inFormalType._isBuilt () && var_cas_inEffectiveType._isBuilt ()) {
    cPtr_AC_galgasType * ptr_135894 = var_cas_inFormalType (HERE) ;
    cPtr_AC_galgasType * ptr_135912 = var_cas_inEffectiveType (HERE) ;
    cPtr_typeGalgas_binaryset * operand_135894 = dynamic_cast <cPtr_typeGalgas_binaryset *> (ptr_135894) ;
    cPtr_typeGalgas_binaryset * operand_135912 = dynamic_cast <cPtr_typeGalgas_binaryset *> (ptr_135912) ;
    if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
    }else{
      cPtr_typeGalgas_stringset * operand_135894 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_135894) ;
      cPtr_typeGalgas_stringset * operand_135912 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_135912) ;
      if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
      }else{
        cPtr_typeGalgas_uint * operand_135894 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_135894) ;
        cPtr_typeGalgas_uint * operand_135912 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_135912) ;
        if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
        }else{
          cPtr_typeGalgas_sint * operand_135894 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_135894) ;
          cPtr_typeGalgas_sint * operand_135912 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_135912) ;
          if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
          }else{
            cPtr_typeGalgas_uint64 * operand_135894 = dynamic_cast <cPtr_typeGalgas_uint64 *> (ptr_135894) ;
            cPtr_typeGalgas_uint64 * operand_135912 = dynamic_cast <cPtr_typeGalgas_uint64 *> (ptr_135912) ;
            if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
            }else{
              cPtr_typeGalgas_sint64 * operand_135894 = dynamic_cast <cPtr_typeGalgas_sint64 *> (ptr_135894) ;
              cPtr_typeGalgas_sint64 * operand_135912 = dynamic_cast <cPtr_typeGalgas_sint64 *> (ptr_135912) ;
              if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
              }else{
                cPtr_typeGalgas_char * operand_135894 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_135894) ;
                cPtr_typeGalgas_char * operand_135912 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_135912) ;
                if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                }else{
                  cPtr_typeGalgas_string * operand_135894 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_135894) ;
                  cPtr_typeGalgas_string * operand_135912 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_135912) ;
                  if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                  }else{
                    cPtr_typeGalgas_bool * operand_135894 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_135894) ;
                    cPtr_typeGalgas_bool * operand_135912 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_135912) ;
                    if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                    }else{
                      cPtr_typeGalgas_double * operand_135894 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_135894) ;
                      cPtr_typeGalgas_double * operand_135912 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_135912) ;
                      if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                      }else{
                        cPtr_typeGalgas_lbool * operand_135894 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_135894) ;
                        cPtr_typeGalgas_lbool * operand_135912 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_135912) ;
                        if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                        }else{
                          cPtr_typeGalgas_lchar * operand_135894 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_135894) ;
                          cPtr_typeGalgas_lchar * operand_135912 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_135912) ;
                          if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                          }else{
                            cPtr_typeGalgas_luint * operand_135894 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_135894) ;
                            cPtr_typeGalgas_luint * operand_135912 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_135912) ;
                            if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                            }else{
                              cPtr_typeGalgas_lsint * operand_135894 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_135894) ;
                              cPtr_typeGalgas_lsint * operand_135912 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_135912) ;
                              if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                              }else{
                                cPtr_typeGalgas_luint64 * operand_135894 = dynamic_cast <cPtr_typeGalgas_luint64 *> (ptr_135894) ;
                                cPtr_typeGalgas_luint64 * operand_135912 = dynamic_cast <cPtr_typeGalgas_luint64 *> (ptr_135912) ;
                                if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                }else{
                                  cPtr_typeGalgas_lsint64 * operand_135894 = dynamic_cast <cPtr_typeGalgas_lsint64 *> (ptr_135894) ;
                                  cPtr_typeGalgas_lsint64 * operand_135912 = dynamic_cast <cPtr_typeGalgas_lsint64 *> (ptr_135912) ;
                                  if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                  }else{
                                    cPtr_typeGalgas_ldouble * operand_135894 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_135894) ;
                                    cPtr_typeGalgas_ldouble * operand_135912 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_135912) ;
                                    if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                    }else{
                                      cPtr_typeGalgas_lstring * operand_135894 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_135894) ;
                                      cPtr_typeGalgas_lstring * operand_135912 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_135912) ;
                                      if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                      }else{
                                        cPtr_typeGalgas_location * operand_135894 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_135894) ;
                                        cPtr_typeGalgas_location * operand_135912 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_135912) ;
                                        if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                        }else{
                                          cPtr_typeGalgas_filewrapper * operand_135894 = dynamic_cast <cPtr_typeGalgas_filewrapper *> (ptr_135894) ;
                                          cPtr_typeGalgas_filewrapper * operand_135912 = dynamic_cast <cPtr_typeGalgas_filewrapper *> (ptr_135912) ;
                                          if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                          }else{
                                            cPtr_typeGalgasStructType * operand_135894 = dynamic_cast <cPtr_typeGalgasStructType *> (ptr_135894) ;
                                            cPtr_typeGalgasStructType * operand_135912 = dynamic_cast <cPtr_typeGalgasStructType *> (ptr_135912) ;
                                            if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                              GGS_bool var_cas_accept ;
                                              var_cas_accept = (operand_135894->mStructTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3267)))._operator_isEqual (operand_135912->mStructTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3267))) ;
                                              if (((var_cas_accept)._operator_not ()).isBuiltAndTrue ()) {
                                                var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "I was expecting the struct type '@"))._operator_concat (operand_135894->mStructTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3269))))._operator_concat (GGS_string (true, "', I have got the struc type '@")))._operator_concat (operand_135912->mStructTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3270))))._operator_concat (GGS_string (true, "\"")) COMMA_SOURCE_FILE_AT_LINE (3271)) ;
                                              }
                                            }else{
                                              cPtr_typeGalgasUndefinedClassType * operand_135894 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_135894) ;
                                              cPtr_typeGalgasClassType * operand_135912 = dynamic_cast <cPtr_typeGalgasClassType *> (ptr_135912) ;
                                              if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                                GGS_bool var_cas_accept ;
                                                var_cas_accept = (operand_135894->mClassTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3275)))._operator_isEqual (operand_135912->mClassTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3275))) ;
                                                if ((((var_cas_accept)._operator_not ())._operator_and (var_cas_inAcceptPolymorphism)).isBuiltAndTrue ()) {
                                                  var_cas_accept = operand_135912->mAncestorClassesMap.reader_hasKey (_inLexique, operand_135894->mClassTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3277)) COMMA_SOURCE_FILE_AT_LINE (3277)) ;
                                                }
                                                if (((var_cas_accept)._operator_not ()).isBuiltAndTrue ()) {
                                                  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "I was expecting the class type '@"))._operator_concat (operand_135894->mClassTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3280))))._operator_concat (GGS_string (true, "', I have got the class type '@")))._operator_concat (operand_135912->mClassTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3281))))._operator_concat (GGS_string (true, "\"")) COMMA_SOURCE_FILE_AT_LINE (3282)) ;
                                                }
                                              }else{
                                                cPtr_typeGalgasUndefinedMapindexType * operand_135894 = dynamic_cast <cPtr_typeGalgasUndefinedMapindexType *> (ptr_135894) ;
                                                cPtr_typeGalgasUndefinedMapindexType * operand_135912 = dynamic_cast <cPtr_typeGalgasUndefinedMapindexType *> (ptr_135912) ;
                                                if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                                  if (((operand_135894->mMapindexTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3285)))._operator_isNotEqual (operand_135912->mMapindexTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3285)))).isBuiltAndTrue ()) {
                                                    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "I was expecting the map index type '@"))._operator_concat (operand_135894->mMapindexTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3286))))._operator_concat (GGS_string (true, "', I have got the map index type '@")))._operator_concat (operand_135912->mMapindexTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3287))))._operator_concat (GGS_string (true, "\"")) COMMA_SOURCE_FILE_AT_LINE (3288)) ;
                                                  }
                                                }else{
                                                  cPtr_typeGalgasUndefinedListType * operand_135894 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_135894) ;
                                                  cPtr_typeGalgasUndefinedListType * operand_135912 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_135912) ;
                                                  if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                                    if (((operand_135894->mListTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3291)))._operator_isNotEqual (operand_135912->mListTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3291)))).isBuiltAndTrue ()) {
                                                      var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "I was expecting the list type '@"))._operator_concat (operand_135894->mListTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3292))))._operator_concat (GGS_string (true, "', I have got the list type '@")))._operator_concat (operand_135912->mListTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3293))))._operator_concat (GGS_string (true, "\"")) COMMA_SOURCE_FILE_AT_LINE (3294)) ;
                                                    }
                                                  }else{
                                                    cPtr_typeGalgasUndefinedSortedListType * operand_135894 = dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (ptr_135894) ;
                                                    cPtr_typeGalgasUndefinedSortedListType * operand_135912 = dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (ptr_135912) ;
                                                    if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                                      if (((operand_135894->mListTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3297)))._operator_isNotEqual (operand_135912->mListTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3297)))).isBuiltAndTrue ()) {
                                                        var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "I was expecting the sorted list type '@"))._operator_concat (operand_135894->mListTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3298))))._operator_concat (GGS_string (true, "', I have got the sorted list type '@")))._operator_concat (operand_135912->mListTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3299))))._operator_concat (GGS_string (true, "\"")) COMMA_SOURCE_FILE_AT_LINE (3300)) ;
                                                      }
                                                    }else{
                                                      cPtr_typeGalgasUndefinedMapType * operand_135894 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_135894) ;
                                                      cPtr_typeGalgasUndefinedMapType * operand_135912 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_135912) ;
                                                      if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                                        if (((operand_135894->mMapTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3303)))._operator_isNotEqual (operand_135912->mMapTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3303)))).isBuiltAndTrue ()) {
                                                          var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "I was expecting the map type '@"))._operator_concat (operand_135894->mMapTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3304))))._operator_concat (GGS_string (true, "', I have got the map type '@")))._operator_concat (operand_135912->mMapTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3305))))._operator_concat (GGS_string (true, "\"")) COMMA_SOURCE_FILE_AT_LINE (3306)) ;
                                                        }
                                                      }else{
                                                        cPtr_typeGalgasUndefinedClassType * operand_135894 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_135894) ;
                                                        cPtr_typeGalgasUndefinedClassType * operand_135912 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_135912) ;
                                                        if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                                          if (((operand_135894->mClassTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3309)))._operator_isNotEqual (operand_135912->mClassTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3309)))).isBuiltAndTrue ()) {
                                                            var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "I was expecting the class type '@"))._operator_concat (operand_135894->mClassTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3310))))._operator_concat (GGS_string (true, "', I have got the class type '@")))._operator_concat (operand_135912->mClassTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3311))))._operator_concat (GGS_string (true, "\"")) COMMA_SOURCE_FILE_AT_LINE (3312)) ;
                                                          }
                                                        }else{
                                                          cPtr_typeGalgasListmapType * operand_135894 = dynamic_cast <cPtr_typeGalgasListmapType *> (ptr_135894) ;
                                                          cPtr_typeGalgasListmapType * operand_135912 = dynamic_cast <cPtr_typeGalgasListmapType *> (ptr_135912) ;
                                                          if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                                            if (((operand_135894->mListmapTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3316)))._operator_isNotEqual (operand_135912->mListmapTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3316)))).isBuiltAndTrue ()) {
                                                              var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "I was expecting an extern variable of listmap '@"))._operator_concat (operand_135894->mListmapTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3317))))._operator_concat (GGS_string (true, "' type variable, and I got a listmap '@")))._operator_concat (operand_135912->mListmapTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3318))))._operator_concat (GGS_string (true, "' type variable")) COMMA_SOURCE_FILE_AT_LINE (3319)) ;
                                                            }
                                                          }else{
                                                            cPtr_typeGalgasUndefinedExternType * operand_135894 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_135894) ;
                                                            cPtr_typeGalgasUndefinedExternType * operand_135912 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_135912) ;
                                                            if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                                              if (((operand_135894->mGalgasClassName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3323)))._operator_isNotEqual (operand_135912->mGalgasClassName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3323)))).isBuiltAndTrue ()) {
                                                                var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "I was expecting an extern variable of extern '@"))._operator_concat (operand_135894->mGalgasClassName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3324))))._operator_concat (GGS_string (true, "' type variable, and I got an extern '@")))._operator_concat (operand_135912->mGalgasClassName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3325))))._operator_concat (GGS_string (true, "' type variable")) COMMA_SOURCE_FILE_AT_LINE (3326)) ;
                                                              }
                                                            }else{
                                                              cPtr_typeGalgas_enum * operand_135894 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_135894) ;
                                                              cPtr_typeGalgas_enum * operand_135912 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_135912) ;
                                                              if ((operand_135894 != NULL) && (operand_135912 != NULL)) {
                                                                if (((operand_135894->mEnumTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3330)))._operator_isNotEqual (operand_135912->mEnumTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3330)))).isBuiltAndTrue ()) {
                                                                  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "I was expecting an enum variable of  '@"))._operator_concat (operand_135894->mEnumTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3331))))._operator_concat (GGS_string (true, "' type variable, and I got an enum '@")))._operator_concat (operand_135912->mEnumTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3332))))._operator_concat (GGS_string (true, "' type variable")) COMMA_SOURCE_FILE_AT_LINE (3333)) ;
                                                                }
                                                              }else{
                                                                var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((var_cas_inFormalType.reader_messageGalgasType (_inLexique COMMA_SOURCE_FILE_AT_LINE (3336)))._operator_concat (GGS_string (true, " is not compatible with ")))._operator_concat (var_cas_inEffectiveType.reader_messageGalgasType (_inLexique COMMA_SOURCE_FILE_AT_LINE (3336))) COMMA_SOURCE_FILE_AT_LINE (3337)) ;
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkAssignmentTypesCompatibility\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of routine "verifierCompatibiliteSignatures"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteSignatures (C_Compiler & _inLexique,
                                const GGS_L_EXsignature   var_cas_signatureReference,
                                const GGS_L_EXsignature   var_cas_signatureTestee,
                                const GGS_location   var_cas_ouSignalerErreur COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_verifierCompatibiliteSignatures at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (((var_cas_signatureReference.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (3351)))._operator_strictInf (var_cas_signatureTestee.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (3351)))).isBuiltAndTrue ()) {
    var_cas_ouSignalerErreur.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "there are too much parameters") COMMA_SOURCE_FILE_AT_LINE (3353)) ;
  }else if (((var_cas_signatureReference.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (3353)))._operator_strictSup (var_cas_signatureTestee.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (3353)))).isBuiltAndTrue ()) {
    var_cas_ouSignalerErreur.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more parameters missing") COMMA_SOURCE_FILE_AT_LINE (3355)) ;
  }else{
    {
      GGS_L_EXsignature::cEnumerator enumerator_142241 (var_cas_signatureReference, true) ;
      const GGS_L_EXsignature::cElement * operand_142241 = NULL ;
      GGS_L_EXsignature::cEnumerator enumerator_142338 (var_cas_signatureTestee, true) ;
      const GGS_L_EXsignature::cElement * operand_142338 = NULL ;
      while (((operand_142241 = enumerator_142241.nextObject ()))
          && ((operand_142338 = enumerator_142338.nextObject ()))) {
        macroValidPointer (operand_142241) ;
        macroValidPointer (operand_142338) ;
        ::routine_checkAssignmentTypesCompatibility (_inLexique,  operand_142241->mType,  operand_142338->mType,  var_cas_ouSignalerErreur,  GGS_bool (true, false) COMMA_SOURCE_FILE_AT_LINE (3358)) ;
        if (((operand_142241->mFormalArgumentPassingMode)._operator_isNotEqual (operand_142338->mFormalArgumentPassingMode)).isBuiltAndTrue ()) {
          var_cas_ouSignalerErreur.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((operand_142338->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique COMMA_SOURCE_FILE_AT_LINE (3365)))._operator_concat (GGS_string (true, " is not compatible with ")))._operator_concat (operand_142338->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique COMMA_SOURCE_FILE_AT_LINE (3366))) COMMA_SOURCE_FILE_AT_LINE (3367)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_verifierCompatibiliteSignatures\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_M_cli_options'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_cli_options::e_M_cli_options (void) :
mOptionChar (),
mOptionString (),
mComment (),
mDefaultValue () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@M_cli_options'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_cli_options::
elementOf_GGS_M_cli_options (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_cli_options & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_cli_options::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mOptionChar.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mOptionString.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mComment.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDefaultValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_cli_options::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_cli_options * _p = dynamic_cast <const elementOf_GGS_M_cli_options *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mOptionChar._operator_isEqual (_p->mInfo.mOptionChar)).boolValue ()
           && (mInfo.mOptionString._operator_isEqual (_p->mInfo.mOptionString)).boolValue ()
           && (mInfo.mComment._operator_isEqual (_p->mInfo.mComment)).boolValue ()
           && (mInfo.mDefaultValue._operator_isEqual (_p->mInfo.mDefaultValue)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_cli_options::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_cli_options *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_cli_options * info = (e_M_cli_options *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_cli_options *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_cli_options * info = (e_M_cli_options *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_cli_options result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_cli_options info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_cli_options::
_operator_isEqual (const GGS_M_cli_options & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_cli_options::
_operator_isNotEqual (const GGS_M_cli_options & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lchar & inParameter0,
                const GGS_lstring & inParameter1,
                const GGS_lstring & inParameter2,
                const GGS_string& inParameter3,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inParameter3._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_cli_options info  ;
    info.mOptionChar = inParameter0 ;
    info.mOptionString = inParameter1 ;
    info.mComment = inParameter2 ;
    info.mDefaultValue = inParameter3 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lchar   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_string  & outParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    outParameter2._drop () ;
    outParameter3._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mOptionChar ;
    outParameter1 = node->mInfo.mOptionString ;
    outParameter2 = node->mInfo.mComment ;
    outParameter3 = node->mInfo.mDefaultValue ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
modifier_setMOptionCharForKey (C_Compiler & inLexique,
                        const GGS_lchar & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMOptionCharForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mOptionChar = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
modifier_setMOptionStringForKey (C_Compiler & inLexique,
                        const GGS_lstring & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMOptionStringForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mOptionString = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
modifier_setMCommentForKey (C_Compiler & inLexique,
                        const GGS_lstring & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMCommentForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mComment = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
modifier_setMDefaultValueForKey (C_Compiler & inLexique,
                        const GGS_string& inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMDefaultValueForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mDefaultValue = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lchar   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_lstring   & outParameter2,
                                GGS_string  & outParameter3 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' command line option is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lchar & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_lstring & inParameter2,
                                const GGS_string& inParameter3 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' command line option has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_cli_options & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_cli_options result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_cli_options result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_cli_options::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_cli_options " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lchar  & GGS_M_cli_options::cEnumerator::_mOptionChar (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mOptionChar ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_M_cli_options::cEnumerator::_mOptionString (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mOptionString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_M_cli_options::cEnumerator::_mComment (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mComment ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_M_cli_options::cEnumerator::_mDefaultValue (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDefaultValue ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_M_optionComponents'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_optionComponents::e_M_optionComponents (void) :
mBoolOptionsMap (),
mUintOptionsMap (),
mStringOptionsMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@M_optionComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_optionComponents::
elementOf_GGS_M_optionComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_optionComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_optionComponents::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mBoolOptionsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mUintOptionsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mStringOptionsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_optionComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_optionComponents * _p = dynamic_cast <const elementOf_GGS_M_optionComponents *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mBoolOptionsMap._operator_isEqual (_p->mInfo.mBoolOptionsMap)).boolValue ()
           && (mInfo.mUintOptionsMap._operator_isEqual (_p->mInfo.mUintOptionsMap)).boolValue ()
           && (mInfo.mStringOptionsMap._operator_isEqual (_p->mInfo.mStringOptionsMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_optionComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_optionComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_optionComponents * info = (e_M_optionComponents *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_optionComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_optionComponents * info = (e_M_optionComponents *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_optionComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_optionComponents info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_optionComponents::
_operator_isEqual (const GGS_M_optionComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_optionComponents::
_operator_isNotEqual (const GGS_M_optionComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_cli_options & inParameter0,
                const GGS_M_cli_options & inParameter1,
                const GGS_M_cli_options & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_optionComponents info  ;
    info.mBoolOptionsMap = inParameter0 ;
    info.mUintOptionsMap = inParameter1 ;
    info.mStringOptionsMap = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_cli_options   & outParameter0,
               GGS_M_cli_options   & outParameter1,
               GGS_M_cli_options   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    outParameter2._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mBoolOptionsMap ;
    outParameter1 = node->mInfo.mUintOptionsMap ;
    outParameter2 = node->mInfo.mStringOptionsMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
modifier_setMBoolOptionsMapForKey (C_Compiler & inLexique,
                        const GGS_M_cli_options & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMBoolOptionsMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mBoolOptionsMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
modifier_setMUintOptionsMapForKey (C_Compiler & inLexique,
                        const GGS_M_cli_options & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMUintOptionsMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mUintOptionsMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
modifier_setMStringOptionsMapForKey (C_Compiler & inLexique,
                        const GGS_M_cli_options & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMStringOptionsMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mStringOptionsMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_cli_options   & outParameter0,
                                GGS_M_cli_options   & outParameter1,
                                GGS_M_cli_options   & outParameter2 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no '%K' option component",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_cli_options & inParameter0,
                                const GGS_M_cli_options & inParameter1,
                                const GGS_M_cli_options & inParameter2 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' option component named is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_optionComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_optionComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_optionComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_optionComponents::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_optionComponents " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_cli_options  & GGS_M_optionComponents::cEnumerator::_mBoolOptionsMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mBoolOptionsMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_cli_options  & GGS_M_optionComponents::cEnumerator::_mUintOptionsMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mUintOptionsMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_cli_options  & GGS_M_optionComponents::cEnumerator::_mStringOptionsMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mStringOptionsMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_M_grammarComponents'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_grammarComponents::e_M_grammarComponents (void) :
mNonterminalSymbolParametersMap (),
mLexiqueName (),
mOptionsMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@M_grammarComponents'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_grammarComponents::
elementOf_GGS_M_grammarComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_grammarComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_grammarComponents::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mNonterminalSymbolParametersMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mLexiqueName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mOptionsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_grammarComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_grammarComponents * _p = dynamic_cast <const elementOf_GGS_M_grammarComponents *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mNonterminalSymbolParametersMap._operator_isEqual (_p->mInfo.mNonterminalSymbolParametersMap)).boolValue ()
           && (mInfo.mLexiqueName._operator_isEqual (_p->mInfo.mLexiqueName)).boolValue ()
           && (mInfo.mOptionsMap._operator_isEqual (_p->mInfo.mOptionsMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_grammarComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_grammarComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_grammarComponents * info = (e_M_grammarComponents *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_grammarComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_grammarComponents * info = (e_M_grammarComponents *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_grammarComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_grammarComponents info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_grammarComponents::
_operator_isEqual (const GGS_M_grammarComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_grammarComponents::
_operator_isNotEqual (const GGS_M_grammarComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0,
                const GGS_lstring & inParameter1,
                const GGS_M_optionComponents & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_grammarComponents info  ;
    info.mNonterminalSymbolParametersMap = inParameter0 ;
    info.mLexiqueName = inParameter1 ;
    info.mOptionsMap = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_M_optionComponents   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    outParameter2._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolParametersMap ;
    outParameter1 = node->mInfo.mLexiqueName ;
    outParameter2 = node->mInfo.mOptionsMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
modifier_setMNonterminalSymbolParametersMapForKey (C_Compiler & inLexique,
                        const GGS_M_nonterminalSymbolAltsForGrammar & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMNonterminalSymbolParametersMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mNonterminalSymbolParametersMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
modifier_setMLexiqueNameForKey (C_Compiler & inLexique,
                        const GGS_lstring & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMLexiqueNameForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mLexiqueName = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
modifier_setMOptionsMapForKey (C_Compiler & inLexique,
                        const GGS_M_optionComponents & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMOptionsMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mOptionsMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_M_optionComponents   & outParameter2 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' grammar component is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_M_optionComponents & inParameter2 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' grammar component has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_grammarComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_grammarComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_grammarComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_grammarComponents::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_grammarComponents " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_nonterminalSymbolAltsForGrammar  & GGS_M_grammarComponents::cEnumerator::_mNonterminalSymbolParametersMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mNonterminalSymbolParametersMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_M_grammarComponents::cEnumerator::_mLexiqueName (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mLexiqueName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_optionComponents  & GGS_M_grammarComponents::cEnumerator::_mOptionsMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mOptionsMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_M_semanticsComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_semanticsComponents::e_M_semanticsComponents (void) :
mModelMap (),
mActionMap (),
mImportedSemanticsComponents (),
mImportedMetamodelComponents (),
mImportedOptionsComponents (),
mOptionsComponents (),
mSemanticsEntitiesMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@M_semanticsComponents'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_semanticsComponents::
elementOf_GGS_M_semanticsComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_semanticsComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_semanticsComponents::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mModelMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mActionMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mImportedSemanticsComponents.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mImportedMetamodelComponents.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mImportedOptionsComponents.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mOptionsComponents.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSemanticsEntitiesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_semanticsComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_semanticsComponents * _p = dynamic_cast <const elementOf_GGS_M_semanticsComponents *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mModelMap._operator_isEqual (_p->mInfo.mModelMap)).boolValue ()
           && (mInfo.mActionMap._operator_isEqual (_p->mInfo.mActionMap)).boolValue ()
           && (mInfo.mImportedSemanticsComponents._operator_isEqual (_p->mInfo.mImportedSemanticsComponents)).boolValue ()
           && (mInfo.mImportedMetamodelComponents._operator_isEqual (_p->mInfo.mImportedMetamodelComponents)).boolValue ()
           && (mInfo.mImportedOptionsComponents._operator_isEqual (_p->mInfo.mImportedOptionsComponents)).boolValue ()
           && (mInfo.mOptionsComponents._operator_isEqual (_p->mInfo.mOptionsComponents)).boolValue ()
           && (mInfo.mSemanticsEntitiesMap._operator_isEqual (_p->mInfo.mSemanticsEntitiesMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_semanticsComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_semanticsComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_semanticsComponents * info = (e_M_semanticsComponents *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_semanticsComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_semanticsComponents * info = (e_M_semanticsComponents *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_semanticsComponents info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_semanticsComponents::
_operator_isEqual (const GGS_M_semanticsComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_semanticsComponents::
_operator_isNotEqual (const GGS_M_semanticsComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_ModelMap & inParameter0,
                const GGS_ActionMap & inParameter1,
                const GGS_stringset & inParameter2,
                const GGS_stringset & inParameter3,
                const GGS_stringset & inParameter4,
                const GGS_M_optionComponents & inParameter5,
                const GGS_M_semanticsEntitiesForUse & inParameter6,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inParameter3._isBuilt ()
   && inParameter4._isBuilt ()
   && inParameter5._isBuilt ()
   && inParameter6._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_semanticsComponents info  ;
    info.mModelMap = inParameter0 ;
    info.mActionMap = inParameter1 ;
    info.mImportedSemanticsComponents = inParameter2 ;
    info.mImportedMetamodelComponents = inParameter3 ;
    info.mImportedOptionsComponents = inParameter4 ;
    info.mOptionsComponents = inParameter5 ;
    info.mSemanticsEntitiesMap = inParameter6 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_ModelMap   & outParameter0,
               GGS_ActionMap   & outParameter1,
               GGS_stringset   & outParameter2,
               GGS_stringset   & outParameter3,
               GGS_stringset   & outParameter4,
               GGS_M_optionComponents   & outParameter5,
               GGS_M_semanticsEntitiesForUse   & outParameter6,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    outParameter2._drop () ;
    outParameter3._drop () ;
    outParameter4._drop () ;
    outParameter5._drop () ;
    outParameter6._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mModelMap ;
    outParameter1 = node->mInfo.mActionMap ;
    outParameter2 = node->mInfo.mImportedSemanticsComponents ;
    outParameter3 = node->mInfo.mImportedMetamodelComponents ;
    outParameter4 = node->mInfo.mImportedOptionsComponents ;
    outParameter5 = node->mInfo.mOptionsComponents ;
    outParameter6 = node->mInfo.mSemanticsEntitiesMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
modifier_setMModelMapForKey (C_Compiler & inLexique,
                        const GGS_ModelMap & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMModelMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mModelMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
modifier_setMActionMapForKey (C_Compiler & inLexique,
                        const GGS_ActionMap & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMActionMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mActionMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
modifier_setMImportedSemanticsComponentsForKey (C_Compiler & inLexique,
                        const GGS_stringset & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMImportedSemanticsComponentsForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mImportedSemanticsComponents = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
modifier_setMImportedMetamodelComponentsForKey (C_Compiler & inLexique,
                        const GGS_stringset & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMImportedMetamodelComponentsForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mImportedMetamodelComponents = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
modifier_setMImportedOptionsComponentsForKey (C_Compiler & inLexique,
                        const GGS_stringset & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMImportedOptionsComponentsForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mImportedOptionsComponents = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
modifier_setMOptionsComponentsForKey (C_Compiler & inLexique,
                        const GGS_M_optionComponents & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMOptionsComponentsForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mOptionsComponents = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
modifier_setMSemanticsEntitiesMapForKey (C_Compiler & inLexique,
                        const GGS_M_semanticsEntitiesForUse & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMSemanticsEntitiesMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mSemanticsEntitiesMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_ModelMap   & outParameter0,
                                GGS_ActionMap   & outParameter1,
                                GGS_stringset   & outParameter2,
                                GGS_stringset   & outParameter3,
                                GGS_stringset   & outParameter4,
                                GGS_M_optionComponents   & outParameter5,
                                GGS_M_semanticsEntitiesForUse   & outParameter6 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no semantics component named '%K'",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  outParameter5,
                  outParameter6,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_ModelMap & inParameter0,
                                const GGS_ActionMap & inParameter1,
                                const GGS_stringset & inParameter2,
                                const GGS_stringset & inParameter3,
                                const GGS_stringset & inParameter4,
                                const GGS_M_optionComponents & inParameter5,
                                const GGS_M_semanticsEntitiesForUse & inParameter6 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a semantics component named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_semanticsComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_semanticsComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_semanticsComponents::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_semanticsComponents " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_ModelMap  & GGS_M_semanticsComponents::cEnumerator::_mModelMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mModelMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_ActionMap  & GGS_M_semanticsComponents::cEnumerator::_mActionMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mActionMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_stringset  & GGS_M_semanticsComponents::cEnumerator::_mImportedSemanticsComponents (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mImportedSemanticsComponents ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_stringset  & GGS_M_semanticsComponents::cEnumerator::_mImportedMetamodelComponents (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mImportedMetamodelComponents ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_stringset  & GGS_M_semanticsComponents::cEnumerator::_mImportedOptionsComponents (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mImportedOptionsComponents ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_optionComponents  & GGS_M_semanticsComponents::cEnumerator::_mOptionsComponents (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mOptionsComponents ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_semanticsEntitiesForUse  & GGS_M_semanticsComponents::cEnumerator::_mSemanticsEntitiesMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSemanticsEntitiesMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_M_regularFiles'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_regularFiles::e_M_regularFiles (void) :
mWrapperDirectoryIndex (),
mWrapperFileIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@M_regularFiles'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_regularFiles::
elementOf_GGS_M_regularFiles (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_regularFiles & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_regularFiles::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mWrapperDirectoryIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mWrapperFileIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_regularFiles::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_regularFiles * _p = dynamic_cast <const elementOf_GGS_M_regularFiles *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mWrapperDirectoryIndex._operator_isEqual (_p->mInfo.mWrapperDirectoryIndex)).boolValue ()
           && (mInfo.mWrapperFileIndex._operator_isEqual (_p->mInfo.mWrapperFileIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_regularFiles::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_regularFiles *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_regularFiles * info = (e_M_regularFiles *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_regularFiles *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_regularFiles * info = (e_M_regularFiles *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_regularFiles GGS_M_regularFiles::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_regularFiles result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_regularFiles info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_regularFiles::
_operator_isEqual (const GGS_M_regularFiles & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_regularFiles::
_operator_isNotEqual (const GGS_M_regularFiles & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                const GGS_uint & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_regularFiles info  ;
    info.mWrapperDirectoryIndex = inParameter0 ;
    info.mWrapperFileIndex = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_uint   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mWrapperDirectoryIndex ;
    outParameter1 = node->mInfo.mWrapperFileIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
modifier_setMWrapperDirectoryIndexForKey (C_Compiler & inLexique,
                        const GGS_uint & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMWrapperDirectoryIndexForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mWrapperDirectoryIndex = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
modifier_setMWrapperFileIndexForKey (C_Compiler & inLexique,
                        const GGS_uint & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMWrapperFileIndexForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mWrapperFileIndex = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_uint   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no regular file named '%K'",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_regularFiles::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_uint & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a regular file named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_regularFiles GGS_M_regularFiles::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_regularFiles & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_regularFiles result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_regularFiles GGS_M_regularFiles::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_regularFiles result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_regularFiles::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_regularFiles " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_regularFiles::cEnumerator::_mWrapperDirectoryIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mWrapperDirectoryIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_regularFiles::cEnumerator::_mWrapperFileIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mWrapperFileIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_filewrapperTemplateMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

e_filewrapperTemplateMap::e_filewrapperTemplateMap (void) :
mFormalAttributeList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@filewrapperTemplateMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperTemplateMap::
elementOf_GGS_filewrapperTemplateMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_filewrapperTemplateMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperTemplateMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mFormalAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperTemplateMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_filewrapperTemplateMap * _p = dynamic_cast <const elementOf_GGS_filewrapperTemplateMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mFormalAttributeList._operator_isEqual (_p->mInfo.mFormalAttributeList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_filewrapperTemplateMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_filewrapperTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_filewrapperTemplateMap * info = (e_filewrapperTemplateMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_filewrapperTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_filewrapperTemplateMap * info = (e_filewrapperTemplateMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_filewrapperTemplateMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperTemplateMap::
_operator_isEqual (const GGS_filewrapperTemplateMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperTemplateMap::
_operator_isNotEqual (const GGS_filewrapperTemplateMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeListeAttributsSemantiques & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_filewrapperTemplateMap info  ;
    info.mFormalAttributeList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalAttributeList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
modifier_setMFormalAttributeListForKey (C_Compiler & inLexique,
                        const GGS_typeListeAttributsSemantiques & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMFormalAttributeListForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mFormalAttributeList = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' template is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' template is already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_filewrapperTemplateMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperTemplateMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @filewrapperTemplateMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeAttributsSemantiques  & GGS_filewrapperTemplateMap::cEnumerator::_mFormalAttributeList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFormalAttributeList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_M_filewrappers'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_filewrappers::e_M_filewrappers (void) :
mRegularFileMap (),
mTemplateMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@M_filewrappers'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_filewrappers::
elementOf_GGS_M_filewrappers (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_filewrappers & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_filewrappers::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mRegularFileMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mTemplateMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_filewrappers::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_filewrappers * _p = dynamic_cast <const elementOf_GGS_M_filewrappers *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mRegularFileMap._operator_isEqual (_p->mInfo.mRegularFileMap)).boolValue ()
           && (mInfo.mTemplateMap._operator_isEqual (_p->mInfo.mTemplateMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_filewrappers::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_filewrappers *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_filewrappers * info = (e_M_filewrappers *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_filewrappers *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_filewrappers * info = (e_M_filewrappers *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_filewrappers GGS_M_filewrappers::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_filewrappers result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_filewrappers info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_filewrappers::
_operator_isEqual (const GGS_M_filewrappers & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_filewrappers::
_operator_isNotEqual (const GGS_M_filewrappers & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_regularFiles & inParameter0,
                const GGS_filewrapperTemplateMap & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_filewrappers info  ;
    info.mRegularFileMap = inParameter0 ;
    info.mTemplateMap = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_regularFiles   & outParameter0,
               GGS_filewrapperTemplateMap   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop () ;
    outParameter1._drop () ;
    if (outIndex != NULL) {
      outIndex->_drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mRegularFileMap ;
    outParameter1 = node->mInfo.mTemplateMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
modifier_setMRegularFileMapForKey (C_Compiler & inLexique,
                        const GGS_M_regularFiles & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMRegularFileMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mRegularFileMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
modifier_setMTemplateMapForKey (C_Compiler & inLexique,
                        const GGS_filewrapperTemplateMap & inValue,
                        const GGS_string & inKey
                        COMMA_LOCATION_ARGS) {
  if (_isBuilt () && inValue._isBuilt () && inKey._isBuilt ()) {
    insulateMap () ;
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    cElement * node = (cElement *) p ;
    if (node == NULL) {
      C_String errorMessage ;
      errorMessage << "the '" << inKey << "' key does not exist when calling 'setMTemplateMapForKey' modifier" ;
      inLexique.onTheFlyRunTimeError (errorMessage COMMA_THERE) ;
    }else{
      node->mInfo.mTemplateMap = inValue ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_regularFiles   & outParameter0,
                                GGS_filewrapperTemplateMap   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no file wrapper named '%K'",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_filewrappers::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_regularFiles & inParameter0,
                                const GGS_filewrapperTemplateMap & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a file wrapper named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_filewrappers GGS_M_filewrappers::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_filewrappers & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_filewrappers result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_filewrappers GGS_M_filewrappers::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_filewrappers result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_filewrappers::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_filewrappers " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_regularFiles  & GGS_M_filewrappers::cEnumerator::_mRegularFileMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRegularFileMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_filewrapperTemplateMap  & GGS_M_filewrappers::cEnumerator::_mTemplateMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTemplateMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@labelForPopUpList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_labelForPopUpList::
elementOf_GGS_labelForPopUpList (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mTerminal1 (argument_0),
mTerminal1ID (argument_1),
mTerminal2 (argument_2),
mTerminal2ID (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_labelForPopUpList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_labelForPopUpList * _p = dynamic_cast <const elementOf_GGS_labelForPopUpList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTerminal1._operator_isEqual (_p->mTerminal1).boolValue ()
         && mTerminal1ID._operator_isEqual (_p->mTerminal1ID).boolValue ()
         && mTerminal2._operator_isEqual (_p->mTerminal2).boolValue ()
         && mTerminal2ID._operator_isEqual (_p->mTerminal2ID).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_labelForPopUpList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminal1.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminal1ID.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminal2.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminal2ID.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@labelForPopUpList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_uint & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_uint & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_uint & argument_3) {
  if (_isBuilt ()&& argument_0._isBuilt ()&& argument_1._isBuilt ()&& argument_2._isBuilt ()&& argument_3._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_labelForPopUpList GGS_labelForPopUpList::
_operator_concat (const GGS_labelForPopUpList & inOperand) const {
  GGS_labelForPopUpList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
_dotAssign_operation (const GGS_labelForPopUpList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_labelForPopUpList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTerminal1 ;
          GGS_uint  p_1 = p->mTerminal1ID ;
          GGS_lstring  p_2 = p->mTerminal2 ;
          GGS_uint  p_3 = p->mTerminal2ID ;
          _internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_uint & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_uint & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTerminal1,
                                _p->mTerminal1ID,
                                _p->mTerminal2,
                                _p->mTerminal2ID
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_labelForPopUpList  GGS_labelForPopUpList::
constructor_emptyList (void) {
  GGS_labelForPopUpList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_labelForPopUpList  GGS_labelForPopUpList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_uint & argument_3) {
  GGS_labelForPopUpList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
internalSubListWithRange (GGS_labelForPopUpList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mTerminal1, _p->mTerminal1ID, _p->mTerminal2, _p->mTerminal2ID) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_labelForPopUpList GGS_labelForPopUpList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_labelForPopUpList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_labelForPopUpList GGS_labelForPopUpList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_labelForPopUpList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_labelForPopUpList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@labelForPopUpList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_uint & _out_1,
              GGS_lstring & _out_2,
              GGS_uint & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTerminal1 ;
    _out_1 = _p->mTerminal1ID ;
    _out_2 = _p->mTerminal2 ;
    _out_3 = _p->mTerminal2ID ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_uint & _out_1,
             GGS_lstring & _out_2,
             GGS_uint & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTerminal1 ;
    _out_1 = _p->mTerminal1ID ;
    _out_2 = _p->mTerminal2 ;
    _out_3 = _p->mTerminal2ID ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_uint & _out_1,
                 GGS_lstring & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTerminal1 ;
    _out_1 = _p->mTerminal1ID ;
    _out_2 = _p->mTerminal2 ;
    _out_3 = _p->mTerminal2ID ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_uint & _out_1,
                GGS_lstring & _out_2,
                GGS_uint & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTerminal1 ;
    _out_1 = _p->mTerminal1ID ;
    _out_2 = _p->mTerminal2 ;
    _out_3 = _p->mTerminal2ID ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
    _out_1._drop () ;
    _out_2._drop () ;
    _out_3._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_labelForPopUpList::
reader_mTerminal1AtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTerminal1 ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_labelForPopUpList::
reader_mTerminal1IDAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTerminal1ID ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_labelForPopUpList::
reader_mTerminal2AtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTerminal2 ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_labelForPopUpList::
reader_mTerminal2IDAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTerminal2ID ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
modifier_setMTerminal1AtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTerminal1 = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
modifier_setMTerminal1IDAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTerminal1ID = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
modifier_setMTerminal2AtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTerminal2 = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_labelForPopUpList::
modifier_setMTerminal2IDAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTerminal2ID = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_labelForPopUpList::cEnumerator::_mTerminal1 (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mTerminal1 ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_labelForPopUpList::cEnumerator::_mTerminal1ID (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mTerminal1ID ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_labelForPopUpList::cEnumerator::_mTerminal2 (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mTerminal2 ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_labelForPopUpList::cEnumerator::_mTerminal2ID (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mTerminal2ID ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "handleStringReaderCall"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleStringReaderCall (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inReaderName,
                                GGS_typeListeAttributsSemantiques  & var_cas_outAccessorTypesList,
                                GGS_AC_galgasType  & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_handleStringReaderCall at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3488)))._operator_isEqual (GGS_string (true, "doesEnvironmentVariableExist"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3490)))._operator_isEqual (GGS_string (true, "length"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3492)))._operator_isEqual (GGS_string (true, "md5"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3494)))._operator_isEqual (GGS_string (true, "uint"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3496)))._operator_isEqual (GGS_string (true, "capacity"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3498)))._operator_isEqual (GGS_string (true, "fileExists"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3500)))._operator_isEqual (GGS_string (true, "directoryExists"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3502)))._operator_isEqual (GGS_string (true, "characterAtIndex"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outReturnedType = GGS_typeGalgas_char ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3505)))._operator_isEqual (GGS_string (true, "stringByRemovingCharacterAtIndex"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3508)))._operator_isEqual (GGS_string (true, "pathExtension"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3510)))._operator_isEqual (GGS_string (true, "rightSubString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3513)))._operator_isEqual (GGS_string (true, "leftSubString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3516)))._operator_isEqual (GGS_string (true, "nativePathWithUnixPath"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3518)))._operator_isEqual (GGS_string (true, "unixPathWithNativePath"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3520)))._operator_isEqual (GGS_string (true, "lastPathComponent"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3522)))._operator_isEqual (GGS_string (true, "stringByDeletingPathExtension"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3524)))._operator_isEqual (GGS_string (true, "stringByCapitalizingFirstCharacter"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3526)))._operator_isEqual (GGS_string (true, "firstCharacterOrNul"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_char ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3528)))._operator_isEqual (GGS_string (true, "stringByDeletingLastPathComponent"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3530)))._operator_isEqual (GGS_string (true, "stringByStandardizingPath"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3532)))._operator_isEqual (GGS_string (true, "stringByLeftPadding"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_char ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3536)))._operator_isEqual (GGS_string (true, "stringByRightPadding"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_char ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3540)))._operator_isEqual (GGS_string (true, "stringByLeftAndRightPadding"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_char ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3544)))._operator_isEqual (GGS_string (true, "absolutePathFromPath"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_outReturnedType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3547)))._operator_isEqual (GGS_string (true, "stringByReplacingStringByString"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_outReturnedType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_outReturnedType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3551)))._operator_isEqual (GGS_string (true, "lowercaseString"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3553)))._operator_isEqual (GGS_string (true, "uppercaseString"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3555)))._operator_isEqual (GGS_string (true, "reversedString"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3557)))._operator_isEqual (GGS_string (true, "escapedString"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3559)))._operator_isEqual (GGS_string (true, "componentsSeparatedByString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    ::routine_build_stringlist_type (_inLexique,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (3561)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3562)))._operator_isEqual (GGS_string (true, "regularFiles"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    ::routine_build_stringlist_type (_inLexique,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (3564)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3565)))._operator_isEqual (GGS_string (true, "hiddenFiles"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    ::routine_build_stringlist_type (_inLexique,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (3567)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3568)))._operator_isEqual (GGS_string (true, "directories"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    ::routine_build_stringlist_type (_inLexique,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (3570)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3571)))._operator_isEqual (GGS_string (true, "directoriesWithExtensions"))).isBuiltAndTrue ()) {
    ::routine_build_stringlist_type (_inLexique,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (3572)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_outReturnedType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3575)))._operator_isEqual (GGS_string (true, "regularFilesWithExtensions"))).isBuiltAndTrue ()) {
    ::routine_build_stringlist_type (_inLexique,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (3576)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_outReturnedType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3579)))._operator_isEqual (GGS_string (true, "system"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_sint ::constructor_new (_inLexique COMMA_HERE) ;
  }else{
    var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "the '"))._operator_concat (var_cas_inReaderName))._operator_concat (GGS_string (true, "' reader is not defined")) COMMA_SOURCE_FILE_AT_LINE (3583)) ;
    var_cas_outReturnedType._drop () ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_handleStringReaderCall\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of routine "handleReaderCall"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleReaderCall (C_Compiler & _inLexique,
                                const GGS_M_semanticsEntitiesForUse   var_cas_ioEntitiesMap,
                                const GGS_AC_galgasType   var_cas_inReceiverType,
                                const GGS_lstring   var_cas_inReaderName,
                                GGS_typeListeAttributsSemantiques  & var_cas_outAccessorTypesList,
                                GGS_AC_galgasType  & var_cas_outReturnedType,
                                GGS_string & var_cas_outCppConversionMethod COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_handleReaderCall at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outCppConversionMethod = GGS_string (true, "") ;
  if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3601)))._operator_isEqual (GGS_string (true, "description"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
  }else{
    { const GGS_AC_galgasType _var_190685 = var_cas_inReceiverType ; // CAST instruction
      if (_var_190685.getPtr () != NULL) {
        macroValidPointer (_var_190685.getPtr ()) ;
        if (dynamic_cast <cPtr_typeGalgas_filewrapper *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3607)))._operator_isEqual (GGS_string (true, "allFilePathes"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            ::routine_build_stringlist_type (_inLexique,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (3609)) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3610)))._operator_isEqual (GGS_string (true, "allDirectoryPathes"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            ::routine_build_stringlist_type (_inLexique,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (3612)) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3613)))._operator_isEqual (GGS_string (true, "currentDirectory"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3616)))._operator_isEqual (GGS_string (true, "directoryExistsAtPath"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3620)))._operator_isEqual (GGS_string (true, "fileExistsAtPath"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3624)))._operator_isEqual (GGS_string (true, "fileContentsAtPath"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3628)))._operator_isEqual (GGS_string (true, "absolutePathForPath"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (3635)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgasUndefinedMapindexType *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3637)))._operator_isEqual (GGS_string (true, "isRegular"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3640)))._operator_isEqual (GGS_string (true, "isNull"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3643)))._operator_isEqual (GGS_string (true, "key"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_lstring ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3646)))._operator_isEqual (GGS_string (true, "isSolved"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (3652)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_string *> (_var_190685.getPtr ()) != NULL) {
          ::routine_handleStringReaderCall (_inLexique,  var_cas_inReaderName,  var_cas_outAccessorTypesList,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (3654)) ;
        }else if (dynamic_cast <cPtr_typeGalgas_lstring *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3656)))._operator_isEqual (GGS_string (true, "string"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3659)))._operator_isEqual (GGS_string (true, "location"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3662)))._operator_isEqual (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            ::routine_handleStringReaderCall (_inLexique,  var_cas_inReaderName,  var_cas_outAccessorTypesList,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (3666)) ;
            var_cas_outCppConversionMethod = GGS_string (true, "ggs_string") ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_location *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3670)))._operator_isEqual (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (3676)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_binaryset *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3678)))._operator_isEqual (GGS_string (true, "isFull"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3681)))._operator_isEqual (GGS_string (true, "isEmpty"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3684)))._operator_isEqual (GGS_string (true, "significantVariableCount"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3687)))._operator_isEqual (GGS_string (true, "ITE"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3692)))._operator_isEqual (GGS_string (true, "forAllOnBitIndex"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3696)))._operator_isEqual (GGS_string (true, "forAllOnBitIndexAndBeyond"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3700)))._operator_isEqual (GGS_string (true, "existOnBitIndex"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3704)))._operator_isEqual (GGS_string (true, "existOnBitIndexAndBeyond"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3708)))._operator_isEqual (GGS_string (true, "valueCount"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3712)))._operator_isEqual (GGS_string (true, "compressedValueCount"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3715)))._operator_isEqual (GGS_string (true, "uint64ValueList"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            ::routine_build_uint64list_type (_inLexique,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (3718)) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3719)))._operator_isEqual (GGS_string (true, "stringValueList"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            ::routine_build_stringlist_type (_inLexique,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (3722)) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3723)))._operator_isEqual (GGS_string (true, "predicateStringValue"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3726)))._operator_isEqual (GGS_string (true, "compressedStringValueList"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            ::routine_build_stringlist_type (_inLexique,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (3729)) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3730)))._operator_isEqual (GGS_string (true, "swap21"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3735)))._operator_isEqual (GGS_string (true, "swap132"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3741)))._operator_isEqual (GGS_string (true, "swap213"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3747)))._operator_isEqual (GGS_string (true, "swap231"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3753)))._operator_isEqual (GGS_string (true, "swap312"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3759)))._operator_isEqual (GGS_string (true, "swap321"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3765)))._operator_isEqual (GGS_string (true, "transitiveClosure"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3769)))._operator_isEqual (GGS_string (true, "accessibleStates"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3774)))._operator_isEqual (GGS_string (true, "equalTo"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3778)))._operator_isEqual (GGS_string (true, "notEqualTo"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3782)))._operator_isEqual (GGS_string (true, "lowerOrEqualTo"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3786)))._operator_isEqual (GGS_string (true, "greaterOrEqualTo"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3790)))._operator_isEqual (GGS_string (true, "greaterThan"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3794)))._operator_isEqual (GGS_string (true, "lowerThan"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (var_cas_inReceiverType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3798)))._operator_isEqual (GGS_string (true, "binarySetByTranslatingFromIndex"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3803)))._operator_isEqual (GGS_string (true, "containsValue"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3809)))._operator_isEqual (GGS_string (true, "existsOnBitRange"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (3817)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_uint *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3819)))._operator_isEqual (GGS_string (true, "sint"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_sint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3822)))._operator_isEqual (GGS_string (true, "uint64"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3825)))._operator_isEqual (GGS_string (true, "lsbIndex"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3828)))._operator_isEqual (GGS_string (true, "significantBitCount"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3831)))._operator_isEqual (GGS_string (true, "sint64"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_sint64 ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3834)))._operator_isEqual (GGS_string (true, "string"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3837)))._operator_isEqual (GGS_string (true, "hexString"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (3843)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_char *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3845)))._operator_isEqual (GGS_string (true, "string"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3848)))._operator_isEqual (GGS_string (true, "uint"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3851)))._operator_isEqual (GGS_string (true, "isalnum"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3854)))._operator_isEqual (GGS_string (true, "isalpha"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3857)))._operator_isEqual (GGS_string (true, "iscntrl"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3860)))._operator_isEqual (GGS_string (true, "isdigit"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3863)))._operator_isEqual (GGS_string (true, "islower"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3866)))._operator_isEqual (GGS_string (true, "isupper"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3869)))._operator_isEqual (GGS_string (true, "isxdigit"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (3875)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_uint64 *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3877)))._operator_isEqual (GGS_string (true, "sint64"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_sint64 ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3880)))._operator_isEqual (GGS_string (true, "sint"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_sint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3883)))._operator_isEqual (GGS_string (true, "uint"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3886)))._operator_isEqual (GGS_string (true, "uintSlice"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3891)))._operator_isEqual (GGS_string (true, "string"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3894)))._operator_isEqual (GGS_string (true, "hexString"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (3900)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_sint *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3902)))._operator_isEqual (GGS_string (true, "uint"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3905)))._operator_isEqual (GGS_string (true, "uint64"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3908)))._operator_isEqual (GGS_string (true, "sint64"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_sint64 ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3911)))._operator_isEqual (GGS_string (true, "string"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (3917)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_sint64 *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3919)))._operator_isEqual (GGS_string (true, "uint64"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3922)))._operator_isEqual (GGS_string (true, "uint"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3925)))._operator_isEqual (GGS_string (true, "sint"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_sint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3928)))._operator_isEqual (GGS_string (true, "string"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (3934)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_double *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3936)))._operator_isEqual (GGS_string (true, "string"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (3942)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_lchar *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3944)))._operator_isEqual (GGS_string (true, "char"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_char ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3947)))._operator_isEqual (GGS_string (true, "value"))).isBuiltAndTrue ()) {
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, GGS_string (true, "in GALGAS 1.4.1 and later, the 'value' reader of @lchar type  is deprecated; use 'char' instead") COMMA_SOURCE_FILE_AT_LINE (3948)) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_char ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3951)))._operator_isEqual (GGS_string (true, "location"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3954)))._operator_isEqual (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (3960)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_lbool *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3962)))._operator_isEqual (GGS_string (true, "bool"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3965)))._operator_isEqual (GGS_string (true, "value"))).isBuiltAndTrue ()) {
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, GGS_string (true, "in GALGAS 1.4.1 and later, the 'value' reader of @lbool type  is deprecated; use 'bool' instead") COMMA_SOURCE_FILE_AT_LINE (3966)) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3969)))._operator_isEqual (GGS_string (true, "location"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (3975)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_luint *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3977)))._operator_isEqual (GGS_string (true, "uint"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3980)))._operator_isEqual (GGS_string (true, "value"))).isBuiltAndTrue ()) {
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, GGS_string (true, "in GALGAS 1.4.1 and later, the 'value' of @luint type  reader is deprecated; use 'uint' instead") COMMA_SOURCE_FILE_AT_LINE (3981)) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3984)))._operator_isEqual (GGS_string (true, "location"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3987)))._operator_isEqual (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (3993)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_luint64 *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3995)))._operator_isEqual (GGS_string (true, "uint64"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (3998)))._operator_isEqual (GGS_string (true, "location"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4001)))._operator_isEqual (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4007)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_lsint *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4009)))._operator_isEqual (GGS_string (true, "sint"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_sint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4012)))._operator_isEqual (GGS_string (true, "value"))).isBuiltAndTrue ()) {
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, GGS_string (true, "in GALGAS 1.4.1 and later, the 'value' reader of @lsint type  is deprecated; use 'sint' instead") COMMA_SOURCE_FILE_AT_LINE (4013)) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_sint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4016)))._operator_isEqual (GGS_string (true, "string"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4019)))._operator_isEqual (GGS_string (true, "location"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4022)))._operator_isEqual (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4028)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_lsint64 *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4030)))._operator_isEqual (GGS_string (true, "sint64"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_sint64 ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4033)))._operator_isEqual (GGS_string (true, "string"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4036)))._operator_isEqual (GGS_string (true, "location"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4039)))._operator_isEqual (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4045)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_ldouble *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4047)))._operator_isEqual (GGS_string (true, "double"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_double ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4050)))._operator_isEqual (GGS_string (true, "value"))).isBuiltAndTrue ()) {
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, GGS_string (true, "in GALGAS 1.4.1 and later, the 'value' reader of @ldouble type  is deprecated; use 'double' instead") COMMA_SOURCE_FILE_AT_LINE (4051)) ;
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_double ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4054)))._operator_isEqual (GGS_string (true, "string"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4057)))._operator_isEqual (GGS_string (true, "location"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4060)))._operator_isEqual (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4066)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgasListType *> (_var_190685.getPtr ()) != NULL) {
          const GGS_typeGalgasListType var_cas_listType (_var_190685.getPtr ()) ;
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4068)))._operator_isEqual (GGS_string (true, "length"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4071)))._operator_isEqual (GGS_string (true, "subListFromIndex"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4075)))._operator_isEqual (GGS_string (true, "subListWithRange"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
          }else{
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_inReceiverType ;
            GGS_typeListeAttributsSemantiques  var_cas_attributeList ;
            var_cas_attributeList = var_cas_listType.reader_mAttributeList (_inLexique COMMA_SOURCE_FILE_AT_LINE (4084)) ;
            GGS_bool var_cas_found ;
            var_cas_found = GGS_bool (true, false) ;
            {
              GGS_typeListeAttributsSemantiques::cEnumerator enumerator_183780 (var_cas_attributeList, true) ;
              const GGS_typeListeAttributsSemantiques::cElement * operand_183780 = NULL ;
              while (((operand_183780 = enumerator_183780.nextObject ()))
                  && ((var_cas_found)._operator_not ().isBuiltAndTrue ())) {
                macroValidPointer (operand_183780) ;
                var_cas_found = ((operand_183780->mAttributeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4087)))._operator_concat (GGS_string (true, "AtIndex")))._operator_isEqual (var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4087))) ;
                if ((var_cas_found).isBuiltAndTrue ()) {
                  var_cas_outReturnedType = operand_183780->mAttributType ;
                }
              }
            }
            if (((var_cas_found)._operator_not ()).isBuiltAndTrue ()) {
              var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "the '"))._operator_concat (var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4094))))._operator_concat (GGS_string (true, "' reader is not supported by a list")) COMMA_SOURCE_FILE_AT_LINE (4095)) ;
            }
          }
        }else if (dynamic_cast <cPtr_typeGalgasSortedListType *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4098)))._operator_isEqual (GGS_string (true, "length"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "sorted list supports only 'length' reader call") COMMA_SOURCE_FILE_AT_LINE (4104)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgasMapType *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4106)))._operator_isEqual (GGS_string (true, "hasKey"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            GGS_AC_galgasType  var_cas_keyType ;
            var_cas_keyType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList._addAssign_operation (var_cas_keyType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4111)))._operator_isEqual (GGS_string (true, "count"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4114)))._operator_isEqual (GGS_string (true, "allKeys"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_stringset ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4117)))._operator_isEqual (GGS_string (true, "keyList"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            ::routine_build_lstringlist_type (_inLexique,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (4119)) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4120)))._operator_isEqual (GGS_string (true, "unsolvedIndexCount"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4123)))._operator_isEqual (GGS_string (true, "unsolvedIndexKeyStringList"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            ::routine_build_stringlist_type (_inLexique,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (4125)) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4129)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgasListmapType *> (_var_190685.getPtr ()) != NULL) {
          const GGS_typeGalgasListmapType var_cas_mapType (_var_190685.getPtr ()) ;
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4131)))._operator_isEqual (GGS_string (true, "hasKey"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4135)))._operator_isEqual (GGS_string (true, "allKeys"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_stringset ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4138)))._operator_isEqual (GGS_string (true, "count"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4141)))._operator_isEqual (GGS_string (true, "keyList"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            ::routine_build_stringlist_type (_inLexique,  var_cas_outReturnedType COMMA_SOURCE_FILE_AT_LINE (4143)) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4144)))._operator_isEqual (GGS_string (true, "listForKey"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE), GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = var_cas_mapType.reader_mListType (_inLexique COMMA_SOURCE_FILE_AT_LINE (4147)) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4151)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_stringset *> (_var_190685.getPtr ()) != NULL) {
          if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4153)))._operator_isEqual (GGS_string (true, "hasKey"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            GGS_AC_galgasType  var_cas_keyType ;
            var_cas_keyType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
            var_cas_outAccessorTypesList._addAssign_operation (var_cas_keyType, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
            var_cas_outReturnedType = GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4158)))._operator_isEqual (GGS_string (true, "count"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
            var_cas_outReturnedType = GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") COMMA_SOURCE_FILE_AT_LINE (4164)) ;
            var_cas_outAccessorTypesList._drop () ;
            var_cas_outReturnedType._drop () ;
          }
        }else if (dynamic_cast <cPtr_typeGalgasClassType *> (_var_190685.getPtr ()) != NULL) {
          const GGS_typeGalgasClassType var_cas_t (_var_190685.getPtr ()) ;
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          if (((var_cas_t.reader_mMessagesMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (4169)).reader_hasKey (_inLexique, var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4169)) COMMA_SOURCE_FILE_AT_LINE (4169)))._operator_not ()).isBuiltAndTrue ()) {
            GGS_bool var_cas_found ;
            var_cas_found = GGS_bool (true, false) ;
            {
              GGS_typeListeAttributsSemantiques::cEnumerator enumerator_188199 (var_cas_t.reader_mAttributeList (_inLexique COMMA_SOURCE_FILE_AT_LINE (4172)), true) ;
              const GGS_typeListeAttributsSemantiques::cElement * operand_188199 = NULL ;
              while (((operand_188199 = enumerator_188199.nextObject ()))
                  && ((var_cas_found)._operator_not ().isBuiltAndTrue ())) {
                macroValidPointer (operand_188199) ;
                var_cas_outReturnedType = operand_188199->mAttributType ;
                var_cas_found = (var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4174)))._operator_isEqual (operand_188199->mAttributeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4174))) ;
              }
            }
            {
              GGS_L_lazyAttributeList::cEnumerator enumerator_188427 (var_cas_t.reader_mLazyAttributeList (_inLexique COMMA_SOURCE_FILE_AT_LINE (4177)), true) ;
              const GGS_L_lazyAttributeList::cElement * operand_188427 = NULL ;
              while (((operand_188427 = enumerator_188427.nextObject ()))
                  && ((var_cas_found)._operator_not ().isBuiltAndTrue ())) {
                macroValidPointer (operand_188427) ;
                {
                  GGS_typeListeAttributsSemantiques::cEnumerator enumerator_188519 (operand_188427->mComputedAttributeTypeAndNameList, true) ;
                  const GGS_typeListeAttributsSemantiques::cElement * operand_188519 = NULL ;
                  while (((operand_188519 = enumerator_188519.nextObject ()))
                      && ((var_cas_found)._operator_not ().isBuiltAndTrue ())) {
                    macroValidPointer (operand_188519) ;
                    var_cas_outReturnedType = operand_188519->mAttributType ;
                    var_cas_found = (var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4180)))._operator_isEqual (operand_188519->mAttributeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4180))) ;
                  }
                }
              }
            }
            {
              GGS_typeSuperClassesMap::cEnumerator enumerator_188775 (var_cas_t.reader_mAncestorClassesMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (4184)), true) ;
              const GGS_typeSuperClassesMap::cElement * operand_188775 = NULL ;
              while (((operand_188775 = enumerator_188775.nextObject ()))
                  && ((var_cas_found)._operator_not ().isBuiltAndTrue ())) {
                macroValidPointer (operand_188775) ;
                GGS_AC_semanticsEntity  var_cas_entite ;
                const GGS_M_semanticsEntitiesForUse  _temp_188890 = var_cas_ioEntitiesMap ;
                if (_temp_188890._isBuilt ()) {
                  _temp_188890 (HERE)->method_searchKey (_inLexique, operand_188775->mKey, var_cas_entite COMMA_SOURCE_FILE_AT_LINE (4186)) ;
                }
                GGS_AC_galgasType  var_cas_type ;
                var_cas_type = GGS_typeEntiteType::_castFrom (_inLexique, var_cas_entite.getPtr (), true, operand_188775->mKey COMMA_SOURCE_FILE_AT_LINE (4187)).reader_aDefType (_inLexique COMMA_SOURCE_FILE_AT_LINE (4187)) ;
                GGS_typeGalgasClassType  var_cas_classType ;
                var_cas_classType = GGS_typeGalgasClassType::_castFrom (_inLexique, var_cas_type.getPtr (), true, operand_188775->mKey COMMA_SOURCE_FILE_AT_LINE (4188)) ;
                {
                  GGS_L_lazyAttributeList::cEnumerator enumerator_189123 (var_cas_classType.reader_mLazyAttributeList (_inLexique COMMA_SOURCE_FILE_AT_LINE (4189)), true) ;
                  const GGS_L_lazyAttributeList::cElement * operand_189123 = NULL ;
                  while (((operand_189123 = enumerator_189123.nextObject ()))
                      && ((var_cas_found)._operator_not ().isBuiltAndTrue ())) {
                    macroValidPointer (operand_189123) ;
                    {
                      GGS_typeListeAttributsSemantiques::cEnumerator enumerator_189225 (operand_189123->mComputedAttributeTypeAndNameList, true) ;
                      const GGS_typeListeAttributsSemantiques::cElement * operand_189225 = NULL ;
                      while (((operand_189225 = enumerator_189225.nextObject ()))
                          && ((var_cas_found)._operator_not ().isBuiltAndTrue ())) {
                        macroValidPointer (operand_189225) ;
                        var_cas_outReturnedType = operand_189225->mAttributType ;
                        var_cas_found = (var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4192)))._operator_isEqual (operand_189225->mAttributeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4192))) ;
                      }
                    }
                  }
                }
              }
            }
            if (((var_cas_found)._operator_not ()).isBuiltAndTrue ()) {
              var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined (you can name as class reader class attributes, class messages and lazy attributes)") COMMA_SOURCE_FILE_AT_LINE (4199)) ;
            }
          }
        }else if (dynamic_cast <cPtr_typeGalgasStructType *> (_var_190685.getPtr ()) != NULL) {
          const GGS_typeGalgasStructType var_cas_t (_var_190685.getPtr ()) ;
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          GGS_bool var_cas_found ;
          var_cas_found = GGS_bool (true, false) ;
          {
            GGS_typeListeAttributsSemantiques::cEnumerator enumerator_189876 (var_cas_t.reader_mAttributeList (_inLexique COMMA_SOURCE_FILE_AT_LINE (4205)), true) ;
            const GGS_typeListeAttributsSemantiques::cElement * operand_189876 = NULL ;
            while (((operand_189876 = enumerator_189876.nextObject ()))
                && ((var_cas_found)._operator_not ().isBuiltAndTrue ())) {
              macroValidPointer (operand_189876) ;
              var_cas_outReturnedType = operand_189876->mAttributType ;
              var_cas_found = (var_cas_inReaderName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4207)))._operator_isEqual (operand_189876->mAttributeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4207))) ;
            }
          }
          if (((var_cas_found)._operator_not ()).isBuiltAndTrue ()) {
            var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined (you can name as reader any struct attribute)") COMMA_SOURCE_FILE_AT_LINE (4211)) ;
          }
        }else if (dynamic_cast <cPtr_typeGalgas_enum *> (_var_190685.getPtr ()) != NULL) {
          const GGS_typeGalgas_enum var_cas_e (_var_190685.getPtr ()) ;
          GGS_typeEnumMessageMap  var_cas_kMessagesMap ;
          var_cas_kMessagesMap = var_cas_e.reader_mMessagesMap (_inLexique COMMA_SOURCE_FILE_AT_LINE (4213)) ;
          GGS_lstringlist  automatic_var_10 ;
          const GGS_typeEnumMessageMap  _temp_190363 = var_cas_kMessagesMap ;
          if (_temp_190363._isBuilt ()) {
            _temp_190363 (HERE)->method_searchKey (_inLexique, var_cas_inReaderName, automatic_var_10 COMMA_SOURCE_FILE_AT_LINE (4214)) ;
          }
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques ::constructor_emptyList () ;
          var_cas_outReturnedType = GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support reader call") COMMA_SOURCE_FILE_AT_LINE (4221)) ;
          var_cas_outAccessorTypesList._drop () ;
          var_cas_outReturnedType._drop () ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_handleReaderCall\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "importSemanticsComponent"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_importSemanticsComponent (C_Compiler & _inLexique,
                                GGS_M_semanticsComponents  & var_cas_ioSemanticsComponentsMap,
                                GGS_ModelMap  & var_cas_ioModelMap,
                                GGS_ActionMap  & var_cas_ioActionMap,
                                GGS_stringset  & var_cas_ioAlreadyImportedSemanticsComponents,
                                GGS_stringset  & var_cas_ioAlreadyImportedMetamodelComponents,
                                GGS_lstring   var_cas_inSemanticsComponentName COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_importSemanticsComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (((var_cas_ioAlreadyImportedSemanticsComponents.reader_hasKey (_inLexique, var_cas_inSemanticsComponentName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4247)) COMMA_SOURCE_FILE_AT_LINE (4247)))._operator_not ()).isBuiltAndTrue ()) {
    GGS_ModelMap  var_cas_modelMap ;
    GGS_ActionMap  var_cas_actionMap ;
    GGS_stringset  var_cas_importedSemanticsComponents ;
    GGS_stringset  var_cas_importedMetamodelComponents ;
    GGS_stringset  var_cas_importedOptionsComponents ;
    GGS_M_optionComponents  automatic_var_11 ;
    GGS_M_semanticsEntitiesForUse  automatic_var_12 ;
    const GGS_M_semanticsComponents  _temp_191964 = var_cas_ioSemanticsComponentsMap ;
    if (_temp_191964._isBuilt ()) {
      _temp_191964 (HERE)->method_searchKey (_inLexique, var_cas_inSemanticsComponentName, var_cas_modelMap, var_cas_actionMap, var_cas_importedSemanticsComponents, var_cas_importedMetamodelComponents, var_cas_importedOptionsComponents, automatic_var_11, automatic_var_12 COMMA_SOURCE_FILE_AT_LINE (4253)) ;
    }
    var_cas_ioAlreadyImportedMetamodelComponents = (var_cas_ioAlreadyImportedMetamodelComponents)._operator_or (var_cas_importedMetamodelComponents) ;
    {
      GGS_stringset::cEnumerator enumerator_192395 (var_cas_importedSemanticsComponents, true) ;
      while (enumerator_192395.hc ()) {
        ::routine_importSemanticsComponent (_inLexique,  var_cas_ioSemanticsComponentsMap,  var_cas_ioModelMap,  var_cas_ioActionMap,  var_cas_ioAlreadyImportedSemanticsComponents,  var_cas_ioAlreadyImportedMetamodelComponents,  GGS_lstring ::constructor_new (_inLexique, enumerator_192395._key (HERE), GGS_location (_inLexique) COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (4267)) ;
        enumerator_192395.next () ;
      }
    }
    {
      GGS_ModelMap::cEnumerator enumerator_192725 (var_cas_modelMap, true) ;
      const GGS_ModelMap::cElement * operand_192725 = NULL ;
      while (((operand_192725 = enumerator_192725.nextObject ()))) {
        macroValidPointer (operand_192725) ;
        if (((var_cas_ioModelMap.reader_hasKey (_inLexique, operand_192725->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4278)) COMMA_SOURCE_FILE_AT_LINE (4278)))._operator_not ()).isBuiltAndTrue ()) {
          var_cas_ioModelMap.modifier_insertKey (_inLexique, operand_192725->mKey, operand_192725->mInfo.mType COMMA_SOURCE_FILE_AT_LINE (4279)) ;
        }
      }
    }
    {
      GGS_ActionMap::cEnumerator enumerator_192936 (var_cas_actionMap, true) ;
      const GGS_ActionMap::cElement * operand_192936 = NULL ;
      while (((operand_192936 = enumerator_192936.nextObject ()))) {
        macroValidPointer (operand_192936) ;
        if (((var_cas_ioActionMap.reader_hasKey (_inLexique, operand_192936->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4284)) COMMA_SOURCE_FILE_AT_LINE (4284)))._operator_not ()).isBuiltAndTrue ()) {
          var_cas_ioActionMap.modifier_insertKey (_inLexique, operand_192936->mKey, operand_192936->mInfo.mSignature, operand_192936->mInfo.mIsExtern COMMA_SOURCE_FILE_AT_LINE (4285)) ;
        }
      }
    }
    var_cas_ioAlreadyImportedSemanticsComponents._addAssign_operation (var_cas_inSemanticsComponentName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (4289))) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_importSemanticsComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "enterBuiltinTypes"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterBuiltinTypes (C_Compiler & _inLexique,
                                GGS_M_semanticsEntitiesForUse  & var_cas_ioComponentSemanticsEntitiesMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_enterBuiltinTypes at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioComponentSemanticsEntitiesMap = GGS_M_semanticsEntitiesForUse ::constructor_emptyMap (_inLexique COMMA_HERE) ;
  GGS_AC_semanticsEntity  var_cas_e ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_lstring ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "lstring"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4303)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_lbool ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "lbool"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4306)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_luint ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "luint"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4309)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_lsint ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "lsint"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4312)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_luint64 ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "luint64"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4315)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_lsint64 ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "lsint64"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4318)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_ldouble ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "ldouble"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4321)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_lchar ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "lchar"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4324)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_location ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "location"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4327)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_uint ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "uint"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4330)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_sint ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "sint"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4333)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_uint64 ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "uint64"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4336)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_sint64 ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "sint64"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4339)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_char ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "char"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4342)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_string ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "string"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4345)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_bool ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "bool"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4348)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_binaryset ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "binaryset"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4351)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_double ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "double"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4354)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_stringset ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "stringset"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4357)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, GGS_typeGalgas_filewrapper ::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "filewrapper"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4360)) ;
  GGS_AC_galgasType  var_cas_t ;
  ::routine_build_uintlist_type (_inLexique,  var_cas_t COMMA_SOURCE_FILE_AT_LINE (4362)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "uintlist"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4364)) ;
  ::routine_build_luintlist_type (_inLexique,  var_cas_t COMMA_SOURCE_FILE_AT_LINE (4366)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "luintlist"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4368)) ;
  ::routine_build_uint64list_type (_inLexique,  var_cas_t COMMA_SOURCE_FILE_AT_LINE (4370)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "uint64list"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4372)) ;
  ::routine_build_stringlist_type (_inLexique,  var_cas_t COMMA_SOURCE_FILE_AT_LINE (4374)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "stringlist"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4376)) ;
  ::routine_build_lstringlist_type (_inLexique,  var_cas_t COMMA_SOURCE_FILE_AT_LINE (4378)) ;
  var_cas_e = GGS_typeEntiteType ::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.modifier_insertKey (_inLexique, GGS_lstring ::constructor_new (_inLexique, GGS_string (true, "lstringlist"), GGS_location (_inLexique) COMMA_HERE), var_cas_e COMMA_SOURCE_FILE_AT_LINE (4380)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_enterBuiltinTypes\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_templateInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstruction::
cPtr_templateInstruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstruction * GGS_templateInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_templateInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_templateInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@templateInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstruction (& typeid (cPtr_templateInstruction), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_templateInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_templateInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_templateInstruction::
GGS_templateInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstruction::
GGS_templateInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_templateInstruction GGS_templateInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_templateInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstruction::actualTypeName (void) const {
  return "templateInstruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_templateInstruction::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__templateInstruction ("templateInstruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@templateInstructionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_templateInstructionList::
elementOf_GGS_templateInstructionList (const GGS_templateInstruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateInstructionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_templateInstructionList * _p = dynamic_cast <const elementOf_GGS_templateInstructionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateInstructionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@templateInstructionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
_internalAppendValues (const GGS_templateInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
_internalPrependValues (const GGS_templateInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
_addAssign_operation (const GGS_templateInstruction & argument_0) {
  if (_isBuilt ()&& argument_0._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionList GGS_templateInstructionList::
_operator_concat (const GGS_templateInstructionList & inOperand) const {
  GGS_templateInstructionList result = * this ;
  result._dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
_dotAssign_operation (const GGS_templateInstructionList inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_templateInstructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_templateInstruction  p_0 = p->mInstruction ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_templateInstruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionList  GGS_templateInstructionList::
constructor_emptyList (void) {
  GGS_templateInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionList  GGS_templateInstructionList::
constructor_listWithValue (const GGS_templateInstruction & argument_0) {
  GGS_templateInstructionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
internalSubListWithRange (GGS_templateInstructionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionList GGS_templateInstructionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionList GGS_templateInstructionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@templateInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_templateInstruction & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_templateInstruction & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_templateInstruction & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_templateInstruction & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstruction  GGS_templateInstructionList::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_templateInstruction  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionList::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_templateInstruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_templateInstruction  & GGS_templateInstructionList::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_templateInstructionString'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionString::
cPtr_templateInstructionString (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstruction (THERE),
mTemplateString (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionString * GGS_templateInstructionString::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionString *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_templateInstructionString *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionString::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionString * _p = dynamic_cast <const cPtr_templateInstructionString *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTemplateString._operator_isEqual (_p->mTemplateString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionString::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@templateInstructionString:"
           << mTemplateString.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionString::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionString::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionString (& typeid (cPtr_templateInstructionString), & typeid (cPtr_templateInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_templateInstructionString::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionString ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_templateInstructionString'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_templateInstructionString::
GGS_templateInstructionString (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionString::
GGS_templateInstructionString (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_templateInstructionString GGS_templateInstructionString::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionString _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionString *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionString) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_templateInstructionString (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionString),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionString GGS_templateInstructionString::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionString result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionString (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionString::
reader_mTemplateString (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionString *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionString *) mPointer)->mTemplateString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionString::actualTypeName (void) const {
  return "templateInstructionString" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__templateInstructionString ("templateInstructionString", gClassInfoFor__templateInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_templateInstructionConstant'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionConstant::
cPtr_templateInstructionConstant (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstruction (THERE),
mCppName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionConstant * GGS_templateInstructionConstant::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionConstant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_templateInstructionConstant *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionConstant::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionConstant * _p = dynamic_cast <const cPtr_templateInstructionConstant *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCppName._operator_isEqual (_p->mCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionConstant::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@templateInstructionConstant:"
           << mCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionConstant::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionConstant::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionConstant (& typeid (cPtr_templateInstructionConstant), & typeid (cPtr_templateInstruction), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_templateInstructionConstant::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionConstant ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_templateInstructionConstant'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_templateInstructionConstant::
GGS_templateInstructionConstant (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionConstant::
GGS_templateInstructionConstant (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_templateInstructionConstant GGS_templateInstructionConstant::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionConstant _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionConstant *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionConstant) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_templateInstructionConstant (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionConstant),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionConstant GGS_templateInstructionConstant::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionConstant result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionConstant (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_templateInstructionConstant::
reader_mCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionConstant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionConstant *) mPointer)->mCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionConstant::actualTypeName (void) const {
  return "templateInstructionConstant" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__templateInstructionConstant ("templateInstructionConstant", gClassInfoFor__templateInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of 'EXsemanticContext' struct                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_EXsemanticContext::GGS_EXsemanticContext (void) :
mFilewrappers (),
mImportedSemanticComponents (),
mCategoryMethodMap () {
}

//---------------------------------------------------------------------------*

GGS_EXsemanticContext::~GGS_EXsemanticContext (void) {
}

//---------------------------------------------------------------------------*

void GGS_EXsemanticContext::_drop (void) {
  mFilewrappers._drop () ;
  mImportedSemanticComponents._drop () ;
  mCategoryMethodMap._drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_EXsemanticContext::_isBuilt (void) const {
  return mFilewrappers._isBuilt ()
    && mImportedSemanticComponents._isBuilt ()
    && mCategoryMethodMap._isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsemanticContext::
_operator_isEqual (const GGS_EXsemanticContext & inOperand) const {
  return mFilewrappers._operator_isEqual (inOperand.mFilewrappers)
    ._operator_and (mImportedSemanticComponents._operator_isEqual (inOperand.mImportedSemanticComponents))
    ._operator_and (mCategoryMethodMap._operator_isEqual (inOperand.mCategoryMethodMap)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsemanticContext::
_operator_isNotEqual (const GGS_EXsemanticContext & inOperand) const {
  return mFilewrappers._operator_isNotEqual (inOperand.mFilewrappers)
    ._operator_or (mImportedSemanticComponents._operator_isNotEqual (inOperand.mImportedSemanticComponents))
    ._operator_or (mCategoryMethodMap._operator_isNotEqual (inOperand.mCategoryMethodMap)) ;
}

//---------------------------------------------------------------------------*

GGS_EXsemanticContext GGS_EXsemanticContext::
constructor_new (const GGS_M_filewrappers & argument_0,
                 const GGS_stringset & argument_1,
                 const GGS_EXcategoryMethodMap & argument_2) {
  GGS_EXsemanticContext result ;
  result.mFilewrappers = argument_0 ;
  result.mImportedSemanticComponents = argument_1 ;
  result.mCategoryMethodMap = argument_2 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXsemanticContext::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String _s ;
  _s << "<struct @EXsemanticContext" ;
  if (_isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mFilewrappers " ;
    _s << mFilewrappers.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mImportedSemanticComponents " ;
    _s << mImportedSemanticComponents.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mCategoryMethodMap " ;
    _s << mCategoryMethodMap.reader_description (_inLexique COMMA_THERE, inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

