//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'common_semantics.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 5th, 2006, at 22h14'15"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "common_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "common_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_lstringList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_lstringList::
elementOf_GGS_L_lstringList (const GGS_lstring & argument_0):
mNextItem (NULL),
mString (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_lstringList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mString.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_lstringList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_lstringList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_lstringList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_lstringList::GGS_L_lstringList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_lstringList::~GGS_L_lstringList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_lstringList::
GGS_L_lstringList (const GGS_L_lstringList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
operator = (const GGS_L_lstringList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_lstringList::element_type * GGS_L_lstringList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mString) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_lstringList  GGS_L_lstringList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_lstringList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_lstringList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_lstringList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_lstringList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_lstringList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Class for 'actualParametersPassingMode' Enumeration             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator == (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator != (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator <= (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator >= (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator < (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator > (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParametersPassingMode::
reader_actualArgumentMessage (C_Lexique & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [4] = {"",
    "an output (!) actual parameter",
    "an output/input (!\?) actual parameter",
    "an input (\?) actual parameter"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParametersPassingMode::
reader_description (C_Lexique & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS) const {
  C_String s ;
  s << "<enum @actualParametersPassingMode" ;
  switch (mValue) {
case enum_parameterOut:
  s << " parameterOut" ;
    break ;
case enum_parameterOutIn:
  s << " parameterOutIn" ;
    break ;
case enum_parameterIn:
  s << " parameterIn" ;
    break ;
  case kNotBuilt:
    s << " (not built)" ;
    break ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Class for 'formalArgumentPassingMode' Enumeration              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator == (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator != (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator <= (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator >= (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator < (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator > (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingMode::
reader_formalArgumentMessage (C_Lexique & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "an input (\?) formal argument",
    "an output (!) formal argument",
    "an input/output (\?!) argument",
    "a constant input (\?\?) formal argument"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingMode::
reader_description (C_Lexique & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS) const {
  C_String s ;
  s << "<enum @formalArgumentPassingMode" ;
  switch (mValue) {
case enum_argumentIn:
  s << " argumentIn" ;
    break ;
case enum_argumentOut:
  s << " argumentOut" ;
    break ;
case enum_argumentInOut:
  s << " argumentInOut" ;
    break ;
case enum_argumentConstantIn:
  s << " argumentConstantIn" ;
    break ;
  case kNotBuilt:
    s << " (not built)" ;
    break ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@L_signature'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_signature::
elementOf_GGS_L_signature (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1):
mNextItem (NULL),
mFormalArgumentPassingMode (argument_0),
mGalgasTypeName (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_signature::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mFormalArgumentPassingMode.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mGalgasTypeName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@L_signature'                             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_signature::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_signature::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_signature::GGS_L_signature (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_signature::~GGS_L_signature (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_signature::
GGS_L_signature (const GGS_L_signature & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
operator = (const GGS_L_signature & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_signature::element_type * GGS_L_signature::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
internalAppendItem (const GGS_formalArgumentPassingMode& argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
addAssign_operation (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mFormalArgumentPassingMode,
                                p->mGalgasTypeName) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_signature  GGS_L_signature::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_signature result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_signature::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_signature::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_signature" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_signature::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@typeListModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListModel::
elementOf_GGS_typeListModel (const GGS_lstring & argument_0):
mNextItem (NULL),
mTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListModel::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@typeListModel'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListModel::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeListModel::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListModel::GGS_typeListModel (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel::~GGS_typeListModel (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel::
GGS_typeListModel (const GGS_typeListModel & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
operator = (const GGS_typeListModel & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListModel::element_type * GGS_typeListModel::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mTypeName) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_typeListModel::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListModel result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeListModel::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListModel::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeListModel" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeListModel::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_TypeModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_TypeModel::
cPtr_TypeModel (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_TypeModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (void) {
  mPointer = (cPtr_TypeModel *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (const GGS_TypeModel & inOperand) {
  mPointer = (cPtr_TypeModel *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_TypeModel::
~GGS_TypeModel (void) {
  macroDetachPointer (mPointer, cPtr_TypeModel) ;
}

//---------------------------------------------------------------------------*

void GGS_TypeModel::
operator = (const GGS_TypeModel & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_TypeModel::
operator = (cPtr_TypeModel * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (cPtr_TypeModel * inSource) {
  mPointer = (cPtr_TypeModel *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_TypeModel * GGS_TypeModel
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_TypeModel
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_TypeModel) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_TypeModel
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @TypeModel" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'BoolModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_BoolModel::cPtr_BoolModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_BoolModel::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@BoolModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_BoolModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_BoolModel * GGS_BoolModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_BoolModel * ptr_ = (cPtr_BoolModel *) NULL ;
    macroMyNew (ptr_, cPtr_BoolModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'CharModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_CharModel::cPtr_CharModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_CharModel::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@CharModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_CharModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_CharModel * GGS_CharModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_CharModel * ptr_ = (cPtr_CharModel *) NULL ;
    macroMyNew (ptr_, cPtr_CharModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'UIntModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_UIntModel::cPtr_UIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_UIntModel::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@UIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_UIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_UIntModel * GGS_UIntModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_UIntModel * ptr_ = (cPtr_UIntModel *) NULL ;
    macroMyNew (ptr_, cPtr_UIntModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'SIntModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_SIntModel::cPtr_SIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_SIntModel::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@SIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_SIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_SIntModel * GGS_SIntModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_SIntModel * ptr_ = (cPtr_SIntModel *) NULL ;
    macroMyNew (ptr_, cPtr_SIntModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'UInt64Model'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_UInt64Model::cPtr_UInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_UInt64Model::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@UInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_UInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_UInt64Model * GGS_UInt64Model::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_UInt64Model * ptr_ = (cPtr_UInt64Model *) NULL ;
    macroMyNew (ptr_, cPtr_UInt64Model (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'SInt64Model'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_SInt64Model::cPtr_SInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_SInt64Model::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@SInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_SInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_SInt64Model * GGS_SInt64Model::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_SInt64Model * ptr_ = (cPtr_SInt64Model *) NULL ;
    macroMyNew (ptr_, cPtr_SInt64Model (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'DoubleModel'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_DoubleModel::cPtr_DoubleModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_DoubleModel::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@DoubleModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_DoubleModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_DoubleModel * GGS_DoubleModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_DoubleModel * ptr_ = (cPtr_DoubleModel *) NULL ;
    macroMyNew (ptr_, cPtr_DoubleModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'StringModel'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_StringModel::cPtr_StringModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_StringModel::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@StringModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_StringModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_StringModel * GGS_StringModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_StringModel * ptr_ = (cPtr_StringModel *) NULL ;
    macroMyNew (ptr_, cPtr_StringModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'LBoolModel'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LBoolModel::cPtr_LBoolModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LBoolModel::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LBoolModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LBoolModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LBoolModel * GGS_LBoolModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_LBoolModel * ptr_ = (cPtr_LBoolModel *) NULL ;
    macroMyNew (ptr_, cPtr_LBoolModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'LCharModel'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LCharModel::cPtr_LCharModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LCharModel::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LCharModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LCharModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LCharModel * GGS_LCharModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_LCharModel * ptr_ = (cPtr_LCharModel *) NULL ;
    macroMyNew (ptr_, cPtr_LCharModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'LUIntModel'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LUIntModel::cPtr_LUIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LUIntModel::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LUIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LUIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LUIntModel * GGS_LUIntModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_LUIntModel * ptr_ = (cPtr_LUIntModel *) NULL ;
    macroMyNew (ptr_, cPtr_LUIntModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'LSIntModel'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LSIntModel::cPtr_LSIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LSIntModel::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LSIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LSIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LSIntModel * GGS_LSIntModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_LSIntModel * ptr_ = (cPtr_LSIntModel *) NULL ;
    macroMyNew (ptr_, cPtr_LSIntModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'LUInt64Model'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LUInt64Model::cPtr_LUInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LUInt64Model::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LUInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LUInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LUInt64Model * GGS_LUInt64Model::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_LUInt64Model * ptr_ = (cPtr_LUInt64Model *) NULL ;
    macroMyNew (ptr_, cPtr_LUInt64Model (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'LSInt64Model'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LSInt64Model::cPtr_LSInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LSInt64Model::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LSInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LSInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LSInt64Model * GGS_LSInt64Model::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_LSInt64Model * ptr_ = (cPtr_LSInt64Model *) NULL ;
    macroMyNew (ptr_, cPtr_LSInt64Model (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'LDoubleModel'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LDoubleModel::cPtr_LDoubleModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LDoubleModel::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LDoubleModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LDoubleModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LDoubleModel * GGS_LDoubleModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_LDoubleModel * ptr_ = (cPtr_LDoubleModel *) NULL ;
    macroMyNew (ptr_, cPtr_LDoubleModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'LStringModel'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LStringModel::cPtr_LStringModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LStringModel::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LStringModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LStringModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LStringModel * GGS_LStringModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_LStringModel * ptr_ = (cPtr_LStringModel *) NULL ;
    macroMyNew (ptr_, cPtr_LStringModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'StringsetModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_StringsetModel::cPtr_StringsetModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_StringsetModel::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@StringsetModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_StringsetModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_StringsetModel * GGS_StringsetModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_StringsetModel * ptr_ = (cPtr_StringsetModel *) NULL ;
    macroMyNew (ptr_, cPtr_StringsetModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'LocationModel'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LocationModel::cPtr_LocationModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_LocationModel::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LocationModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LocationModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LocationModel * GGS_LocationModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_LocationModel * ptr_ = (cPtr_LocationModel *) NULL ;
    macroMyNew (ptr_, cPtr_LocationModel (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'ListModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ListModel::cPtr_ListModel (const GGS_typeListModel & argument_0 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mAttributeList (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_ListModel::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@ListModel:" ;
mAttributeList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_ListModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ListModel * GGS_ListModel::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeListModel & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_ListModel * ptr_ = (cPtr_ListModel *) NULL ;
    macroMyNew (ptr_, cPtr_ListModel (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                             class 'MapModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_MapModel::cPtr_MapModel (const GGS_typeListModel & argument_0 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mAttributeList (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_MapModel::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@MapModel:" ;
mAttributeList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_MapModel'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_MapModel * GGS_MapModel::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeListModel & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_MapModel * ptr_ = (cPtr_MapModel *) NULL ;
    macroMyNew (ptr_, cPtr_MapModel (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'enumConstantMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumConstantMap::
elementOf_GGS_enumConstantMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_enumConstantMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumConstantMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumConstantMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumConstantMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumConstantMap * info = (e_enumConstantMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap GGS_enumConstantMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumConstantMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_enumConstantMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' constant is not declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' constant is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap GGS_enumConstantMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_enumConstantMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumConstantMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap GGS_enumConstantMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumConstantMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumConstantMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @enumConstantMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'enumMessageMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageMap::
elementOf_GGS_enumMessageMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_enumMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumMessageMap * info = (e_enumMessageMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap GGS_enumMessageMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_enumMessageMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' message name is not declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' message name is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap GGS_enumMessageMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_enumMessageMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap GGS_enumMessageMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @enumMessageMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'EnumModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_EnumModel::cPtr_EnumModel (const GGS_enumConstantMap & argument_0,
                                const GGS_enumMessageMap & argument_1 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mEnumConstantesMap (argument_0),
mMessagesMap (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_EnumModel::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@EnumModel:" ;
mEnumConstantesMap.reader_description  (_inLexique COMMA_THERE) ;
mMessagesMap.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_EnumModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_EnumModel * GGS_EnumModel::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_enumConstantMap & argument_0,
                                const GGS_enumMessageMap & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_EnumModel * ptr_ = (cPtr_EnumModel *) NULL ;
    macroMyNew (ptr_, cPtr_EnumModel (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'constructorMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_constructorMap::
elementOf_GGS_constructorMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_constructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constructorMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mFormalInputArgumentList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_constructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constructorMap * info = (e_constructorMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constructorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeListModel &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_constructorMap info  ;
    info.mFormalInputArgumentList = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListModel   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalInputArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListModel   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' constructor is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListModel & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' constructor is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_constructorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constructorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constructorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constructorMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @constructorMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'readerMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_readerMap::
elementOf_GGS_readerMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_readerMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_readerMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mReaderFormalArgumentList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_readerMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_readerMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_readerMap * info = (e_readerMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_readerMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_readerMap info  ;
    info.mReaderFormalArgumentList = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mReaderFormalArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_readerMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' reader is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' reader is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_readerMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_readerMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_readerMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readerMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @readerMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'modifierMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_modifierMap::
elementOf_GGS_modifierMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_modifierMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_modifierMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mModifierFormalArgumentList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_modifierMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_modifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_modifierMap * info = (e_modifierMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_modifierMap info  ;
    info.mModifierFormalArgumentList = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mModifierFormalArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' modifier is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' modifier is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_modifierMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_modifierMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_modifierMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @modifierMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'ExternTypeModel'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ExternTypeModel::cPtr_ExternTypeModel (const GGS_constructorMap & argument_0,
                                const GGS_readerMap & argument_1,
                                const GGS_modifierMap & argument_2,
                                const GGS_typeListModel & argument_3 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mExternTypeConstructorMap (argument_0),
mReaderMap (argument_1),
mModifierMap (argument_2),
mAddAssignFormalInputArgumentList (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_ExternTypeModel::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@ExternTypeModel:" ;
mExternTypeConstructorMap.reader_description  (_inLexique COMMA_THERE) ;
mReaderMap.reader_description  (_inLexique COMMA_THERE) ;
mModifierMap.reader_description  (_inLexique COMMA_THERE) ;
mAddAssignFormalInputArgumentList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_ExternTypeModel'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ExternTypeModel * GGS_ExternTypeModel::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_constructorMap & argument_0,
                                const GGS_readerMap & argument_1,
                                const GGS_modifierMap & argument_2,
                                const GGS_typeListModel & argument_3 COMMA_LOCATION_ARGS) {
    cPtr_ExternTypeModel * ptr_ = (cPtr_ExternTypeModel *) NULL ;
    macroMyNew (ptr_, cPtr_ExternTypeModel (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'classMessageMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_classMessageMap::
elementOf_GGS_classMessageMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_classMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classMessageMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_classMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_classMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_classMessageMap * info = (e_classMessageMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap GGS_classMessageMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMessageMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_classMessageMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' message is not declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' message is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap GGS_classMessageMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_classMessageMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMessageMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap GGS_classMessageMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classMessageMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classMessageMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @classMessageMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'ClassModel'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ClassModel::cPtr_ClassModel (const GGS_bool& argument_0,
                                const GGS_stringset & argument_1,
                                const GGS_typeListModel & argument_2,
                                const GGS_classMessageMap & argument_3 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mIsAbstract (argument_0),
mSuperClasses (argument_1),
mAttributeList (argument_2),
mMessageMap (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_ClassModel::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@ClassModel:" ;
mIsAbstract.reader_description  (_inLexique COMMA_THERE) ;
mSuperClasses.reader_description  (_inLexique COMMA_THERE) ;
mAttributeList.reader_description  (_inLexique COMMA_THERE) ;
mMessageMap.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_ClassModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ClassModel * GGS_ClassModel::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_bool& argument_0,
                                const GGS_stringset & argument_1,
                                const GGS_typeListModel & argument_2,
                                const GGS_classMessageMap & argument_3 COMMA_LOCATION_ARGS) {
    cPtr_ClassModel * ptr_ = (cPtr_ClassModel *) NULL ;
    macroMyNew (ptr_, cPtr_ClassModel (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'ModelMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ModelMap::
elementOf_GGS_ModelMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_ModelMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ModelMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mType.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ModelMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_ModelMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ModelMap * info = (e_ModelMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ModelMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_TypeModel &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_ModelMap info  ;
    info.mType = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_TypeModel   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_TypeModel   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '@%K' type is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_TypeModel & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '@%K' type has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_ModelMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ModelMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ModelMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ModelMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @ModelMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'ActionMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ActionMap::
elementOf_GGS_ActionMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_ActionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ActionMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mSignature.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mIsExtern.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ActionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_ActionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ActionMap * info = (e_ActionMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_ActionMap GGS_ActionMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ActionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               const GGS_bool&  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_ActionMap info  ;
    info.mSignature = inParameter0 ;
    info.mIsExtern = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mSignature ;
    outParameter1 = node->mInfo.mIsExtern ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' action is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' extern action has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_ActionMap GGS_ActionMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_ActionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ActionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ActionMap GGS_ActionMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ActionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ActionMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @ActionMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Class for 'localConstantBuildStyleEnum' Enumeration             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator == (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator != (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator <= (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator >= (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator < (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator > (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localConstantBuildStyleEnum::
reader_description (C_Lexique & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS) const {
  C_String s ;
  s << "<enum @localConstantBuildStyleEnum" ;
  switch (mValue) {
case enum_listStyle:
  s << " listStyle" ;
    break ;
case enum_mapStyle:
  s << " mapStyle" ;
    break ;
case enum_firstIsKeyOtherMapStyle:
  s << " firstIsKeyOtherMapStyle" ;
    break ;
  case kNotBuilt:
    s << " (not built)" ;
    break ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_AC_galgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_galgasType::
cPtr_AC_galgasType (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_acceptAssignmentFromHere (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "assignment from 'here' is not allowed for variables of this type") SOURCE_FILE_AT_LINE (413)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_acceptForeachInstruction (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type cannot be enumerated by in 'foreach' instruction") SOURCE_FILE_AT_LINE (423)) ;
  var_cas_outForeachList.drop_operation () ;
  var_cas_outStyle.drop_operation () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_acceptToBeKeyForMap (C_Lexique & _inLexique COMMA_UNUSED_LOCATION_ARGS) {
  GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this type cannot be a key for map") SOURCE_FILE_AT_LINE (428)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") SOURCE_FILE_AT_LINE (438)) ;
  var_cas_outModifierSignature.drop_operation () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleReaderInstructionCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inReadObjectName */,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_EXsignature & var_cas_outReaderSignature COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support reader instruction") SOURCE_FILE_AT_LINE (449)) ;
  var_cas_outReaderSignature.drop_operation () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (457)) ;
  var_cas_outAccessorTypesList.drop_operation () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleMinusAssignOperatorCall (C_Lexique & _inLexique,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support call of '-=' operator") SOURCE_FILE_AT_LINE (467)) ;
  var_cas_outParametersList.drop_operation () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleAddAssignOperatorCall (C_Lexique & _inLexique,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support call of '+=' operator") SOURCE_FILE_AT_LINE (478)) ;
  var_cas_outParametersList.drop_operation () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleIncrementOperatorCall (C_Lexique & _inLexique,
                                GGS_location  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support call of '++' operator") SOURCE_FILE_AT_LINE (486)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleDecrementOperatorCall (C_Lexique & _inLexique,
                                GGS_location  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support call of '--' operator") SOURCE_FILE_AT_LINE (494)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & _inLexique COMMA_UNUSED_LOCATION_ARGS) {
  GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type cannot be silently converted to @location value") SOURCE_FILE_AT_LINE (500)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_typeCanBeUsedInObjectDeclaration (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType
::static_string_message_messageGalgasType (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType::
message_messageGalgasType (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_galgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (void) {
  mPointer = (cPtr_AC_galgasType *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (const GGS_AC_galgasType & inOperand) {
  mPointer = (cPtr_AC_galgasType *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
~GGS_AC_galgasType (void) {
  macroDetachPointer (mPointer, cPtr_AC_galgasType) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_galgasType::
operator = (const GGS_AC_galgasType & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_galgasType::
operator = (cPtr_AC_galgasType * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (cPtr_AC_galgasType * inSource) {
  mPointer = (cPtr_AC_galgasType *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_galgasType * GGS_AC_galgasType
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_AC_galgasType::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_galgasType
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_galgasType) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_galgasType
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @AC_galgasType" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Class for 'metamodelPropertyKind' Enumeration                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelPropertyKind::
operator == (const GGS_metamodelPropertyKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelPropertyKind::
operator != (const GGS_metamodelPropertyKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelPropertyKind::
operator <= (const GGS_metamodelPropertyKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelPropertyKind::
operator >= (const GGS_metamodelPropertyKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelPropertyKind::
operator < (const GGS_metamodelPropertyKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelPropertyKind::
operator > (const GGS_metamodelPropertyKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelPropertyKind::
reader_description (C_Lexique & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS) const {
  C_String s ;
  s << "<enum @metamodelPropertyKind" ;
  switch (mValue) {
case enum_attributeProperty:
  s << " attributeProperty" ;
    break ;
case enum_singleReferenceProperty:
  s << " singleReferenceProperty" ;
    break ;
case enum_multipleReferenceProperty:
  s << " multipleReferenceProperty" ;
    break ;
  case kNotBuilt:
    s << " (not built)" ;
    break ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_propertyPath'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_propertyPath::
elementOf_GGS_L_propertyPath (const GGS_lstring & argument_0):
mNextItem (NULL),
mPathElement (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_propertyPath::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mPathElement.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_propertyPath'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_propertyPath::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_propertyPath::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_propertyPath::GGS_L_propertyPath (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_propertyPath::~GGS_L_propertyPath (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_propertyPath::
GGS_L_propertyPath (const GGS_L_propertyPath & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
operator = (const GGS_L_propertyPath & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_propertyPath::element_type * GGS_L_propertyPath::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mPathElement) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_propertyPath  GGS_L_propertyPath::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_propertyPath result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_propertyPath::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_propertyPath::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_propertyPath" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_propertyPath::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@L_ListOfPropertyPathes'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_ListOfPropertyPathes::
elementOf_GGS_L_ListOfPropertyPathes (const GGS_L_propertyPath & argument_0,
                                const GGS_location & argument_1):
mNextItem (NULL),
mPath (argument_0),
mEndOfPathLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_ListOfPropertyPathes::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mPath.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mEndOfPathLocation.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@L_ListOfPropertyPathes'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes::GGS_L_ListOfPropertyPathes (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes::~GGS_L_ListOfPropertyPathes (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes::
GGS_L_ListOfPropertyPathes (const GGS_L_ListOfPropertyPathes & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
operator = (const GGS_L_ListOfPropertyPathes & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes::element_type * GGS_L_ListOfPropertyPathes::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
internalAppendItem (const GGS_L_propertyPath & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
addAssign_operation (const GGS_L_propertyPath & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mPath,
                                p->mEndOfPathLocation) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes  GGS_L_ListOfPropertyPathes::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_ListOfPropertyPathes result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_ListOfPropertyPathes::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_ListOfPropertyPathes::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_ListOfPropertyPathes" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_ListOfPropertyPathes::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'entityPropertyMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_entityPropertyMap::
elementOf_GGS_entityPropertyMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_entityPropertyMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_entityPropertyMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mKind.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mTypeName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_entityPropertyMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_entityPropertyMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_entityPropertyMap * info = (e_entityPropertyMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_entityPropertyMap GGS_entityPropertyMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_entityPropertyMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_metamodelPropertyKind&  inParameter0,
               const GGS_lstring &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_entityPropertyMap info  ;
    info.mKind = inParameter0 ;
    info.mTypeName = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_metamodelPropertyKind  & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mKind ;
    outParameter1 = node->mInfo.mTypeName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_metamodelPropertyKind  & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' property is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_metamodelPropertyKind& inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' property has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_entityPropertyMap GGS_entityPropertyMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_entityPropertyMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_entityPropertyMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_entityPropertyMap GGS_entityPropertyMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_entityPropertyMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_entityPropertyMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @entityPropertyMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'contextPropertyMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_contextPropertyMap::
elementOf_GGS_contextPropertyMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_contextPropertyMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_contextPropertyMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mTypeName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mIsMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_contextPropertyMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_contextPropertyMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_contextPropertyMap * info = (e_contextPropertyMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_contextPropertyMap GGS_contextPropertyMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_contextPropertyMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               const GGS_bool&  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_contextPropertyMap info  ;
    info.mTypeName = inParameter0 ;
    info.mIsMap = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mTypeName ;
    outParameter1 = node->mInfo.mIsMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' context property is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' context property has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_contextPropertyMap GGS_contextPropertyMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_contextPropertyMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_contextPropertyMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_contextPropertyMap GGS_contextPropertyMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_contextPropertyMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_contextPropertyMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @contextPropertyMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'contextParameterMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_contextParameterMap::
elementOf_GGS_contextParameterMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_contextParameterMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_contextParameterMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mContextParameterList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_contextParameterMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_contextParameterMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_contextParameterMap * info = (e_contextParameterMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_contextParameterMap GGS_contextParameterMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_contextParameterMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_contextParameterMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_contextParameterMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_lstringList &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_contextParameterMap info  ;
    info.mContextParameterList = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_contextParameterMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_lstringList   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mContextParameterList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_contextParameterMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_lstringList   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' context property is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_contextParameterMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_lstringList & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "context parameter are already defined for the '%K' property",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_contextParameterMap GGS_contextParameterMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_contextParameterMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_contextParameterMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_contextParameterMap GGS_contextParameterMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_contextParameterMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_contextParameterMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @contextParameterMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'mapPropertyMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapPropertyMap::
elementOf_GGS_mapPropertyMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapPropertyMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapPropertyMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mTypeName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapPropertyMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapPropertyMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapPropertyMap * info = (e_mapPropertyMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_mapPropertyMap GGS_mapPropertyMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapPropertyMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_mapPropertyMap info  ;
    info.mTypeName = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mTypeName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' map property is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' map property has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapPropertyMap GGS_mapPropertyMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_mapPropertyMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapPropertyMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapPropertyMap GGS_mapPropertyMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapPropertyMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapPropertyMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @mapPropertyMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'insertionMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_insertionMap::
elementOf_GGS_insertionMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_insertionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_insertionMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mIndexName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_insertionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_insertionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_insertionMap * info = (e_insertionMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_insertionMap GGS_insertionMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_insertionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertionMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_insertionMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_insertionMap info  ;
    info.mIndexName = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertionMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mIndexName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertionMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the attribute is already inserted in the '%K' map",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_insertionMap GGS_insertionMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_insertionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_insertionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertionMap GGS_insertionMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertionMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @insertionMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'relationVarMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_relationVarMap::
elementOf_GGS_relationVarMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_relationVarMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_relationVarMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mDomainVariableName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_relationVarMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_relationVarMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_relationVarMap * info = (e_relationVarMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_relationVarMap GGS_relationVarMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_relationVarMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_relationVarMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_relationVarMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_relationVarMap info  ;
    info.mDomainVariableName = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_relationVarMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mDomainVariableName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_relationVarMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' relation variable is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_relationVarMap::method_searchKeyAndGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' relation variable is not declared",
                 inKey,
                 outParameter0,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_relationVarMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' relation variable has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_relationVarMap GGS_relationVarMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_relationVarMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_relationVarMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_relationVarMap GGS_relationVarMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_relationVarMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_relationVarMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @relationVarMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_metamodelRelationExpression'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationExpression::
cPtr_metamodelRelationExpression (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_metamodelRelationExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelRelationExpression::
GGS_metamodelRelationExpression (void) {
  mPointer = (cPtr_metamodelRelationExpression *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationExpression::
GGS_metamodelRelationExpression (const GGS_metamodelRelationExpression & inOperand) {
  mPointer = (cPtr_metamodelRelationExpression *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationExpression::
~GGS_metamodelRelationExpression (void) {
  macroDetachPointer (mPointer, cPtr_metamodelRelationExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationExpression::
operator = (const GGS_metamodelRelationExpression & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationExpression::
operator = (cPtr_metamodelRelationExpression * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationExpression::
GGS_metamodelRelationExpression (cPtr_metamodelRelationExpression * inSource) {
  mPointer = (cPtr_metamodelRelationExpression *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationExpression * GGS_metamodelRelationExpression
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_metamodelRelationExpression
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_metamodelRelationExpression) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelRelationExpression
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @metamodelRelationExpression" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'metamodelRelationAnd'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationAnd::cPtr_metamodelRelationAnd (const GGS_metamodelRelationExpression & argument_0,
                                const GGS_metamodelRelationExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_metamodelRelationExpression (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationAnd::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationAnd:" ;
mLeftOperand.reader_description  (_inLexique COMMA_THERE) ;
mRightOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_metamodelRelationAnd'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationAnd * GGS_metamodelRelationAnd::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_metamodelRelationExpression & argument_0,
                                const GGS_metamodelRelationExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_metamodelRelationAnd * ptr_ = (cPtr_metamodelRelationAnd *) NULL ;
    macroMyNew (ptr_, cPtr_metamodelRelationAnd (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'metamodelRelationOr'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationOr::cPtr_metamodelRelationOr (const GGS_metamodelRelationExpression & argument_0,
                                const GGS_metamodelRelationExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_metamodelRelationExpression (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationOr::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationOr:" ;
mLeftOperand.reader_description  (_inLexique COMMA_THERE) ;
mRightOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_metamodelRelationOr'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationOr * GGS_metamodelRelationOr::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_metamodelRelationExpression & argument_0,
                                const GGS_metamodelRelationExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_metamodelRelationOr * ptr_ = (cPtr_metamodelRelationOr *) NULL ;
    macroMyNew (ptr_, cPtr_metamodelRelationOr (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'metamodelRelationNot'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationNot::cPtr_metamodelRelationNot (const GGS_metamodelRelationExpression & argument_0 COMMA_LOCATION_ARGS)
:cPtr_metamodelRelationExpression (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationNot::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationNot:" ;
mOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_metamodelRelationNot'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationNot * GGS_metamodelRelationNot::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_metamodelRelationExpression & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_metamodelRelationNot * ptr_ = (cPtr_metamodelRelationNot *) NULL ;
    macroMyNew (ptr_, cPtr_metamodelRelationNot (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'metamodelRelationTrue'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationTrue::cPtr_metamodelRelationTrue (LOCATION_ARGS)
:cPtr_metamodelRelationExpression (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationTrue::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationTrue:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_metamodelRelationTrue'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationTrue * GGS_metamodelRelationTrue::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_metamodelRelationTrue * ptr_ = (cPtr_metamodelRelationTrue *) NULL ;
    macroMyNew (ptr_, cPtr_metamodelRelationTrue (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'metamodelRelationFalse'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationFalse::cPtr_metamodelRelationFalse (LOCATION_ARGS)
:cPtr_metamodelRelationExpression (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationFalse::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationFalse:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_metamodelRelationFalse'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationFalse * GGS_metamodelRelationFalse::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_metamodelRelationFalse * ptr_ = (cPtr_metamodelRelationFalse *) NULL ;
    macroMyNew (ptr_, cPtr_metamodelRelationFalse (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'metamodelRelationPrimary'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationPrimary::cPtr_metamodelRelationPrimary (const GGS_relationVarMap & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstring & argument_4 COMMA_LOCATION_ARGS)
:cPtr_metamodelRelationExpression (THERE),
mRelationVariableMap (argument_0),
mVariable (argument_1),
mVariableIndex (argument_2),
mVariableMap (argument_3),
mDomainName (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationPrimary::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationPrimary:" ;
mRelationVariableMap.reader_description  (_inLexique COMMA_THERE) ;
mVariable.reader_description  (_inLexique COMMA_THERE) ;
mVariableIndex.reader_description  (_inLexique COMMA_THERE) ;
mVariableMap.reader_description  (_inLexique COMMA_THERE) ;
mDomainName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_metamodelRelationPrimary'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationPrimary * GGS_metamodelRelationPrimary::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_relationVarMap & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstring & argument_4 COMMA_LOCATION_ARGS) {
    cPtr_metamodelRelationPrimary * ptr_ = (cPtr_metamodelRelationPrimary *) NULL ;
    macroMyNew (ptr_, cPtr_metamodelRelationPrimary (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@metamodelRelationParameterList'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_metamodelRelationParameterList::
elementOf_GGS_metamodelRelationParameterList (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_lstring & argument_2):
mNextItem (NULL),
mParameter (argument_0),
mParameterIndex (argument_1),
mDomainVariable (argument_2) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_metamodelRelationParameterList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mParameter.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mParameterIndex.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mDomainVariable.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@metamodelRelationParameterList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelRelationParameterList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationParameterList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationParameterList::GGS_metamodelRelationParameterList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationParameterList::~GGS_metamodelRelationParameterList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationParameterList::
GGS_metamodelRelationParameterList (const GGS_metamodelRelationParameterList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationParameterList::
operator = (const GGS_metamodelRelationParameterList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationParameterList::element_type * GGS_metamodelRelationParameterList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationParameterList::
internalAppendItem (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_lstring & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationParameterList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationParameterList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mParameter,
                                p->mParameterIndex,
                                p->mDomainVariable) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationParameterList  GGS_metamodelRelationParameterList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_metamodelRelationParameterList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_metamodelRelationParameterList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelRelationParameterList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @metamodelRelationParameterList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_metamodelRelationParameterList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationParameterList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'metamodelRelationDo'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationDo::cPtr_metamodelRelationDo (const GGS_relationVarMap & argument_0,
                                const GGS_metamodelRelationParameterList & argument_1,
                                const GGS_L_propertyPath & argument_2,
                                const GGS_lbool & argument_3 COMMA_LOCATION_ARGS)
:cPtr_metamodelRelationExpression (THERE),
mRelationVariableMap (argument_0),
mParameterList (argument_1),
mPath (argument_2),
mOperationIsAnd (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationDo::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationDo:" ;
mRelationVariableMap.reader_description  (_inLexique COMMA_THERE) ;
mParameterList.reader_description  (_inLexique COMMA_THERE) ;
mPath.reader_description  (_inLexique COMMA_THERE) ;
mOperationIsAnd.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_metamodelRelationDo'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationDo * GGS_metamodelRelationDo::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_relationVarMap & argument_0,
                                const GGS_metamodelRelationParameterList & argument_1,
                                const GGS_L_propertyPath & argument_2,
                                const GGS_lbool & argument_3 COMMA_LOCATION_ARGS) {
    cPtr_metamodelRelationDo * ptr_ = (cPtr_metamodelRelationDo *) NULL ;
    macroMyNew (ptr_, cPtr_metamodelRelationDo (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'relationMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_relationMap::
elementOf_GGS_relationMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_relationMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_relationMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mRelationVarMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mExpression.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_relationMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_relationMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_relationMap * info = (e_relationMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_relationMap GGS_relationMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_relationMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_relationMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_relationMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_relationVarMap &  inParameter0,
               const GGS_metamodelRelationExpression &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_relationMap info  ;
    info.mRelationVarMap = inParameter0 ;
    info.mExpression = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_relationMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_relationVarMap   & outParameter0,
               GGS_metamodelRelationExpression   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mRelationVarMap ;
    outParameter1 = node->mInfo.mExpression ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_relationMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_relationVarMap   & outParameter0,
                                GGS_metamodelRelationExpression   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' relation property is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_relationMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_relationVarMap & inParameter0,
                                const GGS_metamodelRelationExpression & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' relation property has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_relationMap GGS_relationMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_relationMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_relationMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_relationMap GGS_relationMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_relationMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_relationMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @relationMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'mapEntityMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapEntityMap::
elementOf_GGS_mapEntityMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapEntityMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapEntityMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mElementEntityName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mInsertErrorMessage.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mSearchErrorMessage.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapEntityMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapEntityMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapEntityMap * info = (e_mapEntityMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_mapEntityMap GGS_mapEntityMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapEntityMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapEntityMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapEntityMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               const GGS_lstring &  inParameter1,
               const GGS_lstring &  inParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_mapEntityMap info  ;
    info.mElementEntityName = inParameter0 ;
    info.mInsertErrorMessage = inParameter1 ;
    info.mSearchErrorMessage = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapEntityMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mElementEntityName ;
    outParameter1 = node->mInfo.mInsertErrorMessage ;
    outParameter2 = node->mInfo.mSearchErrorMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapEntityMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_lstring   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' map is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapEntityMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_lstring & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' map has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapEntityMap GGS_mapEntityMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_mapEntityMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapEntityMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapEntityMap GGS_mapEntityMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapEntityMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapEntityMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @mapEntityMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'mapAndEntityUniqueMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapAndEntityUniqueMap::
elementOf_GGS_mapAndEntityUniqueMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapAndEntityUniqueMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapAndEntityUniqueMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapAndEntityUniqueMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapAndEntityUniqueMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapAndEntityUniqueMap * info = (e_mapAndEntityUniqueMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_mapAndEntityUniqueMap GGS_mapAndEntityUniqueMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapAndEntityUniqueMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapAndEntityUniqueMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAndEntityUniqueMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_mapAndEntityUniqueMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapAndEntityUniqueMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapAndEntityUniqueMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' entity or map is not declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAndEntityUniqueMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' entity or map has been already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapAndEntityUniqueMap GGS_mapAndEntityUniqueMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_mapAndEntityUniqueMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapAndEntityUniqueMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapAndEntityUniqueMap GGS_mapAndEntityUniqueMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapAndEntityUniqueMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapAndEntityUniqueMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @mapAndEntityUniqueMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'entityToImplementMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_entityToImplementMap::
elementOf_GGS_entityToImplementMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_entityToImplementMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_entityToImplementMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mAllPropertiesMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mIsAbstract.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mEntityPropertiesMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mSuperEntityName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_entityToImplementMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_entityToImplementMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_entityToImplementMap * info = (e_entityToImplementMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_entityToImplementMap GGS_entityToImplementMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_entityToImplementMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_entityPropertyMap &  inParameter0,
               const GGS_bool&  inParameter1,
               const GGS_entityPropertyMap &  inParameter2,
               const GGS_lstring &  inParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_entityToImplementMap info  ;
    info.mAllPropertiesMap = inParameter0 ;
    info.mIsAbstract = inParameter1 ;
    info.mEntityPropertiesMap = inParameter2 ;
    info.mSuperEntityName = inParameter3 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_entityPropertyMap   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_entityPropertyMap   & outParameter2,
               GGS_lstring   & outParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAllPropertiesMap ;
    outParameter1 = node->mInfo.mIsAbstract ;
    outParameter2 = node->mInfo.mEntityPropertiesMap ;
    outParameter3 = node->mInfo.mSuperEntityName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_entityPropertyMap   & outParameter0,
                                GGS_bool  & outParameter1,
                                GGS_entityPropertyMap   & outParameter2,
                                GGS_lstring   & outParameter3 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '@%K' entity is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_entityPropertyMap & inParameter0,
                                const GGS_bool& inParameter1,
                                const GGS_entityPropertyMap & inParameter2,
                                const GGS_lstring & inParameter3 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '@%K' entity has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_entityToImplementMap GGS_entityToImplementMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_entityToImplementMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_entityToImplementMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_entityToImplementMap GGS_entityToImplementMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_entityToImplementMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_entityToImplementMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @entityToImplementMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeGalgas_singleEntity'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_singleEntity::cPtr_typeGalgas_singleEntity (const GGS_lstring & argument_0,
                                const GGS_entityPropertyMap & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_entityPropertyMap & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_stringset & argument_5 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEntityName (argument_0),
mAllPropertiesMap (argument_1),
mIsAbstract (argument_2),
mEntityPropertiesMap (argument_3),
mSuperEntityName (argument_4),
mSuperEntitiesSet (argument_5) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_singleEntity::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mEntityName.reader_value (_inLexique SOURCE_FILE_AT_LINE (702)) ;
}


const char * cPtr_typeGalgas_singleEntity::message_messageGalgasType (void) const {
  return "an entity" ;
}

const char * cPtr_typeGalgas_singleEntity::static_string_message_messageGalgasType (void) {
  return "an entity" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_singleEntity::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_singleEntity:" ;
mEntityName.reader_description  (_inLexique COMMA_THERE) ;
mAllPropertiesMap.reader_description  (_inLexique COMMA_THERE) ;
mIsAbstract.reader_description  (_inLexique COMMA_THERE) ;
mEntityPropertiesMap.reader_description  (_inLexique COMMA_THERE) ;
mSuperEntityName.reader_description  (_inLexique COMMA_THERE) ;
mSuperEntitiesSet.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeGalgas_singleEntity'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_singleEntity * GGS_typeGalgas_singleEntity::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_entityPropertyMap & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_entityPropertyMap & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_stringset & argument_5 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_singleEntity * ptr_ = (cPtr_typeGalgas_singleEntity *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_singleEntity (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeGalgas_multipleEntity'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_multipleEntity::cPtr_typeGalgas_multipleEntity (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEntityName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_multipleEntity::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = ((GGS_string (true, "_listOf_")) + (mEntityName.reader_value (_inLexique SOURCE_FILE_AT_LINE (715)))) ;
}


const char * cPtr_typeGalgas_multipleEntity::message_messageGalgasType (void) const {
  return "a list of entities" ;
}

const char * cPtr_typeGalgas_multipleEntity::static_string_message_messageGalgasType (void) {
  return "a list of entities" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_multipleEntity::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_multipleEntity:" ;
mEntityName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeGalgas_multipleEntity'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_multipleEntity * GGS_typeGalgas_multipleEntity::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_multipleEntity * ptr_ = (cPtr_typeGalgas_multipleEntity *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_multipleEntity (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeAttributsSemantiques'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeAttributsSemantiques::
elementOf_GGS_typeListeAttributsSemantiques (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1):
mNextItem (NULL),
mAttributType (argument_0),
aNomAttribut (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeAttributsSemantiques::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mAttributType.reader_description  (_inLexique COMMA_THERE) ;
  ioString << aNomAttribut.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeAttributsSemantiques'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::GGS_typeListeAttributsSemantiques (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::~GGS_typeListeAttributsSemantiques (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::
GGS_typeListeAttributsSemantiques (const GGS_typeListeAttributsSemantiques & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
operator = (const GGS_typeListeAttributsSemantiques & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::element_type * GGS_typeListeAttributsSemantiques::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mAttributType,
                                p->aNomAttribut) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeListeAttributsSemantiques::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeAttributsSemantiques result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeListeAttributsSemantiques::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeAttributsSemantiques::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeListeAttributsSemantiques" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeListeAttributsSemantiques::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@typeTypesList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTypesList::
elementOf_GGS_typeTypesList (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1):
mNextItem (NULL),
mType (argument_0),
mEndOfExpressionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTypesList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mEndOfExpressionLocation.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@typeTypesList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTypesList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeTypesList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeTypesList::GGS_typeTypesList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeTypesList::~GGS_typeTypesList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeTypesList::
GGS_typeTypesList (const GGS_typeTypesList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
operator = (const GGS_typeTypesList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeTypesList::element_type * GGS_typeTypesList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mEndOfExpressionLocation) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeTypesList  GGS_typeTypesList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTypesList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeTypesList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTypesList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeTypesList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeTypesList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_EXsignature'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_EXsignature::
elementOf_GGS_L_EXsignature (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1):
mNextItem (NULL),
mType (argument_0),
mFormalArgumentPassingMode (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_EXsignature::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mFormalArgumentPassingMode.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_EXsignature'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_EXsignature::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature::GGS_L_EXsignature (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature::~GGS_L_EXsignature (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature::
GGS_L_EXsignature (const GGS_L_EXsignature & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
operator = (const GGS_L_EXsignature & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature::element_type * GGS_L_EXsignature::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                    const GGS_formalArgumentPassingMode& argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mFormalArgumentPassingMode) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_L_EXsignature::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_EXsignature result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_EXsignature::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_EXsignature::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_EXsignature" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_EXsignature::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_actualParametersSignature'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_actualParametersSignature::
elementOf_GGS_L_actualParametersSignature (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1):
mNextItem (NULL),
mType (argument_0),
mFormalArgumentPassingMode (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_actualParametersSignature::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mFormalArgumentPassingMode.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@L_actualParametersSignature'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::GGS_L_actualParametersSignature (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::~GGS_L_actualParametersSignature (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::
GGS_L_actualParametersSignature (const GGS_L_actualParametersSignature & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
operator = (const GGS_L_actualParametersSignature & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::element_type * GGS_L_actualParametersSignature::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                    const GGS_actualParametersPassingMode& argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mFormalArgumentPassingMode) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature  GGS_L_actualParametersSignature::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_actualParametersSignature result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_actualParametersSignature::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_actualParametersSignature::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_actualParametersSignature" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_actualParametersSignature::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'M_accessors_map'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_accessors_map::
elementOf_GGS_M_accessors_map (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_accessors_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_accessors_map::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mAccessorSignature.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mReturnedType.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_accessors_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_accessors_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_accessors_map * info = (e_M_accessors_map *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_accessors_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_EXsignature &  inParameter0,
               const GGS_AC_galgasType &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_accessors_map info  ;
    info.mAccessorSignature = inParameter0 ;
    info.mReturnedType = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAccessorSignature ;
    outParameter1 = node->mInfo.mReturnedType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_AC_galgasType   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' accessor is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_AC_galgasType & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' accessor has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_accessors_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_accessors_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_accessors_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_accessors_map::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_accessors_map " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_stringList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_stringList::
elementOf_GGS_L_stringList (const GGS_string& argument_0):
mNextItem (NULL),
mErrorMessageElement (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_stringList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mErrorMessageElement.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@L_stringList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_stringList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_stringList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_stringList::GGS_L_stringList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_stringList::~GGS_L_stringList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_stringList::
GGS_L_stringList (const GGS_L_stringList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
operator = (const GGS_L_stringList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_stringList::element_type * GGS_L_stringList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
internalAppendItem (const GGS_string& argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
addAssign_operation (const GGS_string& argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mErrorMessageElement) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_stringList  GGS_L_stringList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_stringList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_stringList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_stringList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_stringList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_stringList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeGalgas_jokerInParameterList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_jokerInParameterList::cPtr_typeGalgas_jokerInParameterList (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_jokerInParameterList::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "") ;
}


const char * cPtr_typeGalgas_jokerInParameterList::message_messageGalgasType (void) const {
  return "\?\?" ;
}

const char * cPtr_typeGalgas_jokerInParameterList::static_string_message_messageGalgasType (void) {
  return "\?\?" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_jokerInParameterList::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_jokerInParameterList:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeGalgas_jokerInParameterList'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_jokerInParameterList * GGS_typeGalgas_jokerInParameterList::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_jokerInParameterList * ptr_ = (cPtr_typeGalgas_jokerInParameterList *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_jokerInParameterList (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_bool'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_bool::cPtr_typeGalgas_bool (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "bool") ;
}


const char * cPtr_typeGalgas_bool::message_messageGalgasType (void) const {
  return "a '@bool' type" ;
}

const char * cPtr_typeGalgas_bool::static_string_message_messageGalgasType (void) {
  return "a '@bool' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_bool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_bool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_bool * GGS_typeGalgas_bool::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_bool * ptr_ = (cPtr_typeGalgas_bool *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_bool (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_string'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_string::cPtr_typeGalgas_string (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "string") ;
}


const char * cPtr_typeGalgas_string::message_messageGalgasType (void) const {
  return "a '@string' type" ;
}

const char * cPtr_typeGalgas_string::static_string_message_messageGalgasType (void) {
  return "a '@string' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_string:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_string'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_string * GGS_typeGalgas_string::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_string * ptr_ = (cPtr_typeGalgas_string *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_string (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_sint'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_sint::cPtr_typeGalgas_sint (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "sint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_handleIncrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_handleDecrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (856))) == (GGS_string (true, "min"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (858))) == (GGS_string (true, "max"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (862)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}


const char * cPtr_typeGalgas_sint::message_messageGalgasType (void) const {
  return "a '@sint' type" ;
}

const char * cPtr_typeGalgas_sint::static_string_message_messageGalgasType (void) {
  return "a '@sint' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_sint:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_sint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_sint * GGS_typeGalgas_sint::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_sint * ptr_ = (cPtr_typeGalgas_sint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_sint (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_sint64'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_sint64::cPtr_typeGalgas_sint64 (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "sint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_handleIncrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_handleDecrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (894))) == (GGS_string (true, "min"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (896))) == (GGS_string (true, "max"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (900)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}


const char * cPtr_typeGalgas_sint64::message_messageGalgasType (void) const {
  return "a '@sint64' type" ;
}

const char * cPtr_typeGalgas_sint64::static_string_message_messageGalgasType (void) {
  return "a '@sint64' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_sint64:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_sint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_sint64 * GGS_typeGalgas_sint64::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_sint64 * ptr_ = (cPtr_typeGalgas_sint64 *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_sint64 (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_uint'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_uint::cPtr_typeGalgas_uint (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "uint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_handleIncrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_handleDecrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (932))) == (GGS_string (true, "max"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (936)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}


const char * cPtr_typeGalgas_uint::message_messageGalgasType (void) const {
  return "a '@uint' type" ;
}

const char * cPtr_typeGalgas_uint::static_string_message_messageGalgasType (void) {
  return "a '@uint' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_uint:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_uint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_uint * GGS_typeGalgas_uint::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_uint * ptr_ = (cPtr_typeGalgas_uint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_uint (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_uint64'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_uint64::cPtr_typeGalgas_uint64 (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "uint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_handleIncrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_handleDecrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (968))) == (GGS_string (true, "max"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (972)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}


const char * cPtr_typeGalgas_uint64::message_messageGalgasType (void) const {
  return "a '@uint64' type" ;
}

const char * cPtr_typeGalgas_uint64::static_string_message_messageGalgasType (void) {
  return "a '@uint64' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_uint64:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_uint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_uint64 * GGS_typeGalgas_uint64::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_uint64 * ptr_ = (cPtr_typeGalgas_uint64 *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_uint64 (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_char'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_char::cPtr_typeGalgas_char (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "char") ;
}


const char * cPtr_typeGalgas_char::message_messageGalgasType (void) const {
  return "a '@char' type" ;
}

const char * cPtr_typeGalgas_char::static_string_message_messageGalgasType (void) {
  return "a '@char' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_char:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_char'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_char * GGS_typeGalgas_char::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_char * ptr_ = (cPtr_typeGalgas_char *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_char (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_double'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_double::cPtr_typeGalgas_double (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_double::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "double") ;
}


const char * cPtr_typeGalgas_double::message_messageGalgasType (void) const {
  return "a '@double' type" ;
}

const char * cPtr_typeGalgas_double::static_string_message_messageGalgasType (void) {
  return "a '@double' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_double::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_double:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_double'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_double * GGS_typeGalgas_double::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_double * ptr_ = (cPtr_typeGalgas_double *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_double (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_galgasPrimitiveType'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_galgasPrimitiveType::
cPtr_C_galgasPrimitiveType (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType
::static_string_message_messageGalgasType (void) {
  return "any primitive type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType::
message_messageGalgasType (void) const {
  return "any primitive type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_galgasPrimitiveType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (void) {
  mPointer = (cPtr_C_galgasPrimitiveType *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (const GGS_C_galgasPrimitiveType & inOperand) {
  mPointer = (cPtr_C_galgasPrimitiveType *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
~GGS_C_galgasPrimitiveType (void) {
  macroDetachPointer (mPointer, cPtr_C_galgasPrimitiveType) ;
}

//---------------------------------------------------------------------------*

void GGS_C_galgasPrimitiveType::
operator = (const GGS_C_galgasPrimitiveType & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_C_galgasPrimitiveType::
operator = (cPtr_C_galgasPrimitiveType * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (cPtr_C_galgasPrimitiveType * inSource) {
  mPointer = (cPtr_C_galgasPrimitiveType *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_galgasPrimitiveType * GGS_C_galgasPrimitiveType
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_galgasPrimitiveType::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_C_galgasPrimitiveType
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_C_galgasPrimitiveType) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_galgasPrimitiveType
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @C_galgasPrimitiveType" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgas_location'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_location::cPtr_typeGalgas_location (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "location") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
method_acceptAssignmentFromHere (C_Lexique & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}


const char * cPtr_typeGalgas_location::message_messageGalgasType (void) const {
  return "a '@location' type" ;
}

const char * cPtr_typeGalgas_location::static_string_message_messageGalgasType (void) {
  return "a '@location' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_location:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_location'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_location * GGS_typeGalgas_location::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_location * ptr_ = (cPtr_typeGalgas_location *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_location (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_lstring'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lstring::cPtr_typeGalgas_lstring (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "lstring") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1049))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1057)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_acceptToBeKeyForMap (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}


const char * cPtr_typeGalgas_lstring::message_messageGalgasType (void) const {
  return "a '@lstring' type" ;
}

const char * cPtr_typeGalgas_lstring::static_string_message_messageGalgasType (void) {
  return "a '@lstring' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lstring:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_lstring'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lstring * GGS_typeGalgas_lstring::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_lstring * ptr_ = (cPtr_typeGalgas_lstring *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lstring (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lchar'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lchar::cPtr_typeGalgas_lchar (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "lchar") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1084))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_char::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1092)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}


const char * cPtr_typeGalgas_lchar::message_messageGalgasType (void) const {
  return "a '@lchar' type" ;
}

const char * cPtr_typeGalgas_lchar::static_string_message_messageGalgasType (void) {
  return "a '@lchar' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lchar:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lchar'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lchar * GGS_typeGalgas_lchar::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_lchar * ptr_ = (cPtr_typeGalgas_lchar *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lchar (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lbool'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lbool::cPtr_typeGalgas_lbool (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "lbool") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1115))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_bool::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1123)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}


const char * cPtr_typeGalgas_lbool::message_messageGalgasType (void) const {
  return "a '@lbool' type" ;
}

const char * cPtr_typeGalgas_lbool::static_string_message_messageGalgasType (void) {
  return "a '@lbool' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lbool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lbool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lbool * GGS_typeGalgas_lbool::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_lbool * ptr_ = (cPtr_typeGalgas_lbool *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lbool (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_luint'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_luint::cPtr_typeGalgas_luint (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "luint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1146))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1154)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_acceptToBeKeyForMap (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}


const char * cPtr_typeGalgas_luint::message_messageGalgasType (void) const {
  return "a '@luint' type" ;
}

const char * cPtr_typeGalgas_luint::static_string_message_messageGalgasType (void) {
  return "a '@luint' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_luint:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_luint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_luint * GGS_typeGalgas_luint::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_luint * ptr_ = (cPtr_typeGalgas_luint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_luint (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_luint64'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_luint64::cPtr_typeGalgas_luint64 (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "luint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1181))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1189)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_acceptToBeKeyForMap (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}


const char * cPtr_typeGalgas_luint64::message_messageGalgasType (void) const {
  return "a '@luint64' type" ;
}

const char * cPtr_typeGalgas_luint64::static_string_message_messageGalgasType (void) {
  return "a '@luint64' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_luint64:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_luint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_luint64 * GGS_typeGalgas_luint64::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_luint64 * ptr_ = (cPtr_typeGalgas_luint64 *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_luint64 (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lsint'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lsint::cPtr_typeGalgas_lsint (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "lsint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1216))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_sint::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1224)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_acceptToBeKeyForMap (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}


const char * cPtr_typeGalgas_lsint::message_messageGalgasType (void) const {
  return "a '@lsint' type" ;
}

const char * cPtr_typeGalgas_lsint::static_string_message_messageGalgasType (void) {
  return "a '@lsint' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lsint:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lsint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lsint * GGS_typeGalgas_lsint::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_lsint * ptr_ = (cPtr_typeGalgas_lsint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lsint (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_lsint64'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lsint64::cPtr_typeGalgas_lsint64 (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "lsint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1251))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_sint::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1259)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_acceptToBeKeyForMap (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}


const char * cPtr_typeGalgas_lsint64::message_messageGalgasType (void) const {
  return "a '@lsint64' type" ;
}

const char * cPtr_typeGalgas_lsint64::static_string_message_messageGalgasType (void) {
  return "a '@lsint64' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lsint64:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_lsint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lsint64 * GGS_typeGalgas_lsint64::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_lsint64 * ptr_ = (cPtr_typeGalgas_lsint64 *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lsint64 (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_ldouble'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_ldouble::cPtr_typeGalgas_ldouble (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "ldouble") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1286))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_double::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1294)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}


const char * cPtr_typeGalgas_ldouble::message_messageGalgasType (void) const {
  return "a '@ldouble' type" ;
}

const char * cPtr_typeGalgas_ldouble::static_string_message_messageGalgasType (void) {
  return "a '@ldouble' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_ldouble:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_ldouble'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_ldouble * GGS_typeGalgas_ldouble::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_ldouble * ptr_ = (cPtr_typeGalgas_ldouble *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_ldouble (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgas_stringset'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_stringset::cPtr_typeGalgas_stringset (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "stringset") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1321))) == (GGS_string (true, "emptySet"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1323))) == (GGS_string (true, "setWithString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1327))) == (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "in GALGAS 1.3.0 and later, use 'emptySet' constructor instead of 'empty' constructor") SOURCE_FILE_AT_LINE (1329)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1331)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_handleAddAssignOperatorCall (C_Lexique & _inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outParametersList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  GGS_AC_galgasType  var_cas_t ;
  var_cas_t = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_outParametersList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_handleMinusAssignOperatorCall (C_Lexique & _inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outParametersList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  GGS_AC_galgasType  var_cas_t ;
  var_cas_t = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_outParametersList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_acceptForeachInstruction (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle COMMA_UNUSED_LOCATION_ARGS) {
  GGS_AC_galgasType  var_cas_keyType ;
  var_cas_keyType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_outForeachList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  var_cas_outForeachList.addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "mKey"), GGS_location (_inLexique) COMMA_HERE)) ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (_inLexique COMMA_HERE) ;
}


const char * cPtr_typeGalgas_stringset::message_messageGalgasType (void) const {
  return "a '@stringset' type" ;
}

const char * cPtr_typeGalgas_stringset::static_string_message_messageGalgasType (void) {
  return "a '@stringset' type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_stringset:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgas_stringset'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_stringset * GGS_typeGalgas_stringset::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_stringset * ptr_ = (cPtr_typeGalgas_stringset *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_stringset (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'typeTableMethodes'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableMethodes::
elementOf_GGS_typeTableMethodes (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableMethodes & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableMethodes::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.aListeTypesParametres.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableMethodes::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableMethodes *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableMethodes * info = (e_typeTableMethodes *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodes result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_EXsignature &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableMethodes info  ;
    info.aListeTypesParametres = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeTypesParametres ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "there is no reader named '%K'",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "a reader named '%K' is already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableMethodes & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodes result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMethodes::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeTableMethodes " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeGalgasUndefinedExternType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedExternType::cPtr_typeGalgasUndefinedExternType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mGalgasClassName (argument_0),
mCppClassName (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedExternType::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mGalgasClassName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1400)) ;
}


const char * cPtr_typeGalgasUndefinedExternType::message_messageGalgasType (void) const {
  return "an undefined extern type" ;
}

const char * cPtr_typeGalgasUndefinedExternType::static_string_message_messageGalgasType (void) {
  return "an undefined extern type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedExternType::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedExternType:" ;
mGalgasClassName.reader_description  (_inLexique COMMA_THERE) ;
mCppClassName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedExternType'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedExternType * GGS_typeGalgasUndefinedExternType::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasUndefinedExternType * ptr_ = (cPtr_typeGalgasUndefinedExternType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedExternType (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_externTypeConstructorMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_externTypeConstructorMap::
elementOf_GGS_M_externTypeConstructorMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_externTypeConstructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_externTypeConstructorMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.aListeDesAttributs.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_externTypeConstructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_externTypeConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_externTypeConstructorMap * info = (e_M_externTypeConstructorMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_externTypeConstructorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeListeAttributsSemantiques &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_externTypeConstructorMap info  ;
    info.aListeDesAttributs = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDesAttributs ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' constructor is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' constructor is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_externTypeConstructorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_externTypeConstructorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_externTypeConstructorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_externTypeConstructorMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_externTypeConstructorMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgasExternType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasExternType::cPtr_typeGalgasExternType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_M_externTypeConstructorMap & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodes & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_typeListeAttributsSemantiques & argument_6 COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedExternType (argument_0, argument_1 COMMA_THERE),
mConstructorMap (argument_2),
mModifiersMap (argument_3),
mReadersInInstructionMap (argument_4),
mAcceptAddAssignOperatorCall (argument_5),
mAddAssignOperatorCallTypeList (argument_6) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (mConstructorMap.isBuilt ()) {
    mConstructorMap (HERE)->method_searchKey (_inLexique, var_cas_inClassMethodName, var_cas_outAccessorTypesList SOURCE_FILE_AT_LINE (1444)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (mModifiersMap.isBuilt ()) {
    mModifiersMap (HERE)->method_searchKey (_inLexique, var_cas_inModifierName, var_cas_outModifierSignature SOURCE_FILE_AT_LINE (1453)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleReaderInstructionCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inReadObjectName */,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_EXsignature & var_cas_outReaderSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (mReadersInInstructionMap.isBuilt ()) {
    mReadersInInstructionMap (HERE)->method_searchKey (_inLexique, var_cas_inReaderName, var_cas_outReaderSignature SOURCE_FILE_AT_LINE (1462)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleAddAssignOperatorCall (C_Lexique & _inLexique,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) {
  if (((! (mAcceptAddAssignOperatorCall))).isBuiltAndTrue ()) {
    inherited::method_handleAddAssignOperatorCall (_inLexique, var_cas_inErrorLocation, var_cas_outParametersList SOURCE_FILE_AT_LINE (1471)) ;
  }else{
    var_cas_outParametersList = mAddAssignOperatorCallTypeList ;
  }
}


const char * cPtr_typeGalgasExternType::message_messageGalgasType (void) const {
  return "an extern type" ;
}

const char * cPtr_typeGalgasExternType::static_string_message_messageGalgasType (void) {
  return "an extern type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasExternType:" ;
mGalgasClassName.reader_description  (_inLexique COMMA_THERE) ;
mCppClassName.reader_description  (_inLexique COMMA_THERE) ;
mConstructorMap.reader_description  (_inLexique COMMA_THERE) ;
mModifiersMap.reader_description  (_inLexique COMMA_THERE) ;
mReadersInInstructionMap.reader_description  (_inLexique COMMA_THERE) ;
mAcceptAddAssignOperatorCall.reader_description  (_inLexique COMMA_THERE) ;
mAddAssignOperatorCallTypeList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgasExternType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasExternType * GGS_typeGalgasExternType::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_M_externTypeConstructorMap & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodes & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_typeListeAttributsSemantiques & argument_6 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasExternType * ptr_ = (cPtr_typeGalgasExternType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasExternType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_terminalSymbolsMapForUse'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_terminalSymbolsMapForUse::
elementOf_GGS_M_terminalSymbolsMapForUse (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_terminalSymbolsMapForUse & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_terminalSymbolsMapForUse::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.aListeDesAttributs.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_terminalSymbolsMapForUse::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_terminalSymbolsMapForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_terminalSymbolsMapForUse * info = (e_M_terminalSymbolsMapForUse *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_terminalSymbolsMapForUse result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeListeAttributsSemantiques &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_terminalSymbolsMapForUse info  ;
    info.aListeDesAttributs = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDesAttributs ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the terminal symbol '$%K$' is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the terminal symbol '$%K$' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_terminalSymbolsMapForUse & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_terminalSymbolsMapForUse result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_terminalSymbolsMapForUse result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_terminalSymbolsMapForUse::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_terminalSymbolsMapForUse " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'M_lexiqueComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_lexiqueComponents::
elementOf_GGS_M_lexiqueComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_lexiqueComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_lexiqueComponents::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mTerminalSymbolMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_lexiqueComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_lexiqueComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_lexiqueComponents * info = (e_M_lexiqueComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_lexiqueComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_terminalSymbolsMapForUse &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_lexiqueComponents info  ;
    info.mTerminalSymbolMap = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_terminalSymbolsMapForUse   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mTerminalSymbolMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_terminalSymbolsMapForUse   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' lexique is not defined",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_terminalSymbolsMapForUse & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' lexique is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_lexiqueComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_lexiqueComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_lexiqueComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_lexiqueComponents::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_lexiqueComponents " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'typeTableEnAvant'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableEnAvant::
elementOf_GGS_typeTableEnAvant (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableEnAvant & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableEnAvant::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mType.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableEnAvant::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableEnAvant *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableEnAvant * info = (e_typeTableEnAvant *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableEnAvant result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_galgasType &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableEnAvant info  ;
    info.mType = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the type '%K' is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the type '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableEnAvant & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableEnAvant result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableEnAvant result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableEnAvant::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeTableEnAvant " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map 'M_nonterminalSymbolAlts'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonterminalSymbolAlts::
elementOf_GGS_M_nonterminalSymbolAlts (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonterminalSymbolAlts & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonterminalSymbolAlts::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mFormalParametersList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mReturnedEntity.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonterminalSymbolAlts::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonterminalSymbolAlts *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonterminalSymbolAlts * info = (e_M_nonterminalSymbolAlts *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAlts result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_EXsignature &  inParameter0,
               const GGS_lstring &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_nonterminalSymbolAlts info  ;
    info.mFormalParametersList = inParameter0 ;
    info.mReturnedEntity = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalParametersList ;
    outParameter1 = node->mInfo.mReturnedEntity ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the label '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the label '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_nonterminalSymbolAlts & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAlts result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonterminalSymbolAlts result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonterminalSymbolAlts::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_nonterminalSymbolAlts " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_AC_semanticsEntity'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_semanticsEntity::
cPtr_AC_semanticsEntity (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity
::static_string_message_messageTypeEntite (void) {
  return "any entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity::
message_messageTypeEntite (void) const {
  return "any entity" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_AC_semanticsEntity'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (void) {
  mPointer = (cPtr_AC_semanticsEntity *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (const GGS_AC_semanticsEntity & inOperand) {
  mPointer = (cPtr_AC_semanticsEntity *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
~GGS_AC_semanticsEntity (void) {
  macroDetachPointer (mPointer, cPtr_AC_semanticsEntity) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_semanticsEntity::
operator = (const GGS_AC_semanticsEntity & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_semanticsEntity::
operator = (cPtr_AC_semanticsEntity * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (cPtr_AC_semanticsEntity * inSource) {
  mPointer = (cPtr_AC_semanticsEntity *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_semanticsEntity * GGS_AC_semanticsEntity
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_AC_semanticsEntity::
reader_messageTypeEntite (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageTypeEntite ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_semanticsEntity
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_semanticsEntity) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_semanticsEntity
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @AC_semanticsEntity" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_grammarForSemantics'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarForSemantics::cPtr_C_grammarForSemantics (const GGS_M_nonterminalSymbolAlts & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
mGrammarAltMap (argument_0) {
}


const char * cPtr_C_grammarForSemantics::message_messageTypeEntite (void) const {
  return "a grammar entity" ;
}

const char * cPtr_C_grammarForSemantics::static_string_message_messageTypeEntite (void) {
  return "a grammar entity" ;
}

//---------------------------------------------------------------------------*

void cPtr_C_grammarForSemantics::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_grammarForSemantics:" ;
mGrammarAltMap.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarForSemantics'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_grammarForSemantics * GGS_C_grammarForSemantics::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_M_nonterminalSymbolAlts & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_C_grammarForSemantics * ptr_ = (cPtr_C_grammarForSemantics *) NULL ;
    macroMyNew (ptr_, cPtr_C_grammarForSemantics (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_semanticsEntitiesForUse'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_semanticsEntitiesForUse::
elementOf_GGS_M_semanticsEntitiesForUse (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_semanticsEntitiesForUse & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_semanticsEntitiesForUse::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.aDefEntite.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_semanticsEntitiesForUse::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_semanticsEntitiesForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_semanticsEntitiesForUse * info = (e_M_semanticsEntitiesForUse *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsEntitiesForUse result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_semanticsEntity &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_semanticsEntitiesForUse info  ;
    info.aDefEntite = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_semanticsEntity   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aDefEntite ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_semanticsEntity   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "there is no semantics entity named '%K'",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_semanticsEntity & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "a semantics entity named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_semanticsEntitiesForUse & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsEntitiesForUse result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_semanticsEntitiesForUse result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_semanticsEntitiesForUse::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_semanticsEntitiesForUse " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_AC_typeForGrammarComponent'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_typeForGrammarComponent::
cPtr_AC_typeForGrammarComponent (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent
::static_string_message_typeForGrammarComponentMessage (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent::
message_typeForGrammarComponentMessage (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_AC_typeForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (void) {
  mPointer = (cPtr_AC_typeForGrammarComponent *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (const GGS_AC_typeForGrammarComponent & inOperand) {
  mPointer = (cPtr_AC_typeForGrammarComponent *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
~GGS_AC_typeForGrammarComponent (void) {
  macroDetachPointer (mPointer, cPtr_AC_typeForGrammarComponent) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_typeForGrammarComponent::
operator = (const GGS_AC_typeForGrammarComponent & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_typeForGrammarComponent::
operator = (cPtr_AC_typeForGrammarComponent * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (cPtr_AC_typeForGrammarComponent * inSource) {
  mPointer = (cPtr_AC_typeForGrammarComponent *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_typeForGrammarComponent * GGS_AC_typeForGrammarComponent
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_AC_typeForGrammarComponent::
reader_typeForGrammarComponentMessage (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_typeForGrammarComponentMessage ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_typeForGrammarComponent
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_typeForGrammarComponent) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_typeForGrammarComponent
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @AC_typeForGrammarComponent" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_typesForGrammarComponent'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_typesForGrammarComponent::
elementOf_GGS_M_typesForGrammarComponent (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_typesForGrammarComponent & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_typesForGrammarComponent::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mType.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_typesForGrammarComponent::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_typesForGrammarComponent *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_typesForGrammarComponent * info = (e_M_typesForGrammarComponent *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_typesForGrammarComponent result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_typeForGrammarComponent &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_typesForGrammarComponent info  ;
    info.mType = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_typeForGrammarComponent   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_typeForGrammarComponent   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '@%K' type is not defined",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_typeForGrammarComponent & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '@%K' type is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_typesForGrammarComponent & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_typesForGrammarComponent result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_typesForGrammarComponent result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_typesForGrammarComponent::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_typesForGrammarComponent " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "checkSignature_ForGrammarComponent"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkSignature_ForGrammarComponent (C_Lexique & _inLexique,
                                const GGS_L_signature  & var_cas_inFormalReferenceSignature,
                                const GGS_L_signature  & var_cas_inFormalTestedSignature,
                                const GGS_location  & var_cas_inFormalTestedLocation,
                                const GGS_location  & var_cas_inFormalReferenceLocation COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inFormalReferenceSignature.reader_length (_inLexique SOURCE_FILE_AT_LINE (1589))) < (var_cas_inFormalTestedSignature.reader_length (_inLexique SOURCE_FILE_AT_LINE (1589)))).isBuiltAndTrue ()) {
    var_cas_inFormalTestedLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "too much formal parameters (from prototype in ")) + (var_cas_inFormalReferenceLocation.reader_locationString (_inLexique SOURCE_FILE_AT_LINE (1590))))) + (GGS_string (true, ")"))) SOURCE_FILE_AT_LINE (1591)) ;
  }else if (((var_cas_inFormalReferenceSignature.reader_length (_inLexique SOURCE_FILE_AT_LINE (1591))) > (var_cas_inFormalTestedSignature.reader_length (_inLexique SOURCE_FILE_AT_LINE (1591)))).isBuiltAndTrue ()) {
    var_cas_inFormalTestedLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "too much formal parameters (from prototype in ")) + (var_cas_inFormalReferenceLocation.reader_locationString (_inLexique SOURCE_FILE_AT_LINE (1592))))) + (GGS_string (true, ")"))) SOURCE_FILE_AT_LINE (1593)) ;
  }else{
    GGS_L_signature::element_type * operand_62474 = var_cas_inFormalReferenceSignature.firstObject () ;
    GGS_L_signature::element_type * operand_62573 = var_cas_inFormalTestedSignature.firstObject () ;
    while ((operand_62474 != NULL)
        && (operand_62573 != NULL)) {
      macroValidPointer (operand_62474) ;
      macroValidPointer (operand_62573) ;
      if (((operand_62474->mFormalArgumentPassingMode) != (operand_62573->mFormalArgumentPassingMode)).isBuiltAndTrue ()) {
        operand_62573->mGalgasTypeName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "Prototype has ")) + (operand_62474->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique SOURCE_FILE_AT_LINE (1597))))) + (GGS_string (true, ", and ")))) + (operand_62474->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique SOURCE_FILE_AT_LINE (1598))))) + (GGS_string (true, " has been found"))) SOURCE_FILE_AT_LINE (1599)) ;
      }
      if (((operand_62474->mGalgasTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1600))) != (operand_62573->mGalgasTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1600)))).isBuiltAndTrue ()) {
        operand_62573->mGalgasTypeName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting the '@")) + (operand_62474->mGalgasTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1601))))) + (GGS_string (true, "' type, I have got the '@")))) + (operand_62573->mGalgasTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1601))))) + (GGS_string (true, "' type"))) SOURCE_FILE_AT_LINE (1602)) ;
      }
      operand_62474 = operand_62474->nextObject () ;
      operand_62573 = operand_62573->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_AC_instruction_ForGrammar'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_instruction_ForGrammar::
cPtr_AC_instruction_ForGrammar (const GGS_location & argument_0 COMMA_LOCATION_ARGS)
:C_GGS_Object (THERE),
mStartLocation (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_AC_instruction_ForGrammar'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (void) {
  mPointer = (cPtr_AC_instruction_ForGrammar *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (const GGS_AC_instruction_ForGrammar & inOperand) {
  mPointer = (cPtr_AC_instruction_ForGrammar *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
~GGS_AC_instruction_ForGrammar (void) {
  macroDetachPointer (mPointer, cPtr_AC_instruction_ForGrammar) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_instruction_ForGrammar::
operator = (const GGS_AC_instruction_ForGrammar & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_instruction_ForGrammar::
operator = (cPtr_AC_instruction_ForGrammar * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (cPtr_AC_instruction_ForGrammar * inSource) {
  mPointer = (cPtr_AC_instruction_ForGrammar *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_instruction_ForGrammar * GGS_AC_instruction_ForGrammar
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_AC_instruction_ForGrammar
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_instruction_ForGrammar) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_instruction_ForGrammar
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @AC_instruction_ForGrammar" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@L_ruleSyntaxSignature'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_ruleSyntaxSignature::
elementOf_GGS_L_ruleSyntaxSignature (const GGS_AC_instruction_ForGrammar & argument_0):
mNextItem (NULL),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_ruleSyntaxSignature::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@L_ruleSyntaxSignature'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::GGS_L_ruleSyntaxSignature (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::~GGS_L_ruleSyntaxSignature (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::
GGS_L_ruleSyntaxSignature (const GGS_L_ruleSyntaxSignature & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
operator = (const GGS_L_ruleSyntaxSignature & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::element_type * GGS_L_ruleSyntaxSignature::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
internalAppendItem (const GGS_AC_instruction_ForGrammar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
addAssign_operation (const GGS_AC_instruction_ForGrammar & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mInstruction) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature  GGS_L_ruleSyntaxSignature::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_ruleSyntaxSignature result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_ruleSyntaxSignature::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_ruleSyntaxSignature::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_ruleSyntaxSignature" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_ruleSyntaxSignature::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'L_grammarsMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_grammarsMap::
elementOf_GGS_L_grammarsMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_L_grammarsMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_grammarsMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mStartSymbolParametersMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_L_grammarsMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_L_grammarsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_L_grammarsMap * info = (e_L_grammarsMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_grammarsMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAlts &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_L_grammarsMap info  ;
    info.mStartSymbolParametersMap = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAlts   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mStartSymbolParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' grammar is not defined",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' grammar is already defined in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_L_grammarsMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_grammarsMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_grammarsMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_grammarsMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @L_grammarsMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class map 'M_nonterminalSymbolAltsForGrammar'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonterminalSymbolAltsForGrammar::
elementOf_GGS_M_nonterminalSymbolAltsForGrammar (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonterminalSymbolAltsForGrammar & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonterminalSymbolAltsForGrammar::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mFormalParametersList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mReturnedEntityTypeName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonterminalSymbolAltsForGrammar::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonterminalSymbolAltsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonterminalSymbolAltsForGrammar * info = (e_M_nonterminalSymbolAltsForGrammar *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAltsForGrammar GGS_M_nonterminalSymbolAltsForGrammar::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAltsForGrammar result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               const GGS_lstring &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_nonterminalSymbolAltsForGrammar info  ;
    info.mFormalParametersList = inParameter0 ;
    info.mReturnedEntityTypeName = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalParametersList ;
    outParameter1 = node->mInfo.mReturnedEntityTypeName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the rule label '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the rule label '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAltsForGrammar GGS_M_nonterminalSymbolAltsForGrammar::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_nonterminalSymbolAltsForGrammar & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAltsForGrammar result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAltsForGrammar GGS_M_nonterminalSymbolAltsForGrammar::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonterminalSymbolAltsForGrammar result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonterminalSymbolAltsForGrammar::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_nonterminalSymbolAltsForGrammar " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@L_productionRules_ForGrammarComponent'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_productionRules_ForGrammarComponent::
elementOf_GGS_L_productionRules_ForGrammarComponent (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2):
mNextItem (NULL),
mLeftNonterminalSymbol (argument_0),
mLeftNonterminalSymbolIndex (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_productionRules_ForGrammarComponent::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mLeftNonterminalSymbol.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mLeftNonterminalSymbolIndex.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@L_productionRules_ForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::GGS_L_productionRules_ForGrammarComponent (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::~GGS_L_productionRules_ForGrammarComponent (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::
GGS_L_productionRules_ForGrammarComponent (const GGS_L_productionRules_ForGrammarComponent & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
operator = (const GGS_L_productionRules_ForGrammarComponent & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::element_type * GGS_L_productionRules_ForGrammarComponent::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
internalAppendItem (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1,
                    const GGS_L_ruleSyntaxSignature & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mLeftNonterminalSymbol,
                                p->mLeftNonterminalSymbolIndex,
                                p->mInstructionList) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent  GGS_L_productionRules_ForGrammarComponent::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_productionRules_ForGrammarComponent result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_productionRules_ForGrammarComponent::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_productionRules_ForGrammarComponent::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_productionRules_ForGrammarComponent" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_productionRules_ForGrammarComponent::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'M_nonTerminalSymbolsForGrammar'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonTerminalSymbolsForGrammar::
elementOf_GGS_M_nonTerminalSymbolsForGrammar (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonTerminalSymbolsForGrammar & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonTerminalSymbolsForGrammar::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mNonterminalSymbolParametersMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonTerminalSymbolsForGrammar::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonTerminalSymbolsForGrammar * info = (e_M_nonTerminalSymbolsForGrammar *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolsForGrammar GGS_M_nonTerminalSymbolsForGrammar::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolsForGrammar result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAltsForGrammar &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_nonTerminalSymbolsForGrammar info  ;
    info.mNonterminalSymbolParametersMap = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "internal search error",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "internal search error",
                 inKey,
                 outParameter0,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "internal insert error",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolsForGrammar GGS_M_nonTerminalSymbolsForGrammar::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_nonTerminalSymbolsForGrammar & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolsForGrammar result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolsForGrammar GGS_M_nonTerminalSymbolsForGrammar::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonTerminalSymbolsForGrammar result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonTerminalSymbolsForGrammar::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_nonTerminalSymbolsForGrammar " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'M_syntaxComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_syntaxComponents::
elementOf_GGS_M_syntaxComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_syntaxComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_syntaxComponents::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mNonterminalSymbolsMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mProductionRulesList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mLexiqueComponentName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_syntaxComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_syntaxComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_syntaxComponents * info = (e_M_syntaxComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_syntaxComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonTerminalSymbolsForGrammar &  inParameter0,
               const GGS_L_productionRules_ForGrammarComponent &  inParameter1,
               const GGS_lstring &  inParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_syntaxComponents info  ;
    info.mNonterminalSymbolsMap = inParameter0 ;
    info.mProductionRulesList = inParameter1 ;
    info.mLexiqueComponentName = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonTerminalSymbolsForGrammar   & outParameter0,
               GGS_L_productionRules_ForGrammarComponent   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolsMap ;
    outParameter1 = node->mInfo.mProductionRulesList ;
    outParameter2 = node->mInfo.mLexiqueComponentName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonTerminalSymbolsForGrammar   & outParameter0,
                                GGS_L_productionRules_ForGrammarComponent   & outParameter1,
                                GGS_lstring   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "there is no syntax component named '%K'",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonTerminalSymbolsForGrammar & inParameter0,
                                const GGS_L_productionRules_ForGrammarComponent & inParameter1,
                                const GGS_lstring & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "a syntax component named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_syntaxComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_syntaxComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_syntaxComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_syntaxComponents::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_syntaxComponents " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'T_terminalInstruction_forGrammarComponent'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_terminalInstruction_forGrammarComponent::cPtr_T_terminalInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mTerminalSymbolName (argument_1),
mTerminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_T_terminalInstruction_forGrammarComponent::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@T_terminalInstruction_forGrammarComponent:" ;
mStartLocation.reader_description  (_inLexique COMMA_THERE) ;
mTerminalSymbolName.reader_description  (_inLexique COMMA_THERE) ;
mTerminalSymbolIndex.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_T_terminalInstruction_forGrammarComponent'        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_T_terminalInstruction_forGrammarComponent * GGS_T_terminalInstruction_forGrammarComponent::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_T_terminalInstruction_forGrammarComponent * ptr_ = (cPtr_T_terminalInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_terminalInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'T_nonterminalInstruction_forGrammarComponent'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_nonterminalInstruction_forGrammarComponent::cPtr_T_nonterminalInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mNonterminalSymbolName (argument_1),
mNonterminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_T_nonterminalInstruction_forGrammarComponent::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@T_nonterminalInstruction_forGrammarComponent:" ;
mStartLocation.reader_description  (_inLexique COMMA_THERE) ;
mNonterminalSymbolName.reader_description  (_inLexique COMMA_THERE) ;
mNonterminalSymbolIndex.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_T_nonterminalInstruction_forGrammarComponent'       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_T_nonterminalInstruction_forGrammarComponent * GGS_T_nonterminalInstruction_forGrammarComponent::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_T_nonterminalInstruction_forGrammarComponent * ptr_ = (cPtr_T_nonterminalInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_nonterminalInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@L_branchList_ForGrammarComponent'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_branchList_ForGrammarComponent::
elementOf_GGS_L_branchList_ForGrammarComponent (const GGS_L_ruleSyntaxSignature & argument_0):
mNextItem (NULL),
mInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_branchList_ForGrammarComponent::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@L_branchList_ForGrammarComponent'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::GGS_L_branchList_ForGrammarComponent (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::~GGS_L_branchList_ForGrammarComponent (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::
GGS_L_branchList_ForGrammarComponent (const GGS_L_branchList_ForGrammarComponent & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
operator = (const GGS_L_branchList_ForGrammarComponent & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::element_type * GGS_L_branchList_ForGrammarComponent::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
internalAppendItem (const GGS_L_ruleSyntaxSignature & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
addAssign_operation (const GGS_L_ruleSyntaxSignature & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mInstructionList) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent  GGS_L_branchList_ForGrammarComponent::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_branchList_ForGrammarComponent result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_branchList_ForGrammarComponent::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_branchList_ForGrammarComponent::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_branchList_ForGrammarComponent" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_branchList_ForGrammarComponent::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'T_selectInstruction_forGrammarComponent'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_selectInstruction_forGrammarComponent::cPtr_T_selectInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mSelectList (argument_1),
mAddedNonterminalmSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_T_selectInstruction_forGrammarComponent::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@T_selectInstruction_forGrammarComponent:" ;
mStartLocation.reader_description  (_inLexique COMMA_THERE) ;
mSelectList.reader_description  (_inLexique COMMA_THERE) ;
mAddedNonterminalmSymbolIndex.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_T_selectInstruction_forGrammarComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_T_selectInstruction_forGrammarComponent * GGS_T_selectInstruction_forGrammarComponent::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_T_selectInstruction_forGrammarComponent * ptr_ = (cPtr_T_selectInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_selectInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'T_repeatInstruction_forGrammarComponent'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_repeatInstruction_forGrammarComponent::cPtr_T_repeatInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mRepeatList (argument_1),
mAddedNonterminalmSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_T_repeatInstruction_forGrammarComponent::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@T_repeatInstruction_forGrammarComponent:" ;
mStartLocation.reader_description  (_inLexique COMMA_THERE) ;
mRepeatList.reader_description  (_inLexique COMMA_THERE) ;
mAddedNonterminalmSymbolIndex.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_T_repeatInstruction_forGrammarComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_T_repeatInstruction_forGrammarComponent * GGS_T_repeatInstruction_forGrammarComponent::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_T_repeatInstruction_forGrammarComponent * ptr_ = (cPtr_T_repeatInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_repeatInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_syntaxComponents_ForGrammar'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_syntaxComponents_ForGrammar::
elementOf_GGS_L_syntaxComponents_ForGrammar (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_lstring & argument_2):
mNextItem (NULL),
mNonterminalSymbolsMap (argument_0),
mProductionRulesList (argument_1),
mSyntaxComponentName (argument_2) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_syntaxComponents_ForGrammar::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mNonterminalSymbolsMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mProductionRulesList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mSyntaxComponentName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_syntaxComponents_ForGrammar'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::GGS_L_syntaxComponents_ForGrammar (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::~GGS_L_syntaxComponents_ForGrammar (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::
GGS_L_syntaxComponents_ForGrammar (const GGS_L_syntaxComponents_ForGrammar & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
operator = (const GGS_L_syntaxComponents_ForGrammar & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::element_type * GGS_L_syntaxComponents_ForGrammar::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
internalAppendItem (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                    const GGS_L_productionRules_ForGrammarComponent & argument_1,
                    const GGS_lstring & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
addAssign_operation (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mNonterminalSymbolsMap,
                                p->mProductionRulesList,
                                p->mSyntaxComponentName) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar  GGS_L_syntaxComponents_ForGrammar::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_syntaxComponents_ForGrammar result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_syntaxComponents_ForGrammar::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_syntaxComponents_ForGrammar::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_syntaxComponents_ForGrammar" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_syntaxComponents_ForGrammar::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class map 'M_startSymbolEntityAndMetamodel'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_startSymbolEntityAndMetamodel::
elementOf_GGS_M_startSymbolEntityAndMetamodel (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_startSymbolEntityAndMetamodel & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_startSymbolEntityAndMetamodel::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mReturnedEntityName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mReturnedMetamodelName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_startSymbolEntityAndMetamodel::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_startSymbolEntityAndMetamodel *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_startSymbolEntityAndMetamodel * info = (e_M_startSymbolEntityAndMetamodel *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_startSymbolEntityAndMetamodel GGS_M_startSymbolEntityAndMetamodel::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_startSymbolEntityAndMetamodel result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               const GGS_lstring &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_startSymbolEntityAndMetamodel info  ;
    info.mReturnedEntityName = inParameter0 ;
    info.mReturnedMetamodelName = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mReturnedEntityName ;
    outParameter1 = node->mInfo.mReturnedMetamodelName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the label '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the label '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_startSymbolEntityAndMetamodel GGS_M_startSymbolEntityAndMetamodel::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_startSymbolEntityAndMetamodel & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_startSymbolEntityAndMetamodel result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_startSymbolEntityAndMetamodel GGS_M_startSymbolEntityAndMetamodel::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_startSymbolEntityAndMetamodel result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_startSymbolEntityAndMetamodel::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_startSymbolEntityAndMetamodel " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_identifiers'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_identifiers::
elementOf_GGS_L_identifiers (const GGS_lstring & argument_0):
mNextItem (NULL),
aIdentificateur (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_identifiers::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << aIdentificateur.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_identifiers'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_identifiers::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_identifiers::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_identifiers::GGS_L_identifiers (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_identifiers::~GGS_L_identifiers (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_identifiers::
GGS_L_identifiers (const GGS_L_identifiers & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
operator = (const GGS_L_identifiers & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_identifiers::element_type * GGS_L_identifiers::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aIdentificateur) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_identifiers  GGS_L_identifiers::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_identifiers result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_identifiers::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_identifiers::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_identifiers" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_identifiers::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'typeSuperClassesMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSuperClassesMap::
elementOf_GGS_typeSuperClassesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeSuperClassesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSuperClassesMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeSuperClassesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeSuperClassesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeSuperClassesMap * info = (e_typeSuperClassesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSuperClassesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeSuperClassesMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the class '%K' is already a super class of the current class",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeSuperClassesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSuperClassesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSuperClassesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSuperClassesMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeSuperClassesMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeClassInheritedMessagesMap'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeClassInheritedMessagesMap::
elementOf_GGS_typeClassInheritedMessagesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeClassInheritedMessagesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeClassInheritedMessagesMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassInheritedMessagesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeClassInheritedMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeClassInheritedMessagesMap * info = (e_typeClassInheritedMessagesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassInheritedMessagesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeClassInheritedMessagesMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the message '%K' is not declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the message '%K' is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeClassInheritedMessagesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassInheritedMessagesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassInheritedMessagesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeClassInheritedMessagesMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeClassInheritedMessagesMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'typeSemanticAttributesMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSemanticAttributesMap::
elementOf_GGS_typeSemanticAttributesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeSemanticAttributesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSemanticAttributesMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mAttributType.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeSemanticAttributesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeSemanticAttributesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeSemanticAttributesMap * info = (e_typeSemanticAttributesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticAttributesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_galgasType &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeSemanticAttributesMap info  ;
    info.mAttributType = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "there is no attribut named '%K'",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "an attribut named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeSemanticAttributesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticAttributesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSemanticAttributesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSemanticAttributesMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeSemanticAttributesMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@insertOrSearchMethodList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_insertOrSearchMethodList::
elementOf_GGS_insertOrSearchMethodList (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2):
mNextItem (NULL),
mMethodName (argument_0),
mErrorMessage (argument_1),
mIsGetIndexMethod (argument_2) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_insertOrSearchMethodList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mIsGetIndexMethod.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@insertOrSearchMethodList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList::GGS_insertOrSearchMethodList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList::~GGS_insertOrSearchMethodList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList::
GGS_insertOrSearchMethodList (const GGS_insertOrSearchMethodList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
operator = (const GGS_insertOrSearchMethodList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList::element_type * GGS_insertOrSearchMethodList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
internalAppendItem (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_bool& argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mMethodName,
                                p->mErrorMessage,
                                p->mIsGetIndexMethod) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_insertOrSearchMethodList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_insertOrSearchMethodList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_insertOrSearchMethodList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertOrSearchMethodList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @insertOrSearchMethodList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_insertOrSearchMethodList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeDefEntiteUtilisable'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefEntiteUtilisable::
cPtr_typeDefEntiteUtilisable (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable
::static_string_message_messageTypeEntite (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable::
message_messageTypeEntite (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeDefEntiteUtilisable'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (void) {
  mPointer = (cPtr_typeDefEntiteUtilisable *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (const GGS_typeDefEntiteUtilisable & inOperand) {
  mPointer = (cPtr_typeDefEntiteUtilisable *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
~GGS_typeDefEntiteUtilisable (void) {
  macroDetachPointer (mPointer, cPtr_typeDefEntiteUtilisable) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefEntiteUtilisable::
operator = (const GGS_typeDefEntiteUtilisable & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefEntiteUtilisable::
operator = (cPtr_typeDefEntiteUtilisable * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (cPtr_typeDefEntiteUtilisable * inSource) {
  mPointer = (cPtr_typeDefEntiteUtilisable *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefEntiteUtilisable * GGS_typeDefEntiteUtilisable
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDefEntiteUtilisable::
reader_messageTypeEntite (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageTypeEntite ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefEntiteUtilisable
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeDefEntiteUtilisable) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDefEntiteUtilisable
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeDefEntiteUtilisable" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeGalgasUndefinedListType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedListType::cPtr_typeGalgasUndefinedListType (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mListTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedListType::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mListTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1846)) ;
}


const char * cPtr_typeGalgasUndefinedListType::message_messageGalgasType (void) const {
  return "an undefined list type" ;
}

const char * cPtr_typeGalgasUndefinedListType::static_string_message_messageGalgasType (void) {
  return "an undefined list type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedListType::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedListType:" ;
mListTypeName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedListType'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedListType * GGS_typeGalgasUndefinedListType::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasUndefinedListType * ptr_ = (cPtr_typeGalgasUndefinedListType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedListType (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgasListType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasListType::cPtr_typeGalgasListType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedListType (argument_0 COMMA_THERE),
mNonExternAttributesList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_acceptForeachInstruction (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outForeachList = mNonExternAttributesList ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_listStyle (_inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_handleAddAssignOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outParametersList = mNonExternAttributesList ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1886))) == (GGS_string (true, "emptyList"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1888))) == (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "in GALGAS 1.3.0 and later, use 'emptyList' constructor instead of 'empty' constructor") SOURCE_FILE_AT_LINE (1890)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1892)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}


const char * cPtr_typeGalgasListType::message_messageGalgasType (void) const {
  return "a list type" ;
}

const char * cPtr_typeGalgasListType::static_string_message_messageGalgasType (void) {
  return "a list type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasListType:" ;
mListTypeName.reader_description  (_inLexique COMMA_THERE) ;
mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasListType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasListType * GGS_typeGalgasListType::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasListType * ptr_ = (cPtr_typeGalgasListType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasListType (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'typeTableBlocsDeTable'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableBlocsDeTable::
elementOf_GGS_typeTableBlocsDeTable (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableBlocsDeTable & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableBlocsDeTable::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.aSignatureDebut.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.aSignatureFin.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableBlocsDeTable::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableBlocsDeTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableBlocsDeTable * info = (e_typeTableBlocsDeTable *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableBlocsDeTable result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_EXsignature &  inParameter0,
               const GGS_L_EXsignature &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableBlocsDeTable info  ;
    info.aSignatureDebut = inParameter0 ;
    info.aSignatureFin = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aSignatureDebut ;
    outParameter1 = node->mInfo.aSignatureFin ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_L_EXsignature   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "there is no block method named '%K'",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_L_EXsignature & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "a block method named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableBlocsDeTable & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableBlocsDeTable result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableBlocsDeTable result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableBlocsDeTable::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeTableBlocsDeTable " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeGalgasUndefinedMapType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedMapType::cPtr_typeGalgasUndefinedMapType (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mMapTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapType::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mMapTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1922)) ;
}


const char * cPtr_typeGalgasUndefinedMapType::message_messageGalgasType (void) const {
  return "an undefined map type" ;
}

const char * cPtr_typeGalgasUndefinedMapType::static_string_message_messageGalgasType (void) {
  return "an undefined map type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapType::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedMapType:" ;
mMapTypeName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedMapType'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedMapType * GGS_typeGalgasUndefinedMapType::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasUndefinedMapType * ptr_ = (cPtr_typeGalgasUndefinedMapType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedMapType (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'mapMethodMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapMethodMap::
elementOf_GGS_mapMethodMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapMethodMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mMethodSignature.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapMethodMap * info = (e_mapMethodMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_EXsignature &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_mapMethodMap info  ;
    info.mMethodSignature = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMethodSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "there is no insert nor search method named '%K'",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "an insert or a search method named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_mapMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapMethodMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @mapMethodMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgasMapType'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasMapType::cPtr_typeGalgasMapType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableBlocsDeTable & argument_2,
                                const GGS_mapMethodMap & argument_3,
                                const GGS_mapMethodMap & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedMapType (argument_0 COMMA_THERE),
mNonExternAttributesList (argument_1),
aTableMethodesSurcharger (argument_2),
mModifierMethodMap (argument_3),
mReaderMethodMap (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (mModifierMethodMap.isBuilt ()) {
    mModifierMethodMap (HERE)->method_searchKey (_inLexique, var_cas_inModifierName, var_cas_outModifierSignature SOURCE_FILE_AT_LINE (1958)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_handleReaderInstructionCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inReadObjectName */,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_EXsignature & var_cas_outReaderSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (mReaderMethodMap.isBuilt ()) {
    mReaderMethodMap (HERE)->method_searchKey (_inLexique, var_cas_inReaderName, var_cas_outReaderSignature SOURCE_FILE_AT_LINE (1968)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_acceptForeachInstruction (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle COMMA_UNUSED_LOCATION_ARGS) {
  GGS_AC_galgasType  var_cas_keyType ;
  var_cas_keyType = GGS_typeGalgas_lstring::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_outForeachList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  var_cas_outForeachList.addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "\?\?\?"), GGS_location (_inLexique) COMMA_HERE)) ;
  GGS_typeListeAttributsSemantiques::element_type * operand_80250 = mNonExternAttributesList.firstObject () ;
  while ((operand_80250 != NULL)) {
    macroValidPointer (operand_80250) ;
    var_cas_outForeachList.addAssign_operation (operand_80250->mAttributType, operand_80250->aNomAttribut) ;
    operand_80250 = operand_80250->nextObject () ;
  }
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (_inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1993))) == (GGS_string (true, "emptyMap"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (1995))) == (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "in GALGAS 1.3.0 and later, use 'emptyMap' constructor instead of 'empty' constructor") SOURCE_FILE_AT_LINE (1997)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1999)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}


const char * cPtr_typeGalgasMapType::message_messageGalgasType (void) const {
  return "a map type" ;
}

const char * cPtr_typeGalgasMapType::static_string_message_messageGalgasType (void) {
  return "a map type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasMapType:" ;
mMapTypeName.reader_description  (_inLexique COMMA_THERE) ;
mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE) ;
aTableMethodesSurcharger.reader_description  (_inLexique COMMA_THERE) ;
mModifierMethodMap.reader_description  (_inLexique COMMA_THERE) ;
mReaderMethodMap.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgasMapType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasMapType * GGS_typeGalgasMapType::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableBlocsDeTable & argument_2,
                                const GGS_mapMethodMap & argument_3,
                                const GGS_mapMethodMap & argument_4 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasMapType * ptr_ = (cPtr_typeGalgasMapType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasMapType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeGalgasUndefinedClassType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedClassType::cPtr_typeGalgasUndefinedClassType (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mClassTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedClassType::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2016)) ;
}


const char * cPtr_typeGalgasUndefinedClassType::message_messageGalgasType (void) const {
  return "an undefined class type" ;
}

const char * cPtr_typeGalgasUndefinedClassType::static_string_message_messageGalgasType (void) {
  return "an undefined class type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedClassType::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedClassType:" ;
mClassTypeName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedClassType'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedClassType * GGS_typeGalgasUndefinedClassType::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasUndefinedClassType * ptr_ = (cPtr_typeGalgasUndefinedClassType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedClassType (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgasClassType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasClassType::cPtr_typeGalgasClassType (const GGS_lstring & argument_0,
                                const GGS_typeTableMethodes & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeSuperClassesMap & argument_3,
                                const GGS_typeClassInheritedMessagesMap & argument_4,
                                const GGS_typeSemanticAttributesMap & argument_5,
                                const GGS_bool& argument_6 COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedClassType (argument_0 COMMA_THERE),
mReaderMap (argument_1),
mNonExternAttributesList (argument_2),
mAncestorClassesMap (argument_3),
mMessagesMap (argument_4),
mNonExternAttributesMap (argument_5),
mClassIsAbstract (argument_6) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
method_typeCanBeUsedInObjectDeclaration (C_Lexique & _inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (((! (mClassIsAbstract))).isBuiltAndTrue ()) {
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "non abstract class object cannot be declared (only instancied by 'new')") SOURCE_FILE_AT_LINE (2047)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
method_handleReaderInstructionCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inReadObjectName */,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_L_EXsignature & var_cas_outMethodSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (mReaderMap.isBuilt ()) {
    mReaderMap (HERE)->method_searchKey (_inLexique, var_cas_inMethodName, var_cas_outMethodSignature SOURCE_FILE_AT_LINE (2057)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if ((mClassIsAbstract).isBuiltAndTrue ()) {
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "an abstract class cannot be instancied") SOURCE_FILE_AT_LINE (2067)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }else if (((var_cas_inClassMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2067))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = mNonExternAttributesList ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (2071)) ;
    var_cas_outAccessorTypesList.drop_operation () ;
  }
}


const char * cPtr_typeGalgasClassType::message_messageGalgasType (void) const {
  return "a class type" ;
}

const char * cPtr_typeGalgasClassType::static_string_message_messageGalgasType (void) {
  return "a class type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasClassType:" ;
mClassTypeName.reader_description  (_inLexique COMMA_THERE) ;
mReaderMap.reader_description  (_inLexique COMMA_THERE) ;
mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE) ;
mAncestorClassesMap.reader_description  (_inLexique COMMA_THERE) ;
mMessagesMap.reader_description  (_inLexique COMMA_THERE) ;
mNonExternAttributesMap.reader_description  (_inLexique COMMA_THERE) ;
mClassIsAbstract.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasClassType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasClassType * GGS_typeGalgasClassType::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeTableMethodes & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeSuperClassesMap & argument_3,
                                const GGS_typeClassInheritedMessagesMap & argument_4,
                                const GGS_typeSemanticAttributesMap & argument_5,
                                const GGS_bool& argument_6 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgasClassType * ptr_ = (cPtr_typeGalgasClassType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasClassType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEntiteType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteType::cPtr_typeEntiteType (const GGS_AC_galgasType & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aDefType (argument_0) {
}


const char * cPtr_typeEntiteType::message_messageTypeEntite (void) const {
  return "a type" ;
}

const char * cPtr_typeEntiteType::static_string_message_messageTypeEntite (void) {
  return "a type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteType::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteType:" ;
aDefType.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteType * GGS_typeEntiteType::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_galgasType & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeEntiteType * ptr_ = (cPtr_typeEntiteType *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteType (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeEntiteRoutine'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteRoutine::cPtr_typeEntiteRoutine (const GGS_L_EXsignature & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aListeArgumentsFormels (argument_0) {
}


const char * cPtr_typeEntiteRoutine::message_messageTypeEntite (void) const {
  return "a routine" ;
}

const char * cPtr_typeEntiteRoutine::static_string_message_messageTypeEntite (void) {
  return "a routine" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteRoutine::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteRoutine:" ;
aListeArgumentsFormels.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeEntiteRoutine'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteRoutine * GGS_typeEntiteRoutine::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_L_EXsignature & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeEntiteRoutine * ptr_ = (cPtr_typeEntiteRoutine *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteRoutine (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeGalgas_entityInInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_entityInInstruction::cPtr_typeGalgas_entityInInstruction (const GGS_string& argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEntityName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_entityInInstruction::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mEntityName ;
}


const char * cPtr_typeGalgas_entityInInstruction::message_messageGalgasType (void) const {
  return "an entity" ;
}

const char * cPtr_typeGalgas_entityInInstruction::static_string_message_messageGalgasType (void) {
  return "an entity" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_entityInInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_entityInInstruction:" ;
mEntityName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeGalgas_entityInInstruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_entityInInstruction * GGS_typeGalgas_entityInInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_string& argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_entityInInstruction * ptr_ = (cPtr_typeGalgas_entityInInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_entityInInstruction (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeGalgas_mapIndexInInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_mapIndexInInstruction::cPtr_typeGalgas_mapIndexInInstruction (const GGS_string& argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mMapTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_mapIndexInInstruction::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "") ;
}


const char * cPtr_typeGalgas_mapIndexInInstruction::message_messageGalgasType (void) const {
  return "a map index" ;
}

const char * cPtr_typeGalgas_mapIndexInInstruction::static_string_message_messageGalgasType (void) {
  return "a map index" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_mapIndexInInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_mapIndexInInstruction:" ;
mMapTypeName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeGalgas_mapIndexInInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_mapIndexInInstruction * GGS_typeGalgas_mapIndexInInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_string& argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_mapIndexInInstruction * ptr_ = (cPtr_typeGalgas_mapIndexInInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_mapIndexInInstruction (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeGalgas_mapEntityInInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_mapEntityInInstruction::cPtr_typeGalgas_mapEntityInInstruction (const GGS_string& argument_0,
                                const GGS_string& argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEntityName (argument_0),
mElementTypeName (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_mapEntityInInstruction::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mEntityName ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_mapEntityInInstruction::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inModifiedObjectName,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inModifierName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2150))) == (GGS_string (true, "insertKey"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_lstring::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature.addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_entityInInstruction::constructor_new (_inLexique, mElementTypeName COMMA_HERE) ;
    var_cas_outModifierSignature.addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2156))) == (GGS_string (true, "insertKeyAndGetIndex"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_lstring::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature.addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_entityInInstruction::constructor_new (_inLexique, mElementTypeName COMMA_HERE) ;
    var_cas_outModifierSignature.addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_mapIndexInInstruction::constructor_new (_inLexique, var_cas_inModifiedObjectName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2162)) COMMA_HERE) ;
    var_cas_outModifierSignature.addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type only accept 'insertKey' and 'insertKey' modifier calls") SOURCE_FILE_AT_LINE (2167)) ;
    var_cas_outModifierSignature.drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_mapEntityInInstruction::
method_handleReaderInstructionCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inReadObjectName,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_EXsignature & var_cas_outReaderSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inReaderName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2177))) == (GGS_string (true, "searchKey"))).isBuiltAndTrue ()) {
    var_cas_outReaderSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_lstring::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outReaderSignature.addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_entityInInstruction::constructor_new (_inLexique, mElementTypeName COMMA_HERE) ;
    var_cas_outReaderSignature.addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2183))) == (GGS_string (true, "searchKeyAndGetIndex"))).isBuiltAndTrue ()) {
    var_cas_outReaderSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_lstring::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outReaderSignature.addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_entityInInstruction::constructor_new (_inLexique, mElementTypeName COMMA_HERE) ;
    var_cas_outReaderSignature.addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_mapIndexInInstruction::constructor_new (_inLexique, var_cas_inReadObjectName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2189)) COMMA_HERE) ;
    var_cas_outReaderSignature.addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inReadObjectName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type  only accept 'searchKey'  'searchKeyAndGetIndex' reader calls") SOURCE_FILE_AT_LINE (2195)) ;
    var_cas_outReaderSignature.drop_operation () ;
  }
}


const char * cPtr_typeGalgas_mapEntityInInstruction::message_messageGalgasType (void) const {
  return "a map entity" ;
}

const char * cPtr_typeGalgas_mapEntityInInstruction::static_string_message_messageGalgasType (void) {
  return "a map entity" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_mapEntityInInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_mapEntityInInstruction:" ;
mEntityName.reader_description  (_inLexique COMMA_THERE) ;
mElementTypeName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeGalgas_mapEntityInInstruction'            *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_mapEntityInInstruction * GGS_typeGalgas_mapEntityInInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_string& argument_0,
                                const GGS_string& argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_mapEntityInInstruction * ptr_ = (cPtr_typeGalgas_mapEntityInInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_mapEntityInInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'typeEnumMessageMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumMessageMap::
elementOf_GGS_typeEnumMessageMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEnumMessageMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mMessageStringList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeEnumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumMessageMap * info = (e_typeEnumMessageMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumMessageMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_lstringList &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeEnumMessageMap info  ;
    info.mMessageStringList = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_lstringList   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessageStringList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_lstringList   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' message name is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_lstringList & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' message name is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeEnumMessageMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumMessageMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumMessageMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEnumMessageMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeEnumMessageMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_enum'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_enum::cPtr_typeGalgas_enum (const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEnumTypeName (argument_0),
mEnumConstantesMap (argument_1),
mMessagesMap (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mEnumTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2228)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (mEnumConstantesMap.isBuilt ()) {
    mEnumConstantesMap (HERE)->method_searchKey (_inLexique, var_cas_inClassMethodName SOURCE_FILE_AT_LINE (2236)) ;
  }
  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
}


const char * cPtr_typeGalgas_enum::message_messageGalgasType (void) const {
  return "an enum type" ;
}

const char * cPtr_typeGalgas_enum::static_string_message_messageGalgasType (void) {
  return "an enum type" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_enum:" ;
mEnumTypeName.reader_description  (_inLexique COMMA_THERE) ;
mEnumConstantesMap.reader_description  (_inLexique COMMA_THERE) ;
mMessagesMap.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_enum'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_enum * GGS_typeGalgas_enum::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeGalgas_enum * ptr_ = (cPtr_typeGalgas_enum *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_enum (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//    Implementation of routine "verifierCompatibiliteTypesSemantiques"      *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteTypesSemantiques (C_Lexique & _inLexique,
                                const GGS_AC_galgasType  & var_cas_inFormalType,
                                const GGS_AC_galgasType  & var_cas_inEffectiveType,
                                const GGS_location  & var_cas_inErrorLocation,
                                const GGS_bool & var_cas_inAcceptPolymorphisme COMMA_UNUSED_LOCATION_ARGS) {
  if (var_cas_inFormalType.isBuilt () && var_cas_inEffectiveType.isBuilt ()) {
    cPtr_AC_galgasType * ptr_90851 = var_cas_inFormalType (HERE) ;
    cPtr_AC_galgasType * ptr_90870 = var_cas_inEffectiveType (HERE) ;
    cPtr_typeGalgas_stringset * operand_90851 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_90851) ;
    cPtr_typeGalgas_stringset * operand_90870 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_90870) ;
    if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
    }else{
      cPtr_typeGalgas_uint * operand_90851 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_90851) ;
      cPtr_typeGalgas_uint * operand_90870 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_90870) ;
      if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
      }else{
        cPtr_typeGalgas_sint * operand_90851 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_90851) ;
        cPtr_typeGalgas_sint * operand_90870 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_90870) ;
        if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
        }else{
          cPtr_typeGalgas_uint64 * operand_90851 = dynamic_cast <cPtr_typeGalgas_uint64 *> (ptr_90851) ;
          cPtr_typeGalgas_uint64 * operand_90870 = dynamic_cast <cPtr_typeGalgas_uint64 *> (ptr_90870) ;
          if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
          }else{
            cPtr_typeGalgas_sint64 * operand_90851 = dynamic_cast <cPtr_typeGalgas_sint64 *> (ptr_90851) ;
            cPtr_typeGalgas_sint64 * operand_90870 = dynamic_cast <cPtr_typeGalgas_sint64 *> (ptr_90870) ;
            if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
            }else{
              cPtr_typeGalgas_char * operand_90851 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_90851) ;
              cPtr_typeGalgas_char * operand_90870 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_90870) ;
              if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
              }else{
                cPtr_typeGalgas_string * operand_90851 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_90851) ;
                cPtr_typeGalgas_string * operand_90870 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_90870) ;
                if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                }else{
                  cPtr_typeGalgas_bool * operand_90851 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_90851) ;
                  cPtr_typeGalgas_bool * operand_90870 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_90870) ;
                  if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                  }else{
                    cPtr_typeGalgas_double * operand_90851 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_90851) ;
                    cPtr_typeGalgas_double * operand_90870 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_90870) ;
                    if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                    }else{
                      cPtr_typeGalgas_lbool * operand_90851 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_90851) ;
                      cPtr_typeGalgas_lbool * operand_90870 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_90870) ;
                      if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                      }else{
                        cPtr_typeGalgas_lchar * operand_90851 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_90851) ;
                        cPtr_typeGalgas_lchar * operand_90870 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_90870) ;
                        if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                        }else{
                          cPtr_typeGalgas_luint * operand_90851 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_90851) ;
                          cPtr_typeGalgas_luint * operand_90870 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_90870) ;
                          if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                          }else{
                            cPtr_typeGalgas_lsint * operand_90851 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_90851) ;
                            cPtr_typeGalgas_lsint * operand_90870 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_90870) ;
                            if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                            }else{
                              cPtr_typeGalgas_luint64 * operand_90851 = dynamic_cast <cPtr_typeGalgas_luint64 *> (ptr_90851) ;
                              cPtr_typeGalgas_luint64 * operand_90870 = dynamic_cast <cPtr_typeGalgas_luint64 *> (ptr_90870) ;
                              if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                              }else{
                                cPtr_typeGalgas_lsint64 * operand_90851 = dynamic_cast <cPtr_typeGalgas_lsint64 *> (ptr_90851) ;
                                cPtr_typeGalgas_lsint64 * operand_90870 = dynamic_cast <cPtr_typeGalgas_lsint64 *> (ptr_90870) ;
                                if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                                }else{
                                  cPtr_typeGalgas_ldouble * operand_90851 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_90851) ;
                                  cPtr_typeGalgas_ldouble * operand_90870 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_90870) ;
                                  if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                                  }else{
                                    cPtr_typeGalgas_lstring * operand_90851 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_90851) ;
                                    cPtr_typeGalgas_lstring * operand_90870 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_90870) ;
                                    if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                                    }else{
                                      cPtr_typeGalgas_location * operand_90851 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_90851) ;
                                      cPtr_typeGalgas_location * operand_90870 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_90870) ;
                                      if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                                      }else{
                                        cPtr_typeGalgasUndefinedListType * operand_90851 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_90851) ;
                                        cPtr_typeGalgasUndefinedListType * operand_90870 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_90870) ;
                                        if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                                          if (((operand_90851->mListTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2276))) != (operand_90870->mListTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2276)))).isBuiltAndTrue ()) {
                                            var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting the list type '@")) + (operand_90851->mListTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2277))))) + (GGS_string (true, "', I have got the list type '@")))) + (operand_90870->mListTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2278))))) + (GGS_string (true, "\""))) SOURCE_FILE_AT_LINE (2279)) ;
                                          }
                                        }else{
                                          cPtr_typeGalgasUndefinedMapType * operand_90851 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_90851) ;
                                          cPtr_typeGalgasUndefinedMapType * operand_90870 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_90870) ;
                                          if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                                            if (((operand_90851->mMapTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2282))) != (operand_90870->mMapTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2282)))).isBuiltAndTrue ()) {
                                              var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting the map type '@")) + (operand_90851->mMapTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2283))))) + (GGS_string (true, "', I have got the map type '@")))) + (operand_90870->mMapTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2284))))) + (GGS_string (true, "\""))) SOURCE_FILE_AT_LINE (2285)) ;
                                            }
                                          }else{
                                            cPtr_typeGalgasUndefinedClassType * operand_90851 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_90851) ;
                                            cPtr_typeGalgasClassType * operand_90870 = dynamic_cast <cPtr_typeGalgasClassType *> (ptr_90870) ;
                                            if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                                              GGS_bool var_cas_accept ;
                                              var_cas_accept = (operand_90851->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2289))) == (operand_90870->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2289))) ;
                                              if (((((! (var_cas_accept))) & (var_cas_inAcceptPolymorphisme))).isBuiltAndTrue ()) {
                                                var_cas_accept = operand_90870->mAncestorClassesMap.reader_hasKey (_inLexique, operand_90851->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2291)) SOURCE_FILE_AT_LINE (2291)) ;
                                              }
                                              if (((! (var_cas_accept))).isBuiltAndTrue ()) {
                                                var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting the class type '@")) + (operand_90851->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2294))))) + (GGS_string (true, "', I have got the class type '@")))) + (operand_90870->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2295))))) + (GGS_string (true, "\""))) SOURCE_FILE_AT_LINE (2296)) ;
                                              }
                                            }else{
                                              cPtr_typeGalgasUndefinedClassType * operand_90851 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_90851) ;
                                              cPtr_typeGalgasUndefinedClassType * operand_90870 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_90870) ;
                                              if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                                                GGS_bool var_cas_accept ;
                                                var_cas_accept = (operand_90851->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2299))) != (operand_90870->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2299))) ;
                                                if (((operand_90851->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2300))) != (operand_90870->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2300)))).isBuiltAndTrue ()) {
                                                  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting the class type '@")) + (operand_90851->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2301))))) + (GGS_string (true, "', I have got the class type '@")))) + (operand_90870->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2302))))) + (GGS_string (true, "\""))) SOURCE_FILE_AT_LINE (2303)) ;
                                                }
                                              }else{
                                                cPtr_typeGalgasUndefinedExternType * operand_90851 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_90851) ;
                                                cPtr_typeGalgasUndefinedExternType * operand_90870 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_90870) ;
                                                if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                                                  if (((operand_90851->mGalgasClassName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2307))) != (operand_90870->mGalgasClassName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2307)))).isBuiltAndTrue ()) {
                                                    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting an extern variable of extern '@")) + (operand_90851->mGalgasClassName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2308))))) + (GGS_string (true, "' type variable, and I got an extern '@")))) + (operand_90870->mGalgasClassName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2309))))) + (GGS_string (true, "' type variable"))) SOURCE_FILE_AT_LINE (2310)) ;
                                                  }
                                                }else{
                                                  cPtr_typeGalgas_enum * operand_90851 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_90851) ;
                                                  cPtr_typeGalgas_enum * operand_90870 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_90870) ;
                                                  if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                                                    if (((operand_90851->mEnumTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2314))) != (operand_90870->mEnumTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2314)))).isBuiltAndTrue ()) {
                                                      var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting an enum variable of  '@")) + (operand_90851->mEnumTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2315))))) + (GGS_string (true, "' type variable, and I got an enum '@")))) + (operand_90870->mEnumTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2316))))) + (GGS_string (true, "' type variable"))) SOURCE_FILE_AT_LINE (2317)) ;
                                                    }
                                                  }else{
                                                    cPtr_typeGalgas_entityInInstruction * operand_90851 = dynamic_cast <cPtr_typeGalgas_entityInInstruction *> (ptr_90851) ;
                                                    cPtr_typeGalgas_entityInInstruction * operand_90870 = dynamic_cast <cPtr_typeGalgas_entityInInstruction *> (ptr_90870) ;
                                                    if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                                                      if (((operand_90851->mEntityName) != (operand_90870->mEntityName)).isBuiltAndTrue ()) {
                                                        var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting an entity instance of  '@")) + (operand_90851->mEntityName))) + (GGS_string (true, "' type variable, and I got an entity instance of type '@")))) + (operand_90870->mEntityName))) + (GGS_string (true, "'"))) SOURCE_FILE_AT_LINE (2324)) ;
                                                      }
                                                    }else{
                                                      cPtr_typeGalgas_mapIndexInInstruction * operand_90851 = dynamic_cast <cPtr_typeGalgas_mapIndexInInstruction *> (ptr_90851) ;
                                                      cPtr_typeGalgas_mapIndexInInstruction * operand_90870 = dynamic_cast <cPtr_typeGalgas_mapIndexInInstruction *> (ptr_90870) ;
                                                      if ((operand_90851 != NULL) && (operand_90870 != NULL)) {
                                                        if (((operand_90851->mMapTypeName) != (operand_90870->mMapTypeName)).isBuiltAndTrue ()) {
                                                          var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting a map index of  '")) + (operand_90851->mMapTypeName))) + (GGS_string (true, "' map property, and I got a map index of '")))) + (operand_90870->mMapTypeName))) + (GGS_string (true, "' map property"))) SOURCE_FILE_AT_LINE (2331)) ;
                                                        }
                                                      }else{
                                                        var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((var_cas_inFormalType.reader_messageGalgasType (_inLexique SOURCE_FILE_AT_LINE (2334))) + (GGS_string (true, " is not compatible with ")))) + (var_cas_inEffectiveType.reader_messageGalgasType (_inLexique SOURCE_FILE_AT_LINE (2334)))) SOURCE_FILE_AT_LINE (2335)) ;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of routine "verifierCompatibiliteSignatures"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteSignatures (C_Lexique & _inLexique,
                                const GGS_L_EXsignature  & var_cas_signatureReference,
                                const GGS_L_EXsignature  & var_cas_signatureTestee,
                                const GGS_location  & var_cas_ouSignalerErreur COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_signatureReference.reader_length (_inLexique SOURCE_FILE_AT_LINE (2349))) < (var_cas_signatureTestee.reader_length (_inLexique SOURCE_FILE_AT_LINE (2349)))).isBuiltAndTrue ()) {
    var_cas_ouSignalerErreur.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "there are too much parameters") SOURCE_FILE_AT_LINE (2351)) ;
  }else if (((var_cas_signatureReference.reader_length (_inLexique SOURCE_FILE_AT_LINE (2351))) > (var_cas_signatureTestee.reader_length (_inLexique SOURCE_FILE_AT_LINE (2351)))).isBuiltAndTrue ()) {
    var_cas_ouSignalerErreur.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more parameters missing") SOURCE_FILE_AT_LINE (2353)) ;
  }else{
    GGS_L_EXsignature::element_type * operand_96311 = var_cas_signatureReference.firstObject () ;
    GGS_L_EXsignature::element_type * operand_96410 = var_cas_signatureTestee.firstObject () ;
    while ((operand_96311 != NULL)
        && (operand_96410 != NULL)) {
      macroValidPointer (operand_96311) ;
      macroValidPointer (operand_96410) ;
      ::routine_verifierCompatibiliteTypesSemantiques (_inLexique,  operand_96311->mType,  operand_96410->mType,  var_cas_ouSignalerErreur,  GGS_bool (true, false) SOURCE_FILE_AT_LINE (2357)) ;
      if (((operand_96311->mFormalArgumentPassingMode) != (operand_96410->mFormalArgumentPassingMode)).isBuiltAndTrue ()) {
        var_cas_ouSignalerErreur.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((operand_96410->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique SOURCE_FILE_AT_LINE (2363))) + (GGS_string (true, " is not compatible with ")))) + (operand_96410->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique SOURCE_FILE_AT_LINE (2364)))) SOURCE_FILE_AT_LINE (2365)) ;
      }
      operand_96311 = operand_96311->nextObject () ;
      operand_96410 = operand_96410->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'M_cli_options'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_cli_options::
elementOf_GGS_M_cli_options (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_cli_options & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_cli_options::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mOptionChar.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mOptionString.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mComment.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mDefaultValue.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_cli_options::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_cli_options *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_cli_options * info = (e_M_cli_options *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_cli_options result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lchar &  inParameter0,
               const GGS_lstring &  inParameter1,
               const GGS_lstring &  inParameter2,
               const GGS_uint &  inParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_cli_options info  ;
    info.mOptionChar = inParameter0 ;
    info.mOptionString = inParameter1 ;
    info.mComment = inParameter2 ;
    info.mDefaultValue = inParameter3 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lchar   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_uint   & outParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mOptionChar ;
    outParameter1 = node->mInfo.mOptionString ;
    outParameter2 = node->mInfo.mComment ;
    outParameter3 = node->mInfo.mDefaultValue ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lchar   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_lstring   & outParameter2,
                                GGS_uint   & outParameter3 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' command line option is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lchar & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_lstring & inParameter2,
                                const GGS_uint & inParameter3 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' command line option has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_cli_options & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_cli_options result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_cli_options result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_cli_options::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_cli_options " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'M_optionComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_optionComponents::
elementOf_GGS_M_optionComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_optionComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_optionComponents::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mBoolOptionsMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mUintOptionsMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mStringOptionsMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_optionComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_optionComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_optionComponents * info = (e_M_optionComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_optionComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_cli_options &  inParameter0,
               const GGS_M_cli_options &  inParameter1,
               const GGS_M_cli_options &  inParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_optionComponents info  ;
    info.mBoolOptionsMap = inParameter0 ;
    info.mUintOptionsMap = inParameter1 ;
    info.mStringOptionsMap = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_cli_options   & outParameter0,
               GGS_M_cli_options   & outParameter1,
               GGS_M_cli_options   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mBoolOptionsMap ;
    outParameter1 = node->mInfo.mUintOptionsMap ;
    outParameter2 = node->mInfo.mStringOptionsMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_cli_options   & outParameter0,
                                GGS_M_cli_options   & outParameter1,
                                GGS_M_cli_options   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "there is no '%K' option component",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_cli_options & inParameter0,
                                const GGS_M_cli_options & inParameter1,
                                const GGS_M_cli_options & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' option component named is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_optionComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_optionComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_optionComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_optionComponents::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_optionComponents " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'M_grammarComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_grammarComponents::
elementOf_GGS_M_grammarComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_grammarComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_grammarComponents::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mNonterminalSymbolParametersMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mLexiqueName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mOptionsMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_grammarComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_grammarComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_grammarComponents * info = (e_M_grammarComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_grammarComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAltsForGrammar &  inParameter0,
               const GGS_lstring &  inParameter1,
               const GGS_M_optionComponents &  inParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_grammarComponents info  ;
    info.mNonterminalSymbolParametersMap = inParameter0 ;
    info.mLexiqueName = inParameter1 ;
    info.mOptionsMap = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_M_optionComponents   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolParametersMap ;
    outParameter1 = node->mInfo.mLexiqueName ;
    outParameter2 = node->mInfo.mOptionsMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_M_optionComponents   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' grammar component is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_M_optionComponents & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' grammar component has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_grammarComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_grammarComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_grammarComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_grammarComponents::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_grammarComponents " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'M_semanticsComponents'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_semanticsComponents::
elementOf_GGS_M_semanticsComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_semanticsComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_semanticsComponents::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mModelMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mActionMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mImportedSemanticsComponents.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mImportedMetamodelComponents.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mImportedOptionsComponents.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mOptionsComponents.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mSemanticsEntitiesMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_semanticsComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_semanticsComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_semanticsComponents * info = (e_M_semanticsComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_ModelMap &  inParameter0,
               const GGS_ActionMap &  inParameter1,
               const GGS_stringset &  inParameter2,
               const GGS_stringset &  inParameter3,
               const GGS_stringset &  inParameter4,
               const GGS_M_optionComponents &  inParameter5,
               const GGS_M_semanticsEntitiesForUse &  inParameter6,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inParameter5.isBuilt ()
   && inParameter6.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_semanticsComponents info  ;
    info.mModelMap = inParameter0 ;
    info.mActionMap = inParameter1 ;
    info.mImportedSemanticsComponents = inParameter2 ;
    info.mImportedMetamodelComponents = inParameter3 ;
    info.mImportedOptionsComponents = inParameter4 ;
    info.mOptionsComponents = inParameter5 ;
    info.mSemanticsEntitiesMap = inParameter6 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_ModelMap   & outParameter0,
               GGS_ActionMap   & outParameter1,
               GGS_stringset   & outParameter2,
               GGS_stringset   & outParameter3,
               GGS_stringset   & outParameter4,
               GGS_M_optionComponents   & outParameter5,
               GGS_M_semanticsEntitiesForUse   & outParameter6,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    outParameter4.drop_operation () ;
    outParameter5.drop_operation () ;
    outParameter6.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mModelMap ;
    outParameter1 = node->mInfo.mActionMap ;
    outParameter2 = node->mInfo.mImportedSemanticsComponents ;
    outParameter3 = node->mInfo.mImportedMetamodelComponents ;
    outParameter4 = node->mInfo.mImportedOptionsComponents ;
    outParameter5 = node->mInfo.mOptionsComponents ;
    outParameter6 = node->mInfo.mSemanticsEntitiesMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_ModelMap   & outParameter0,
                                GGS_ActionMap   & outParameter1,
                                GGS_stringset   & outParameter2,
                                GGS_stringset   & outParameter3,
                                GGS_stringset   & outParameter4,
                                GGS_M_optionComponents   & outParameter5,
                                GGS_M_semanticsEntitiesForUse   & outParameter6 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "there is no semantics component named '%K'",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_ModelMap & inParameter0,
                                const GGS_ActionMap & inParameter1,
                                const GGS_stringset & inParameter2,
                                const GGS_stringset & inParameter3,
                                const GGS_stringset & inParameter4,
                                const GGS_M_optionComponents & inParameter5,
                                const GGS_M_semanticsEntitiesForUse & inParameter6 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "a semantics component named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_semanticsComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_semanticsComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_semanticsComponents::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_semanticsComponents " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'M_metamodelsComponents'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_metamodelsComponents::
elementOf_GGS_M_metamodelsComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_metamodelsComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_metamodelsComponents::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mRootEntity.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mSemanticsEntitiesMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mEntityMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mMultiReferencedEntities.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_metamodelsComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_metamodelsComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_metamodelsComponents * info = (e_M_metamodelsComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_metamodelsComponents GGS_M_metamodelsComponents::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_metamodelsComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               const GGS_M_semanticsEntitiesForUse &  inParameter1,
               const GGS_entityToImplementMap &  inParameter2,
               const GGS_stringset &  inParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_metamodelsComponents info  ;
    info.mRootEntity = inParameter0 ;
    info.mSemanticsEntitiesMap = inParameter1 ;
    info.mEntityMap = inParameter2 ;
    info.mMultiReferencedEntities = inParameter3 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_M_semanticsEntitiesForUse   & outParameter1,
               GGS_entityToImplementMap   & outParameter2,
               GGS_stringset   & outParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mRootEntity ;
    outParameter1 = node->mInfo.mSemanticsEntitiesMap ;
    outParameter2 = node->mInfo.mEntityMap ;
    outParameter3 = node->mInfo.mMultiReferencedEntities ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_M_semanticsEntitiesForUse   & outParameter1,
                                GGS_entityToImplementMap   & outParameter2,
                                GGS_stringset   & outParameter3 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "there is no metamodel component named '%K'",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_M_semanticsEntitiesForUse & inParameter1,
                                const GGS_entityToImplementMap & inParameter2,
                                const GGS_stringset & inParameter3 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "a metamodel component named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_metamodelsComponents GGS_M_metamodelsComponents::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_metamodelsComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_metamodelsComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_metamodelsComponents GGS_M_metamodelsComponents::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_metamodelsComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_metamodelsComponents::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_metamodelsComponents " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'M_constraintComponents'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_constraintComponents::
elementOf_GGS_M_constraintComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_constraintComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_constraintComponents::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mMetamodel.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_constraintComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_constraintComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_constraintComponents * info = (e_M_constraintComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_constraintComponents GGS_M_constraintComponents::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_constraintComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_constraintComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_constraintComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_constraintComponents info  ;
    info.mMetamodel = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_constraintComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMetamodel ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_constraintComponents::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "there is no constraint component named '%K'",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_constraintComponents::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "a constraint component named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_constraintComponents GGS_M_constraintComponents::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_constraintComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_constraintComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_constraintComponents GGS_M_constraintComponents::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_constraintComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_constraintComponents::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_constraintComponents " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@typeListeAttributsAxiome'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeAttributsAxiome::
elementOf_GGS_typeListeAttributsAxiome (const GGS_lstring & argument_0):
mNextItem (NULL),
aAttributAxiome (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeAttributsAxiome::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << aAttributAxiome.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeListeAttributsAxiome'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome::GGS_typeListeAttributsAxiome (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome::~GGS_typeListeAttributsAxiome (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome::
GGS_typeListeAttributsAxiome (const GGS_typeListeAttributsAxiome & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome::
operator = (const GGS_typeListeAttributsAxiome & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome::element_type * GGS_typeListeAttributsAxiome::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aAttributAxiome) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome  GGS_typeListeAttributsAxiome::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeAttributsAxiome result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeListeAttributsAxiome::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeAttributsAxiome::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeListeAttributsAxiome" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeListeAttributsAxiome::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_grammarDescriptorForProgram'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_grammarDescriptorForProgram::
elementOf_GGS_L_grammarDescriptorForProgram (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_signature & argument_2,
                                const GGS_typeListeAttributsAxiome & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_lstring & argument_6,
                                const GGS_L_lstringList & argument_7):
mNextItem (NULL),
mGrammarPostfix (argument_0),
mGrammarName (argument_1),
mStartSymbolSignature (argument_2),
mStartSymbolAttributesList (argument_3),
mLexiqueClassName (argument_4),
mReturnedMetamodelName (argument_5),
mReturnedRootEntityName (argument_6),
mConstraintsForMetamodel (argument_7) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_grammarDescriptorForProgram::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mGrammarPostfix.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mGrammarName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mStartSymbolSignature.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mStartSymbolAttributesList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mLexiqueClassName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mReturnedMetamodelName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mReturnedRootEntityName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mConstraintsForMetamodel.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_grammarDescriptorForProgram'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::GGS_L_grammarDescriptorForProgram (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::~GGS_L_grammarDescriptorForProgram (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::
GGS_L_grammarDescriptorForProgram (const GGS_L_grammarDescriptorForProgram & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
operator = (const GGS_L_grammarDescriptorForProgram & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::element_type * GGS_L_grammarDescriptorForProgram::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
internalAppendItem (const GGS_string& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_L_signature & argument_2,
                    const GGS_typeListeAttributsAxiome & argument_3,
                    const GGS_lstring & argument_4,
                    const GGS_lstring & argument_5,
                    const GGS_lstring & argument_6,
                    const GGS_L_lstringList & argument_7) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_signature & argument_2,
                                const GGS_typeListeAttributsAxiome & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_lstring & argument_6,
                                const GGS_L_lstringList & argument_7) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mGrammarPostfix,
                                p->mGrammarName,
                                p->mStartSymbolSignature,
                                p->mStartSymbolAttributesList,
                                p->mLexiqueClassName,
                                p->mReturnedMetamodelName,
                                p->mReturnedRootEntityName,
                                p->mConstraintsForMetamodel) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram  GGS_L_grammarDescriptorForProgram::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_grammarDescriptorForProgram result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_grammarDescriptorForProgram::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_grammarDescriptorForProgram::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_grammarDescriptorForProgram" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_grammarDescriptorForProgram::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of routine "handleReaderCall"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleReaderCall (C_Lexique & _inLexique,
                                const GGS_AC_galgasType  & var_cas_inReceiverType,
                                const GGS_lstring  & var_cas_inMethodName,
                                GGS_typeListeAttributsSemantiques  & var_cas_outAccessorTypesList,
                                GGS_AC_galgasType  & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2497))) == (GGS_string (true, "description"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else{
    if (var_cas_inReceiverType.isBuilt ()) {
      if (dynamic_cast <cPtr_typeGalgas_string *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2503))) == (GGS_string (true, "fileExists"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2506))) == (GGS_string (true, "pathExtension"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2509))) == (GGS_string (true, "lastPathComponent"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2512))) == (GGS_string (true, "stringByDeletingPathExtension"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2515))) == (GGS_string (true, "stringByCapitalizingFirstCharacter"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2518))) == (GGS_string (true, "firstCharacterOrNul"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_char::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2521))) == (GGS_string (true, "stringByDeletingLastPathComponent"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2524))) == (GGS_string (true, "stringByReplacingStringByString"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList.addAssign_operation (var_cas_outReturnedType, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
          var_cas_outAccessorTypesList.addAssign_operation (var_cas_outReturnedType, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2532)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_location *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2534))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2540)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_uint *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2542))) == (GGS_string (true, "sint"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_sint::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2545))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2551)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_uint64 *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2553))) == (GGS_string (true, "sint64"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_sint64::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2556))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2562)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_sint *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2564))) == (GGS_string (true, "uint"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2567))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2573)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_sint64 *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2575))) == (GGS_string (true, "uint64"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_uint64::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2578))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2584)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_lstring *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2586))) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2589))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2592))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2598)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_lchar *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2600))) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_char::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2603))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2606))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2612)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_lbool *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2614))) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2617))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2623)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_luint *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2625))) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2628))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2631))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2637)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_luint64 *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2639))) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_uint64::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2642))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2645))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2651)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_lsint *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2653))) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_sint::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2656))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2659))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2662))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2668)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_lsint64 *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2670))) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_sint64::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2673))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2676))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2679))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2685)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_ldouble *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2687))) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_double::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2690))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2693))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2696))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2702)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgasListType *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2704))) == (GGS_string (true, "length"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "list supports only 'length' reader call") SOURCE_FILE_AT_LINE (2710)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgasMapType *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2712))) == (GGS_string (true, "hasKey"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          GGS_AC_galgasType  var_cas_keyType ;
          var_cas_keyType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList.addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
          var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2717))) == (GGS_string (true, "count"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2720))) == (GGS_string (true, "allKeys"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_stringset::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2726)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgas_stringset *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2728))) == (GGS_string (true, "hasKey"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          GGS_AC_galgasType  var_cas_keyType ;
          var_cas_keyType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
          var_cas_outAccessorTypesList.addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
          var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new (_inLexique COMMA_HERE) ;
        }else if (((var_cas_inMethodName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2733))) == (GGS_string (true, "count"))).isBuiltAndTrue ()) {
          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
          var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
        }else{
          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2739)) ;
          var_cas_outAccessorTypesList.drop_operation () ;
          var_cas_outReturnedType.drop_operation () ;
        }
      }else if (dynamic_cast <cPtr_typeGalgasClassType *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        cPtr_typeGalgasClassType * operand_115980 = dynamic_cast <cPtr_typeGalgasClassType *> (var_cas_inReceiverType.getPtr ()) ;
        macroValidPointer (operand_115980) ; 
        if (operand_115980->mMessagesMap.isBuilt ()) {
          operand_115980->mMessagesMap (HERE)->method_searchKey (_inLexique, var_cas_inMethodName SOURCE_FILE_AT_LINE (2741)) ;
        }
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
      }else if (dynamic_cast <cPtr_typeGalgas_enum *> (var_cas_inReceiverType.getPtr ()) != NULL) {
        cPtr_typeGalgas_enum * operand_116259 = dynamic_cast <cPtr_typeGalgas_enum *> (var_cas_inReceiverType.getPtr ()) ;
        macroValidPointer (operand_116259) ; 
        GGS_L_lstringList  var_cas_116371 ;
        if (operand_116259->mMessagesMap.isBuilt ()) {
          operand_116259->mMessagesMap (HERE)->method_searchKey (_inLexique, var_cas_inMethodName, var_cas_116371 SOURCE_FILE_AT_LINE (2745)) ;
        }
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
      }else{ // Else part
        var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support reader call") SOURCE_FILE_AT_LINE (2752)) ;
        var_cas_outAccessorTypesList.drop_operation () ;
        var_cas_outReturnedType.drop_operation () ;
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "importSemanticsComponent"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_importSemanticsComponent (C_Lexique & _inLexique,
                                GGS_M_semanticsComponents  & var_cas_ioSemanticsComponentsMap,
                                GGS_M_metamodelsComponents  & var_cas_ioMetamodelComponentMap,
                                GGS_ModelMap  & var_cas_ioModelMap,
                                GGS_ActionMap  & var_cas_ioActionMap,
                                GGS_stringset  & var_cas_ioAlreadyImportedSemanticsComponents,
                                GGS_stringset  & var_cas_ioAlreadyImportedMetamodelComponents,
                                GGS_lstring   var_cas_inSemanticsComponentName COMMA_UNUSED_LOCATION_ARGS) {
  if (((! (var_cas_ioAlreadyImportedSemanticsComponents.reader_hasKey (_inLexique, var_cas_inSemanticsComponentName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2779)) SOURCE_FILE_AT_LINE (2779))))).isBuiltAndTrue ()) {
    GGS_ModelMap  var_cas_modelMap ;
    GGS_ActionMap  var_cas_actionMap ;
    GGS_stringset  var_cas_importedSemanticsComponents ;
    GGS_stringset  var_cas_importedMetamodelComponents ;
    GGS_stringset  var_cas_importedOptionsComponents ;
    GGS_M_optionComponents  var_cas_118169 ;
    GGS_M_semanticsEntitiesForUse  var_cas_118178 ;
    if (var_cas_ioSemanticsComponentsMap.isBuilt ()) {
      var_cas_ioSemanticsComponentsMap (HERE)->method_searchKey (_inLexique, var_cas_inSemanticsComponentName, var_cas_modelMap, var_cas_actionMap, var_cas_importedSemanticsComponents, var_cas_importedMetamodelComponents, var_cas_importedOptionsComponents, var_cas_118169, var_cas_118178 SOURCE_FILE_AT_LINE (2786)) ;
    }
    var_cas_ioAlreadyImportedMetamodelComponents = ((var_cas_ioAlreadyImportedMetamodelComponents) | (var_cas_importedMetamodelComponents)) ;
    GGS_stringset::element_type * operand_118423 = var_cas_importedSemanticsComponents.firstObject () ;
    while ((operand_118423 != NULL)) {
      macroValidPointer (operand_118423) ;
      ::routine_importSemanticsComponent (_inLexique,  var_cas_ioSemanticsComponentsMap,  var_cas_ioMetamodelComponentMap,  var_cas_ioModelMap,  var_cas_ioActionMap,  var_cas_ioAlreadyImportedSemanticsComponents,  var_cas_ioAlreadyImportedMetamodelComponents,  GGS_lstring::constructor_new (_inLexique, operand_118423->mKey, GGS_location (_inLexique) COMMA_HERE) SOURCE_FILE_AT_LINE (2800)) ;
      operand_118423 = operand_118423->nextObject () ;
    }
    GGS_ModelMap::element_type * operand_118788 = var_cas_modelMap.firstObject () ;
    while ((operand_118788 != NULL)) {
      macroValidPointer (operand_118788) ;
      if (((! (var_cas_ioModelMap.reader_hasKey (_inLexique, operand_118788->mKey.reader_value (_inLexique SOURCE_FILE_AT_LINE (2811)) SOURCE_FILE_AT_LINE (2811))))).isBuiltAndTrue ()) {
        var_cas_ioModelMap.method_insertKey (_inLexique, operand_118788->mKey, operand_118788->mInfo.mType SOURCE_FILE_AT_LINE (2812)) ;
      }
      operand_118788 = operand_118788->nextObject () ;
    }
    GGS_ActionMap::element_type * operand_119001 = var_cas_actionMap.firstObject () ;
    while ((operand_119001 != NULL)) {
      macroValidPointer (operand_119001) ;
      if (((! (var_cas_ioActionMap.reader_hasKey (_inLexique, operand_119001->mKey.reader_value (_inLexique SOURCE_FILE_AT_LINE (2817)) SOURCE_FILE_AT_LINE (2817))))).isBuiltAndTrue ()) {
        var_cas_ioActionMap.method_insertKey (_inLexique, operand_119001->mKey, operand_119001->mInfo.mSignature, operand_119001->mInfo.mIsExtern SOURCE_FILE_AT_LINE (2818)) ;
      }
      operand_119001 = operand_119001->nextObject () ;
    }
    var_cas_ioAlreadyImportedSemanticsComponents.addAssign_operation (var_cas_inSemanticsComponentName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2822))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildSuperEntitySet"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildSuperEntitySet (C_Lexique & _inLexique,
                                const GGS_entityToImplementMap  & var_cas_inEntityMap,
                                const GGS_lstring  & var_cas_inSuperEntityName,
                                GGS_stringset  & var_cas_ioSuperEntitySet COMMA_UNUSED_LOCATION_ARGS) {
  if (((((((var_cas_inSuperEntityName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2833))) != (GGS_string (true, ""))) & (var_cas_inEntityMap.reader_hasKey (_inLexique, var_cas_inSuperEntityName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2834)) SOURCE_FILE_AT_LINE (2834))))) & ((! (var_cas_ioSuperEntitySet.reader_hasKey (_inLexique, var_cas_inSuperEntityName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2835)) SOURCE_FILE_AT_LINE (2835))))))).isBuiltAndTrue ()) {
    var_cas_ioSuperEntitySet.addAssign_operation (var_cas_inSuperEntityName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2836))) ;
    GGS_lstring  var_cas_superEntityName ;
    GGS_entityPropertyMap  var_cas_119860 ;
    GGS_bool var_cas_119863 ;
    GGS_entityPropertyMap  var_cas_119866 ;
    if (var_cas_inEntityMap.isBuilt ()) {
      var_cas_inEntityMap (HERE)->method_searchKey (_inLexique, var_cas_inSuperEntityName, var_cas_119860, var_cas_119863, var_cas_119866, var_cas_superEntityName SOURCE_FILE_AT_LINE (2838)) ;
    }
    ::routine_buildSuperEntitySet (_inLexique,  var_cas_inEntityMap,  var_cas_superEntityName,  var_cas_ioSuperEntitySet SOURCE_FILE_AT_LINE (2839)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of routine "checkPath"                    *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkPath (C_Lexique & _inLexique,
                                GGS_entityToImplementMap  & var_cas_ioEntityMap,
                                GGS_mapEntityMap  & var_cas_ioMapEntityMap,
                                GGS_entityPropertyMap   var_cas_inAllPropertiesOfCurrentEntity,
                                GGS_lstring   var_cas_inCurrentEntityName,
                                GGS_L_propertyPath   var_cas_inPath,
                                GGS_metamodelPropertyKind & var_cas_outKind,
                                GGS_lstring  & var_cas_outTypeName,
                                GGS_lstring  & var_cas_outLastEntityTypeName COMMA_UNUSED_LOCATION_ARGS) {
  GGS_entityPropertyMap  var_cas_currentMap ;
  var_cas_currentMap = var_cas_inAllPropertiesOfCurrentEntity ;
  var_cas_outTypeName = var_cas_inCurrentEntityName ;
  var_cas_outLastEntityTypeName = var_cas_inCurrentEntityName ;
  var_cas_outKind = GGS_metamodelPropertyKind::constructor_singleReferenceProperty (_inLexique COMMA_HERE) ;
  GGS_L_propertyPath::element_type * operand_120603 = var_cas_inPath.firstObject () ;
  while ((operand_120603 != NULL)) {
    macroValidPointer (operand_120603) ;
    GGS_string var_cas_entityTypeName ;
    var_cas_entityTypeName = operand_120603->mPathElement.reader_value (_inLexique SOURCE_FILE_AT_LINE (2860)).reader_pathExtension (_inLexique SOURCE_FILE_AT_LINE (2860)) ;
    if (((var_cas_entityTypeName) != (GGS_string (true, ""))).isBuiltAndTrue ()) {
      GGS_stringset  var_cas_superEntitySet ;
      var_cas_superEntitySet = GGS_stringset::constructor_emptySet (_inLexique COMMA_HERE) ;
      GGS_lstring  var_cas_actualEntityName ;
      var_cas_actualEntityName = GGS_lstring::constructor_new (_inLexique, var_cas_entityTypeName, operand_120603->mPathElement.reader_location (_inLexique SOURCE_FILE_AT_LINE (2863)) COMMA_HERE) ;
      ::routine_buildSuperEntitySet (_inLexique,  var_cas_ioEntityMap,  var_cas_actualEntityName,  var_cas_superEntitySet SOURCE_FILE_AT_LINE (2865)) ;
      if (((! (var_cas_superEntitySet.reader_hasKey (_inLexique, var_cas_outTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2869)) SOURCE_FILE_AT_LINE (2869))))).isBuiltAndTrue ()) {
        operand_120603->mPathElement.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "this entity is not a descendant of '@")) + (var_cas_outTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2871))))) + (GGS_string (true, "' entity"))) SOURCE_FILE_AT_LINE (2872)) ;
      }
      var_cas_outLastEntityTypeName = var_cas_outTypeName ;
      var_cas_outTypeName = var_cas_actualEntityName ;
      var_cas_outKind = GGS_metamodelPropertyKind::constructor_singleReferenceProperty (_inLexique COMMA_HERE) ;
      GGS_bool var_cas_121393 ;
      GGS_entityPropertyMap  var_cas_121396 ;
      GGS_lstring  var_cas_121399 ;
      if (var_cas_ioEntityMap.isBuilt ()) {
        var_cas_ioEntityMap (HERE)->method_searchKey (_inLexique, var_cas_outTypeName, var_cas_currentMap, var_cas_121393, var_cas_121396, var_cas_121399 SOURCE_FILE_AT_LINE (2876)) ;
      }
    }else{
      var_cas_outLastEntityTypeName = var_cas_outTypeName ;
      if (var_cas_currentMap.isBuilt ()) {
        var_cas_currentMap (HERE)->method_searchKey (_inLexique, operand_120603->mPathElement, var_cas_outKind, var_cas_outTypeName SOURCE_FILE_AT_LINE (2879)) ;
      }
      if (((var_cas_outKind) != (GGS_metamodelPropertyKind::constructor_attributeProperty (_inLexique COMMA_HERE))).isBuiltAndTrue ()) {
        if ((var_cas_ioMapEntityMap.reader_hasKey (_inLexique, var_cas_outTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2881)) SOURCE_FILE_AT_LINE (2881))).isBuiltAndTrue ()) {
          GGS_lstring  var_cas_elementEntity ;
          GGS_lstring  var_cas_121761 ;
          GGS_lstring  var_cas_121764 ;
          if (var_cas_ioMapEntityMap.isBuilt ()) {
            var_cas_ioMapEntityMap (HERE)->method_searchKey (_inLexique, var_cas_outTypeName, var_cas_elementEntity, var_cas_121761, var_cas_121764 SOURCE_FILE_AT_LINE (2883)) ;
          }
          GGS_bool var_cas_121831 ;
          GGS_entityPropertyMap  var_cas_121834 ;
          GGS_lstring  var_cas_121837 ;
          if (var_cas_ioEntityMap.isBuilt ()) {
            var_cas_ioEntityMap (HERE)->method_searchKey (_inLexique, var_cas_elementEntity, var_cas_currentMap, var_cas_121831, var_cas_121834, var_cas_121837 SOURCE_FILE_AT_LINE (2884)) ;
          }
        }else{
          GGS_bool var_cas_121916 ;
          GGS_entityPropertyMap  var_cas_121919 ;
          GGS_lstring  var_cas_121922 ;
          if (var_cas_ioEntityMap.isBuilt ()) {
            var_cas_ioEntityMap (HERE)->method_searchKey (_inLexique, var_cas_outTypeName, var_cas_currentMap, var_cas_121916, var_cas_121919, var_cas_121922 SOURCE_FILE_AT_LINE (2886)) ;
          }
        }
      }
    }
    operand_120603 = operand_120603->nextObject () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "computeDescendantSet"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_computeDescendantSet (C_Lexique & _inLexique,
                                const GGS_entityToImplementMap  & var_cas_inEntityMap,
                                GGS_lstring   var_cas_inEntityName,
                                GGS_stringset  & var_cas_ioDescendantEntitySet COMMA_UNUSED_LOCATION_ARGS) {
  GGS_entityToImplementMap::element_type * operand_122237 = var_cas_inEntityMap.firstObject () ;
  while ((operand_122237 != NULL)) {
    macroValidPointer (operand_122237) ;
    if (((((operand_122237->mInfo.mSuperEntityName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2901))) == (var_cas_inEntityName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2901)))) & ((! (var_cas_ioDescendantEntitySet.reader_hasKey (_inLexique, var_cas_inEntityName.reader_value (_inLexique SOURCE_FILE_AT_LINE (2901)) SOURCE_FILE_AT_LINE (2901))))))).isBuiltAndTrue ()) {
      var_cas_ioDescendantEntitySet.addAssign_operation (operand_122237->mKey.reader_value (_inLexique SOURCE_FILE_AT_LINE (2902))) ;
      ::routine_computeDescendantSet (_inLexique,  var_cas_inEntityMap,  operand_122237->mKey,  var_cas_ioDescendantEntitySet SOURCE_FILE_AT_LINE (2903)) ;
    }
    operand_122237 = operand_122237->nextObject () ;
  }
}

//---------------------------------------------------------------------------*

