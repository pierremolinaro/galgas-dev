//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'common_semantics.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      january 3rd, 2006, at 21h6'43"                       *
//                                                                           *
// This file is free software; you can redistribute it and/or modify it      *
// under the terms of the GNU Lesser General Public License as published     *
// by the Free Software Foundation; either version 2 of the License, or      *
// (at your option) any later version.                                       *
//                                                                           *
// This file is distributed in the hope it will be useful, but WITHOUT       *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public       *
// License for more details.                                                 *
//                                                                           *
// You should have received a copy of the GNU General Public License along   *
// with this program; if not, write to the Free Software Foundation          *
// Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA            *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "common_semantics.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               Include directives generated by extern types                *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cClassMethodsMap.hh"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@attributeListModel'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_attributeListModel::
elementOf_GGS_attributeListModel (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (elementOf_GGS_attributeListModel *) NULL ;
  mTypeName = argument_0 ;
  mAttributeName = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@attributeListModel'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_attributeListModel
::GGS_attributeListModel (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_attributeListModel::~GGS_attributeListModel (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_attributeListModel::GGS_attributeListModel (const GGS_attributeListModel & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_attributeListModel
::operator = (const GGS_attributeListModel & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeListModel
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeListModel::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeListModel::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeListModel
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mTypeName,
                                p->mAttributeName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeListModel  GGS_attributeListModel::
constructor_empty (void) {
  GGS_attributeListModel result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeListModel
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_TypeModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_TypeModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (void) {
  mPointer = (cPtr_TypeModel *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (const GGS_TypeModel & inOperand) {
  mPointer = (cPtr_TypeModel *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_TypeModel::
~GGS_TypeModel (void) {
  macroDetachPointer (mPointer, cPtr_TypeModel) ;
}

//---------------------------------------------------------------------------*

void GGS_TypeModel::
operator = (const GGS_TypeModel & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_TypeModel::
operator = (cPtr_TypeModel * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (cPtr_TypeModel * inSource) {
  mPointer = (cPtr_TypeModel *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_TypeModel * GGS_TypeModel
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_TypeModel
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_TypeModel) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'ListModel'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ListModel::cPtr_ListModel (const GGS_attributeListModel & argument_0)
:mAttributeList (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_ListModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_ListModel * GGS_ListModel::
    constructor_new (const GGS_attributeListModel & argument_0) {
    cPtr_ListModel * ptr_ = (cPtr_ListModel *) NULL ;
    macroMyNew (ptr_, cPtr_ListModel (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'ModelMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ModelMap::
elementOf_GGS_ModelMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_ModelMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ModelMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_ModelMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ModelMap * info = (e_ModelMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::constructor_empty (void) {
  GGS_ModelMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_TypeModel &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_ModelMap info  ;
    info.mType = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_TypeModel   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_TypeModel   & outParameter0) {
  searchElement (inLexique,
                 "the '%K' type is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_TypeModel & inParameter0) {
  insertElement (lexique_var_,
                 "the '%K' type has been already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class for enumeration 'actualParametersPassingMode'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator == (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator != (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator <= (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator >= (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator < (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator > (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParametersPassingMode::
reader_actualArgumentMessage (void) const {
  const char * kMessages [4] = {"",
    "an output (!) actual parameter",
    "an output/input (!\?) actual parameter",
    "an input (\?) actual parameter"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class for enumeration 'formalArgumentPassingMode'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator == (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator != (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator <= (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator >= (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator < (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator > (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingMode::
reader_formalArgumentMessage (void) const {
  const char * kMessages [5] = {"",
    "an input (\?) formal argument",
    "an output (!) formal argument",
    "an input/output (\?!) argument",
    "a constant input (\?\?) formal argument"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class for enumeration 'localConstantBuildStyleEnum'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator == (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator != (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator <= (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator >= (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator < (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator > (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_AC_galgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_acceptAssignmentFromHere (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inErrorLocation) {
    var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "assignment from 'here' is not allowed for variables of this type")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_acceptForeachInstruction (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & /* var_cas_outForeachList */,
                                GGS_localConstantBuildStyleEnum& /* var_cas_outStyle */) {
    var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type cannot be enumerated by in 'foreach' instruction")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_acceptToBeKeyForMap (C_Lexique & lexique_var_) {
    GGS_location (lexique_var_).reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this type cannot be a key for map")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleModifierCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_signature & /* var_cas_outModifierSignature */) {
    var_cas_inModifierName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support modifier call")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleReaderInstructionCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_signature & /* var_cas_outReaderSignature */) {
    var_cas_inReaderName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support reader instruction")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & /* var_cas_outAccessorTypesList */) {
    var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleAddAssignOperatorCall (C_Lexique & lexique_var_,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & /* var_cas_outParametersList */,
                                GGS_bool& /* var_cas_outAccept_uint_assignment */) {
    var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support call of '+=' operator")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleIncrementOperatorCall (C_Lexique & lexique_var_,
                                GGS_location  var_cas_inErrorLocation) {
    var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support call of '++' operator")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & lexique_var_) {
    GGS_location (lexique_var_).reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type cannot be silently converted to @location value")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_typeCanBeUsedInObjectDeclaration (C_Lexique & /* lexique_var_ */) {
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType
::static_string_message_messageGalgasType (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType::
message_messageGalgasType (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_galgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (void) {
  mPointer = (cPtr_AC_galgasType *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (const GGS_AC_galgasType & inOperand) {
  mPointer = (cPtr_AC_galgasType *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
~GGS_AC_galgasType (void) {
  macroDetachPointer (mPointer, cPtr_AC_galgasType) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_galgasType::
operator = (const GGS_AC_galgasType & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_galgasType::
operator = (cPtr_AC_galgasType * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (cPtr_AC_galgasType * inSource) {
  mPointer = (cPtr_AC_galgasType *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_AC_galgasType * GGS_AC_galgasType
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_AC_galgasType::reader_messageGalgasType (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_galgasType
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_galgasType) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeAttributsSemantiques'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeAttributsSemantiques::
elementOf_GGS_typeListeAttributsSemantiques (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (elementOf_GGS_typeListeAttributsSemantiques *) NULL ;
  mAttributType = argument_0 ;
  aNomAttribut = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeAttributsSemantiques'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques
::GGS_typeListeAttributsSemantiques (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::~GGS_typeListeAttributsSemantiques (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::GGS_typeListeAttributsSemantiques (const GGS_typeListeAttributsSemantiques & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques
::operator = (const GGS_typeListeAttributsSemantiques & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mAttributType,
                                p->aNomAttribut) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeListeAttributsSemantiques::
constructor_empty (void) {
  GGS_typeListeAttributsSemantiques result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@typeTypesList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTypesList::
elementOf_GGS_typeTypesList (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  mNextItem = (elementOf_GGS_typeTypesList *) NULL ;
  mType = argument_0 ;
  mEndOfExpressionLocation = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@typeTypesList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTypesList
::GGS_typeTypesList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeTypesList::~GGS_typeTypesList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeTypesList::GGS_typeTypesList (const GGS_typeTypesList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList
::operator = (const GGS_typeTypesList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mEndOfExpressionLocation) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeTypesList  GGS_typeTypesList::
constructor_empty (void) {
  GGS_typeTypesList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@L_signature'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_signature::
elementOf_GGS_L_signature (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) {
  mNextItem = (elementOf_GGS_L_signature *) NULL ;
  mType = argument_0 ;
  mFormalArgumentPassingMode = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@L_signature'                             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_signature
::GGS_L_signature (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_signature::~GGS_L_signature (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_signature::GGS_L_signature (const GGS_L_signature & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature
::operator = (const GGS_L_signature & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mFormalArgumentPassingMode) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_signature  GGS_L_signature::
constructor_empty (void) {
  GGS_L_signature result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_actualParametersSignature'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_actualParametersSignature::
elementOf_GGS_L_actualParametersSignature (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1) {
  mNextItem = (elementOf_GGS_L_actualParametersSignature *) NULL ;
  mType = argument_0 ;
  mFormalArgumentPassingMode = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@L_actualParametersSignature'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature
::GGS_L_actualParametersSignature (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::~GGS_L_actualParametersSignature (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::GGS_L_actualParametersSignature (const GGS_L_actualParametersSignature & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature
::operator = (const GGS_L_actualParametersSignature & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mFormalArgumentPassingMode) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature  GGS_L_actualParametersSignature::
constructor_empty (void) {
  GGS_L_actualParametersSignature result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'M_accessors_map'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_accessors_map::
elementOf_GGS_M_accessors_map (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_accessors_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_accessors_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_accessors_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_accessors_map * info = (e_M_accessors_map *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::constructor_empty (void) {
  GGS_M_accessors_map result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               const GGS_AC_galgasType &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_accessors_map info  ;
    info.mAccessorSignature = inParameter0 ;
    info.mReturnedType = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAccessorSignature ;
    outParameter1 = node->mInfo.mReturnedType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0,
                                GGS_AC_galgasType   & outParameter1) {
  searchElement (inLexique,
                 "the '%K' accessor is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0,
                                const GGS_AC_galgasType & inParameter1) {
  insertElement (lexique_var_,
                 "the '%K' accessor has been already declared",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_stringList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_stringList::
elementOf_GGS_L_stringList (const GGS_string& argument_0) {
  mNextItem = (elementOf_GGS_L_stringList *) NULL ;
  mErrorMessageElement = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@L_stringList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_stringList
::GGS_L_stringList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_stringList::~GGS_L_stringList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_stringList::GGS_L_stringList (const GGS_L_stringList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_stringList
::operator = (const GGS_L_stringList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
internalAppendItem (const GGS_string& argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
addAssign_operation (const GGS_string& argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mErrorMessageElement) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_stringList  GGS_L_stringList::
constructor_empty (void) {
  GGS_L_stringList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_stringList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_lstringList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_lstringList::
elementOf_GGS_L_lstringList (const GGS_lstring & argument_0) {
  mNextItem = (elementOf_GGS_L_lstringList *) NULL ;
  mString = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_lstringList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_lstringList
::GGS_L_lstringList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_lstringList::~GGS_L_lstringList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_lstringList::GGS_L_lstringList (const GGS_L_lstringList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList
::operator = (const GGS_L_lstringList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mString) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_lstringList  GGS_L_lstringList::
constructor_empty (void) {
  GGS_L_lstringList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeGalgas_jokerInParameterList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_jokerInParameterList::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "") ;
}


const char * cPtr_typeGalgas_jokerInParameterList::message_messageGalgasType (void) const {
  return "\?\?" ;
}

const char * cPtr_typeGalgas_jokerInParameterList::static_string_message_messageGalgasType (void) {
  return "\?\?" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeGalgas_jokerInParameterList'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_jokerInParameterList * GGS_typeGalgas_jokerInParameterList::
    constructor_new () {
    cPtr_typeGalgas_jokerInParameterList * ptr_ = (cPtr_typeGalgas_jokerInParameterList *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_jokerInParameterList ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_bool'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "bool") ;
}


const char * cPtr_typeGalgas_bool::message_messageGalgasType (void) const {
  return "a bool type" ;
}

const char * cPtr_typeGalgas_bool::static_string_message_messageGalgasType (void) {
  return "a bool type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_bool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_bool * GGS_typeGalgas_bool::
    constructor_new () {
    cPtr_typeGalgas_bool * ptr_ = (cPtr_typeGalgas_bool *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_bool ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_string'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "string") ;
}


const char * cPtr_typeGalgas_string::message_messageGalgasType (void) const {
  return "a 'string' type" ;
}

const char * cPtr_typeGalgas_string::static_string_message_messageGalgasType (void) {
  return "a 'string' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_string'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_string * GGS_typeGalgas_string::
    constructor_new () {
    cPtr_typeGalgas_string * ptr_ = (cPtr_typeGalgas_string *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_string ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_sint'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "sint") ;
}


const char * cPtr_typeGalgas_sint::message_messageGalgasType (void) const {
  return "a 'sint' type" ;
}

const char * cPtr_typeGalgas_sint::static_string_message_messageGalgasType (void) {
  return "a 'sint' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_sint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_sint * GGS_typeGalgas_sint::
    constructor_new () {
    cPtr_typeGalgas_sint * ptr_ = (cPtr_typeGalgas_sint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_sint ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_uint'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "uint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
methode_handleIncrementOperatorCall (C_Lexique & /* lexique_var_ */,
                                GGS_location  /* var_cas_inErrorLocation */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "max"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}


const char * cPtr_typeGalgas_uint::message_messageGalgasType (void) const {
  return "a 'uint' type" ;
}

const char * cPtr_typeGalgas_uint::static_string_message_messageGalgasType (void) {
  return "a 'uint' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_uint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_uint * GGS_typeGalgas_uint::
    constructor_new () {
    cPtr_typeGalgas_uint * ptr_ = (cPtr_typeGalgas_uint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_uint ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_char'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "char") ;
}


const char * cPtr_typeGalgas_char::message_messageGalgasType (void) const {
  return "a 'char' type" ;
}

const char * cPtr_typeGalgas_char::static_string_message_messageGalgasType (void) {
  return "a 'char' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_char'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_char * GGS_typeGalgas_char::
    constructor_new () {
    cPtr_typeGalgas_char * ptr_ = (cPtr_typeGalgas_char *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_char ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_double'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_double::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "double") ;
}


const char * cPtr_typeGalgas_double::message_messageGalgasType (void) const {
  return "a double type" ;
}

const char * cPtr_typeGalgas_double::static_string_message_messageGalgasType (void) {
  return "a double type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_double'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_double * GGS_typeGalgas_double::
    constructor_new () {
    cPtr_typeGalgas_double * ptr_ = (cPtr_typeGalgas_double *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_double ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_galgasPrimitiveType'                 *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType
::static_string_message_messageGalgasType (void) {
  return "any primitive type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType::
message_messageGalgasType (void) const {
  return "any primitive type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_galgasPrimitiveType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (void) {
  mPointer = (cPtr_C_galgasPrimitiveType *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (const GGS_C_galgasPrimitiveType & inOperand) {
  mPointer = (cPtr_C_galgasPrimitiveType *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
~GGS_C_galgasPrimitiveType (void) {
  macroDetachPointer (mPointer, cPtr_C_galgasPrimitiveType) ;
}

//---------------------------------------------------------------------------*

void GGS_C_galgasPrimitiveType::
operator = (const GGS_C_galgasPrimitiveType & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_C_galgasPrimitiveType::
operator = (cPtr_C_galgasPrimitiveType * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (cPtr_C_galgasPrimitiveType * inSource) {
  mPointer = (cPtr_C_galgasPrimitiveType *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_galgasPrimitiveType * GGS_C_galgasPrimitiveType
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_galgasPrimitiveType::reader_messageGalgasType (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_C_galgasPrimitiveType
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_C_galgasPrimitiveType) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgas_location'                         *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "location") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
methode_acceptAssignmentFromHere (C_Lexique & /* lexique_var_ */,
                                GGS_lstring  /* var_cas_inErrorLocation */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_location::message_messageGalgasType (void) const {
  return "'location' type" ;
}

const char * cPtr_typeGalgas_location::static_string_message_messageGalgasType (void) {
  return "'location' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_location'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_location * GGS_typeGalgas_location::
    constructor_new () {
    cPtr_typeGalgas_location * ptr_ = (cPtr_typeGalgas_location *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_location ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_lstring'                         *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "lstring") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_string::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
methode_acceptToBeKeyForMap (C_Lexique & /* lexique_var_ */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_lstring::message_messageGalgasType (void) const {
  return "a 'lstring' type" ;
}

const char * cPtr_typeGalgas_lstring::static_string_message_messageGalgasType (void) {
  return "a 'lstring' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_lstring'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_lstring * GGS_typeGalgas_lstring::
    constructor_new () {
    cPtr_typeGalgas_lstring * ptr_ = (cPtr_typeGalgas_lstring *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lstring ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lchar'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "lchar") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_char::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_lchar::message_messageGalgasType (void) const {
  return "a 'lchar' type" ;
}

const char * cPtr_typeGalgas_lchar::static_string_message_messageGalgasType (void) {
  return "a 'lchar' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lchar'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_lchar * GGS_typeGalgas_lchar::
    constructor_new () {
    cPtr_typeGalgas_lchar * ptr_ = (cPtr_typeGalgas_lchar *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lchar ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lbool'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "lbool") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_bool::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_lbool::message_messageGalgasType (void) const {
  return "a 'lbool' type" ;
}

const char * cPtr_typeGalgas_lbool::static_string_message_messageGalgasType (void) {
  return "a 'lbool' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lbool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_lbool * GGS_typeGalgas_lbool::
    constructor_new () {
    cPtr_typeGalgas_lbool * ptr_ = (cPtr_typeGalgas_lbool *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lbool ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_luint'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "luint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_uint::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
methode_acceptToBeKeyForMap (C_Lexique & /* lexique_var_ */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_luint::message_messageGalgasType (void) const {
  return "a 'luint' type" ;
}

const char * cPtr_typeGalgas_luint::static_string_message_messageGalgasType (void) {
  return "a 'luint' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_luint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_luint * GGS_typeGalgas_luint::
    constructor_new () {
    cPtr_typeGalgas_luint * ptr_ = (cPtr_typeGalgas_luint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_luint ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lsint'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "lsint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_sint::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
methode_acceptToBeKeyForMap (C_Lexique & /* lexique_var_ */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_lsint::message_messageGalgasType (void) const {
  return "a 'lsint' type" ;
}

const char * cPtr_typeGalgas_lsint::static_string_message_messageGalgasType (void) {
  return "a 'lsint' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lsint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_lsint * GGS_typeGalgas_lsint::
    constructor_new () {
    cPtr_typeGalgas_lsint * ptr_ = (cPtr_typeGalgas_lsint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lsint ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_ldouble'                         *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "ldouble") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_double::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_ldouble::message_messageGalgasType (void) const {
  return "a 'ldouble' type" ;
}

const char * cPtr_typeGalgas_ldouble::static_string_message_messageGalgasType (void) {
  return "a 'ldouble' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_ldouble'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_ldouble * GGS_typeGalgas_ldouble::
    constructor_new () {
    cPtr_typeGalgas_ldouble * ptr_ = (cPtr_typeGalgas_ldouble *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_ldouble ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgas_stringset'                        *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "stringset") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
methode_handleAddAssignOperatorCall (C_Lexique & lexique_var_,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList,
                                GGS_bool& var_cas_outAccept_uint_assignment) {
  var_cas_outParametersList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
  GGS_AC_galgasType  var_cas_t ;
  var_cas_t = GGS_typeGalgas_string::constructor_new () ;
  var_cas_outParametersList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
  var_cas_outAccept_uint_assignment = GGS_bool (true, true) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
methode_acceptForeachInstruction (C_Lexique & lexique_var_,
                                GGS_lstring  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle) {
  GGS_AC_galgasType  var_cas_keyType ;
  var_cas_keyType = GGS_typeGalgas_string::constructor_new () ;
  var_cas_outForeachList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
  var_cas_outForeachList.addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (GGS_string (true, "mKey"), GGS_location (lexique_var_))) ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle () ;
}


const char * cPtr_typeGalgas_stringset::message_messageGalgasType (void) const {
  return "a 'stringset' type" ;
}

const char * cPtr_typeGalgas_stringset::static_string_message_messageGalgasType (void) {
  return "a 'stringset' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgas_stringset'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_stringset * GGS_typeGalgas_stringset::
    constructor_new () {
    cPtr_typeGalgas_stringset * ptr_ = (cPtr_typeGalgas_stringset *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_stringset ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map element 'e_typeTableMethodes'                   *
//                                                                           *
//---------------------------------------------------------------------------*

template class cClassMethodsMap <e_typeTableMethodes> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         Map 'typeTableMethodes'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::constructor_empty (void) {
  GGS_typeTableMethodes t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0) {
  GGS_typeTableMethodes::element_type * info = searchKey (inLexique, inKey, inKey, "there is no reader named '%'") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.aListeTypesParametres ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_L_signature   & outParameter0) {
  GGS_typeTableMethodes::element_type * info = searchKey (inLexique, inKey, inKey, "there is no reader named '%'") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.aListeTypesParametres ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_searchForOverride (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0) {
  GGS_typeTableMethodes::element_type * info = searchForOverride (inLexique, inKey, inKey, "the reader '%' cannot be overriden : it is not declared in superclass") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.aListeTypesParametres ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_searchForOverrideGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_L_signature   & outParameter0) {
  GGS_typeTableMethodes::element_type * info = searchForOverride (inLexique, inKey, inKey, "the reader '%' cannot be overriden : it is not declared in superclass") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.aListeTypesParametres ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_insertAbstract (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0) {
  e_typeTableMethodes info ;
  info.aListeTypesParametres = inParameter0 ;
  insertAbstract (lexique_var_, info, inKey, inKey, "a reader named '%' is already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_insertAbstractGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_signature &  inParameter0) {
  e_typeTableMethodes info ;
  info.aListeTypesParametres = inParameter0 ;
  const sint32 index = insertAbstract (lexique_var_, info, inKey, inKey, "a reader named '%' is already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_insertNotAbstract (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0) {
  e_typeTableMethodes info ;
  info.aListeTypesParametres = inParameter0 ;
  insertNotAbstract (lexique_var_, info, inKey, inKey, "a reader named '%' is already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::methode_insertNotAbstractGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_signature &  inParameter0) {
  e_typeTableMethodes info ;
  info.aListeTypesParametres = inParameter0 ;
  const sint32 index = insertNotAbstract (lexique_var_, info, inKey, inKey, "a reader named '%' is already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeGalgasUndefinedExternType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedExternType::cPtr_typeGalgasUndefinedExternType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1)
:mGalgasClassName (argument_0),
mCppClassName (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedExternType::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mGalgasClassName.reader_value () ;
}


const char * cPtr_typeGalgasUndefinedExternType::message_messageGalgasType (void) const {
  return "an undefined extern type" ;
}

const char * cPtr_typeGalgasUndefinedExternType::static_string_message_messageGalgasType (void) {
  return "an undefined extern type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedExternType'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasUndefinedExternType * GGS_typeGalgasUndefinedExternType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
    cPtr_typeGalgasUndefinedExternType * ptr_ = (cPtr_typeGalgasUndefinedExternType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedExternType (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_externTypeConstructorMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_externTypeConstructorMap::
elementOf_GGS_M_externTypeConstructorMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_externTypeConstructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_externTypeConstructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_externTypeConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_externTypeConstructorMap * info = (e_M_externTypeConstructorMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::constructor_empty (void) {
  GGS_M_externTypeConstructorMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeListeAttributsSemantiques &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_externTypeConstructorMap info  ;
    info.aListeDesAttributs = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDesAttributs ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0) {
  searchElement (inLexique,
                 "the '%K' constructor is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0) {
  insertElement (lexique_var_,
                 "the '%K' constructor is already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgasExternType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasExternType::cPtr_typeGalgasExternType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_M_externTypeConstructorMap & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodes & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_typeListeAttributsSemantiques & argument_6)
:cPtr_typeGalgasUndefinedExternType (argument_0, argument_1),
mConstructorMap (argument_2),
mModifiersMap (argument_3),
mReadersInInstructionMap (argument_4),
mAcceptAddAssignOperatorCall (argument_5),
mAddAssignOperatorCallTypeList (argument_6) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  GGS_M_externTypeConstructorMap  var_cas_constructorMap ;
  var_cas_constructorMap = mConstructorMap ;
  var_cas_constructorMap.methode_searchKey (lexique_var_, var_cas_inClassMethodName, var_cas_outAccessorTypesList) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
methode_handleModifierCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_signature & var_cas_outModifierSignature) {
  GGS_typeTableMethodes  var_cas_methodMap ;
  var_cas_methodMap = mModifiersMap ;
  var_cas_methodMap.methode_searchKey (lexique_var_, var_cas_inModifierName, var_cas_outModifierSignature) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
methode_handleReaderInstructionCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_signature & var_cas_outReaderSignature) {
  GGS_typeTableMethodes  var_cas_methodMap ;
  var_cas_methodMap = mReadersInInstructionMap ;
  var_cas_methodMap.methode_searchKey (lexique_var_, var_cas_inReaderName, var_cas_outReaderSignature) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
methode_handleAddAssignOperatorCall (C_Lexique & lexique_var_,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList,
                                GGS_bool& var_cas_outAccept_uint_assignment) {
  if (((! mAcceptAddAssignOperatorCall)).isBuiltAndTrue ()) {
    inherited::methode_handleAddAssignOperatorCall (lexique_var_, var_cas_inErrorLocation, var_cas_outParametersList, var_cas_outAccept_uint_assignment) ;
  }else{
    var_cas_outParametersList = mAddAssignOperatorCallTypeList ;
    var_cas_outAccept_uint_assignment = GGS_bool (true, false) ;
  }
}


const char * cPtr_typeGalgasExternType::message_messageGalgasType (void) const {
  return "an extern type" ;
}

const char * cPtr_typeGalgasExternType::static_string_message_messageGalgasType (void) {
  return "an extern type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgasExternType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasExternType * GGS_typeGalgasExternType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_M_externTypeConstructorMap & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodes & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_typeListeAttributsSemantiques & argument_6) {
    cPtr_typeGalgasExternType * ptr_ = (cPtr_typeGalgasExternType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasExternType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_terminalSymbolsMapForUse'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_terminalSymbolsMapForUse::
elementOf_GGS_M_terminalSymbolsMapForUse (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_terminalSymbolsMapForUse & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_terminalSymbolsMapForUse::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_terminalSymbolsMapForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_terminalSymbolsMapForUse * info = (e_M_terminalSymbolsMapForUse *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::constructor_empty (void) {
  GGS_M_terminalSymbolsMapForUse result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeListeAttributsSemantiques &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_terminalSymbolsMapForUse info  ;
    info.aListeDesAttributs = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDesAttributs ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0) {
  searchElement (inLexique,
                 "the terminal symbol '$%K$' is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0) {
  insertElement (lexique_var_,
                 "the terminal symbol '$%K$' is already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'M_lexiqueComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_lexiqueComponents::
elementOf_GGS_M_lexiqueComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_lexiqueComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_lexiqueComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_lexiqueComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_lexiqueComponents * info = (e_M_lexiqueComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::constructor_empty (void) {
  GGS_M_lexiqueComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_terminalSymbolsMapForUse &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_lexiqueComponents info  ;
    info.mTerminalSymbolMap = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_terminalSymbolsMapForUse   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mTerminalSymbolMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_terminalSymbolsMapForUse   & outParameter0) {
  searchElement (inLexique,
                 "the '%K' lexique is not defined",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_M_terminalSymbolsMapForUse & inParameter0) {
  insertElement (lexique_var_,
                 "the '%K' lexique is already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'typeTableEnAvant'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableEnAvant::
elementOf_GGS_typeTableEnAvant (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableEnAvant & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableEnAvant::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableEnAvant *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableEnAvant * info = (e_typeTableEnAvant *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::constructor_empty (void) {
  GGS_typeTableEnAvant result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_galgasType &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableEnAvant info  ;
    info.mType = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0) {
  searchElement (inLexique,
                 "the type '%K' is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0) {
  insertElement (lexique_var_,
                 "the type '%K' is already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map 'M_nonterminalSymbolAlts'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonterminalSymbolAlts::
elementOf_GGS_M_nonterminalSymbolAlts (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonterminalSymbolAlts & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonterminalSymbolAlts::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonterminalSymbolAlts *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonterminalSymbolAlts * info = (e_M_nonterminalSymbolAlts *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::constructor_empty (void) {
  GGS_M_nonterminalSymbolAlts result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_nonterminalSymbolAlts info  ;
    info.mFormalParametersList = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalParametersList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0) {
  searchElement (inLexique,
                 "the label '%K' is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0) {
  insertElement (lexique_var_,
                 "the label '%K' has been already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_externClassesDirectories'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_externClassesDirectories::
elementOf_GGS_M_externClassesDirectories (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_externClassesDirectories & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_externClassesDirectories::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_externClassesDirectories *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_externClassesDirectories * info = (e_M_externClassesDirectories *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_externClassesDirectories GGS_M_externClassesDirectories::constructor_empty (void) {
  GGS_M_externClassesDirectories result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_externClassesDirectories::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externClassesDirectories::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_externClassesDirectories info  ;
    info.mDirectory = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externClassesDirectories::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mDirectory ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externClassesDirectories::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0) {
  searchElement (inLexique,
                 "the extern class '%K' is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externClassesDirectories::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0) {
  insertElement (lexique_var_,
                 "the extern class '%K' has been already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_AC_semanticsEntity'                  *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity
::static_string_message_messageTypeEntite (void) {
  return "any entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity::
message_messageTypeEntite (void) const {
  return "any entity" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_AC_semanticsEntity'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (void) {
  mPointer = (cPtr_AC_semanticsEntity *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (const GGS_AC_semanticsEntity & inOperand) {
  mPointer = (cPtr_AC_semanticsEntity *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
~GGS_AC_semanticsEntity (void) {
  macroDetachPointer (mPointer, cPtr_AC_semanticsEntity) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_semanticsEntity::
operator = (const GGS_AC_semanticsEntity & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_semanticsEntity::
operator = (cPtr_AC_semanticsEntity * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (cPtr_AC_semanticsEntity * inSource) {
  mPointer = (cPtr_AC_semanticsEntity *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_AC_semanticsEntity * GGS_AC_semanticsEntity
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_AC_semanticsEntity::reader_messageTypeEntite (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageTypeEntite ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_semanticsEntity
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_semanticsEntity) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_grammarForSemantics'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarForSemantics::cPtr_C_grammarForSemantics (const GGS_M_nonterminalSymbolAlts & argument_0)
:mGrammarAltMap (argument_0) {
}


const char * cPtr_C_grammarForSemantics::message_messageTypeEntite (void) const {
  return "a grammar entity" ;
}

const char * cPtr_C_grammarForSemantics::static_string_message_messageTypeEntite (void) {
  return "a grammar entity" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarForSemantics'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_grammarForSemantics * GGS_C_grammarForSemantics::
    constructor_new (const GGS_M_nonterminalSymbolAlts & argument_0) {
    cPtr_C_grammarForSemantics * ptr_ = (cPtr_C_grammarForSemantics *) NULL ;
    macroMyNew (ptr_, cPtr_C_grammarForSemantics (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_semanticsEntitiesForUse'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_semanticsEntitiesForUse::
elementOf_GGS_M_semanticsEntitiesForUse (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_semanticsEntitiesForUse & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_semanticsEntitiesForUse::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_semanticsEntitiesForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_semanticsEntitiesForUse * info = (e_M_semanticsEntitiesForUse *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::constructor_empty (void) {
  GGS_M_semanticsEntitiesForUse result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_semanticsEntity &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_semanticsEntitiesForUse info  ;
    info.aDefEntite = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_semanticsEntity   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aDefEntite ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_semanticsEntity   & outParameter0) {
  searchElement (inLexique,
                 "there is no semantics entity named '%K'",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_semanticsEntity & inParameter0) {
  insertElement (lexique_var_,
                 "a semantics entity named '%K' is already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_AC_typeForGrammarComponent'              *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent
::static_string_message_typeForGrammarComponentMessage (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent::
message_typeForGrammarComponentMessage (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_AC_typeForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (void) {
  mPointer = (cPtr_AC_typeForGrammarComponent *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (const GGS_AC_typeForGrammarComponent & inOperand) {
  mPointer = (cPtr_AC_typeForGrammarComponent *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
~GGS_AC_typeForGrammarComponent (void) {
  macroDetachPointer (mPointer, cPtr_AC_typeForGrammarComponent) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_typeForGrammarComponent::
operator = (const GGS_AC_typeForGrammarComponent & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_typeForGrammarComponent::
operator = (cPtr_AC_typeForGrammarComponent * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (cPtr_AC_typeForGrammarComponent * inSource) {
  mPointer = (cPtr_AC_typeForGrammarComponent *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_AC_typeForGrammarComponent * GGS_AC_typeForGrammarComponent
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_AC_typeForGrammarComponent::reader_typeForGrammarComponentMessage (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_typeForGrammarComponentMessage ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_typeForGrammarComponent
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_typeForGrammarComponent) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_typesForGrammarComponent'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_typesForGrammarComponent::
elementOf_GGS_M_typesForGrammarComponent (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_typesForGrammarComponent & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_typesForGrammarComponent::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_typesForGrammarComponent *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_typesForGrammarComponent * info = (e_M_typesForGrammarComponent *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::constructor_empty (void) {
  GGS_M_typesForGrammarComponent result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_typeForGrammarComponent &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_typesForGrammarComponent info  ;
    info.mType = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_typeForGrammarComponent   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_typeForGrammarComponent   & outParameter0) {
  searchElement (inLexique,
                 "the '@%K' type is not defined",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_typeForGrammarComponent & inParameter0) {
  insertElement (lexique_var_,
                 "the '@%K' type is already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@L_signature_ForGrammarComponent'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_signature_ForGrammarComponent::
elementOf_GGS_L_signature_ForGrammarComponent (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (elementOf_GGS_L_signature_ForGrammarComponent *) NULL ;
  mFormalArgumentPassingMode = argument_0 ;
  mGalgasTypeName = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@L_signature_ForGrammarComponent'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_signature_ForGrammarComponent
::GGS_L_signature_ForGrammarComponent (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_signature_ForGrammarComponent::~GGS_L_signature_ForGrammarComponent (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_signature_ForGrammarComponent::GGS_L_signature_ForGrammarComponent (const GGS_L_signature_ForGrammarComponent & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature_ForGrammarComponent
::operator = (const GGS_L_signature_ForGrammarComponent & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature_ForGrammarComponent
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature_ForGrammarComponent::
internalAppendItem (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature_ForGrammarComponent::
addAssign_operation (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature_ForGrammarComponent
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mFormalArgumentPassingMode,
                                p->mGalgasTypeName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_signature_ForGrammarComponent  GGS_L_signature_ForGrammarComponent::
constructor_empty (void) {
  GGS_L_signature_ForGrammarComponent result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature_ForGrammarComponent
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "checkSignature_ForGrammarComponent"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkSignature_ForGrammarComponent (C_Lexique & lexique_var_,
                                const GGS_L_signature_ForGrammarComponent  & var_cas_inFormalReferenceSignature,
                                const GGS_L_signature_ForGrammarComponent  & var_cas_inFormalTestedSignature,
                                const GGS_location  & var_cas_inEndOfListLocation) {
  if (((var_cas_inFormalReferenceSignature.reader_length ()) < (var_cas_inFormalTestedSignature.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inEndOfListLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "too much formal parameters")) ;
  }else if (((var_cas_inFormalReferenceSignature.reader_length ()) > (var_cas_inFormalTestedSignature.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inEndOfListLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "one or more formal parameters missing")) ;
  }else{
    GGS_L_signature_ForGrammarComponent::element_type * operand_36597 = var_cas_inFormalReferenceSignature.firstObject () ;
    GGS_L_signature_ForGrammarComponent::element_type * operand_36696 = var_cas_inFormalTestedSignature.firstObject () ;
    while ((operand_36597 != NULL)
        && (operand_36696 != NULL)) {
      macroValidPointer (operand_36597) ;
      macroValidPointer (operand_36696) ;
      if (((operand_36597->mFormalArgumentPassingMode) != (operand_36696->mFormalArgumentPassingMode)).isBuiltAndTrue ()) {
          operand_36696->mGalgasTypeName.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "Prototype has ")) + (operand_36597->mFormalArgumentPassingMode.reader_formalArgumentMessage ()))) + (GGS_string (true, ", and ")))) + (operand_36597->mFormalArgumentPassingMode.reader_formalArgumentMessage ()))) + (GGS_string (true, " has been found")))) ;
      }
      if (((operand_36597->mGalgasTypeName.reader_value ()) != (operand_36696->mGalgasTypeName.reader_value ())).isBuiltAndTrue ()) {
          operand_36696->mGalgasTypeName.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting the '@")) + (operand_36597->mGalgasTypeName.reader_value ()))) + (GGS_string (true, "' type, I have got the '@")))) + (operand_36696->mGalgasTypeName.reader_value ()))) + (GGS_string (true, "' type")))) ;
      }
      operand_36597 = operand_36597->nextObject () ;
      operand_36696 = operand_36696->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_AC_instruction_ForGrammar'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_instruction_ForGrammar::
cPtr_AC_instruction_ForGrammar (const GGS_location & argument_0)
:mStartLocation (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_AC_instruction_ForGrammar'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (void) {
  mPointer = (cPtr_AC_instruction_ForGrammar *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (const GGS_AC_instruction_ForGrammar & inOperand) {
  mPointer = (cPtr_AC_instruction_ForGrammar *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
~GGS_AC_instruction_ForGrammar (void) {
  macroDetachPointer (mPointer, cPtr_AC_instruction_ForGrammar) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_instruction_ForGrammar::
operator = (const GGS_AC_instruction_ForGrammar & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_instruction_ForGrammar::
operator = (cPtr_AC_instruction_ForGrammar * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (cPtr_AC_instruction_ForGrammar * inSource) {
  mPointer = (cPtr_AC_instruction_ForGrammar *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_AC_instruction_ForGrammar * GGS_AC_instruction_ForGrammar
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_AC_instruction_ForGrammar
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_instruction_ForGrammar) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@L_ruleSyntaxSignature'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_ruleSyntaxSignature::
elementOf_GGS_L_ruleSyntaxSignature (const GGS_AC_instruction_ForGrammar & argument_0) {
  mNextItem = (elementOf_GGS_L_ruleSyntaxSignature *) NULL ;
  mInstruction = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@L_ruleSyntaxSignature'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature
::GGS_L_ruleSyntaxSignature (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::~GGS_L_ruleSyntaxSignature (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::GGS_L_ruleSyntaxSignature (const GGS_L_ruleSyntaxSignature & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature
::operator = (const GGS_L_ruleSyntaxSignature & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
internalAppendItem (const GGS_AC_instruction_ForGrammar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
addAssign_operation (const GGS_AC_instruction_ForGrammar & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mInstruction) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature  GGS_L_ruleSyntaxSignature::
constructor_empty (void) {
  GGS_L_ruleSyntaxSignature result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'L_grammarsMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_grammarsMap::
elementOf_GGS_L_grammarsMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_L_grammarsMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_L_grammarsMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_L_grammarsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_L_grammarsMap * info = (e_L_grammarsMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::constructor_empty (void) {
  GGS_L_grammarsMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAlts &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_L_grammarsMap info  ;
    info.mStartSymbolParametersMap = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAlts   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mStartSymbolParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   & outParameter0) {
  searchElement (inLexique,
                 "the '%K' grammar is not defined",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts & inParameter0) {
  insertElement (lexique_var_,
                 "the '%K' grammar is already defined",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class map 'M_nonterminalSymbolAltsForGrammar'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonterminalSymbolAltsForGrammar::
elementOf_GGS_M_nonterminalSymbolAltsForGrammar (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonterminalSymbolAltsForGrammar & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonterminalSymbolAltsForGrammar::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonterminalSymbolAltsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonterminalSymbolAltsForGrammar * info = (e_M_nonterminalSymbolAltsForGrammar *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAltsForGrammar GGS_M_nonterminalSymbolAltsForGrammar::constructor_empty (void) {
  GGS_M_nonterminalSymbolAltsForGrammar result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_signature_ForGrammarComponent &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_nonterminalSymbolAltsForGrammar info  ;
    info.mFormalParametersList = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature_ForGrammarComponent   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalParametersList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature_ForGrammarComponent   & outParameter0) {
  searchElement (inLexique,
                 "the rule label '%K' is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_signature_ForGrammarComponent & inParameter0) {
  insertElement (lexique_var_,
                 "the rule label '%K' has been already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@L_productionRules_ForGrammarComponent'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_productionRules_ForGrammarComponent::
elementOf_GGS_L_productionRules_ForGrammarComponent (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) {
  mNextItem = (elementOf_GGS_L_productionRules_ForGrammarComponent *) NULL ;
  mLeftNonterminalSymbol = argument_0 ;
  mLeftNonterminalSymbolIndex = argument_1 ;
  mInstructionsList = argument_2 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@L_productionRules_ForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent
::GGS_L_productionRules_ForGrammarComponent (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::~GGS_L_productionRules_ForGrammarComponent (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::GGS_L_productionRules_ForGrammarComponent (const GGS_L_productionRules_ForGrammarComponent & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent
::operator = (const GGS_L_productionRules_ForGrammarComponent & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mLeftNonterminalSymbol,
                                p->mLeftNonterminalSymbolIndex,
                                p->mInstructionsList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent  GGS_L_productionRules_ForGrammarComponent::
constructor_empty (void) {
  GGS_L_productionRules_ForGrammarComponent result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'M_nonTerminalSymbolsForGrammar'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonTerminalSymbolsForGrammar::
elementOf_GGS_M_nonTerminalSymbolsForGrammar (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonTerminalSymbolsForGrammar & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonTerminalSymbolsForGrammar::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonTerminalSymbolsForGrammar * info = (e_M_nonTerminalSymbolsForGrammar *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolsForGrammar GGS_M_nonTerminalSymbolsForGrammar::constructor_empty (void) {
  GGS_M_nonTerminalSymbolsForGrammar result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAltsForGrammar &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_nonTerminalSymbolsForGrammar info  ;
    info.mNonterminalSymbolParametersMap = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0) {
  searchElement (inLexique,
                 "internal search error",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0) {
  searchElement (inLexique,
                 "internal search error",
                 inKey,
                 outParameter0,
                 & outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0) {
  insertElement (lexique_var_,
                 "internal insert error",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'M_syntaxComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_syntaxComponents::
elementOf_GGS_M_syntaxComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_syntaxComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_syntaxComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_syntaxComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_syntaxComponents * info = (e_M_syntaxComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::constructor_empty (void) {
  GGS_M_syntaxComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonTerminalSymbolsForGrammar &  inParameter0,
               const GGS_L_productionRules_ForGrammarComponent &  inParameter1,
               const GGS_lstring &  inParameter2,
               const GGS_stringset &  inParameter3,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_syntaxComponents info  ;
    info.mNonterminalSymbolsMap = inParameter0 ;
    info.mProductionRulesList = inParameter1 ;
    info.mLexiqueComponentName = inParameter2 ;
    info.mClassesNamesSet = inParameter3 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonTerminalSymbolsForGrammar   & outParameter0,
               GGS_L_productionRules_ForGrammarComponent   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_stringset   & outParameter3,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolsMap ;
    outParameter1 = node->mInfo.mProductionRulesList ;
    outParameter2 = node->mInfo.mLexiqueComponentName ;
    outParameter3 = node->mInfo.mClassesNamesSet ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonTerminalSymbolsForGrammar   & outParameter0,
                                GGS_L_productionRules_ForGrammarComponent   & outParameter1,
                                GGS_lstring   & outParameter2,
                                GGS_stringset   & outParameter3) {
  searchElement (inLexique,
                 "there is no syntax component named '%K'",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_M_nonTerminalSymbolsForGrammar & inParameter0,
                                const GGS_L_productionRules_ForGrammarComponent & inParameter1,
                                const GGS_lstring & inParameter2,
                                const GGS_stringset & inParameter3) {
  insertElement (lexique_var_,
                 "a syntax component named '%K' is already declared",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'T_terminalInstruction_forGrammarComponent'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_terminalInstruction_forGrammarComponent::cPtr_T_terminalInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2)
:cPtr_AC_instruction_ForGrammar (argument_0),
mTerminalSymbolName (argument_1),
mTerminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_T_terminalInstruction_forGrammarComponent'        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_T_terminalInstruction_forGrammarComponent * GGS_T_terminalInstruction_forGrammarComponent::
    constructor_new (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2) {
    cPtr_T_terminalInstruction_forGrammarComponent * ptr_ = (cPtr_T_terminalInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_terminalInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'T_nonterminalInstruction_forGrammarComponent'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_nonterminalInstruction_forGrammarComponent::cPtr_T_nonterminalInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2)
:cPtr_AC_instruction_ForGrammar (argument_0),
mNonterminalSymbolName (argument_1),
mNonterminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_T_nonterminalInstruction_forGrammarComponent'       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_T_nonterminalInstruction_forGrammarComponent * GGS_T_nonterminalInstruction_forGrammarComponent::
    constructor_new (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2) {
    cPtr_T_nonterminalInstruction_forGrammarComponent * ptr_ = (cPtr_T_nonterminalInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_nonterminalInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@L_branchList_ForGrammarComponent'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_branchList_ForGrammarComponent::
elementOf_GGS_L_branchList_ForGrammarComponent (const GGS_L_ruleSyntaxSignature & argument_0) {
  mNextItem = (elementOf_GGS_L_branchList_ForGrammarComponent *) NULL ;
  mInstructionsList = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@L_branchList_ForGrammarComponent'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent
::GGS_L_branchList_ForGrammarComponent (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::~GGS_L_branchList_ForGrammarComponent (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::GGS_L_branchList_ForGrammarComponent (const GGS_L_branchList_ForGrammarComponent & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent
::operator = (const GGS_L_branchList_ForGrammarComponent & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
internalAppendItem (const GGS_L_ruleSyntaxSignature & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
addAssign_operation (const GGS_L_ruleSyntaxSignature & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mInstructionsList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent  GGS_L_branchList_ForGrammarComponent::
constructor_empty (void) {
  GGS_L_branchList_ForGrammarComponent result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'T_selectInstruction_forGrammarComponent'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_selectInstruction_forGrammarComponent::cPtr_T_selectInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2)
:cPtr_AC_instruction_ForGrammar (argument_0),
mSelectList (argument_1),
mAddedNonterminalmSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_T_selectInstruction_forGrammarComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_T_selectInstruction_forGrammarComponent * GGS_T_selectInstruction_forGrammarComponent::
    constructor_new (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2) {
    cPtr_T_selectInstruction_forGrammarComponent * ptr_ = (cPtr_T_selectInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_selectInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'T_repeatInstruction_forGrammarComponent'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_repeatInstruction_forGrammarComponent::cPtr_T_repeatInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2)
:cPtr_AC_instruction_ForGrammar (argument_0),
mRepeatList (argument_1),
mAddedNonterminalmSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_T_repeatInstruction_forGrammarComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_T_repeatInstruction_forGrammarComponent * GGS_T_repeatInstruction_forGrammarComponent::
    constructor_new (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2) {
    cPtr_T_repeatInstruction_forGrammarComponent * ptr_ = (cPtr_T_repeatInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_repeatInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_syntaxComponents_ForGrammar'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_syntaxComponents_ForGrammar::
elementOf_GGS_L_syntaxComponents_ForGrammar (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_stringset & argument_2,
                                const GGS_lstring & argument_3) {
  mNextItem = (elementOf_GGS_L_syntaxComponents_ForGrammar *) NULL ;
  mNonterminalSymbolsMap = argument_0 ;
  mProductionRulesList = argument_1 ;
  mClassesNamesSet = argument_2 ;
  mSyntaxComponentName = argument_3 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_syntaxComponents_ForGrammar'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar
::GGS_L_syntaxComponents_ForGrammar (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::~GGS_L_syntaxComponents_ForGrammar (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::GGS_L_syntaxComponents_ForGrammar (const GGS_L_syntaxComponents_ForGrammar & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar
::operator = (const GGS_L_syntaxComponents_ForGrammar & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
internalAppendItem (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_stringset & argument_2,
                                const GGS_lstring & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
addAssign_operation (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_stringset & argument_2,
                                const GGS_lstring & argument_3) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mNonterminalSymbolsMap,
                                p->mProductionRulesList,
                                p->mClassesNamesSet,
                                p->mSyntaxComponentName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar  GGS_L_syntaxComponents_ForGrammar::
constructor_empty (void) {
  GGS_L_syntaxComponents_ForGrammar result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_identifiers'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_identifiers::
elementOf_GGS_L_identifiers (const GGS_lstring & argument_0) {
  mNextItem = (elementOf_GGS_L_identifiers *) NULL ;
  aIdentificateur = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_identifiers'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_identifiers
::GGS_L_identifiers (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_identifiers::~GGS_L_identifiers (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_identifiers::GGS_L_identifiers (const GGS_L_identifiers & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers
::operator = (const GGS_L_identifiers & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aIdentificateur) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_identifiers  GGS_L_identifiers::
constructor_empty (void) {
  GGS_L_identifiers result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'typeSuperClassesMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSuperClassesMap::
elementOf_GGS_typeSuperClassesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeSuperClassesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeSuperClassesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeSuperClassesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeSuperClassesMap * info = (e_typeSuperClassesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::constructor_empty (void) {
  GGS_typeSuperClassesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeSuperClassesMap info  ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey) {
  insertElement (lexique_var_,
                 "the class '%K' is already a super class of the current class",
                 inKey,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeClassInheritedMessagesMap'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeClassInheritedMessagesMap::
elementOf_GGS_typeClassInheritedMessagesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeClassInheritedMessagesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassInheritedMessagesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeClassInheritedMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeClassInheritedMessagesMap * info = (e_typeClassInheritedMessagesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::constructor_empty (void) {
  GGS_typeClassInheritedMessagesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeClassInheritedMessagesMap info  ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey) {
  searchElement (inLexique,
                 "the message '%K' is not declared",
                 inKey,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey) {
  insertElement (lexique_var_,
                 "the message '%K' is already declared",
                 inKey,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'typeSemanticAttributesMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSemanticAttributesMap::
elementOf_GGS_typeSemanticAttributesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeSemanticAttributesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeSemanticAttributesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeSemanticAttributesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeSemanticAttributesMap * info = (e_typeSemanticAttributesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::constructor_empty (void) {
  GGS_typeSemanticAttributesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_galgasType &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeSemanticAttributesMap info  ;
    info.mAttributType = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0) {
  searchElement (inLexique,
                 "there is no attribut named '%K'",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0) {
  insertElement (lexique_var_,
                 "an attribut named '%K' is already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class for enumeration 'lastStateEnum'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_lastStateEnum::
operator == (const GGS_lastStateEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lastStateEnum::
operator != (const GGS_lastStateEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lastStateEnum::
operator <= (const GGS_lastStateEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lastStateEnum::
operator >= (const GGS_lastStateEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lastStateEnum::
operator < (const GGS_lastStateEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lastStateEnum::
operator > (const GGS_lastStateEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@lastStateList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lastStateList::
elementOf_GGS_lastStateList (const GGS_lstring & argument_0,
                                const GGS_lastStateEnum& argument_1,
                                const GGS_L_stringList & argument_2) {
  mNextItem = (elementOf_GGS_lastStateList *) NULL ;
  mLastState = argument_0 ;
  mStatus = argument_1 ;
  mMessageList = argument_2 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@lastStateList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lastStateList
::GGS_lastStateList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_lastStateList::~GGS_lastStateList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_lastStateList::GGS_lastStateList (const GGS_lastStateList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_lastStateList
::operator = (const GGS_lastStateList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lastStateList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lastStateList::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lastStateEnum& argument_1,
                                const GGS_L_stringList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lastStateList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lastStateEnum& argument_1,
                                const GGS_L_stringList & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lastStateList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mLastState,
                                p->mStatus,
                                p->mMessageList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lastStateList  GGS_lastStateList::
constructor_empty (void) {
  GGS_lastStateList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lastStateList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'transitionStatusMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_transitionStatusMap::
elementOf_GGS_transitionStatusMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_transitionStatusMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_transitionStatusMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_transitionStatusMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_transitionStatusMap * info = (e_transitionStatusMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_transitionStatusMap GGS_transitionStatusMap::constructor_empty (void) {
  GGS_transitionStatusMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_transitionStatusMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_transitionStatusMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lastStateEnum&  inParameter0,
               const GGS_L_stringList &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_transitionStatusMap info  ;
    info.mStatus = inParameter0 ;
    info.mMessageList = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_transitionStatusMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lastStateEnum  & outParameter0,
               GGS_L_stringList   & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mStatus ;
    outParameter1 = node->mInfo.mMessageList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_transitionStatusMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_lastStateEnum& inParameter0,
                                const GGS_L_stringList & inParameter1) {
  insertElement (lexique_var_,
                 "a transition named '%K' is already declared",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@insertOrSearchMethodList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_insertOrSearchMethodList::
elementOf_GGS_insertOrSearchMethodList (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_lastStateList & argument_3,
                                const GGS_transitionStatusMap & argument_4,
                                const GGS_bool& argument_5) {
  mNextItem = (elementOf_GGS_insertOrSearchMethodList *) NULL ;
  mMethodName = argument_0 ;
  mErrorMessage = argument_1 ;
  mFirstState = argument_2 ;
  mLastStateList = argument_3 ;
  mTransitionStatusMap = argument_4 ;
  mIsGetIndexMethod = argument_5 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@insertOrSearchMethodList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList
::GGS_insertOrSearchMethodList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList::~GGS_insertOrSearchMethodList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList::GGS_insertOrSearchMethodList (const GGS_insertOrSearchMethodList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList
::operator = (const GGS_insertOrSearchMethodList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_lastStateList & argument_3,
                                const GGS_transitionStatusMap & argument_4,
                                const GGS_bool& argument_5) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_lastStateList & argument_3,
                                const GGS_transitionStatusMap & argument_4,
                                const GGS_bool& argument_5) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mMethodName,
                                p->mErrorMessage,
                                p->mFirstState,
                                p->mLastStateList,
                                p->mTransitionStatusMap,
                                p->mIsGetIndexMethod) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_insertOrSearchMethodList::
constructor_empty (void) {
  GGS_insertOrSearchMethodList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeDefEntiteUtilisable'                *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable
::static_string_message_messageTypeEntite (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable::
message_messageTypeEntite (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeDefEntiteUtilisable'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (void) {
  mPointer = (cPtr_typeDefEntiteUtilisable *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (const GGS_typeDefEntiteUtilisable & inOperand) {
  mPointer = (cPtr_typeDefEntiteUtilisable *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
~GGS_typeDefEntiteUtilisable (void) {
  macroDetachPointer (mPointer, cPtr_typeDefEntiteUtilisable) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefEntiteUtilisable::
operator = (const GGS_typeDefEntiteUtilisable & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefEntiteUtilisable::
operator = (cPtr_typeDefEntiteUtilisable * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (cPtr_typeDefEntiteUtilisable * inSource) {
  mPointer = (cPtr_typeDefEntiteUtilisable *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDefEntiteUtilisable * GGS_typeDefEntiteUtilisable
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDefEntiteUtilisable::reader_messageTypeEntite (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageTypeEntite ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefEntiteUtilisable
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeDefEntiteUtilisable) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeGalgasUndefinedListType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedListType::cPtr_typeGalgasUndefinedListType (const GGS_lstring & argument_0)
:mListTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedListType::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mListTypeName.reader_value () ;
}


const char * cPtr_typeGalgasUndefinedListType::message_messageGalgasType (void) const {
  return "undefined 'list' type" ;
}

const char * cPtr_typeGalgasUndefinedListType::static_string_message_messageGalgasType (void) {
  return "undefined 'list' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedListType'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasUndefinedListType * GGS_typeGalgasUndefinedListType::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeGalgasUndefinedListType * ptr_ = (cPtr_typeGalgasUndefinedListType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedListType (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgasListType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasListType::cPtr_typeGalgasListType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1)
:cPtr_typeGalgasUndefinedListType (argument_0),
mNonExternAttributesList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
methode_acceptForeachInstruction (C_Lexique & /* lexique_var_ */,
                                GGS_lstring  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle) {
  var_cas_outForeachList = mNonExternAttributesList ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_listStyle () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
methode_handleAddAssignOperatorCall (C_Lexique & /* lexique_var_ */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList,
                                GGS_bool& var_cas_outAccept_uint_assignment) {
  var_cas_outParametersList = mNonExternAttributesList ;
  var_cas_outAccept_uint_assignment = GGS_bool (true, false) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}


const char * cPtr_typeGalgasListType::message_messageGalgasType (void) const {
  return "'list' type" ;
}

const char * cPtr_typeGalgasListType::static_string_message_messageGalgasType (void) {
  return "'list' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasListType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasListType * GGS_typeGalgasListType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1) {
    cPtr_typeGalgasListType * ptr_ = (cPtr_typeGalgasListType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasListType (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'typeTableBlocsDeTable'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableBlocsDeTable::
elementOf_GGS_typeTableBlocsDeTable (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableBlocsDeTable & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableBlocsDeTable::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableBlocsDeTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableBlocsDeTable * info = (e_typeTableBlocsDeTable *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::constructor_empty (void) {
  GGS_typeTableBlocsDeTable result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               const GGS_L_signature &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableBlocsDeTable info  ;
    info.aSignatureDebut = inParameter0 ;
    info.aSignatureFin = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_L_signature   & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aSignatureDebut ;
    outParameter1 = node->mInfo.aSignatureFin ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0,
                                GGS_L_signature   & outParameter1) {
  searchElement (inLexique,
                 "there is no block method named '%K'",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0,
                                const GGS_L_signature & inParameter1) {
  insertElement (lexique_var_,
                 "a block method named '%K' is already declared",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeGalgasUndefinedMapType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedMapType::cPtr_typeGalgasUndefinedMapType (const GGS_lstring & argument_0)
:mMapTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapType::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mMapTypeName.reader_value () ;
}


const char * cPtr_typeGalgasUndefinedMapType::message_messageGalgasType (void) const {
  return "undefined 'map' type" ;
}

const char * cPtr_typeGalgasUndefinedMapType::static_string_message_messageGalgasType (void) {
  return "undefined 'map' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedMapType'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasUndefinedMapType * GGS_typeGalgasUndefinedMapType::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeGalgasUndefinedMapType * ptr_ = (cPtr_typeGalgasUndefinedMapType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedMapType (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'mapMethodMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapMethodMap::
elementOf_GGS_mapMethodMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapMethodMap * info = (e_mapMethodMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::constructor_empty (void) {
  GGS_mapMethodMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_mapMethodMap info  ;
    info.mMethodSignature = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMethodSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0) {
  searchElement (inLexique,
                 "there is no insert nor search method named '%K'",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0) {
  insertElement (lexique_var_,
                 "an insert or a search method named '%K' is already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgasMapType'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasMapType::cPtr_typeGalgasMapType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableBlocsDeTable & argument_2,
                                const GGS_mapMethodMap & argument_3)
:cPtr_typeGalgasUndefinedMapType (argument_0),
mNonExternAttributesList (argument_1),
aTableMethodesSurcharger (argument_2),
mMethodMap (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
methode_handleModifierCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_signature & var_cas_outModifierSignature) {
  GGS_mapMethodMap  var_cas_methodMap ;
  var_cas_methodMap = mMethodMap ;
  var_cas_methodMap.methode_searchKey (lexique_var_, var_cas_inModifierName, var_cas_outModifierSignature) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
methode_acceptForeachInstruction (C_Lexique & lexique_var_,
                                GGS_lstring  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle) {
  GGS_AC_galgasType  var_cas_keyType ;
  var_cas_keyType = GGS_typeGalgas_lstring::constructor_new () ;
  var_cas_outForeachList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
  var_cas_outForeachList.addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (GGS_string (true, "\?\?\?"), GGS_location (lexique_var_))) ;
  GGS_typeListeAttributsSemantiques::element_type * operand_53832 = mNonExternAttributesList.firstObject () ;
  while ((operand_53832 != NULL)) {
    macroValidPointer (operand_53832) ;
    var_cas_outForeachList.addAssign_operation (operand_53832->mAttributType, operand_53832->aNomAttribut) ;
    operand_53832 = operand_53832->nextObject () ;
  }
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}


const char * cPtr_typeGalgasMapType::message_messageGalgasType (void) const {
  return "'map' type" ;
}

const char * cPtr_typeGalgasMapType::static_string_message_messageGalgasType (void) {
  return "'map' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgasMapType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasMapType * GGS_typeGalgasMapType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableBlocsDeTable & argument_2,
                                const GGS_mapMethodMap & argument_3) {
    cPtr_typeGalgasMapType * ptr_ = (cPtr_typeGalgasMapType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasMapType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeGalgasUndefinedClassType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedClassType::cPtr_typeGalgasUndefinedClassType (const GGS_lstring & argument_0)
:mClassTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedClassType::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mClassTypeName.reader_value () ;
}


const char * cPtr_typeGalgasUndefinedClassType::message_messageGalgasType (void) const {
  return "undefined 'class' type" ;
}

const char * cPtr_typeGalgasUndefinedClassType::static_string_message_messageGalgasType (void) {
  return "undefined 'class' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedClassType'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasUndefinedClassType * GGS_typeGalgasUndefinedClassType::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeGalgasUndefinedClassType * ptr_ = (cPtr_typeGalgasUndefinedClassType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedClassType (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgasClassType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasClassType::cPtr_typeGalgasClassType (const GGS_lstring & argument_0,
                                const GGS_typeTableMethodes & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeSuperClassesMap & argument_3,
                                const GGS_typeClassInheritedMessagesMap & argument_4,
                                const GGS_typeSemanticAttributesMap & argument_5,
                                const GGS_bool& argument_6)
:cPtr_typeGalgasUndefinedClassType (argument_0),
mMethodsMap (argument_1),
mNonExternAttributesList (argument_2),
mAncestorClassesMap (argument_3),
mMessagesMap (argument_4),
mNonExternAttributesMap (argument_5),
mClassIsAbstract (argument_6) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
methode_typeCanBeUsedInObjectDeclaration (C_Lexique & lexique_var_) {
  if (((! mClassIsAbstract)).isBuiltAndTrue ()) {
      GGS_location (lexique_var_).reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "non abstract class object cannot be declared (only instancied by 'new')")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
methode_handleReaderInstructionCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_L_signature & var_cas_outMethodSignature) {
  GGS_typeTableMethodes  var_cas_methodMap ;
  var_cas_methodMap = mMethodsMap ;
  var_cas_methodMap.methode_searchKey (lexique_var_, var_cas_inMethodName, var_cas_outMethodSignature) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if ((mClassIsAbstract).isBuiltAndTrue ()) {
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "an abstract class cannot be instancied")) ;
  }else if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = mNonExternAttributesList ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}


const char * cPtr_typeGalgasClassType::message_messageGalgasType (void) const {
  return "'class' type" ;
}

const char * cPtr_typeGalgasClassType::static_string_message_messageGalgasType (void) {
  return "'class' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasClassType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasClassType * GGS_typeGalgasClassType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeTableMethodes & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeSuperClassesMap & argument_3,
                                const GGS_typeClassInheritedMessagesMap & argument_4,
                                const GGS_typeSemanticAttributesMap & argument_5,
                                const GGS_bool& argument_6) {
    cPtr_typeGalgasClassType * ptr_ = (cPtr_typeGalgasClassType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasClassType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEntiteType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteType::cPtr_typeEntiteType (const GGS_AC_galgasType & argument_0)
:aDefType (argument_0) {
}


const char * cPtr_typeEntiteType::message_messageTypeEntite (void) const {
  return "a type" ;
}

const char * cPtr_typeEntiteType::static_string_message_messageTypeEntite (void) {
  return "a type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEntiteType * GGS_typeEntiteType::
    constructor_new (const GGS_AC_galgasType & argument_0) {
    cPtr_typeEntiteType * ptr_ = (cPtr_typeEntiteType *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteType (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeEntiteRoutine'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteRoutine::cPtr_typeEntiteRoutine (const GGS_L_signature & argument_0)
:aListeArgumentsFormels (argument_0) {
}


const char * cPtr_typeEntiteRoutine::message_messageTypeEntite (void) const {
  return "a routine" ;
}

const char * cPtr_typeEntiteRoutine::static_string_message_messageTypeEntite (void) {
  return "a routine" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeEntiteRoutine'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEntiteRoutine * GGS_typeEntiteRoutine::
    constructor_new (const GGS_L_signature & argument_0) {
    cPtr_typeEntiteRoutine * ptr_ = (cPtr_typeEntiteRoutine *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteRoutine (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               class map 'typeTableUtilisationsSemantiques'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableUtilisationsSemantiques::
elementOf_GGS_typeTableUtilisationsSemantiques (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableUtilisationsSemantiques & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableUtilisationsSemantiques::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableUtilisationsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableUtilisationsSemantiques * info = (e_typeTableUtilisationsSemantiques *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableUtilisationsSemantiques GGS_typeTableUtilisationsSemantiques::constructor_empty (void) {
  GGS_typeTableUtilisationsSemantiques result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableUtilisationsSemantiques::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableUtilisationsSemantiques::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableUtilisationsSemantiques info  ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableUtilisationsSemantiques::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableUtilisationsSemantiques::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey) {
  insertElement (lexique_var_,
                 "--- internal error ---",
                 inKey,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'typeEnumConstantesMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumConstantesMap::
elementOf_GGS_typeEnumConstantesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumConstantesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumConstantesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeEnumConstantesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumConstantesMap * info = (e_typeEnumConstantesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumConstantesMap GGS_typeEnumConstantesMap::constructor_empty (void) {
  GGS_typeEnumConstantesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumConstantesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumConstantesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeEnumConstantesMap info  ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumConstantesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumConstantesMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey) {
  searchElement (inLexique,
                 "the '%K' constant is not declared",
                 inKey,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumConstantesMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey) {
  insertElement (lexique_var_,
                 "the '%K' constant is already declared",
                 inKey,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'typeEnumMessageMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumMessageMap::
elementOf_GGS_typeEnumMessageMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeEnumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumMessageMap * info = (e_typeEnumMessageMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::constructor_empty (void) {
  GGS_typeEnumMessageMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_lstringList &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeEnumMessageMap info  ;
    info.mMessageStringList = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_lstringList   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessageStringList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_lstringList   & outParameter0) {
  searchElement (inLexique,
                 "the '%K' message name is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_lstringList & inParameter0) {
  insertElement (lexique_var_,
                 "the '%K' message name is already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_enum'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_enum::cPtr_typeGalgas_enum (const GGS_lstring & argument_0,
                                const GGS_typeEnumConstantesMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2)
:mEnumTypeName (argument_0),
mEnumConstantesMap (argument_1),
mMessagesMap (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
methode_getTypeName (C_Lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mEnumTypeName.reader_value () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
methode_handleConstructorCall (C_Lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  GGS_typeEnumConstantesMap  var_cas_enumConstantesMap ;
  var_cas_enumConstantesMap = mEnumConstantesMap ;
  var_cas_enumConstantesMap.methode_searchKey (lexique_var_, var_cas_inClassMethodName) ;
  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
}


const char * cPtr_typeGalgas_enum::message_messageGalgasType (void) const {
  return "a 'enum' type" ;
}

const char * cPtr_typeGalgas_enum::static_string_message_messageGalgasType (void) {
  return "a 'enum' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_enum'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_enum * GGS_typeGalgas_enum::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeEnumConstantesMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2) {
    cPtr_typeGalgas_enum * ptr_ = (cPtr_typeGalgas_enum *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_enum (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//    Implementation of routine "verifierCompatibiliteTypesSemantiques"      *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteTypesSemantiques (C_Lexique & lexique_var_,
                                const GGS_AC_galgasType  & var_cas_inFormalType,
                                const GGS_AC_galgasType  & var_cas_inEffectiveType,
                                const GGS_location  & var_cas_inErrorLocation) {
  if (var_cas_inFormalType.isBuilt () && var_cas_inEffectiveType.isBuilt ()) {
    cPtr_AC_galgasType * ptr_60358 = var_cas_inFormalType (HERE) ;
    cPtr_AC_galgasType * ptr_60377 = var_cas_inEffectiveType (HERE) ;
    cPtr_typeGalgas_stringset * operand_60358 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_60358) ;
    cPtr_typeGalgas_stringset * operand_60377 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_60377) ;
    if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
    }else{
      cPtr_typeGalgas_uint * operand_60358 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_60358) ;
      cPtr_typeGalgas_uint * operand_60377 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_60377) ;
      if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
      }else{
        cPtr_typeGalgas_sint * operand_60358 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_60358) ;
        cPtr_typeGalgas_sint * operand_60377 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_60377) ;
        if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
        }else{
          cPtr_typeGalgas_char * operand_60358 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_60358) ;
          cPtr_typeGalgas_char * operand_60377 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_60377) ;
          if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
          }else{
            cPtr_typeGalgas_string * operand_60358 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_60358) ;
            cPtr_typeGalgas_string * operand_60377 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_60377) ;
            if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
            }else{
              cPtr_typeGalgas_bool * operand_60358 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_60358) ;
              cPtr_typeGalgas_bool * operand_60377 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_60377) ;
              if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
              }else{
                cPtr_typeGalgas_double * operand_60358 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_60358) ;
                cPtr_typeGalgas_double * operand_60377 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_60377) ;
                if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
                }else{
                  cPtr_typeGalgas_lbool * operand_60358 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_60358) ;
                  cPtr_typeGalgas_lbool * operand_60377 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_60377) ;
                  if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
                  }else{
                    cPtr_typeGalgas_lchar * operand_60358 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_60358) ;
                    cPtr_typeGalgas_lchar * operand_60377 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_60377) ;
                    if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
                    }else{
                      cPtr_typeGalgas_luint * operand_60358 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_60358) ;
                      cPtr_typeGalgas_luint * operand_60377 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_60377) ;
                      if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
                      }else{
                        cPtr_typeGalgas_lsint * operand_60358 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_60358) ;
                        cPtr_typeGalgas_lsint * operand_60377 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_60377) ;
                        if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
                        }else{
                          cPtr_typeGalgas_ldouble * operand_60358 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_60358) ;
                          cPtr_typeGalgas_ldouble * operand_60377 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_60377) ;
                          if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
                          }else{
                            cPtr_typeGalgas_lstring * operand_60358 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_60358) ;
                            cPtr_typeGalgas_lstring * operand_60377 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_60377) ;
                            if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
                            }else{
                              cPtr_typeGalgas_location * operand_60358 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_60358) ;
                              cPtr_typeGalgas_location * operand_60377 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_60377) ;
                              if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
                              }else{
                                cPtr_typeGalgasUndefinedListType * operand_60358 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_60358) ;
                                cPtr_typeGalgasUndefinedListType * operand_60377 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_60377) ;
                                if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
                                  if (((operand_60358->mListTypeName.reader_value ()) != (operand_60377->mListTypeName.reader_value ())).isBuiltAndTrue ()) {
                                      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting the list type '")) + (operand_60358->mListTypeName.reader_value ()))) + (GGS_string (true, "', I have got the list type '")))) + (operand_60377->mListTypeName.reader_value ()))) + (GGS_string (true, "\"")))) ;
                                  }
                                }else{
                                  cPtr_typeGalgasUndefinedMapType * operand_60358 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_60358) ;
                                  cPtr_typeGalgasUndefinedMapType * operand_60377 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_60377) ;
                                  if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
                                    if (((operand_60358->mMapTypeName.reader_value ()) != (operand_60377->mMapTypeName.reader_value ())).isBuiltAndTrue ()) {
                                        var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting the map type '")) + (operand_60358->mMapTypeName.reader_value ()))) + (GGS_string (true, "', I have got the map type '")))) + (operand_60377->mMapTypeName.reader_value ()))) + (GGS_string (true, "\"")))) ;
                                    }
                                  }else{
                                    cPtr_typeGalgasUndefinedClassType * operand_60358 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_60358) ;
                                    cPtr_typeGalgasUndefinedClassType * operand_60377 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_60377) ;
                                    if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
                                      if (((operand_60358->mClassTypeName.reader_value ()) != (operand_60377->mClassTypeName.reader_value ())).isBuiltAndTrue ()) {
                                          var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting the class type '")) + (operand_60358->mClassTypeName.reader_value ()))) + (GGS_string (true, "', I have got the class type '")))) + (operand_60377->mClassTypeName.reader_value ()))) + (GGS_string (true, "\"")))) ;
                                      }
                                    }else{
                                      cPtr_typeGalgasUndefinedExternType * operand_60358 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_60358) ;
                                      cPtr_typeGalgasUndefinedExternType * operand_60377 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_60377) ;
                                      if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
                                        if (((operand_60358->mGalgasClassName.reader_value ()) != (operand_60377->mGalgasClassName.reader_value ())).isBuiltAndTrue ()) {
                                            var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting an extern variable of extern '")) + (operand_60358->mGalgasClassName.reader_value ()))) + (GGS_string (true, "' type variable, and I got an extern '")))) + (operand_60377->mGalgasClassName.reader_value ()))) + (GGS_string (true, "' type variable")))) ;
                                        }
                                      }else{
                                        cPtr_typeGalgas_enum * operand_60358 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_60358) ;
                                        cPtr_typeGalgas_enum * operand_60377 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_60377) ;
                                        if ((operand_60358 != NULL) && (operand_60377 != NULL)) {
                                          if (((operand_60358->mEnumTypeName.reader_value ()) != (operand_60377->mEnumTypeName.reader_value ())).isBuiltAndTrue ()) {
                                              var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting an enum variable of  '")) + (operand_60358->mEnumTypeName.reader_value ()))) + (GGS_string (true, "' type variable, and I got an enum '")))) + (operand_60377->mEnumTypeName.reader_value ()))) + (GGS_string (true, "' type variable")))) ;
                                          }
                                        }else{
                                            var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((var_cas_inFormalType.reader_messageGalgasType ()) + (GGS_string (true, " is not compatible with ")))) + (var_cas_inEffectiveType.reader_messageGalgasType ()))) ;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of routine "verifierCompatibiliteSignatures"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteSignatures (C_Lexique & lexique_var_,
                                GGS_L_signature   var_cas_signatureReference,
                                GGS_L_signature   var_cas_signatureTestee,
                                GGS_location   var_cas_ouSignalerErreur) {
  if (((var_cas_signatureReference.reader_length ()) < (var_cas_signatureTestee.reader_length ())).isBuiltAndTrue ()) {
      var_cas_ouSignalerErreur.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "there are too much parameters")) ;
  }else if (((var_cas_signatureReference.reader_length ()) > (var_cas_signatureTestee.reader_length ())).isBuiltAndTrue ()) {
      var_cas_ouSignalerErreur.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "one or more parameters missing")) ;
  }else{
    GGS_L_signature::element_type * operand_64159 = var_cas_signatureReference.firstObject () ;
    GGS_L_signature::element_type * operand_64258 = var_cas_signatureTestee.firstObject () ;
    while ((operand_64159 != NULL)
        && (operand_64258 != NULL)) {
      macroValidPointer (operand_64159) ;
      macroValidPointer (operand_64258) ;
      ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  operand_64159->mType,  operand_64258->mType,  var_cas_ouSignalerErreur) ;
      if (((operand_64159->mFormalArgumentPassingMode) != (operand_64258->mFormalArgumentPassingMode)).isBuiltAndTrue ()) {
          var_cas_ouSignalerErreur.reader_location ().signalGGSSemanticError (lexique_var_, ((((operand_64258->mFormalArgumentPassingMode.reader_formalArgumentMessage ()) + (GGS_string (true, " is not compatible with ")))) + (operand_64258->mFormalArgumentPassingMode.reader_formalArgumentMessage ()))) ;
      }
      operand_64159 = operand_64159->nextObject () ;
      operand_64258 = operand_64258->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'M_cli_options'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_cli_options::
elementOf_GGS_M_cli_options (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_cli_options & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_cli_options::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_cli_options *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_cli_options * info = (e_M_cli_options *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::constructor_empty (void) {
  GGS_M_cli_options result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lchar &  inParameter0,
               const GGS_lstring &  inParameter1,
               const GGS_lstring &  inParameter2,
               const GGS_uint &  inParameter3,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_cli_options info  ;
    info.mOptionChar = inParameter0 ;
    info.mOptionString = inParameter1 ;
    info.mComment = inParameter2 ;
    info.mDefaultValue = inParameter3 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lchar   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_uint   & outParameter3,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mOptionChar ;
    outParameter1 = node->mInfo.mOptionString ;
    outParameter2 = node->mInfo.mComment ;
    outParameter3 = node->mInfo.mDefaultValue ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lchar   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_lstring   & outParameter2,
                                GGS_uint   & outParameter3) {
  searchElement (inLexique,
                 "the '%K' command line option is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_lchar & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_lstring & inParameter2,
                                const GGS_uint & inParameter3) {
  insertElement (lexique_var_,
                 "the '%K' command line option has been already declared",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'M_optionComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_optionComponents::
elementOf_GGS_M_optionComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_optionComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_optionComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_optionComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_optionComponents * info = (e_M_optionComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::constructor_empty (void) {
  GGS_M_optionComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_cli_options &  inParameter0,
               const GGS_M_cli_options &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_optionComponents info  ;
    info.mBoolOptionsMap = inParameter0 ;
    info.mUintOptionsMap = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_cli_options   & outParameter0,
               GGS_M_cli_options   & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mBoolOptionsMap ;
    outParameter1 = node->mInfo.mUintOptionsMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_cli_options   & outParameter0,
                                GGS_M_cli_options   & outParameter1) {
  searchElement (inLexique,
                 "there is no '%K' option component",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_M_cli_options & inParameter0,
                                const GGS_M_cli_options & inParameter1) {
  insertElement (lexique_var_,
                 "the '%K' option component named is already declared",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'M_semanticsComponents'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_semanticsComponents::
elementOf_GGS_M_semanticsComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_semanticsComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_semanticsComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_semanticsComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_semanticsComponents * info = (e_M_semanticsComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::constructor_empty (void) {
  GGS_M_semanticsComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_semanticsEntitiesForUse &  inParameter0,
               const GGS_M_optionComponents &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_semanticsComponents info  ;
    info.mSemanticsEntitiesMap = inParameter0 ;
    info.mOptionsComponents = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_semanticsEntitiesForUse   & outParameter0,
               GGS_M_optionComponents   & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mSemanticsEntitiesMap ;
    outParameter1 = node->mInfo.mOptionsComponents ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_semanticsEntitiesForUse   & outParameter0,
                                GGS_M_optionComponents   & outParameter1) {
  searchElement (inLexique,
                 "there is no semantics component named '%K'",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_M_semanticsEntitiesForUse & inParameter0,
                                const GGS_M_optionComponents & inParameter1) {
  insertElement (lexique_var_,
                 "a semantics component named '%K' is already declared",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'M_grammarComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_grammarComponents::
elementOf_GGS_M_grammarComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_grammarComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_grammarComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_grammarComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_grammarComponents * info = (e_M_grammarComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::constructor_empty (void) {
  GGS_M_grammarComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAltsForGrammar &  inParameter0,
               const GGS_lstring &  inParameter1,
               const GGS_M_optionComponents &  inParameter2,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_grammarComponents info  ;
    info.mNonterminalSymbolParametersMap = inParameter0 ;
    info.mLexiqueName = inParameter1 ;
    info.mOptionsMap = inParameter2 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_M_optionComponents   & outParameter2,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolParametersMap ;
    outParameter1 = node->mInfo.mLexiqueName ;
    outParameter2 = node->mInfo.mOptionsMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_M_optionComponents   & outParameter2) {
  searchElement (inLexique,
                 "the '%K' grammar component is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_M_optionComponents & inParameter2) {
  insertElement (lexique_var_,
                 "the '%K' grammar component has been already declared",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of routine "handleReaderCall"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleReaderCall (C_Lexique & lexique_var_,
                                const GGS_AC_galgasType  & var_cas_inReceiverType,
                                const GGS_lstring  & var_cas_inMethodName,
                                GGS_typeListeAttributsSemantiques  & var_cas_outAccessorTypesList,
                                GGS_AC_galgasType  & var_cas_outReturnedType) {
  if (var_cas_inReceiverType.isBuilt ()) {
    if (dynamic_cast <cPtr_typeGalgas_string *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "fileExists"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "pathExtension"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "lastPathComponent"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "stringByDeletingPathExtension"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "stringByCapitalizingFirstCharacter"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "stringByDeletingLastPathComponent"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_uint *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "sint"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_sint::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_lstring *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_lchar *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_char::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_lbool *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_luint *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_lsint *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_sint::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_ldouble *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_double::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgasListType *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "length"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "list supports only 'length' reader call")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgasMapType *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "hasKey"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        GGS_AC_galgasType  var_cas_keyType ;
        var_cas_keyType = GGS_typeGalgas_string::constructor_new () ;
        var_cas_outAccessorTypesList.addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
        var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "count"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "allKeys"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_stringset::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "unreadKeys"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_stringset::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_stringset *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "hasKey"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        GGS_AC_galgasType  var_cas_keyType ;
        var_cas_keyType = GGS_typeGalgas_string::constructor_new () ;
        var_cas_outAccessorTypesList.addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
        var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "count"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgasClassType *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      cPtr_typeGalgasClassType * operand_75268 = dynamic_cast <cPtr_typeGalgasClassType *> (var_cas_inReceiverType.getPtr ()) ;
      macroValidPointer (operand_75268) ; 
      GGS_typeClassInheritedMessagesMap  var_cas_messagesMap ;
      var_cas_messagesMap = operand_75268->mMessagesMap ;
      var_cas_messagesMap.methode_searchKey (lexique_var_, var_cas_inMethodName) ;
      var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
    }else if (dynamic_cast <cPtr_typeGalgas_enum *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      cPtr_typeGalgas_enum * operand_75601 = dynamic_cast <cPtr_typeGalgas_enum *> (var_cas_inReceiverType.getPtr ()) ;
      macroValidPointer (operand_75601) ; 
      GGS_typeEnumMessageMap  var_cas_messagesMap ;
      var_cas_messagesMap = operand_75601->mMessagesMap ;
      GGS_L_lstringList  var_cas_75766 ;
      var_cas_messagesMap.methode_searchKey (lexique_var_, var_cas_inMethodName, var_cas_75766) ;
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
      var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
    }else{ // Else part
        var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support reader call")) ;
    }
  }
}

//---------------------------------------------------------------------------*

