//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'common_semantics.cpp'                         *
//               Generated by version 0.14.1 (LL(1) grammar)                 *
//                       april 12th, 2005, at 12h9'3"                        *
//                                                                           *
// This program is free software; you can redistribute it and/or modify it   *
// under the terms of the GNU General Public License as published by the     *
// Free Software Foundation.                                                 *
//                                                                           *
// This program is distributed in the hope it will be useful, but WITHOUT    *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *
// more details.                                                             *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "files/C_text_file_write.h"
#include "common_semantics.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               Include directives generated by extern types                *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cClassMethodsMap.hh"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//           class for enumeration 'actualParametersPassingMode'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator == (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator != (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator <= (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator >= (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator < (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator > (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParametersPassingMode::
reader_actualArgumentMessage (void) const {
  const char * kMessages [4] = {"",
    "an output (!) actual parameter",
    "an output/input (!\?) actual parameter",
    "an input (\?) actual parameter"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class for enumeration 'formalArgumentPassingMode'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator == (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator != (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator <= (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator >= (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator < (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator > (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingMode::
reader_formalArgumentMessage (void) const {
  const char * kMessages [5] = {"",
    "an input (\?) formal argument",
    "an output (!) formal argument",
    "an input/output (\?!) argument",
    "a constant input (\?\?) formal argument"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_AC_galgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_acceptAssignmentFromHere (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inErrorLocation) {
    var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "assignment from 'here' is not allowed for variables of this type")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_acceptToBeKeyForMap (C_lexique & lexique_var_) {
    GGS_location (lexique_var_).reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this type cannot be a key for map")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleModifierCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_signature & /* var_cas_outModifierSignature */) {
    var_cas_inModifierName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support modifier call")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleReaderInstructionCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_signature & /* var_cas_outReaderSignature */) {
    var_cas_inReaderName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support reader instruction")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleConstructorCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & /* var_cas_outAccessorTypesList */) {
    var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This class method is not defined")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleAddAssignOperatorCall (C_lexique & lexique_var_,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & /* var_cas_outParametersList */,
                                GGS_bool& /* var_cas_outAccept_luint_assignment */) {
    var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support call of '+=' operator")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_handleIncrementOperatorCall (C_lexique & lexique_var_,
                                GGS_location  var_cas_inErrorLocation) {
    var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support call of '++' operator")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_lexique & lexique_var_) {
    GGS_location (lexique_var_).reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type cannot be silently converted to @location value")) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
methode_typeCanBeUsedInObjectDeclaration (C_lexique & /* lexique_var_ */) {
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType
::static_string_message_messageGalgasType (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType::
message_messageGalgasType (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_galgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (void) {
  mPointer = (cPtr_AC_galgasType *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (const GGS_AC_galgasType & inOperand) {
  mPointer = (cPtr_AC_galgasType *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
~GGS_AC_galgasType (void) {
  macroDetachPointer (mPointer, cPtr_AC_galgasType) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_galgasType::
operator = (const GGS_AC_galgasType & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_AC_galgasType::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_AC_galgasType::
operator = (cPtr_AC_galgasType * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (cPtr_AC_galgasType * inSource) {
  mPointer = (cPtr_AC_galgasType *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_AC_galgasType * GGS_AC_galgasType
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_galgasType::reader_messageGalgasType (void) const {
  return GGS_string (mPointer != NULL, C_string ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_galgasType
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_galgasType) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Class element of list 'typeListeAttributsSemantiques'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::element_type::
element_type (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (element_type *) NULL ;
  mAttributType = argument_0 ;
  aNomAttribut = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class list 'typeListeAttributsSemantiques'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques
::GGS_typeListeAttributsSemantiques (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::~GGS_typeListeAttributsSemantiques (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::GGS_typeListeAttributsSemantiques (const GGS_typeListeAttributsSemantiques & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques
::operator = (const GGS_typeListeAttributsSemantiques & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mAttributType,
                                p->aNomAttribut) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeListeAttributsSemantiques::
constructor_empty (void) {
  GGS_typeListeAttributsSemantiques result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Class element of list 'typeTypesList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTypesList::element_type::
element_type (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  mNextItem = (element_type *) NULL ;
  mType = argument_0 ;
  mEndOfExpressionLocation = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class list 'typeTypesList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTypesList
::GGS_typeTypesList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeTypesList::~GGS_typeTypesList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeTypesList::GGS_typeTypesList (const GGS_typeTypesList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList
::operator = (const GGS_typeTypesList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mEndOfExpressionLocation) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeTypesList  GGS_typeTypesList::
constructor_empty (void) {
  GGS_typeTypesList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Class element of list 'L_signature'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_signature::element_type::
element_type (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) {
  mNextItem = (element_type *) NULL ;
  mType = argument_0 ;
  mFormalArgumentPassingMode = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class list 'L_signature'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_signature
::GGS_L_signature (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_signature::~GGS_L_signature (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_signature::GGS_L_signature (const GGS_L_signature & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature
::operator = (const GGS_L_signature & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mFormalArgumentPassingMode) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_signature  GGS_L_signature::
constructor_empty (void) {
  GGS_L_signature result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Class element of list 'L_actualParametersSignature'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::element_type::
element_type (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1) {
  mNextItem = (element_type *) NULL ;
  mType = argument_0 ;
  mFormalArgumentPassingMode = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class list 'L_actualParametersSignature'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature
::GGS_L_actualParametersSignature (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::~GGS_L_actualParametersSignature (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::GGS_L_actualParametersSignature (const GGS_L_actualParametersSignature & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature
::operator = (const GGS_L_actualParametersSignature & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mFormalArgumentPassingMode) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature  GGS_L_actualParametersSignature::
constructor_empty (void) {
  GGS_L_actualParametersSignature result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'M_accessors_map'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_accessors_map::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_accessors_map & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_accessors_map::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_accessors_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_accessors_map * info = (e_M_accessors_map *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_accessors_map::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_accessors_map::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::constructor_empty (void) {
  GGS_M_accessors_map result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_accessors_map::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               const GGS_AC_galgasType &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()
                 && inParameter1.isBuilt ()) {
     insulateMap () ;
    e_M_accessors_map info  ;
    info.mAccessorSignature = inParameter0 ;
    info.mReturnedType = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_L_signature   * outParameter0,
               GGS_AC_galgasType   * outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mAccessorSignature ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = node->mInfo.mReturnedType ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_accessors_map (C_lexique & inLexique,
                                GGS_M_accessors_map & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_signature   * outParameter0,
                                GGS_AC_galgasType   * outParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' accessor is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outParameter1,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_accessors_map (C_lexique & lexique_var_,
                                GGS_M_accessors_map & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0,
                                const GGS_AC_galgasType & inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' accessor has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       inParameter1,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Class element of list 'L_stringList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_stringList::element_type::
element_type (const GGS_string& argument_0) {
  mNextItem = (element_type *) NULL ;
  mErrorMessageElement = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class list 'L_stringList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_stringList
::GGS_L_stringList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_stringList::~GGS_L_stringList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_stringList::GGS_L_stringList (const GGS_L_stringList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_stringList
::operator = (const GGS_L_stringList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
internalAppendItem (const GGS_string& argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
addAssign_operation (const GGS_string& argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mErrorMessageElement) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_stringList  GGS_L_stringList::
constructor_empty (void) {
  GGS_L_stringList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_stringList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Class element of list 'L_lstringList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_lstringList::element_type::
element_type (const GGS_lstring & argument_0) {
  mNextItem = (element_type *) NULL ;
  mString = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class list 'L_lstringList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_lstringList
::GGS_L_lstringList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_lstringList::~GGS_L_lstringList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_lstringList::GGS_L_lstringList (const GGS_L_lstringList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList
::operator = (const GGS_L_lstringList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mString) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_lstringList  GGS_L_lstringList::
constructor_empty (void) {
  GGS_L_lstringList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeGalgas_jokerInParameterList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_jokerInParameterList::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_jokerInParameterList::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "") ;
}


const char * cPtr_typeGalgas_jokerInParameterList::message_messageGalgasType (void) const {
  return "\?\?" ;
}

const char * cPtr_typeGalgas_jokerInParameterList::static_string_message_messageGalgasType (void) {
  return "\?\?" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeGalgas_jokerInParameterList'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_jokerInParameterList * GGS_typeGalgas_jokerInParameterList::
    constructor_new () {
    cPtr_typeGalgas_jokerInParameterList * ptr_ = (cPtr_typeGalgas_jokerInParameterList *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_jokerInParameterList ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_bool'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_bool::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "bool") ;
}


const char * cPtr_typeGalgas_bool::message_messageGalgasType (void) const {
  return "a bool type" ;
}

const char * cPtr_typeGalgas_bool::static_string_message_messageGalgasType (void) {
  return "a bool type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_bool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_bool * GGS_typeGalgas_bool::
    constructor_new () {
    cPtr_typeGalgas_bool * ptr_ = (cPtr_typeGalgas_bool *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_bool ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_string'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_string::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "string") ;
}


const char * cPtr_typeGalgas_string::message_messageGalgasType (void) const {
  return "a 'string' type" ;
}

const char * cPtr_typeGalgas_string::static_string_message_messageGalgasType (void) {
  return "a 'string' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_string'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_string * GGS_typeGalgas_string::
    constructor_new () {
    cPtr_typeGalgas_string * ptr_ = (cPtr_typeGalgas_string *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_string ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_sint'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_sint::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "sint") ;
}


const char * cPtr_typeGalgas_sint::message_messageGalgasType (void) const {
  return "a 'sint' type" ;
}

const char * cPtr_typeGalgas_sint::static_string_message_messageGalgasType (void) {
  return "a 'sint' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_sint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_sint * GGS_typeGalgas_sint::
    constructor_new () {
    cPtr_typeGalgas_sint * ptr_ = (cPtr_typeGalgas_sint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_sint ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_uint'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_uint::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "uint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
methode_handleIncrementOperatorCall (C_lexique & /* lexique_var_ */,
                                GGS_location  /* var_cas_inErrorLocation */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
methode_handleConstructorCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "max"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This class method is not defined")) ;
  }
}


const char * cPtr_typeGalgas_uint::message_messageGalgasType (void) const {
  return "a 'uint' type" ;
}

const char * cPtr_typeGalgas_uint::static_string_message_messageGalgasType (void) {
  return "a 'uint' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_uint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_uint * GGS_typeGalgas_uint::
    constructor_new () {
    cPtr_typeGalgas_uint * ptr_ = (cPtr_typeGalgas_uint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_uint ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_char'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_char::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "char") ;
}


const char * cPtr_typeGalgas_char::message_messageGalgasType (void) const {
  return "a 'char' type" ;
}

const char * cPtr_typeGalgas_char::static_string_message_messageGalgasType (void) {
  return "a 'char' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_char'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_char * GGS_typeGalgas_char::
    constructor_new () {
    cPtr_typeGalgas_char * ptr_ = (cPtr_typeGalgas_char *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_char ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_dfloat'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_dfloat::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_dfloat::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "dfloat") ;
}


const char * cPtr_typeGalgas_dfloat::message_messageGalgasType (void) const {
  return "a dfloat type" ;
}

const char * cPtr_typeGalgas_dfloat::static_string_message_messageGalgasType (void) {
  return "a dfloat type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_dfloat'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_dfloat * GGS_typeGalgas_dfloat::
    constructor_new () {
    cPtr_typeGalgas_dfloat * ptr_ = (cPtr_typeGalgas_dfloat *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_dfloat ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_galgasPrimitiveType'                 *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType
::static_string_message_messageGalgasType (void) {
  return "any primitive type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType::
message_messageGalgasType (void) const {
  return "any primitive type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_galgasPrimitiveType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (void) {
  mPointer = (cPtr_C_galgasPrimitiveType *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (const GGS_C_galgasPrimitiveType & inOperand) {
  mPointer = (cPtr_C_galgasPrimitiveType *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
~GGS_C_galgasPrimitiveType (void) {
  macroDetachPointer (mPointer, cPtr_C_galgasPrimitiveType) ;
}

//---------------------------------------------------------------------------*

void GGS_C_galgasPrimitiveType::
operator = (const GGS_C_galgasPrimitiveType & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_C_galgasPrimitiveType::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_C_galgasPrimitiveType::
operator = (cPtr_C_galgasPrimitiveType * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (cPtr_C_galgasPrimitiveType * inSource) {
  mPointer = (cPtr_C_galgasPrimitiveType *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_C_galgasPrimitiveType * GGS_C_galgasPrimitiveType
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_galgasPrimitiveType::reader_messageGalgasType (void) const {
  return GGS_string (mPointer != NULL, C_string ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_C_galgasPrimitiveType
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_C_galgasPrimitiveType) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgas_location'                         *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_location::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "location") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
methode_acceptAssignmentFromHere (C_lexique & /* lexique_var_ */,
                                GGS_lstring  /* var_cas_inErrorLocation */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_location::message_messageGalgasType (void) const {
  return "'location' type" ;
}

const char * cPtr_typeGalgas_location::static_string_message_messageGalgasType (void) {
  return "'location' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_location'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_location * GGS_typeGalgas_location::
    constructor_new () {
    cPtr_typeGalgas_location * ptr_ = (cPtr_typeGalgas_location *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_location ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_lstring'                         *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lstring::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "lstring") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
methode_handleConstructorCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_string::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This class method is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
methode_acceptToBeKeyForMap (C_lexique & /* lexique_var_ */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_lstring::message_messageGalgasType (void) const {
  return "a 'lstring' type" ;
}

const char * cPtr_typeGalgas_lstring::static_string_message_messageGalgasType (void) {
  return "a 'lstring' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_lstring'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_lstring * GGS_typeGalgas_lstring::
    constructor_new () {
    cPtr_typeGalgas_lstring * ptr_ = (cPtr_typeGalgas_lstring *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lstring ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lchar'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lchar::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "lchar") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
methode_handleConstructorCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_char::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This class method is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_lchar::message_messageGalgasType (void) const {
  return "a 'lchar' type" ;
}

const char * cPtr_typeGalgas_lchar::static_string_message_messageGalgasType (void) {
  return "a 'lchar' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lchar'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_lchar * GGS_typeGalgas_lchar::
    constructor_new () {
    cPtr_typeGalgas_lchar * ptr_ = (cPtr_typeGalgas_lchar *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lchar ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lbool'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lbool::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "lbool") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
methode_handleConstructorCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_bool::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This class method is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_lbool::message_messageGalgasType (void) const {
  return "a 'lbool' type" ;
}

const char * cPtr_typeGalgas_lbool::static_string_message_messageGalgasType (void) {
  return "a 'lbool' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lbool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_lbool * GGS_typeGalgas_lbool::
    constructor_new () {
    cPtr_typeGalgas_lbool * ptr_ = (cPtr_typeGalgas_lbool *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lbool ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_luint'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_luint::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "luint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
methode_handleConstructorCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_uint::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This class method is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
methode_acceptToBeKeyForMap (C_lexique & /* lexique_var_ */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_luint::message_messageGalgasType (void) const {
  return "a 'luint' type" ;
}

const char * cPtr_typeGalgas_luint::static_string_message_messageGalgasType (void) {
  return "a 'luint' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_luint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_luint * GGS_typeGalgas_luint::
    constructor_new () {
    cPtr_typeGalgas_luint * ptr_ = (cPtr_typeGalgas_luint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_luint ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_lsint'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lsint::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "lsint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
methode_handleConstructorCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_sint::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This class method is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
methode_acceptToBeKeyForMap (C_lexique & /* lexique_var_ */) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_lsint::message_messageGalgasType (void) const {
  return "a 'lsint' type" ;
}

const char * cPtr_typeGalgas_lsint::static_string_message_messageGalgasType (void) {
  return "a 'lsint' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lsint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_lsint * GGS_typeGalgas_lsint::
    constructor_new () {
    cPtr_typeGalgas_lsint * ptr_ = (cPtr_typeGalgas_lsint *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_lsint ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgas_ldfloat'                         *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_ldfloat::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldfloat::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = GGS_string (true, "ldfloat") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldfloat::
methode_handleConstructorCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_dfloat::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new () ;
    var_cas_outAccessorTypesList.addAssign_operation (var_cas_t, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This class method is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldfloat::
methode_checkAbilityToBeSilentlyConvertedToLocation (C_lexique & /* lexique_var_ */) {
}


const char * cPtr_typeGalgas_ldfloat::message_messageGalgasType (void) const {
  return "a 'dfloat' type" ;
}

const char * cPtr_typeGalgas_ldfloat::static_string_message_messageGalgasType (void) {
  return "a 'dfloat' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_ldfloat'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_ldfloat * GGS_typeGalgas_ldfloat::
    constructor_new () {
    cPtr_typeGalgas_ldfloat * ptr_ = (cPtr_typeGalgas_ldfloat *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_ldfloat ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map element 'e_typeTableMethodes'                   *
//                                                                           *
//---------------------------------------------------------------------------*

template class cClassMethodsMap <e_typeTableMethodes, GGS_lstring> ;

//---------------------------------------------------------------------------*

bool e_typeTableMethodes::isBuilt (void) const {
  return aListeTypesParametres.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         Map 'typeTableMethodes'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void searchKey_typeTableMethodes (C_lexique & inLexique,
                                GGS_typeTableMethodes & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_signature   * outParameter0,
                                GGS_luint * outIndex) {
  const char * errorMessage_0 = "there is no reader named '%'" ;
  GGS_typeTableMethodes::element_type * info = ioMap.searchKey (inLexique, inKey, inKey, errorMessage_0) ;
  if (info == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
    }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = info->mInfo.aListeTypesParametres ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchForOverride_typeTableMethodes (C_lexique & inLexique,
                                GGS_typeTableMethodes & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_signature   * outParameter0,
                                GGS_luint * outIndex) {
  const char * errorMessage_0 = "the reader '%' cannot be overriden : it is not declared in superclass" ;
  GGS_typeTableMethodes::element_type * info = ioMap.searchForOverride (inLexique, inKey, inKey, errorMessage_0) ;
  if (info == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
    }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = info->mInfo.aListeTypesParametres ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void insertAbstract_typeTableMethodes (C_lexique & lexique_var_,
                                GGS_typeTableMethodes & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage_0 = "a reader named '%' is already declared" ;
  e_typeTableMethodes info ;
  info.aListeTypesParametres = inParameter0 ;
  const sint32 index = ioMap.insertAbstract (lexique_var_, info, inKey, inKey, kErrorMessage_0) ;
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void insertNotAbstract_typeTableMethodes (C_lexique & lexique_var_,
                                GGS_typeTableMethodes & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage_0 = "a reader named '%' is already declared" ;
  e_typeTableMethodes info ;
  info.aListeTypesParametres = inParameter0 ;
  const sint32 index = ioMap.insertNotAbstract (lexique_var_, info, inKey, inKey, kErrorMessage_0) ;
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeGalgasUndefinedExternType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedExternType::cPtr_typeGalgasUndefinedExternType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1)
:mGalgasClassName (argument_0),
mCppClassName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedExternType::isBuilt (void) const {
  return mGalgasClassName.isBuilt () &&
       mCppClassName.isBuilt () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedExternType::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mGalgasClassName.reader_value () ;
}


const char * cPtr_typeGalgasUndefinedExternType::message_messageGalgasType (void) const {
  return "an undefined extern type" ;
}

const char * cPtr_typeGalgasUndefinedExternType::static_string_message_messageGalgasType (void) {
  return "an undefined extern type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedExternType'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasUndefinedExternType * GGS_typeGalgasUndefinedExternType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
    cPtr_typeGalgasUndefinedExternType * ptr_ = (cPtr_typeGalgasUndefinedExternType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedExternType (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_externTypeConstructorMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_externTypeConstructorMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_externTypeConstructorMap::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_externTypeConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_externTypeConstructorMap * info = (e_M_externTypeConstructorMap *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_externTypeConstructorMap::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_externTypeConstructorMap::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::constructor_empty (void) {
  GGS_M_externTypeConstructorMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_externTypeConstructorMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_typeListeAttributsSemantiques &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_M_externTypeConstructorMap info  ;
    info.aListeDesAttributs = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.aListeDesAttributs ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_externTypeConstructorMap (C_lexique & inLexique,
                                GGS_M_externTypeConstructorMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' constructor is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_externTypeConstructorMap (C_lexique & lexique_var_,
                                GGS_M_externTypeConstructorMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' constructor is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgasExternType'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasExternType::cPtr_typeGalgasExternType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_M_externTypeConstructorMap & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodes & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_typeListeAttributsSemantiques & argument_6)
:cPtr_typeGalgasUndefinedExternType (argument_0, argument_1),
mConstructorMap (argument_2),
mModifiersMap (argument_3),
mReadersInInstructionMap (argument_4),
mAcceptAddAssignOperatorCall (argument_5),
mAddAssignOperatorCallTypeList (argument_6) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasExternType::isBuilt (void) const {
  return mGalgasClassName.isBuilt () &&
       mCppClassName.isBuilt () &&
       mConstructorMap.isBuilt () &&
       mModifiersMap.isBuilt () &&
       mReadersInInstructionMap.isBuilt () &&
       mAcceptAddAssignOperatorCall.isBuilt () &&
       mAddAssignOperatorCallTypeList.isBuilt () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
methode_handleConstructorCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  GGS_M_externTypeConstructorMap  var_cas_constructorMap ;
  var_cas_constructorMap = mConstructorMap ;
  searchKey_M_externTypeConstructorMap (lexique_var_,
                                  var_cas_constructorMap,
                                  var_cas_inClassMethodName,
                                  & var_cas_outAccessorTypesList,
                                  NULL) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
methode_handleModifierCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_signature & var_cas_outModifierSignature) {
  GGS_typeTableMethodes  var_cas_methodMap ;
  var_cas_methodMap = mModifiersMap ;
  searchKey_typeTableMethodes (lexique_var_,
                                  var_cas_methodMap,
                                  var_cas_inModifierName,
                                  & var_cas_outModifierSignature,
                                  NULL) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
methode_handleReaderInstructionCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_signature & var_cas_outReaderSignature) {
  GGS_typeTableMethodes  var_cas_methodMap ;
  var_cas_methodMap = mReadersInInstructionMap ;
  searchKey_typeTableMethodes (lexique_var_,
                                  var_cas_methodMap,
                                  var_cas_inReaderName,
                                  & var_cas_outReaderSignature,
                                  NULL) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
methode_handleAddAssignOperatorCall (C_lexique & lexique_var_,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList,
                                GGS_bool& var_cas_outAccept_luint_assignment) {
  if (((! mAcceptAddAssignOperatorCall)).isBuiltAndTrue ()) {
    inherited::methode_handleAddAssignOperatorCall (lexique_var_, var_cas_inErrorLocation, var_cas_outParametersList, var_cas_outAccept_luint_assignment) ;
  }else{
    var_cas_outParametersList = mAddAssignOperatorCallTypeList ;
    var_cas_outAccept_luint_assignment = GGS_bool (true, false) ;
  }
}


const char * cPtr_typeGalgasExternType::message_messageGalgasType (void) const {
  return "an extern type" ;
}

const char * cPtr_typeGalgasExternType::static_string_message_messageGalgasType (void) {
  return "an extern type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgasExternType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasExternType * GGS_typeGalgasExternType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_M_externTypeConstructorMap & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodes & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_typeListeAttributsSemantiques & argument_6) {
    cPtr_typeGalgasExternType * ptr_ = (cPtr_typeGalgasExternType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasExternType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_terminalSymbolsMapForUse'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_terminalSymbolsMapForUse & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_terminalSymbolsMapForUse::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_terminalSymbolsMapForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_terminalSymbolsMapForUse * info = (e_M_terminalSymbolsMapForUse *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_terminalSymbolsMapForUse::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_terminalSymbolsMapForUse::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::constructor_empty (void) {
  GGS_M_terminalSymbolsMapForUse result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_terminalSymbolsMapForUse::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_typeListeAttributsSemantiques &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_M_terminalSymbolsMapForUse info  ;
    info.aListeDesAttributs = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.aListeDesAttributs ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_terminalSymbolsMapForUse (C_lexique & inLexique,
                                GGS_M_terminalSymbolsMapForUse & ioMap,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the terminal symbol '$",
                                   "",
                                   "$' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_terminalSymbolsMapForUse (C_lexique & lexique_var_,
                                GGS_M_terminalSymbolsMapForUse & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the terminal symbol '$",
                                   "",
                                   "$' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'M_lexiqueComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_lexiqueComponents & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_lexiqueComponents::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_lexiqueComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_lexiqueComponents * info = (e_M_lexiqueComponents *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_lexiqueComponents::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_lexiqueComponents::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::constructor_empty (void) {
  GGS_M_lexiqueComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_lexiqueComponents::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_M_terminalSymbolsMapForUse &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_M_lexiqueComponents info  ;
    info.mTerminalSymbolMap = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_M_terminalSymbolsMapForUse   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mTerminalSymbolMap ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_lexiqueComponents (C_lexique & inLexique,
                                GGS_M_lexiqueComponents & ioMap,
                                const GGS_lstring & inKey,
                                GGS_M_terminalSymbolsMapForUse   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' lexique is not defined",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_lexiqueComponents (C_lexique & lexique_var_,
                                GGS_M_lexiqueComponents & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_M_terminalSymbolsMapForUse & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' lexique is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'typeTableEnAvant'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableEnAvant::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableEnAvant & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableEnAvant::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_typeTableEnAvant *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeTableEnAvant * info = (e_typeTableEnAvant *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeTableEnAvant::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_typeTableEnAvant::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::constructor_empty (void) {
  GGS_typeTableEnAvant result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableEnAvant::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_AC_galgasType &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_typeTableEnAvant info  ;
    info.mType = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_AC_galgasType   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mType ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeTableEnAvant (C_lexique & inLexique,
                                GGS_typeTableEnAvant & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the type '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeTableEnAvant (C_lexique & lexique_var_,
                                GGS_typeTableEnAvant & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the type '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map 'M_nonterminalSymbolAlts'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonterminalSymbolAlts & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonterminalSymbolAlts::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_nonterminalSymbolAlts *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_nonterminalSymbolAlts * info = (e_M_nonterminalSymbolAlts *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_nonterminalSymbolAlts::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_nonterminalSymbolAlts::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::constructor_empty (void) {
  GGS_M_nonterminalSymbolAlts result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonterminalSymbolAlts::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_M_nonterminalSymbolAlts info  ;
    info.mFormalParametersList = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_L_signature   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mFormalParametersList ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_nonterminalSymbolAlts (C_lexique & inLexique,
                                GGS_M_nonterminalSymbolAlts & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_signature   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the label '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_nonterminalSymbolAlts (C_lexique & lexique_var_,
                                GGS_M_nonterminalSymbolAlts & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the label '",
                                   "",
                                   "' has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_externClassesDirectories'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_externClassesDirectories::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_externClassesDirectories & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_externClassesDirectories::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_externClassesDirectories *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_externClassesDirectories * info = (e_M_externClassesDirectories *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_externClassesDirectories::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_externClassesDirectories::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_externClassesDirectories GGS_M_externClassesDirectories::constructor_empty (void) {
  GGS_M_externClassesDirectories result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_externClassesDirectories::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externClassesDirectories::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externClassesDirectories::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_M_externClassesDirectories info  ;
    info.mDirectory = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externClassesDirectories::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_lstring   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mDirectory ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_externClassesDirectories (C_lexique & inLexique,
                                GGS_M_externClassesDirectories & ioMap,
                                const GGS_lstring & inKey,
                                GGS_lstring   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the extern class '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_externClassesDirectories (C_lexique & lexique_var_,
                                GGS_M_externClassesDirectories & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the extern class '",
                                   "",
                                   "' has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_AC_semanticsEntity'                  *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity
::static_string_message_messageTypeEntite (void) {
  return "any entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity::
message_messageTypeEntite (void) const {
  return "any entity" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_AC_semanticsEntity'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (void) {
  mPointer = (cPtr_AC_semanticsEntity *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (const GGS_AC_semanticsEntity & inOperand) {
  mPointer = (cPtr_AC_semanticsEntity *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
~GGS_AC_semanticsEntity (void) {
  macroDetachPointer (mPointer, cPtr_AC_semanticsEntity) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_semanticsEntity::
operator = (const GGS_AC_semanticsEntity & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_AC_semanticsEntity::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_AC_semanticsEntity::
operator = (cPtr_AC_semanticsEntity * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (cPtr_AC_semanticsEntity * inSource) {
  mPointer = (cPtr_AC_semanticsEntity *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_AC_semanticsEntity * GGS_AC_semanticsEntity
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_semanticsEntity::reader_messageTypeEntite (void) const {
  return GGS_string (mPointer != NULL, C_string ((mPointer == NULL) ? "" : mPointer->message_messageTypeEntite ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_semanticsEntity
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_semanticsEntity) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_grammarForSemantics'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarForSemantics::cPtr_C_grammarForSemantics (const GGS_M_nonterminalSymbolAlts & argument_0)
:mGrammarAltMap (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_grammarForSemantics::isBuilt (void) const {
  return mGrammarAltMap.isBuilt () ;
}


const char * cPtr_C_grammarForSemantics::message_messageTypeEntite (void) const {
  return "a grammar entity" ;
}

const char * cPtr_C_grammarForSemantics::static_string_message_messageTypeEntite (void) {
  return "a grammar entity" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarForSemantics'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_grammarForSemantics * GGS_C_grammarForSemantics::
    constructor_new (const GGS_M_nonterminalSymbolAlts & argument_0) {
    cPtr_C_grammarForSemantics * ptr_ = (cPtr_C_grammarForSemantics *) NULL ;
    macroMyNew (ptr_, cPtr_C_grammarForSemantics (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_semanticsEntitiesForUse'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_semanticsEntitiesForUse & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_semanticsEntitiesForUse::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_semanticsEntitiesForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_semanticsEntitiesForUse * info = (e_M_semanticsEntitiesForUse *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_semanticsEntitiesForUse::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_semanticsEntitiesForUse::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::constructor_empty (void) {
  GGS_M_semanticsEntitiesForUse result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_semanticsEntitiesForUse::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_AC_semanticsEntity &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_M_semanticsEntitiesForUse info  ;
    info.aDefEntite = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_AC_semanticsEntity   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.aDefEntite ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_semanticsEntitiesForUse (C_lexique & inLexique,
                                GGS_M_semanticsEntitiesForUse & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_semanticsEntity   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"there is no semantics entity named '",
                                   "",
                                   "'",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_semanticsEntitiesForUse (C_lexique & lexique_var_,
                                GGS_M_semanticsEntitiesForUse & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_semanticsEntity & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"a semantics entity named '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_AC_typeForGrammarComponent'              *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent
::static_string_message_typeForGrammarComponentMessage (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent::
message_typeForGrammarComponentMessage (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_AC_typeForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (void) {
  mPointer = (cPtr_AC_typeForGrammarComponent *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (const GGS_AC_typeForGrammarComponent & inOperand) {
  mPointer = (cPtr_AC_typeForGrammarComponent *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
~GGS_AC_typeForGrammarComponent (void) {
  macroDetachPointer (mPointer, cPtr_AC_typeForGrammarComponent) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_typeForGrammarComponent::
operator = (const GGS_AC_typeForGrammarComponent & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_AC_typeForGrammarComponent::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_AC_typeForGrammarComponent::
operator = (cPtr_AC_typeForGrammarComponent * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (cPtr_AC_typeForGrammarComponent * inSource) {
  mPointer = (cPtr_AC_typeForGrammarComponent *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_AC_typeForGrammarComponent * GGS_AC_typeForGrammarComponent
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_typeForGrammarComponent::reader_typeForGrammarComponentMessage (void) const {
  return GGS_string (mPointer != NULL, C_string ((mPointer == NULL) ? "" : mPointer->message_typeForGrammarComponentMessage ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_typeForGrammarComponent
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_typeForGrammarComponent) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_typesForGrammarComponent'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_typesForGrammarComponent & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_typesForGrammarComponent::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_typesForGrammarComponent *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_typesForGrammarComponent * info = (e_M_typesForGrammarComponent *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_typesForGrammarComponent::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_typesForGrammarComponent::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::constructor_empty (void) {
  GGS_M_typesForGrammarComponent result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_typesForGrammarComponent::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_AC_typeForGrammarComponent &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_M_typesForGrammarComponent info  ;
    info.mType = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_AC_typeForGrammarComponent   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mType ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_typesForGrammarComponent (C_lexique & inLexique,
                                GGS_M_typesForGrammarComponent & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_typeForGrammarComponent   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' type is not defined",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_typesForGrammarComponent (C_lexique & lexique_var_,
                                GGS_M_typesForGrammarComponent & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_typeForGrammarComponent & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' type is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Class element of list 'L_signature_ForGrammarComponent'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_signature_ForGrammarComponent::element_type::
element_type (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (element_type *) NULL ;
  mFormalArgumentPassingMode = argument_0 ;
  mGalgasTypeName = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class list 'L_signature_ForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_signature_ForGrammarComponent
::GGS_L_signature_ForGrammarComponent (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_signature_ForGrammarComponent::~GGS_L_signature_ForGrammarComponent (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_signature_ForGrammarComponent::GGS_L_signature_ForGrammarComponent (const GGS_L_signature_ForGrammarComponent & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature_ForGrammarComponent
::operator = (const GGS_L_signature_ForGrammarComponent & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature_ForGrammarComponent
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature_ForGrammarComponent::
internalAppendItem (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature_ForGrammarComponent::
addAssign_operation (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature_ForGrammarComponent
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mFormalArgumentPassingMode,
                                p->mGalgasTypeName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_signature_ForGrammarComponent  GGS_L_signature_ForGrammarComponent::
constructor_empty (void) {
  GGS_L_signature_ForGrammarComponent result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature_ForGrammarComponent
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "checkSignature_ForGrammarComponent"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkSignature_ForGrammarComponent (C_lexique & lexique_var_,
                                const GGS_L_signature_ForGrammarComponent  & var_cas_inFormalReferenceSignature,
                                const GGS_L_signature_ForGrammarComponent  & var_cas_inFormalTestedSignature,
                                const GGS_location  & var_cas_inEndOfListLocation) {
  if (((var_cas_inFormalReferenceSignature.reader_length ()) < (var_cas_inFormalTestedSignature.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inEndOfListLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "too much formal parameters")) ;
  }else if (((var_cas_inFormalReferenceSignature.reader_length ()) > (var_cas_inFormalTestedSignature.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inEndOfListLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "one or more formal parameters missing")) ;
  }else{
    GGS_L_signature_ForGrammarComponent::element_type * operand_34184 = var_cas_inFormalReferenceSignature.getFirstItem () ;
    GGS_L_signature_ForGrammarComponent::element_type * operand_34264 = var_cas_inFormalTestedSignature.getFirstItem () ;
    while ((operand_34184 != NULL) && (operand_34264 != NULL)) {
      macroValidPointer (operand_34184) ;
      macroValidPointer (operand_34264) ;
      if (((operand_34184->mFormalArgumentPassingMode) != (operand_34264->mFormalArgumentPassingMode)).isBuiltAndTrue ()) {
          operand_34264->mGalgasTypeName.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "Prototype has ")) + (operand_34184->mFormalArgumentPassingMode.reader_formalArgumentMessage ()))) + (GGS_string (true, ", and ")))) + (operand_34184->mFormalArgumentPassingMode.reader_formalArgumentMessage ()))) + (GGS_string (true, " has been found")))) ;
      }
      if (((operand_34184->mGalgasTypeName.reader_value ()) != (operand_34264->mGalgasTypeName.reader_value ())).isBuiltAndTrue ()) {
          operand_34264->mGalgasTypeName.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting the '@")) + (operand_34184->mGalgasTypeName.reader_value ()))) + (GGS_string (true, "' type, I have got the '@")))) + (operand_34264->mGalgasTypeName.reader_value ()))) + (GGS_string (true, "' type")))) ;
      }
      operand_34184 = operand_34184->getNextItem () ;
      operand_34264 = operand_34264->getNextItem () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_AC_instruction_ForGrammar'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_instruction_ForGrammar::
cPtr_AC_instruction_ForGrammar (const GGS_location & argument_0)
:mStartLocation (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_AC_instruction_ForGrammar'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (void) {
  mPointer = (cPtr_AC_instruction_ForGrammar *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (const GGS_AC_instruction_ForGrammar & inOperand) {
  mPointer = (cPtr_AC_instruction_ForGrammar *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
~GGS_AC_instruction_ForGrammar (void) {
  macroDetachPointer (mPointer, cPtr_AC_instruction_ForGrammar) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_instruction_ForGrammar::
operator = (const GGS_AC_instruction_ForGrammar & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_AC_instruction_ForGrammar::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_AC_instruction_ForGrammar::
operator = (cPtr_AC_instruction_ForGrammar * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (cPtr_AC_instruction_ForGrammar * inSource) {
  mPointer = (cPtr_AC_instruction_ForGrammar *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_AC_instruction_ForGrammar * GGS_AC_instruction_ForGrammar
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_AC_instruction_ForGrammar
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_instruction_ForGrammar) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Class element of list 'L_ruleSyntaxSignature'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::element_type::
element_type (const GGS_AC_instruction_ForGrammar & argument_0) {
  mNextItem = (element_type *) NULL ;
  mInstruction = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class list 'L_ruleSyntaxSignature'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature
::GGS_L_ruleSyntaxSignature (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::~GGS_L_ruleSyntaxSignature (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::GGS_L_ruleSyntaxSignature (const GGS_L_ruleSyntaxSignature & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature
::operator = (const GGS_L_ruleSyntaxSignature & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
internalAppendItem (const GGS_AC_instruction_ForGrammar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
addAssign_operation (const GGS_AC_instruction_ForGrammar & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mInstruction) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature  GGS_L_ruleSyntaxSignature::
constructor_empty (void) {
  GGS_L_ruleSyntaxSignature result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'L_grammarsMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_grammarsMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_L_grammarsMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_L_grammarsMap::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_L_grammarsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_L_grammarsMap * info = (e_L_grammarsMap *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_grammarsMap::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_L_grammarsMap::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::constructor_empty (void) {
  GGS_L_grammarsMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_grammarsMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAlts &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_L_grammarsMap info  ;
    info.mStartSymbolParametersMap = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAlts   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mStartSymbolParametersMap ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_L_grammarsMap (C_lexique & inLexique,
                                GGS_L_grammarsMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' grammar is not defined",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_L_grammarsMap (C_lexique & lexique_var_,
                                GGS_L_grammarsMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' grammar is already defined",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class map 'M_nonterminalSymbolAltsForGrammar'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAltsForGrammar::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonterminalSymbolAltsForGrammar & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonterminalSymbolAltsForGrammar::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_nonterminalSymbolAltsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_nonterminalSymbolAltsForGrammar * info = (e_M_nonterminalSymbolAltsForGrammar *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_nonterminalSymbolAltsForGrammar::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_nonterminalSymbolAltsForGrammar::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAltsForGrammar GGS_M_nonterminalSymbolAltsForGrammar::constructor_empty (void) {
  GGS_M_nonterminalSymbolAltsForGrammar result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonterminalSymbolAltsForGrammar::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_L_signature_ForGrammarComponent &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_M_nonterminalSymbolAltsForGrammar info  ;
    info.mFormalParametersList = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_L_signature_ForGrammarComponent   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mFormalParametersList ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_nonterminalSymbolAltsForGrammar (C_lexique & inLexique,
                                GGS_M_nonterminalSymbolAltsForGrammar & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_signature_ForGrammarComponent   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the rules label '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_nonterminalSymbolAltsForGrammar (C_lexique & lexique_var_,
                                GGS_M_nonterminalSymbolAltsForGrammar & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_signature_ForGrammarComponent & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the rules label '",
                                   "",
                                   "' has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Class element of list 'L_productionRules_ForGrammarComponent'        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::element_type::
element_type (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) {
  mNextItem = (element_type *) NULL ;
  mLeftNonterminalSymbol = argument_0 ;
  mLeftNonterminalSymbolIndex = argument_1 ;
  mInstructionsList = argument_2 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class list 'L_productionRules_ForGrammarComponent'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent
::GGS_L_productionRules_ForGrammarComponent (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::~GGS_L_productionRules_ForGrammarComponent (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::GGS_L_productionRules_ForGrammarComponent (const GGS_L_productionRules_ForGrammarComponent & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent
::operator = (const GGS_L_productionRules_ForGrammarComponent & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()
                 && argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mLeftNonterminalSymbol,
                                p->mLeftNonterminalSymbolIndex,
                                p->mInstructionsList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent  GGS_L_productionRules_ForGrammarComponent::
constructor_empty (void) {
  GGS_L_productionRules_ForGrammarComponent result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'M_nonTerminalSymbolsForGrammar'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolsForGrammar::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonTerminalSymbolsForGrammar & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonTerminalSymbolsForGrammar::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_nonTerminalSymbolsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_nonTerminalSymbolsForGrammar * info = (e_M_nonTerminalSymbolsForGrammar *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_nonTerminalSymbolsForGrammar::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_nonTerminalSymbolsForGrammar::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolsForGrammar GGS_M_nonTerminalSymbolsForGrammar::constructor_empty (void) {
  GGS_M_nonTerminalSymbolsForGrammar result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonTerminalSymbolsForGrammar::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAltsForGrammar &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_M_nonTerminalSymbolsForGrammar info  ;
    info.mNonterminalSymbolParametersMap = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAltsForGrammar   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mNonterminalSymbolParametersMap ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_nonTerminalSymbolsForGrammar (C_lexique & inLexique,
                                GGS_M_nonTerminalSymbolsForGrammar & ioMap,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAltsForGrammar   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"internal search error",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_nonTerminalSymbolsForGrammar (C_lexique & lexique_var_,
                                GGS_M_nonTerminalSymbolsForGrammar & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"internal insert error",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'M_syntaxComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_syntaxComponents::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_syntaxComponents & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_syntaxComponents::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_syntaxComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_syntaxComponents * info = (e_M_syntaxComponents *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_syntaxComponents::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_syntaxComponents::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::constructor_empty (void) {
  GGS_M_syntaxComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_syntaxComponents::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_M_nonTerminalSymbolsForGrammar &  inParameter0,
               const GGS_L_productionRules_ForGrammarComponent &  inParameter1,
               const GGS_lstring &  inParameter2,
               const GGS_string_set&  inParameter3,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()
                 && inParameter1.isBuilt ()
                 && inParameter2.isBuilt ()
                 && inParameter3.isBuilt ()) {
     insulateMap () ;
    e_M_syntaxComponents info  ;
    info.mNonterminalSymbolsMap = inParameter0 ;
    info.mProductionRulesList = inParameter1 ;
    info.mLexiqueComponentName = inParameter2 ;
    info.mClassesNamesSet = inParameter3 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_M_nonTerminalSymbolsForGrammar   * outParameter0,
               GGS_L_productionRules_ForGrammarComponent   * outParameter1,
               GGS_lstring   * outParameter2,
               GGS_string_set  * outParameter3,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outParameter2 != NULL) {
      outParameter2->drop_operation () ;
    }
    if (outParameter3 != NULL) {
      outParameter3->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mNonterminalSymbolsMap ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = node->mInfo.mProductionRulesList ;
    }
    if (outParameter2 != NULL) {
      * outParameter2 = node->mInfo.mLexiqueComponentName ;
    }
    if (outParameter3 != NULL) {
      * outParameter3 = node->mInfo.mClassesNamesSet ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_syntaxComponents (C_lexique & inLexique,
                                GGS_M_syntaxComponents & ioMap,
                                const GGS_lstring & inKey,
                                GGS_M_nonTerminalSymbolsForGrammar   * outParameter0,
                                GGS_L_productionRules_ForGrammarComponent   * outParameter1,
                                GGS_lstring   * outParameter2,
                                GGS_string_set  * outParameter3,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"there is no syntax component named '",
                                   "",
                                   "'",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outParameter1,
                       outParameter2,
                       outParameter3,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_syntaxComponents (C_lexique & lexique_var_,
                                GGS_M_syntaxComponents & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_M_nonTerminalSymbolsForGrammar & inParameter0,
                                const GGS_L_productionRules_ForGrammarComponent & inParameter1,
                                const GGS_lstring & inParameter2,
                                const GGS_string_set& inParameter3,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"a syntax component named '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       inParameter1,
                       inParameter2,
                       inParameter3,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'T_terminalInstruction_forGrammarComponent'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_terminalInstruction_forGrammarComponent::cPtr_T_terminalInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2)
:cPtr_AC_instruction_ForGrammar (argument_0),
mTerminalSymbolName (argument_1),
mTerminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_T_terminalInstruction_forGrammarComponent::isBuilt (void) const {
  return mStartLocation.isBuilt () &&
       mTerminalSymbolName.isBuilt () &&
       mTerminalSymbolIndex.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_T_terminalInstruction_forGrammarComponent'        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_T_terminalInstruction_forGrammarComponent * GGS_T_terminalInstruction_forGrammarComponent::
    constructor_new (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2) {
    cPtr_T_terminalInstruction_forGrammarComponent * ptr_ = (cPtr_T_terminalInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_terminalInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'T_nonterminalInstruction_forGrammarComponent'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_nonterminalInstruction_forGrammarComponent::cPtr_T_nonterminalInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2)
:cPtr_AC_instruction_ForGrammar (argument_0),
mNonterminalSymbolName (argument_1),
mNonterminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_T_nonterminalInstruction_forGrammarComponent::isBuilt (void) const {
  return mStartLocation.isBuilt () &&
       mNonterminalSymbolName.isBuilt () &&
       mNonterminalSymbolIndex.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_T_nonterminalInstruction_forGrammarComponent'       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_T_nonterminalInstruction_forGrammarComponent * GGS_T_nonterminalInstruction_forGrammarComponent::
    constructor_new (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2) {
    cPtr_T_nonterminalInstruction_forGrammarComponent * ptr_ = (cPtr_T_nonterminalInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_nonterminalInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//         Class element of list 'L_branchList_ForGrammarComponent'          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::element_type::
element_type (const GGS_L_ruleSyntaxSignature & argument_0) {
  mNextItem = (element_type *) NULL ;
  mInstructionsList = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class list 'L_branchList_ForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent
::GGS_L_branchList_ForGrammarComponent (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::~GGS_L_branchList_ForGrammarComponent (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::GGS_L_branchList_ForGrammarComponent (const GGS_L_branchList_ForGrammarComponent & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent
::operator = (const GGS_L_branchList_ForGrammarComponent & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
internalAppendItem (const GGS_L_ruleSyntaxSignature & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
addAssign_operation (const GGS_L_ruleSyntaxSignature & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mInstructionsList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent  GGS_L_branchList_ForGrammarComponent::
constructor_empty (void) {
  GGS_L_branchList_ForGrammarComponent result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'T_selectInstruction_forGrammarComponent'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_selectInstruction_forGrammarComponent::cPtr_T_selectInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2)
:cPtr_AC_instruction_ForGrammar (argument_0),
mSelectList (argument_1),
mAddedNonterminalmSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_T_selectInstruction_forGrammarComponent::isBuilt (void) const {
  return mStartLocation.isBuilt () &&
       mSelectList.isBuilt () &&
       mAddedNonterminalmSymbolIndex.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_T_selectInstruction_forGrammarComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_T_selectInstruction_forGrammarComponent * GGS_T_selectInstruction_forGrammarComponent::
    constructor_new (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2) {
    cPtr_T_selectInstruction_forGrammarComponent * ptr_ = (cPtr_T_selectInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_selectInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'T_repeatInstruction_forGrammarComponent'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_repeatInstruction_forGrammarComponent::cPtr_T_repeatInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2)
:cPtr_AC_instruction_ForGrammar (argument_0),
mRepeatList (argument_1),
mAddedNonterminalmSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_T_repeatInstruction_forGrammarComponent::isBuilt (void) const {
  return mStartLocation.isBuilt () &&
       mRepeatList.isBuilt () &&
       mAddedNonterminalmSymbolIndex.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_T_repeatInstruction_forGrammarComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_T_repeatInstruction_forGrammarComponent * GGS_T_repeatInstruction_forGrammarComponent::
    constructor_new (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2) {
    cPtr_T_repeatInstruction_forGrammarComponent * ptr_ = (cPtr_T_repeatInstruction_forGrammarComponent *) NULL ;
    macroMyNew (ptr_, cPtr_T_repeatInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//          Class element of list 'L_syntaxComponents_ForGrammar'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::element_type::
element_type (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_string_set& argument_2,
                                const GGS_lstring & argument_3) {
  mNextItem = (element_type *) NULL ;
  mNonterminalSymbolsMap = argument_0 ;
  mProductionRulesList = argument_1 ;
  mClassesNamesSet = argument_2 ;
  mSyntaxComponentName = argument_3 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class list 'L_syntaxComponents_ForGrammar'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar
::GGS_L_syntaxComponents_ForGrammar (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::~GGS_L_syntaxComponents_ForGrammar (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::GGS_L_syntaxComponents_ForGrammar (const GGS_L_syntaxComponents_ForGrammar & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar
::operator = (const GGS_L_syntaxComponents_ForGrammar & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
internalAppendItem (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_string_set& argument_2,
                                const GGS_lstring & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
addAssign_operation (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_string_set& argument_2,
                                const GGS_lstring & argument_3) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()
                 && argument_2.isBuilt ()
                 && argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mNonterminalSymbolsMap,
                                p->mProductionRulesList,
                                p->mClassesNamesSet,
                                p->mSyntaxComponentName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar  GGS_L_syntaxComponents_ForGrammar::
constructor_empty (void) {
  GGS_L_syntaxComponents_ForGrammar result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Class element of list 'L_identifiers'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_identifiers::element_type::
element_type (const GGS_lstring & argument_0) {
  mNextItem = (element_type *) NULL ;
  aIdentificateur = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class list 'L_identifiers'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_identifiers
::GGS_L_identifiers (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_identifiers::~GGS_L_identifiers (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_identifiers::GGS_L_identifiers (const GGS_L_identifiers & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers
::operator = (const GGS_L_identifiers & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aIdentificateur) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_identifiers  GGS_L_identifiers::
constructor_empty (void) {
  GGS_L_identifiers result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'typeSuperClassesMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeSuperClassesMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeSuperClassesMap::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_typeSuperClassesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeSuperClassesMap * info = (e_typeSuperClassesMap *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeSuperClassesMap::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_typeSuperClassesMap::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::constructor_empty (void) {
  GGS_typeSuperClassesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSuperClassesMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
     insulateMap () ;
    e_typeSuperClassesMap info  ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void insertKey_typeSuperClassesMap (C_lexique & lexique_var_,
                                GGS_typeSuperClassesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the class '",
                                   "",
                                   "' is already a super class of the current class",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeClassInheritedMessagesMap'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeClassInheritedMessagesMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassInheritedMessagesMap::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_typeClassInheritedMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeClassInheritedMessagesMap * info = (e_typeClassInheritedMessagesMap *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeClassInheritedMessagesMap::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_typeClassInheritedMessagesMap::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::constructor_empty (void) {
  GGS_typeClassInheritedMessagesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassInheritedMessagesMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
     insulateMap () ;
    e_typeClassInheritedMessagesMap info  ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeClassInheritedMessagesMap (C_lexique & inLexique,
                                GGS_typeClassInheritedMessagesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the message '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeClassInheritedMessagesMap (C_lexique & lexique_var_,
                                GGS_typeClassInheritedMessagesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the message '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'typeSemanticAttributesMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeSemanticAttributesMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeSemanticAttributesMap::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_typeSemanticAttributesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeSemanticAttributesMap * info = (e_typeSemanticAttributesMap *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeSemanticAttributesMap::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_typeSemanticAttributesMap::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::constructor_empty (void) {
  GGS_typeSemanticAttributesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSemanticAttributesMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_AC_galgasType &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_typeSemanticAttributesMap info  ;
    info.mAttributType = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_AC_galgasType   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mAttributType ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeSemanticAttributesMap (C_lexique & inLexique,
                                GGS_typeSemanticAttributesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"there is no attribut named '",
                                   "",
                                   "'",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeSemanticAttributesMap (C_lexique & lexique_var_,
                                GGS_typeSemanticAttributesMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"an attribut named '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class map 'typeTableMethodesInsererChercher'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableMethodesInsererChercher::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableMethodesInsererChercher & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableMethodesInsererChercher::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_typeTableMethodesInsererChercher *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeTableMethodesInsererChercher * info = (e_typeTableMethodesInsererChercher *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeTableMethodesInsererChercher::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_typeTableMethodesInsererChercher::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodesInsererChercher GGS_typeTableMethodesInsererChercher::constructor_empty (void) {
  GGS_typeTableMethodesInsererChercher result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMethodesInsererChercher::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesInsererChercher::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesInsererChercher::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_L_stringList &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_typeTableMethodesInsererChercher info  ;
    info.mErrorMessageList = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesInsererChercher::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_L_stringList   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mErrorMessageList ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeTableMethodesInsererChercher (C_lexique & inLexique,
                                GGS_typeTableMethodesInsererChercher & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_stringList   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"there is no method named '",
                                   "",
                                   "'",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeTableMethodesInsererChercher (C_lexique & lexique_var_,
                                GGS_typeTableMethodesInsererChercher & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_stringList & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"a method named '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeDefEntiteUtilisable'                *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable
::static_string_message_messageTypeEntite (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable::
message_messageTypeEntite (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeDefEntiteUtilisable'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (void) {
  mPointer = (cPtr_typeDefEntiteUtilisable *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (const GGS_typeDefEntiteUtilisable & inOperand) {
  mPointer = (cPtr_typeDefEntiteUtilisable *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
~GGS_typeDefEntiteUtilisable (void) {
  macroDetachPointer (mPointer, cPtr_typeDefEntiteUtilisable) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefEntiteUtilisable::
operator = (const GGS_typeDefEntiteUtilisable & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeDefEntiteUtilisable::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefEntiteUtilisable::
operator = (cPtr_typeDefEntiteUtilisable * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (cPtr_typeDefEntiteUtilisable * inSource) {
  mPointer = (cPtr_typeDefEntiteUtilisable *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeDefEntiteUtilisable * GGS_typeDefEntiteUtilisable
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDefEntiteUtilisable::reader_messageTypeEntite (void) const {
  return GGS_string (mPointer != NULL, C_string ((mPointer == NULL) ? "" : mPointer->message_messageTypeEntite ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefEntiteUtilisable
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeDefEntiteUtilisable) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgasSetType'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasSetType::cPtr_typeGalgasSetType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_AC_galgasType & argument_2)
:mSetTypeName (argument_0),
mEnumElementTypeName (argument_1),
mEnumType (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasSetType::isBuilt (void) const {
  return mSetTypeName.isBuilt () &&
       mEnumElementTypeName.isBuilt () &&
       mEnumType.isBuilt () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSetType::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mSetTypeName.reader_value () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSetType::
methode_handleConstructorCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This class method is not defined")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSetType::
methode_handleModifierCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_signature & var_cas_outModifierSignature) {
  if (((var_cas_inModifierName.reader_value ()) == (GGS_string (true, "add"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_signature::constructor_empty () ;
    var_cas_outModifierSignature.addAssign_operation (mEnumType, GGS_formalArgumentPassingMode::constructor_argumentIn ()) ;
  }else{
      var_cas_inModifierName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support modifier call")) ;
  }
}


const char * cPtr_typeGalgasSetType::message_messageGalgasType (void) const {
  return "set type" ;
}

const char * cPtr_typeGalgasSetType::static_string_message_messageGalgasType (void) {
  return "set type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgasSetType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasSetType * GGS_typeGalgasSetType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_AC_galgasType & argument_2) {
    cPtr_typeGalgasSetType * ptr_ = (cPtr_typeGalgasSetType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasSetType (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeGalgasUndefinedListType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedListType::cPtr_typeGalgasUndefinedListType (const GGS_lstring & argument_0)
:mListTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedListType::isBuilt (void) const {
  return mListTypeName.isBuilt () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedListType::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mListTypeName.reader_value () ;
}


const char * cPtr_typeGalgasUndefinedListType::message_messageGalgasType (void) const {
  return "undefined 'list' type" ;
}

const char * cPtr_typeGalgasUndefinedListType::static_string_message_messageGalgasType (void) {
  return "undefined 'list' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedListType'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasUndefinedListType * GGS_typeGalgasUndefinedListType::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeGalgasUndefinedListType * ptr_ = (cPtr_typeGalgasUndefinedListType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedListType (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgasListType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasListType::cPtr_typeGalgasListType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1)
:cPtr_typeGalgasUndefinedListType (argument_0),
mNonExternAttributesList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasListType::isBuilt (void) const {
  return mListTypeName.isBuilt () &&
       mNonExternAttributesList.isBuilt () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
methode_handleAddAssignOperatorCall (C_lexique & /* lexique_var_ */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList,
                                GGS_bool& var_cas_outAccept_luint_assignment) {
  var_cas_outParametersList = mNonExternAttributesList ;
  var_cas_outAccept_luint_assignment = GGS_bool (true, false) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
methode_handleConstructorCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}


const char * cPtr_typeGalgasListType::message_messageGalgasType (void) const {
  return "'list' type" ;
}

const char * cPtr_typeGalgasListType::static_string_message_messageGalgasType (void) {
  return "'list' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasListType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasListType * GGS_typeGalgasListType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1) {
    cPtr_typeGalgasListType * ptr_ = (cPtr_typeGalgasListType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasListType (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'typeTableBlocsDeTable'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableBlocsDeTable & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableBlocsDeTable::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_typeTableBlocsDeTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeTableBlocsDeTable * info = (e_typeTableBlocsDeTable *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeTableBlocsDeTable::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_typeTableBlocsDeTable::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::constructor_empty (void) {
  GGS_typeTableBlocsDeTable result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableBlocsDeTable::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_L_signature &  inParameter0,
               const GGS_L_signature &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()
                 && inParameter1.isBuilt ()) {
     insulateMap () ;
    e_typeTableBlocsDeTable info  ;
    info.aSignatureDebut = inParameter0 ;
    info.aSignatureFin = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_L_signature   * outParameter0,
               GGS_L_signature   * outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.aSignatureDebut ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = node->mInfo.aSignatureFin ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeTableBlocsDeTable (C_lexique & inLexique,
                                GGS_typeTableBlocsDeTable & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_signature   * outParameter0,
                                GGS_L_signature   * outParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"there is no block method named '",
                                   "",
                                   "'",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outParameter1,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeTableBlocsDeTable (C_lexique & lexique_var_,
                                GGS_typeTableBlocsDeTable & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0,
                                const GGS_L_signature & inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"a block method named '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       inParameter1,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeGalgasUndefinedMapType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedMapType::cPtr_typeGalgasUndefinedMapType (const GGS_lstring & argument_0)
:mMapTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedMapType::isBuilt (void) const {
  return mMapTypeName.isBuilt () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapType::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mMapTypeName.reader_value () ;
}


const char * cPtr_typeGalgasUndefinedMapType::message_messageGalgasType (void) const {
  return "undefined 'map' type" ;
}

const char * cPtr_typeGalgasUndefinedMapType::static_string_message_messageGalgasType (void) {
  return "undefined 'map' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedMapType'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasUndefinedMapType * GGS_typeGalgasUndefinedMapType::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeGalgasUndefinedMapType * ptr_ = (cPtr_typeGalgasUndefinedMapType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedMapType (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeGalgasMapType'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasMapType::cPtr_typeGalgasMapType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodesInsererChercher & argument_2,
                                const GGS_typeTableMethodesInsererChercher & argument_3,
                                const GGS_typeTableBlocsDeTable & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_AC_galgasType & argument_6)
:cPtr_typeGalgasUndefinedMapType (argument_0),
mNonExternAttributesList (argument_1),
aTableMethodesInserer (argument_2),
aTableMethodesChercher (argument_3),
aTableMethodesSurcharger (argument_4),
mKeyTypeName (argument_5),
mKeyType (argument_6) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasMapType::isBuilt (void) const {
  return mMapTypeName.isBuilt () &&
       mNonExternAttributesList.isBuilt () &&
       aTableMethodesInserer.isBuilt () &&
       aTableMethodesChercher.isBuilt () &&
       aTableMethodesSurcharger.isBuilt () &&
       mKeyTypeName.isBuilt () &&
       mKeyType.isBuilt () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
methode_handleConstructorCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This constructor is not defined")) ;
  }
}


const char * cPtr_typeGalgasMapType::message_messageGalgasType (void) const {
  return "'map' type" ;
}

const char * cPtr_typeGalgasMapType::static_string_message_messageGalgasType (void) {
  return "'map' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgasMapType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasMapType * GGS_typeGalgasMapType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodesInsererChercher & argument_2,
                                const GGS_typeTableMethodesInsererChercher & argument_3,
                                const GGS_typeTableBlocsDeTable & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_AC_galgasType & argument_6) {
    cPtr_typeGalgasMapType * ptr_ = (cPtr_typeGalgasMapType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasMapType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeGalgasUndefinedClassType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedClassType::cPtr_typeGalgasUndefinedClassType (const GGS_lstring & argument_0)
:mClassTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedClassType::isBuilt (void) const {
  return mClassTypeName.isBuilt () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedClassType::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mClassTypeName.reader_value () ;
}


const char * cPtr_typeGalgasUndefinedClassType::message_messageGalgasType (void) const {
  return "undefined 'class' type" ;
}

const char * cPtr_typeGalgasUndefinedClassType::static_string_message_messageGalgasType (void) {
  return "undefined 'class' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedClassType'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasUndefinedClassType * GGS_typeGalgasUndefinedClassType::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeGalgasUndefinedClassType * ptr_ = (cPtr_typeGalgasUndefinedClassType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasUndefinedClassType (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeGalgasClassType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasClassType::cPtr_typeGalgasClassType (const GGS_lstring & argument_0,
                                const GGS_typeTableMethodes & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeSuperClassesMap & argument_3,
                                const GGS_typeClassInheritedMessagesMap & argument_4,
                                const GGS_typeSemanticAttributesMap & argument_5,
                                const GGS_bool& argument_6)
:cPtr_typeGalgasUndefinedClassType (argument_0),
mMethodsMap (argument_1),
mNonExternAttributesList (argument_2),
mAncestorClassesMap (argument_3),
mMessagesMap (argument_4),
mNonExternAttributesMap (argument_5),
mClassIsAbstract (argument_6) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasClassType::isBuilt (void) const {
  return mClassTypeName.isBuilt () &&
       mMethodsMap.isBuilt () &&
       mNonExternAttributesList.isBuilt () &&
       mAncestorClassesMap.isBuilt () &&
       mMessagesMap.isBuilt () &&
       mNonExternAttributesMap.isBuilt () &&
       mClassIsAbstract.isBuilt () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
methode_typeCanBeUsedInObjectDeclaration (C_lexique & lexique_var_) {
  if (((! mClassIsAbstract)).isBuiltAndTrue ()) {
      GGS_location (lexique_var_).reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "non abstract class object cannot be declared (only instancied by 'new')")) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
methode_handleReaderInstructionCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_L_signature & var_cas_outMethodSignature) {
  GGS_typeTableMethodes  var_cas_methodMap ;
  var_cas_methodMap = mMethodsMap ;
  searchKey_typeTableMethodes (lexique_var_,
                                  var_cas_methodMap,
                                  var_cas_inMethodName,
                                  & var_cas_outMethodSignature,
                                  NULL) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
methode_handleConstructorCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  if ((mClassIsAbstract).isBuiltAndTrue ()) {
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "an abstract class cannot be instancied")) ;
  }else if (((var_cas_inClassMethodName.reader_value ()) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = mNonExternAttributesList ;
  }else{
      var_cas_inClassMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "This class method is not defined")) ;
  }
}


const char * cPtr_typeGalgasClassType::message_messageGalgasType (void) const {
  return "'class' type" ;
}

const char * cPtr_typeGalgasClassType::static_string_message_messageGalgasType (void) {
  return "'class' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasClassType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgasClassType * GGS_typeGalgasClassType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeTableMethodes & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeSuperClassesMap & argument_3,
                                const GGS_typeClassInheritedMessagesMap & argument_4,
                                const GGS_typeSemanticAttributesMap & argument_5,
                                const GGS_bool& argument_6) {
    cPtr_typeGalgasClassType * ptr_ = (cPtr_typeGalgasClassType *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgasClassType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEntiteType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteType::cPtr_typeEntiteType (const GGS_AC_galgasType & argument_0)
:aDefType (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteType::isBuilt (void) const {
  return aDefType.isBuilt () ;
}


const char * cPtr_typeEntiteType::message_messageTypeEntite (void) const {
  return "a type" ;
}

const char * cPtr_typeEntiteType::static_string_message_messageTypeEntite (void) {
  return "a type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEntiteType * GGS_typeEntiteType::
    constructor_new (const GGS_AC_galgasType & argument_0) {
    cPtr_typeEntiteType * ptr_ = (cPtr_typeEntiteType *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteType (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeEntiteRoutine'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteRoutine::cPtr_typeEntiteRoutine (const GGS_L_signature & argument_0)
:aListeArgumentsFormels (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteRoutine::isBuilt (void) const {
  return aListeArgumentsFormels.isBuilt () ;
}


const char * cPtr_typeEntiteRoutine::message_messageTypeEntite (void) const {
  return "a routine" ;
}

const char * cPtr_typeEntiteRoutine::static_string_message_messageTypeEntite (void) {
  return "a routine" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeEntiteRoutine'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEntiteRoutine * GGS_typeEntiteRoutine::
    constructor_new (const GGS_L_signature & argument_0) {
    cPtr_typeEntiteRoutine * ptr_ = (cPtr_typeEntiteRoutine *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteRoutine (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               class map 'typeTableUtilisationsSemantiques'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableUtilisationsSemantiques::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableUtilisationsSemantiques & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableUtilisationsSemantiques::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_typeTableUtilisationsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeTableUtilisationsSemantiques * info = (e_typeTableUtilisationsSemantiques *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeTableUtilisationsSemantiques::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_typeTableUtilisationsSemantiques::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableUtilisationsSemantiques GGS_typeTableUtilisationsSemantiques::constructor_empty (void) {
  GGS_typeTableUtilisationsSemantiques result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableUtilisationsSemantiques::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableUtilisationsSemantiques::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableUtilisationsSemantiques::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
     insulateMap () ;
    e_typeTableUtilisationsSemantiques info  ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableUtilisationsSemantiques::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void insertKey_typeTableUtilisationsSemantiques (C_lexique & lexique_var_,
                                GGS_typeTableUtilisationsSemantiques & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"--- internal error ---",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'typeEnumConstantesMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEnumConstantesMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumConstantesMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumConstantesMap::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_typeEnumConstantesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeEnumConstantesMap * info = (e_typeEnumConstantesMap *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeEnumConstantesMap::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_typeEnumConstantesMap::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumConstantesMap GGS_typeEnumConstantesMap::constructor_empty (void) {
  GGS_typeEnumConstantesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumConstantesMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumConstantesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumConstantesMap::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
     insulateMap () ;
    e_typeEnumConstantesMap info  ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumConstantesMap::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeEnumConstantesMap (C_lexique & inLexique,
                                GGS_typeEnumConstantesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' constant is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeEnumConstantesMap (C_lexique & lexique_var_,
                                GGS_typeEnumConstantesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' constant is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'typeEnumMessageMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumMessageMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumMessageMap::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_typeEnumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeEnumMessageMap * info = (e_typeEnumMessageMap *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeEnumMessageMap::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_typeEnumMessageMap::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::constructor_empty (void) {
  GGS_typeEnumMessageMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumMessageMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_L_lstringList &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_typeEnumMessageMap info  ;
    info.mMessageStringList = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_L_lstringList   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mMessageStringList ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeEnumMessageMap (C_lexique & inLexique,
                                GGS_typeEnumMessageMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_L_lstringList   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' message name is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeEnumMessageMap (C_lexique & lexique_var_,
                                GGS_typeEnumMessageMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_lstringList & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' message name is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeGalgas_enum'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_enum::cPtr_typeGalgas_enum (const GGS_lstring & argument_0,
                                const GGS_typeEnumConstantesMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2)
:mEnumTypeName (argument_0),
mEnumConstantesMap (argument_1),
mMessagesMap (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_enum::isBuilt (void) const {
  return mEnumTypeName.isBuilt () &&
       mEnumConstantesMap.isBuilt () &&
       mMessagesMap.isBuilt () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
methode_getTypeName (C_lexique & /* lexique_var_ */,
                                GGS_string& var_cas_outTypeName) {
  var_cas_outTypeName = mEnumTypeName.reader_value () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
methode_handleConstructorCall (C_lexique & lexique_var_,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList) {
  GGS_typeEnumConstantesMap  var_cas_enumConstantesMap ;
  var_cas_enumConstantesMap = mEnumConstantesMap ;
  searchKey_typeEnumConstantesMap (lexique_var_,
                                  var_cas_enumConstantesMap,
                                  var_cas_inClassMethodName,
                                  NULL) ;
  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
}


const char * cPtr_typeGalgas_enum::message_messageGalgasType (void) const {
  return "a 'enum' type" ;
}

const char * cPtr_typeGalgas_enum::static_string_message_messageGalgasType (void) {
  return "a 'enum' type" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_enum'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeGalgas_enum * GGS_typeGalgas_enum::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeEnumConstantesMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2) {
    cPtr_typeGalgas_enum * ptr_ = (cPtr_typeGalgas_enum *) NULL ;
    macroMyNew (ptr_, cPtr_typeGalgas_enum (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//    Implementation of routine "verifierCompatibiliteTypesSemantiques"      *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteTypesSemantiques (C_lexique & lexique_var_,
                                const GGS_AC_galgasType  & var_cas_inFormalType,
                                const GGS_AC_galgasType  & var_cas_inEffectiveType,
                                const GGS_location  & var_cas_inErrorLocation) {
  if (var_cas_inFormalType.isBuilt () && var_cas_inEffectiveType.isBuilt ()) {
    cPtr_AC_galgasType * ptr_58379 = var_cas_inFormalType () ;
    cPtr_AC_galgasType * ptr_58398 = var_cas_inEffectiveType () ;
    cPtr_typeGalgas_uint * operand_58379 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_58379) ;
    cPtr_typeGalgas_uint * operand_58398 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_58398) ;
    if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
    }else{
      cPtr_typeGalgas_sint * operand_58379 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_58379) ;
      cPtr_typeGalgas_sint * operand_58398 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_58398) ;
      if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
      }else{
        cPtr_typeGalgas_char * operand_58379 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_58379) ;
        cPtr_typeGalgas_char * operand_58398 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_58398) ;
        if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
        }else{
          cPtr_typeGalgas_string * operand_58379 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_58379) ;
          cPtr_typeGalgas_string * operand_58398 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_58398) ;
          if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
          }else{
            cPtr_typeGalgas_bool * operand_58379 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_58379) ;
            cPtr_typeGalgas_bool * operand_58398 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_58398) ;
            if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
            }else{
              cPtr_typeGalgas_dfloat * operand_58379 = dynamic_cast <cPtr_typeGalgas_dfloat *> (ptr_58379) ;
              cPtr_typeGalgas_dfloat * operand_58398 = dynamic_cast <cPtr_typeGalgas_dfloat *> (ptr_58398) ;
              if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
              }else{
                cPtr_typeGalgas_lbool * operand_58379 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_58379) ;
                cPtr_typeGalgas_lbool * operand_58398 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_58398) ;
                if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
                }else{
                  cPtr_typeGalgas_lchar * operand_58379 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_58379) ;
                  cPtr_typeGalgas_lchar * operand_58398 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_58398) ;
                  if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
                  }else{
                    cPtr_typeGalgas_luint * operand_58379 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_58379) ;
                    cPtr_typeGalgas_luint * operand_58398 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_58398) ;
                    if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
                    }else{
                      cPtr_typeGalgas_lsint * operand_58379 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_58379) ;
                      cPtr_typeGalgas_lsint * operand_58398 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_58398) ;
                      if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
                      }else{
                        cPtr_typeGalgas_ldfloat * operand_58379 = dynamic_cast <cPtr_typeGalgas_ldfloat *> (ptr_58379) ;
                        cPtr_typeGalgas_ldfloat * operand_58398 = dynamic_cast <cPtr_typeGalgas_ldfloat *> (ptr_58398) ;
                        if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
                        }else{
                          cPtr_typeGalgas_lstring * operand_58379 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_58379) ;
                          cPtr_typeGalgas_lstring * operand_58398 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_58398) ;
                          if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
                          }else{
                            cPtr_typeGalgas_location * operand_58379 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_58379) ;
                            cPtr_typeGalgas_location * operand_58398 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_58398) ;
                            if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
                            }else{
                              cPtr_typeGalgasUndefinedListType * operand_58379 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_58379) ;
                              cPtr_typeGalgasUndefinedListType * operand_58398 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_58398) ;
                              if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
                                if (((operand_58379->mListTypeName.reader_value ()) != (operand_58398->mListTypeName.reader_value ())).isBuiltAndTrue ()) {
                                    var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting the list type '")) + (operand_58379->mListTypeName.reader_value ()))) + (GGS_string (true, "', I have got the list type '")))) + (operand_58398->mListTypeName.reader_value ()))) + (GGS_string (true, "\"")))) ;
                                }
                              }else{
                                cPtr_typeGalgasUndefinedMapType * operand_58379 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_58379) ;
                                cPtr_typeGalgasUndefinedMapType * operand_58398 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_58398) ;
                                if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
                                  if (((operand_58379->mMapTypeName.reader_value ()) != (operand_58398->mMapTypeName.reader_value ())).isBuiltAndTrue ()) {
                                      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting the map type '")) + (operand_58379->mMapTypeName.reader_value ()))) + (GGS_string (true, "', I have got the map type '")))) + (operand_58398->mMapTypeName.reader_value ()))) + (GGS_string (true, "\"")))) ;
                                  }
                                }else{
                                  cPtr_typeGalgasUndefinedClassType * operand_58379 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_58379) ;
                                  cPtr_typeGalgasUndefinedClassType * operand_58398 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_58398) ;
                                  if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
                                    if (((operand_58379->mClassTypeName.reader_value ()) != (operand_58398->mClassTypeName.reader_value ())).isBuiltAndTrue ()) {
                                        var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting the class type '")) + (operand_58379->mClassTypeName.reader_value ()))) + (GGS_string (true, "', I have got the class type '")))) + (operand_58398->mClassTypeName.reader_value ()))) + (GGS_string (true, "\"")))) ;
                                    }
                                  }else{
                                    cPtr_typeGalgasUndefinedExternType * operand_58379 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_58379) ;
                                    cPtr_typeGalgasUndefinedExternType * operand_58398 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_58398) ;
                                    if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
                                      if (((operand_58379->mGalgasClassName.reader_value ()) != (operand_58398->mGalgasClassName.reader_value ())).isBuiltAndTrue ()) {
                                          var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting an extern variable of extern '")) + (operand_58379->mGalgasClassName.reader_value ()))) + (GGS_string (true, "' type variable, and I got an extern '")))) + (operand_58398->mGalgasClassName.reader_value ()))) + (GGS_string (true, "' type variable")))) ;
                                      }
                                    }else{
                                      cPtr_typeGalgas_enum * operand_58379 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_58379) ;
                                      cPtr_typeGalgas_enum * operand_58398 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_58398) ;
                                      if ((operand_58379 != NULL) && (operand_58398 != NULL)) {
                                        if (((operand_58379->mEnumTypeName.reader_value ()) != (operand_58398->mEnumTypeName.reader_value ())).isBuiltAndTrue ()) {
                                            var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting an enum variable of  '")) + (operand_58379->mEnumTypeName.reader_value ()))) + (GGS_string (true, "' type variable, and I got an enum '")))) + (operand_58398->mEnumTypeName.reader_value ()))) + (GGS_string (true, "' type variable")))) ;
                                        }
                                      }else{
                                          var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((var_cas_inFormalType.reader_messageGalgasType ()) + (GGS_string (true, " is not compatible with ")))) + (var_cas_inEffectiveType.reader_messageGalgasType ()))) ;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of routine "verifierCompatibiliteSignatures"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteSignatures (C_lexique & lexique_var_,
                                GGS_L_signature   var_cas_signatureReference,
                                GGS_L_signature   var_cas_signatureTestee,
                                GGS_location   var_cas_ouSignalerErreur) {
  if (((var_cas_signatureReference.reader_length ()) < (var_cas_signatureTestee.reader_length ())).isBuiltAndTrue ()) {
      var_cas_ouSignalerErreur.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "there are too much parameters")) ;
  }else if (((var_cas_signatureReference.reader_length ()) > (var_cas_signatureTestee.reader_length ())).isBuiltAndTrue ()) {
      var_cas_ouSignalerErreur.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "one or more parameters missing")) ;
  }else{
    GGS_L_signature::element_type * operand_62146 = var_cas_signatureReference.getFirstItem () ;
    GGS_L_signature::element_type * operand_62234 = var_cas_signatureTestee.getFirstItem () ;
    while ((operand_62146 != NULL) && (operand_62234 != NULL)) {
      macroValidPointer (operand_62146) ;
      macroValidPointer (operand_62234) ;
      ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  operand_62146->mType,  operand_62234->mType,  var_cas_ouSignalerErreur) ;
      if (((operand_62146->mFormalArgumentPassingMode) != (operand_62234->mFormalArgumentPassingMode)).isBuiltAndTrue ()) {
          var_cas_ouSignalerErreur.reader_location ().signalGGSSemanticError (lexique_var_, ((((operand_62234->mFormalArgumentPassingMode.reader_formalArgumentMessage ()) + (GGS_string (true, " is not compatible with ")))) + (operand_62234->mFormalArgumentPassingMode.reader_formalArgumentMessage ()))) ;
      }
      operand_62146 = operand_62146->getNextItem () ;
      operand_62234 = operand_62234->getNextItem () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'M_cli_options'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_cli_options::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_cli_options & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_cli_options::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_cli_options *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_cli_options * info = (e_M_cli_options *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_cli_options::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_cli_options::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::constructor_empty (void) {
  GGS_M_cli_options result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_cli_options::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_lchar &  inParameter0,
               const GGS_lstring &  inParameter1,
               const GGS_lstring &  inParameter2,
               const GGS_uint &  inParameter3,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()
                 && inParameter1.isBuilt ()
                 && inParameter2.isBuilt ()
                 && inParameter3.isBuilt ()) {
     insulateMap () ;
    e_M_cli_options info  ;
    info.mOptionChar = inParameter0 ;
    info.mOptionString = inParameter1 ;
    info.mComment = inParameter2 ;
    info.mDefaultValue = inParameter3 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_lchar   * outParameter0,
               GGS_lstring   * outParameter1,
               GGS_lstring   * outParameter2,
               GGS_uint   * outParameter3,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outParameter2 != NULL) {
      outParameter2->drop_operation () ;
    }
    if (outParameter3 != NULL) {
      outParameter3->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mOptionChar ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = node->mInfo.mOptionString ;
    }
    if (outParameter2 != NULL) {
      * outParameter2 = node->mInfo.mComment ;
    }
    if (outParameter3 != NULL) {
      * outParameter3 = node->mInfo.mDefaultValue ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_cli_options (C_lexique & inLexique,
                                GGS_M_cli_options & ioMap,
                                const GGS_lstring & inKey,
                                GGS_lchar   * outParameter0,
                                GGS_lstring   * outParameter1,
                                GGS_lstring   * outParameter2,
                                GGS_uint   * outParameter3,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' command line option is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outParameter1,
                       outParameter2,
                       outParameter3,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_cli_options (C_lexique & lexique_var_,
                                GGS_M_cli_options & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_lchar & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_lstring & inParameter2,
                                const GGS_uint & inParameter3,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' command line option has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       inParameter1,
                       inParameter2,
                       inParameter3,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'M_optionComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_optionComponents::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_optionComponents & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_optionComponents::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_optionComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_optionComponents * info = (e_M_optionComponents *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_optionComponents::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_optionComponents::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::constructor_empty (void) {
  GGS_M_optionComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_optionComponents::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_M_cli_options &  inParameter0,
               const GGS_M_cli_options &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()
                 && inParameter1.isBuilt ()) {
     insulateMap () ;
    e_M_optionComponents info  ;
    info.mBoolOptionsMap = inParameter0 ;
    info.mUintOptionsMap = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_M_cli_options   * outParameter0,
               GGS_M_cli_options   * outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mBoolOptionsMap ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = node->mInfo.mUintOptionsMap ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_optionComponents (C_lexique & inLexique,
                                GGS_M_optionComponents & ioMap,
                                const GGS_lstring & inKey,
                                GGS_M_cli_options   * outParameter0,
                                GGS_M_cli_options   * outParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"there is no '",
                                   "",
                                   "' option component",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outParameter1,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_optionComponents (C_lexique & lexique_var_,
                                GGS_M_optionComponents & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_M_cli_options & inParameter0,
                                const GGS_M_cli_options & inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' option component named is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       inParameter1,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'M_semanticsComponents'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_semanticsComponents::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_semanticsComponents & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_semanticsComponents::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_semanticsComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_semanticsComponents * info = (e_M_semanticsComponents *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_semanticsComponents::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_semanticsComponents::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::constructor_empty (void) {
  GGS_M_semanticsComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_semanticsComponents::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_M_semanticsEntitiesForUse &  inParameter0,
               const GGS_M_optionComponents &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()
                 && inParameter1.isBuilt ()) {
     insulateMap () ;
    e_M_semanticsComponents info  ;
    info.mSemanticsEntitiesMap = inParameter0 ;
    info.mOptionsComponents = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_M_semanticsEntitiesForUse   * outParameter0,
               GGS_M_optionComponents   * outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mSemanticsEntitiesMap ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = node->mInfo.mOptionsComponents ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_semanticsComponents (C_lexique & inLexique,
                                GGS_M_semanticsComponents & ioMap,
                                const GGS_lstring & inKey,
                                GGS_M_semanticsEntitiesForUse   * outParameter0,
                                GGS_M_optionComponents   * outParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"there is no semantics component named '",
                                   "",
                                   "'",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outParameter1,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_semanticsComponents (C_lexique & lexique_var_,
                                GGS_M_semanticsComponents & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_M_semanticsEntitiesForUse & inParameter0,
                                const GGS_M_optionComponents & inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"a semantics component named '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       inParameter1,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'M_grammarComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_grammarComponents::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_grammarComponents & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_grammarComponents::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_grammarComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_grammarComponents * info = (e_M_grammarComponents *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_grammarComponents::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_grammarComponents::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::constructor_empty (void) {
  GGS_M_grammarComponents result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_grammarComponents::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAltsForGrammar &  inParameter0,
               const GGS_lstring &  inParameter1,
               const GGS_M_optionComponents &  inParameter2,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()
                 && inParameter1.isBuilt ()
                 && inParameter2.isBuilt ()) {
     insulateMap () ;
    e_M_grammarComponents info  ;
    info.mNonterminalSymbolParametersMap = inParameter0 ;
    info.mLexiqueName = inParameter1 ;
    info.mOptionsMap = inParameter2 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAltsForGrammar   * outParameter0,
               GGS_lstring   * outParameter1,
               GGS_M_optionComponents   * outParameter2,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outParameter2 != NULL) {
      outParameter2->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mNonterminalSymbolParametersMap ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = node->mInfo.mLexiqueName ;
    }
    if (outParameter2 != NULL) {
      * outParameter2 = node->mInfo.mOptionsMap ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_grammarComponents (C_lexique & inLexique,
                                GGS_M_grammarComponents & ioMap,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAltsForGrammar   * outParameter0,
                                GGS_lstring   * outParameter1,
                                GGS_M_optionComponents   * outParameter2,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' grammar component is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outParameter1,
                       outParameter2,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_grammarComponents (C_lexique & lexique_var_,
                                GGS_M_grammarComponents & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_M_optionComponents & inParameter2,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' grammar component has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       inParameter1,
                       inParameter2,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of routine "handleReaderCall"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleReaderCall (C_lexique & lexique_var_,
                                const GGS_AC_galgasType  & var_cas_inReceiverType,
                                const GGS_lstring  & var_cas_inMethodName,
                                GGS_typeListeAttributsSemantiques  & var_cas_outAccessorTypesList,
                                GGS_AC_galgasType  & var_cas_outReturnedType) {
  if (var_cas_inReceiverType.isBuilt ()) {
    if (dynamic_cast <cPtr_typeGalgas_string *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "fileExists"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "pathExtension"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "lastPathComponent"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "stringByDeletingPathExtension"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "stringByDeletingLastPathComponent"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_uint *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "sint"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_sint::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_lstring *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_lchar *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_char::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_lbool *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_luint *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_lsint *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_sint::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgas_ldfloat *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_dfloat::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgasListType *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "length"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "list supports only 'length' reader call")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgasMapType *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      cPtr_typeGalgasMapType * operand_71602 = dynamic_cast <cPtr_typeGalgasMapType *> (var_cas_inReceiverType.getPtr ()) ;
      macroValidPointer (operand_71602) ; 
      if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "hasKey"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outAccessorTypesList.addAssign_operation (operand_71602->mKeyType, GGS_lstring::constructor_new (GGS_string (true, ""), GGS_location (lexique_var_))) ;
        var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new () ;
      }else if (((var_cas_inMethodName.reader_value ()) == (GGS_string (true, "length"))).isBuiltAndTrue ()) {
        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
        var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new () ;
      }else{
          var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "this reader is not defined")) ;
      }
    }else if (dynamic_cast <cPtr_typeGalgasClassType *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      cPtr_typeGalgasClassType * operand_72214 = dynamic_cast <cPtr_typeGalgasClassType *> (var_cas_inReceiverType.getPtr ()) ;
      macroValidPointer (operand_72214) ; 
      GGS_typeClassInheritedMessagesMap  var_cas_messagesMap ;
      var_cas_messagesMap = operand_72214->mMessagesMap ;
      searchKey_typeClassInheritedMessagesMap (lexique_var_,
                                      var_cas_messagesMap,
                                      var_cas_inMethodName,
                                      NULL) ;
      var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
    }else if (dynamic_cast <cPtr_typeGalgas_enum *> (var_cas_inReceiverType.getPtr ()) != NULL) {
      cPtr_typeGalgas_enum * operand_72552 = dynamic_cast <cPtr_typeGalgas_enum *> (var_cas_inReceiverType.getPtr ()) ;
      macroValidPointer (operand_72552) ; 
      GGS_typeEnumMessageMap  var_cas_messagesMap ;
      var_cas_messagesMap = operand_72552->mMessagesMap ;
      searchKey_typeEnumMessageMap (lexique_var_,
                                      var_cas_messagesMap,
                                      var_cas_inMethodName,
                                      NULL,
                                      NULL) ;
      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_empty () ;
      var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new () ;
    }else{ // Else part
        var_cas_inMethodName.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "variables of this type do not support reader call")) ;
    }
  }
}

//---------------------------------------------------------------------------*

