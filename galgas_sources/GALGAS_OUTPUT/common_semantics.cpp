//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'common_semantics.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                     december 7th, 2006, at 18h21'41"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "common_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "common_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_lstringList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_lstringList::
elementOf_GGS_L_lstringList (const GGS_lstring & argument_0):
mString (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_lstringList::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_lstringList * _p = dynamic_cast <const elementOf_GGS_L_lstringList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mString == _p->mString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_lstringList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mString.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_lstringList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_lstringList::GGS_L_lstringList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_lstringList::
GGS_L_lstringList (const GGS_L_lstringList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_lstringList::
operator == (const GGS_L_lstringList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_lstringList::
operator != (const GGS_L_lstringList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
_addAssign_operation (const GGS_lstring & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_lstringList GGS_L_lstringList::
operator + (const GGS_L_lstringList & inOperand) const {
  GGS_L_lstringList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_lstringList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mString ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mString) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_lstringList  GGS_L_lstringList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_lstringList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_lstringList  GGS_L_lstringList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_lstringList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_lstringList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_lstringList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mString ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mString ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mString ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_lstringList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mString ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//           Class for 'actualParametersPassingMode' Enumeration             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator == (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator != (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator <= (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator >= (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator < (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
operator > (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParametersPassingMode::
reader_actualArgumentMessage (C_Lexique & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [4] = {"",
    "an output (!) actual parameter",
    "an output/input (!\?) actual parameter",
    "an input (\?) actual parameter"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParametersPassingMode::
reader_description (C_Lexique & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @actualParametersPassingMode" ;
  switch (mValue) {
case enum_parameterOut:
  s << " parameterOut>" ;
    break ;
case enum_parameterOutIn:
  s << " parameterOutIn>" ;
    break ;
case enum_parameterIn:
  s << " parameterIn>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Class for 'formalArgumentPassingMode' Enumeration              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator == (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator != (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator <= (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator >= (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator < (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
operator > (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingMode::
reader_formalArgumentMessage (C_Lexique & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "an input (\?) formal argument",
    "an output (!) formal argument",
    "an input/output (\?!) argument",
    "a constant input (\?\?) formal argument"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingMode::
reader_description (C_Lexique & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @formalArgumentPassingMode" ;
  switch (mValue) {
case enum_argumentIn:
  s << " argumentIn>" ;
    break ;
case enum_argumentOut:
  s << " argumentOut>" ;
    break ;
case enum_argumentInOut:
  s << " argumentInOut>" ;
    break ;
case enum_argumentConstantIn:
  s << " argumentConstantIn>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@L_signature'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_signature::
elementOf_GGS_L_signature (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1):
mFormalArgumentPassingMode (argument_0),
mGalgasTypeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_signature::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_signature * _p = dynamic_cast <const elementOf_GGS_L_signature *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mFormalArgumentPassingMode == _p->mFormalArgumentPassingMode).boolValue ()
         && (mGalgasTypeName == _p->mGalgasTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_signature::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGalgasTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@L_signature'                             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_signature::GGS_L_signature (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_signature::
GGS_L_signature (const GGS_L_signature & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_signature::
operator == (const GGS_L_signature & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_signature::
operator != (const GGS_L_signature & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
_internalAppendValues (const GGS_formalArgumentPassingMode& argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
_internalPrependValues (const GGS_formalArgumentPassingMode& argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
_addAssign_operation (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_signature GGS_L_signature::
operator + (const GGS_L_signature & inOperand) const {
  GGS_L_signature result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_signature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_formalArgumentPassingMode p_0 = p->mFormalArgumentPassingMode ;
          GGS_lstring  p_1 = p->mGalgasTypeName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_formalArgumentPassingMode& argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mFormalArgumentPassingMode,
                                _p->mGalgasTypeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_signature  GGS_L_signature::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_signature result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_signature  GGS_L_signature::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_formalArgumentPassingMode& argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_signature result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_signature::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_signature", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
method_first (C_Lexique & _inLexique,
              GGS_formalArgumentPassingMode& _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalArgumentPassingMode ;
    _out_1 = _p->mGalgasTypeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
method_last (C_Lexique & _inLexique,
             GGS_formalArgumentPassingMode& _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalArgumentPassingMode ;
    _out_1 = _p->mGalgasTypeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_formalArgumentPassingMode& _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalArgumentPassingMode ;
    _out_1 = _p->mGalgasTypeName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_signature::
modifier_popLast (C_Lexique & _inLexique,
                GGS_formalArgumentPassingMode& _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalArgumentPassingMode ;
    _out_1 = _p->mGalgasTypeName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@typeListModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListModel::
elementOf_GGS_typeListModel (const GGS_lstring & argument_0):
mTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListModel::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListModel * _p = dynamic_cast <const elementOf_GGS_typeListModel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mTypeName == _p->mTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListModel::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@typeListModel'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListModel::GGS_typeListModel (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeListModel::
GGS_typeListModel (const GGS_typeListModel & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListModel::
operator == (const GGS_typeListModel & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListModel::
operator != (const GGS_typeListModel & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
_addAssign_operation (const GGS_lstring & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListModel GGS_typeListModel::
operator + (const GGS_typeListModel & inOperand) const {
  GGS_typeListModel result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListModel * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTypeName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTypeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_typeListModel::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListModel result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_typeListModel::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListModel result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListModel", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListModel::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTypeName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_TypeModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_TypeModel::
cPtr_TypeModel (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_TypeModel * GGS_TypeModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_TypeModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@TypeModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_TypeModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_TypeModel::
GGS_TypeModel (const GGS_TypeModel & inOperand) {
  mPointer = (cPtr_TypeModel *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_TypeModel::
~GGS_TypeModel (void) {
  macroDetachPointer (mPointer, cPtr_TypeModel) ;
}

//---------------------------------------------------------------------------*

void GGS_TypeModel::
operator = (const GGS_TypeModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_TypeModel::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_TypeModel) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_TypeModel::
operator == (const GGS_TypeModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_TypeModel::
operator != (const GGS_TypeModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_TypeModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @TypeModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_BoolModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_BoolModel::
cPtr_BoolModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_BoolModel * GGS_BoolModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_BoolModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_BoolModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_BoolModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_BoolModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@BoolModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_BoolModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_BoolModel::
GGS_BoolModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_BoolModel::
GGS_BoolModel (const GGS_BoolModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_BoolModel::
~GGS_BoolModel (void) {
  macroDetachPointer (mPointer, cPtr_BoolModel) ;
}

//---------------------------------------------------------------------------*

void GGS_BoolModel::
operator = (const GGS_BoolModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_BoolModel GGS_BoolModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_BoolModel * _ptr = (cPtr_BoolModel *) NULL ;
  macroMyNew (_ptr, cPtr_BoolModel (THERE)) ;
  GGS_BoolModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_BoolModel::
operator == (const GGS_BoolModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_BoolModel::
operator != (const GGS_BoolModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_BoolModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @BoolModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_CharModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_CharModel::
cPtr_CharModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_CharModel * GGS_CharModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_CharModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_CharModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_CharModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_CharModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@CharModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_CharModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_CharModel::
GGS_CharModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_CharModel::
GGS_CharModel (const GGS_CharModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_CharModel::
~GGS_CharModel (void) {
  macroDetachPointer (mPointer, cPtr_CharModel) ;
}

//---------------------------------------------------------------------------*

void GGS_CharModel::
operator = (const GGS_CharModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_CharModel GGS_CharModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_CharModel * _ptr = (cPtr_CharModel *) NULL ;
  macroMyNew (_ptr, cPtr_CharModel (THERE)) ;
  GGS_CharModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_CharModel::
operator == (const GGS_CharModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_CharModel::
operator != (const GGS_CharModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_CharModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @CharModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_UIntModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_UIntModel::
cPtr_UIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_UIntModel * GGS_UIntModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_UIntModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_UIntModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_UIntModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_UIntModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@UIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_UIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_UIntModel::
GGS_UIntModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_UIntModel::
GGS_UIntModel (const GGS_UIntModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_UIntModel::
~GGS_UIntModel (void) {
  macroDetachPointer (mPointer, cPtr_UIntModel) ;
}

//---------------------------------------------------------------------------*

void GGS_UIntModel::
operator = (const GGS_UIntModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_UIntModel GGS_UIntModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_UIntModel * _ptr = (cPtr_UIntModel *) NULL ;
  macroMyNew (_ptr, cPtr_UIntModel (THERE)) ;
  GGS_UIntModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_UIntModel::
operator == (const GGS_UIntModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_UIntModel::
operator != (const GGS_UIntModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_UIntModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @UIntModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_SIntModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_SIntModel::
cPtr_SIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_SIntModel * GGS_SIntModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_SIntModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_SIntModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_SIntModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_SIntModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@SIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_SIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_SIntModel::
GGS_SIntModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_SIntModel::
GGS_SIntModel (const GGS_SIntModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_SIntModel::
~GGS_SIntModel (void) {
  macroDetachPointer (mPointer, cPtr_SIntModel) ;
}

//---------------------------------------------------------------------------*

void GGS_SIntModel::
operator = (const GGS_SIntModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_SIntModel GGS_SIntModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_SIntModel * _ptr = (cPtr_SIntModel *) NULL ;
  macroMyNew (_ptr, cPtr_SIntModel (THERE)) ;
  GGS_SIntModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_SIntModel::
operator == (const GGS_SIntModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_SIntModel::
operator != (const GGS_SIntModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_SIntModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @SIntModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_UInt64Model'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_UInt64Model::
cPtr_UInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_UInt64Model * GGS_UInt64Model::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_UInt64Model *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_UInt64Model *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_UInt64Model::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_UInt64Model::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@UInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_UInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_UInt64Model::
GGS_UInt64Model (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_UInt64Model::
GGS_UInt64Model (const GGS_UInt64Model & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_UInt64Model::
~GGS_UInt64Model (void) {
  macroDetachPointer (mPointer, cPtr_UInt64Model) ;
}

//---------------------------------------------------------------------------*

void GGS_UInt64Model::
operator = (const GGS_UInt64Model & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_UInt64Model GGS_UInt64Model::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_UInt64Model * _ptr = (cPtr_UInt64Model *) NULL ;
  macroMyNew (_ptr, cPtr_UInt64Model (THERE)) ;
  GGS_UInt64Model result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_UInt64Model::
operator == (const GGS_UInt64Model & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_UInt64Model::
operator != (const GGS_UInt64Model & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_UInt64Model::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @UInt64Model" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_SInt64Model'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_SInt64Model::
cPtr_SInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_SInt64Model * GGS_SInt64Model::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_SInt64Model *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_SInt64Model *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_SInt64Model::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_SInt64Model::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@SInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_SInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_SInt64Model::
GGS_SInt64Model (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_SInt64Model::
GGS_SInt64Model (const GGS_SInt64Model & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_SInt64Model::
~GGS_SInt64Model (void) {
  macroDetachPointer (mPointer, cPtr_SInt64Model) ;
}

//---------------------------------------------------------------------------*

void GGS_SInt64Model::
operator = (const GGS_SInt64Model & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_SInt64Model GGS_SInt64Model::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_SInt64Model * _ptr = (cPtr_SInt64Model *) NULL ;
  macroMyNew (_ptr, cPtr_SInt64Model (THERE)) ;
  GGS_SInt64Model result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_SInt64Model::
operator == (const GGS_SInt64Model & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_SInt64Model::
operator != (const GGS_SInt64Model & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_SInt64Model::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @SInt64Model" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_DoubleModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_DoubleModel::
cPtr_DoubleModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_DoubleModel * GGS_DoubleModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_DoubleModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_DoubleModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_DoubleModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_DoubleModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@DoubleModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_DoubleModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_DoubleModel::
GGS_DoubleModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_DoubleModel::
GGS_DoubleModel (const GGS_DoubleModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_DoubleModel::
~GGS_DoubleModel (void) {
  macroDetachPointer (mPointer, cPtr_DoubleModel) ;
}

//---------------------------------------------------------------------------*

void GGS_DoubleModel::
operator = (const GGS_DoubleModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_DoubleModel GGS_DoubleModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_DoubleModel * _ptr = (cPtr_DoubleModel *) NULL ;
  macroMyNew (_ptr, cPtr_DoubleModel (THERE)) ;
  GGS_DoubleModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_DoubleModel::
operator == (const GGS_DoubleModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_DoubleModel::
operator != (const GGS_DoubleModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_DoubleModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @DoubleModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_StringModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_StringModel::
cPtr_StringModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_StringModel * GGS_StringModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_StringModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_StringModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_StringModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_StringModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@StringModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_StringModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_StringModel::
GGS_StringModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_StringModel::
GGS_StringModel (const GGS_StringModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_StringModel::
~GGS_StringModel (void) {
  macroDetachPointer (mPointer, cPtr_StringModel) ;
}

//---------------------------------------------------------------------------*

void GGS_StringModel::
operator = (const GGS_StringModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_StringModel GGS_StringModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_StringModel * _ptr = (cPtr_StringModel *) NULL ;
  macroMyNew (_ptr, cPtr_StringModel (THERE)) ;
  GGS_StringModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_StringModel::
operator == (const GGS_StringModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_StringModel::
operator != (const GGS_StringModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_StringModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @StringModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_LBoolModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LBoolModel::
cPtr_LBoolModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LBoolModel * GGS_LBoolModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LBoolModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LBoolModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LBoolModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LBoolModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LBoolModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LBoolModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LBoolModel::
GGS_LBoolModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_LBoolModel::
GGS_LBoolModel (const GGS_LBoolModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LBoolModel::
~GGS_LBoolModel (void) {
  macroDetachPointer (mPointer, cPtr_LBoolModel) ;
}

//---------------------------------------------------------------------------*

void GGS_LBoolModel::
operator = (const GGS_LBoolModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LBoolModel GGS_LBoolModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_LBoolModel * _ptr = (cPtr_LBoolModel *) NULL ;
  macroMyNew (_ptr, cPtr_LBoolModel (THERE)) ;
  GGS_LBoolModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LBoolModel::
operator == (const GGS_LBoolModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LBoolModel::
operator != (const GGS_LBoolModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_LBoolModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @LBoolModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_LCharModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LCharModel::
cPtr_LCharModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LCharModel * GGS_LCharModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LCharModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LCharModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LCharModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LCharModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LCharModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LCharModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LCharModel::
GGS_LCharModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_LCharModel::
GGS_LCharModel (const GGS_LCharModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LCharModel::
~GGS_LCharModel (void) {
  macroDetachPointer (mPointer, cPtr_LCharModel) ;
}

//---------------------------------------------------------------------------*

void GGS_LCharModel::
operator = (const GGS_LCharModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LCharModel GGS_LCharModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_LCharModel * _ptr = (cPtr_LCharModel *) NULL ;
  macroMyNew (_ptr, cPtr_LCharModel (THERE)) ;
  GGS_LCharModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LCharModel::
operator == (const GGS_LCharModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LCharModel::
operator != (const GGS_LCharModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_LCharModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @LCharModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_LUIntModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LUIntModel::
cPtr_LUIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LUIntModel * GGS_LUIntModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LUIntModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LUIntModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LUIntModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LUIntModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LUIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LUIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LUIntModel::
GGS_LUIntModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_LUIntModel::
GGS_LUIntModel (const GGS_LUIntModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LUIntModel::
~GGS_LUIntModel (void) {
  macroDetachPointer (mPointer, cPtr_LUIntModel) ;
}

//---------------------------------------------------------------------------*

void GGS_LUIntModel::
operator = (const GGS_LUIntModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LUIntModel GGS_LUIntModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_LUIntModel * _ptr = (cPtr_LUIntModel *) NULL ;
  macroMyNew (_ptr, cPtr_LUIntModel (THERE)) ;
  GGS_LUIntModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LUIntModel::
operator == (const GGS_LUIntModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LUIntModel::
operator != (const GGS_LUIntModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_LUIntModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @LUIntModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_LSIntModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LSIntModel::
cPtr_LSIntModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LSIntModel * GGS_LSIntModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LSIntModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LSIntModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LSIntModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LSIntModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LSIntModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_LSIntModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LSIntModel::
GGS_LSIntModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_LSIntModel::
GGS_LSIntModel (const GGS_LSIntModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LSIntModel::
~GGS_LSIntModel (void) {
  macroDetachPointer (mPointer, cPtr_LSIntModel) ;
}

//---------------------------------------------------------------------------*

void GGS_LSIntModel::
operator = (const GGS_LSIntModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LSIntModel GGS_LSIntModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_LSIntModel * _ptr = (cPtr_LSIntModel *) NULL ;
  macroMyNew (_ptr, cPtr_LSIntModel (THERE)) ;
  GGS_LSIntModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LSIntModel::
operator == (const GGS_LSIntModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LSIntModel::
operator != (const GGS_LSIntModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_LSIntModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @LSIntModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_LUInt64Model'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LUInt64Model::
cPtr_LUInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LUInt64Model * GGS_LUInt64Model::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LUInt64Model *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LUInt64Model *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LUInt64Model::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LUInt64Model::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LUInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LUInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LUInt64Model::
GGS_LUInt64Model (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_LUInt64Model::
GGS_LUInt64Model (const GGS_LUInt64Model & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LUInt64Model::
~GGS_LUInt64Model (void) {
  macroDetachPointer (mPointer, cPtr_LUInt64Model) ;
}

//---------------------------------------------------------------------------*

void GGS_LUInt64Model::
operator = (const GGS_LUInt64Model & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LUInt64Model GGS_LUInt64Model::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_LUInt64Model * _ptr = (cPtr_LUInt64Model *) NULL ;
  macroMyNew (_ptr, cPtr_LUInt64Model (THERE)) ;
  GGS_LUInt64Model result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LUInt64Model::
operator == (const GGS_LUInt64Model & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LUInt64Model::
operator != (const GGS_LUInt64Model & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_LUInt64Model::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @LUInt64Model" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_LSInt64Model'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LSInt64Model::
cPtr_LSInt64Model (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LSInt64Model * GGS_LSInt64Model::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LSInt64Model *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LSInt64Model *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LSInt64Model::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LSInt64Model::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LSInt64Model:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LSInt64Model'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LSInt64Model::
GGS_LSInt64Model (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_LSInt64Model::
GGS_LSInt64Model (const GGS_LSInt64Model & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LSInt64Model::
~GGS_LSInt64Model (void) {
  macroDetachPointer (mPointer, cPtr_LSInt64Model) ;
}

//---------------------------------------------------------------------------*

void GGS_LSInt64Model::
operator = (const GGS_LSInt64Model & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LSInt64Model GGS_LSInt64Model::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_LSInt64Model * _ptr = (cPtr_LSInt64Model *) NULL ;
  macroMyNew (_ptr, cPtr_LSInt64Model (THERE)) ;
  GGS_LSInt64Model result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LSInt64Model::
operator == (const GGS_LSInt64Model & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LSInt64Model::
operator != (const GGS_LSInt64Model & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_LSInt64Model::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @LSInt64Model" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_LDoubleModel'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LDoubleModel::
cPtr_LDoubleModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LDoubleModel * GGS_LDoubleModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LDoubleModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LDoubleModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LDoubleModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LDoubleModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LDoubleModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LDoubleModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LDoubleModel::
GGS_LDoubleModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_LDoubleModel::
GGS_LDoubleModel (const GGS_LDoubleModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LDoubleModel::
~GGS_LDoubleModel (void) {
  macroDetachPointer (mPointer, cPtr_LDoubleModel) ;
}

//---------------------------------------------------------------------------*

void GGS_LDoubleModel::
operator = (const GGS_LDoubleModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LDoubleModel GGS_LDoubleModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_LDoubleModel * _ptr = (cPtr_LDoubleModel *) NULL ;
  macroMyNew (_ptr, cPtr_LDoubleModel (THERE)) ;
  GGS_LDoubleModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LDoubleModel::
operator == (const GGS_LDoubleModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LDoubleModel::
operator != (const GGS_LDoubleModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_LDoubleModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @LDoubleModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_LStringModel'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LStringModel::
cPtr_LStringModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LStringModel * GGS_LStringModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LStringModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LStringModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LStringModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LStringModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LStringModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LStringModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LStringModel::
GGS_LStringModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_LStringModel::
GGS_LStringModel (const GGS_LStringModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LStringModel::
~GGS_LStringModel (void) {
  macroDetachPointer (mPointer, cPtr_LStringModel) ;
}

//---------------------------------------------------------------------------*

void GGS_LStringModel::
operator = (const GGS_LStringModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LStringModel GGS_LStringModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_LStringModel * _ptr = (cPtr_LStringModel *) NULL ;
  macroMyNew (_ptr, cPtr_LStringModel (THERE)) ;
  GGS_LStringModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LStringModel::
operator == (const GGS_LStringModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LStringModel::
operator != (const GGS_LStringModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_LStringModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @LStringModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_StringsetModel'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_StringsetModel::
cPtr_StringsetModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_StringsetModel * GGS_StringsetModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_StringsetModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_StringsetModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_StringsetModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_StringsetModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@StringsetModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_StringsetModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_StringsetModel::
GGS_StringsetModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_StringsetModel::
GGS_StringsetModel (const GGS_StringsetModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_StringsetModel::
~GGS_StringsetModel (void) {
  macroDetachPointer (mPointer, cPtr_StringsetModel) ;
}

//---------------------------------------------------------------------------*

void GGS_StringsetModel::
operator = (const GGS_StringsetModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_StringsetModel GGS_StringsetModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_StringsetModel * _ptr = (cPtr_StringsetModel *) NULL ;
  macroMyNew (_ptr, cPtr_StringsetModel (THERE)) ;
  GGS_StringsetModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_StringsetModel::
operator == (const GGS_StringsetModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_StringsetModel::
operator != (const GGS_StringsetModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_StringsetModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @StringsetModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_LocationModel'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_LocationModel::
cPtr_LocationModel (LOCATION_ARGS)
:cPtr_TypeModel (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_LocationModel * GGS_LocationModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_LocationModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_LocationModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_LocationModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_LocationModel::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@LocationModel:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_LocationModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_LocationModel::
GGS_LocationModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_LocationModel::
GGS_LocationModel (const GGS_LocationModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LocationModel::
~GGS_LocationModel (void) {
  macroDetachPointer (mPointer, cPtr_LocationModel) ;
}

//---------------------------------------------------------------------------*

void GGS_LocationModel::
operator = (const GGS_LocationModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_LocationModel GGS_LocationModel::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_LocationModel * _ptr = (cPtr_LocationModel *) NULL ;
  macroMyNew (_ptr, cPtr_LocationModel (THERE)) ;
  GGS_LocationModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LocationModel::
operator == (const GGS_LocationModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_LocationModel::
operator != (const GGS_LocationModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_LocationModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @LocationModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_ListModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ListModel::
cPtr_ListModel (const GGS_typeListModel & argument_0 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mAttributeList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ListModel * GGS_ListModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ListModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ListModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ListModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ListModel * _p = dynamic_cast <const cPtr_ListModel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mAttributeList == _p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ListModel::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ListModel:"
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_ListModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ListModel::
GGS_ListModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_ListModel::
GGS_ListModel (const GGS_ListModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ListModel::
~GGS_ListModel (void) {
  macroDetachPointer (mPointer, cPtr_ListModel) ;
}

//---------------------------------------------------------------------------*

void GGS_ListModel::
operator = (const GGS_ListModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ListModel GGS_ListModel::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeListModel & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_ListModel * _ptr = (cPtr_ListModel *) NULL ;
  macroMyNew (_ptr, cPtr_ListModel (argument_0 COMMA_THERE)) ;
  GGS_ListModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_ListModel::
reader_mAttributeList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListModel   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ListModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ListModel *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ListModel::
operator == (const GGS_ListModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ListModel::
operator != (const GGS_ListModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ListModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @ListModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      abstract class 'cPtr_MapModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_MapModel::
cPtr_MapModel (const GGS_typeListModel & argument_0 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mAttributeList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_MapModel * GGS_MapModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_MapModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_MapModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_MapModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_MapModel * _p = dynamic_cast <const cPtr_MapModel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mAttributeList == _p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_MapModel::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@MapModel:"
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_MapModel'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_MapModel::
GGS_MapModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_MapModel::
GGS_MapModel (const GGS_MapModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_MapModel::
~GGS_MapModel (void) {
  macroDetachPointer (mPointer, cPtr_MapModel) ;
}

//---------------------------------------------------------------------------*

void GGS_MapModel::
operator = (const GGS_MapModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_MapModel GGS_MapModel::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeListModel & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_MapModel * _ptr = (cPtr_MapModel *) NULL ;
  macroMyNew (_ptr, cPtr_MapModel (argument_0 COMMA_THERE)) ;
  GGS_MapModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_MapModel::
reader_mAttributeList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListModel   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_MapModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_MapModel *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_MapModel::
operator == (const GGS_MapModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_MapModel::
operator != (const GGS_MapModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_MapModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @MapModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'enumConstantMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumConstantMap::
elementOf_GGS_enumConstantMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_enumConstantMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumConstantMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumConstantMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumConstantMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumConstantMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumConstantMap * info = (e_enumConstantMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap GGS_enumConstantMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumConstantMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumConstantMap::
operator == (const GGS_enumConstantMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumConstantMap::
operator != (const GGS_enumConstantMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_enumConstantMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' constant is not declared",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumConstantMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' constant is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap GGS_enumConstantMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_enumConstantMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumConstantMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap GGS_enumConstantMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumConstantMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumConstantMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @enumConstantMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'enumMessageMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageMap::
elementOf_GGS_enumMessageMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_enumMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_enumMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_enumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_enumMessageMap * info = (e_enumMessageMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap GGS_enumMessageMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumMessageMap::
operator == (const GGS_enumMessageMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumMessageMap::
operator != (const GGS_enumMessageMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_enumMessageMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' message name is not declared",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' message name is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap GGS_enumMessageMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_enumMessageMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap GGS_enumMessageMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @enumMessageMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_EnumModel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_EnumModel::
cPtr_EnumModel (const GGS_enumConstantMap & argument_0,
                                const GGS_enumMessageMap & argument_1 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mEnumConstantesMap (argument_0),
mMessagesMap (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_EnumModel * GGS_EnumModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_EnumModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_EnumModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_EnumModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_EnumModel * _p = dynamic_cast <const cPtr_EnumModel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mEnumConstantesMap == _p->mEnumConstantesMap).boolValue ()
         && (mMessagesMap == _p->mMessagesMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_EnumModel::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@EnumModel:"
           << mEnumConstantesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMessagesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_EnumModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_EnumModel::
GGS_EnumModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_EnumModel::
GGS_EnumModel (const GGS_EnumModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_EnumModel::
~GGS_EnumModel (void) {
  macroDetachPointer (mPointer, cPtr_EnumModel) ;
}

//---------------------------------------------------------------------------*

void GGS_EnumModel::
operator = (const GGS_EnumModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_EnumModel GGS_EnumModel::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_enumConstantMap & argument_0,
                 const GGS_enumMessageMap & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_EnumModel * _ptr = (cPtr_EnumModel *) NULL ;
  macroMyNew (_ptr, cPtr_EnumModel (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_EnumModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap  GGS_EnumModel::
reader_mEnumConstantesMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumConstantMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_EnumModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_EnumModel *) mPointer)->mEnumConstantesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageMap  GGS_EnumModel::
reader_mMessagesMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_EnumModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_EnumModel *) mPointer)->mMessagesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EnumModel::
operator == (const GGS_EnumModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EnumModel::
operator != (const GGS_EnumModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EnumModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @EnumModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'constructorMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_constructorMap::
elementOf_GGS_constructorMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_constructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constructorMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mFormalInputArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_constructorMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_constructorMap * _p = dynamic_cast <const elementOf_GGS_constructorMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mFormalInputArgumentList == _p->mInfo.mFormalInputArgumentList).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_constructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constructorMap * info = (e_constructorMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constructorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constructorMap::
operator == (const GGS_constructorMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constructorMap::
operator != (const GGS_constructorMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeListModel & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_constructorMap info  ;
    info.mFormalInputArgumentList = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListModel   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalInputArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListModel   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' constructor is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListModel & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' constructor is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_constructorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constructorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constructorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constructorMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @constructorMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'readerMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_readerMap::
elementOf_GGS_readerMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_readerMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_readerMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mReaderFormalArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_readerMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_readerMap * _p = dynamic_cast <const elementOf_GGS_readerMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mReaderFormalArgumentList == _p->mInfo.mReaderFormalArgumentList).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_readerMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_readerMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_readerMap * info = (e_readerMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_readerMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerMap::
operator == (const GGS_readerMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerMap::
operator != (const GGS_readerMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_signature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_readerMap info  ;
    info.mReaderFormalArgumentList = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mReaderFormalArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' reader is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' reader is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_readerMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_readerMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_readerMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readerMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @readerMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'modifierMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_modifierMap::
elementOf_GGS_modifierMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_modifierMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_modifierMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mModifierFormalArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_modifierMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_modifierMap * _p = dynamic_cast <const elementOf_GGS_modifierMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mModifierFormalArgumentList == _p->mInfo.mModifierFormalArgumentList).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_modifierMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_modifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_modifierMap * info = (e_modifierMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_modifierMap::
operator == (const GGS_modifierMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_modifierMap::
operator != (const GGS_modifierMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_signature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_modifierMap info  ;
    info.mModifierFormalArgumentList = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mModifierFormalArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' modifier is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' modifier is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_modifierMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_modifierMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_modifierMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @modifierMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_ExternTypeModel'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ExternTypeModel::
cPtr_ExternTypeModel (const GGS_constructorMap & argument_0,
                                const GGS_readerMap & argument_1,
                                const GGS_modifierMap & argument_2,
                                const GGS_typeListModel & argument_3 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mExternTypeConstructorMap (argument_0),
mReaderMap (argument_1),
mModifierMap (argument_2),
mAddAssignFormalInputArgumentList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ExternTypeModel * GGS_ExternTypeModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ExternTypeModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ExternTypeModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ExternTypeModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ExternTypeModel * _p = dynamic_cast <const cPtr_ExternTypeModel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mExternTypeConstructorMap == _p->mExternTypeConstructorMap).boolValue ()
         && (mReaderMap == _p->mReaderMap).boolValue ()
         && (mModifierMap == _p->mModifierMap).boolValue ()
         && (mAddAssignFormalInputArgumentList == _p->mAddAssignFormalInputArgumentList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ExternTypeModel::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ExternTypeModel:"
           << mExternTypeConstructorMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReaderMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModifierMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAddAssignFormalInputArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_ExternTypeModel'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ExternTypeModel::
GGS_ExternTypeModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_ExternTypeModel::
GGS_ExternTypeModel (const GGS_ExternTypeModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ExternTypeModel::
~GGS_ExternTypeModel (void) {
  macroDetachPointer (mPointer, cPtr_ExternTypeModel) ;
}

//---------------------------------------------------------------------------*

void GGS_ExternTypeModel::
operator = (const GGS_ExternTypeModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ExternTypeModel GGS_ExternTypeModel::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_constructorMap & argument_0,
                 const GGS_readerMap & argument_1,
                 const GGS_modifierMap & argument_2,
                 const GGS_typeListModel & argument_3 COMMA_LOCATION_ARGS) {
  cPtr_ExternTypeModel * _ptr = (cPtr_ExternTypeModel *) NULL ;
  macroMyNew (_ptr, cPtr_ExternTypeModel (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  GGS_ExternTypeModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap  GGS_ExternTypeModel::
reader_mExternTypeConstructorMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constructorMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ExternTypeModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ExternTypeModel *) mPointer)->mExternTypeConstructorMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerMap  GGS_ExternTypeModel::
reader_mReaderMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_readerMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ExternTypeModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ExternTypeModel *) mPointer)->mReaderMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap  GGS_ExternTypeModel::
reader_mModifierMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_modifierMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ExternTypeModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ExternTypeModel *) mPointer)->mModifierMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_ExternTypeModel::
reader_mAddAssignFormalInputArgumentList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListModel   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ExternTypeModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ExternTypeModel *) mPointer)->mAddAssignFormalInputArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ExternTypeModel::
operator == (const GGS_ExternTypeModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ExternTypeModel::
operator != (const GGS_ExternTypeModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ExternTypeModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @ExternTypeModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'classMessageMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_classMessageMap::
elementOf_GGS_classMessageMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_classMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classMessageMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_classMessageMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_classMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_classMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_classMessageMap * info = (e_classMessageMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap GGS_classMessageMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMessageMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMessageMap::
operator == (const GGS_classMessageMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMessageMap::
operator != (const GGS_classMessageMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_classMessageMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' message is not declared",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' message is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap GGS_classMessageMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_classMessageMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMessageMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap GGS_classMessageMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classMessageMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classMessageMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @classMessageMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_ClassModel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ClassModel::
cPtr_ClassModel (const GGS_bool& argument_0,
                                const GGS_stringset & argument_1,
                                const GGS_typeListModel & argument_2,
                                const GGS_classMessageMap & argument_3 COMMA_LOCATION_ARGS)
:cPtr_TypeModel (THERE),
mIsAbstract (argument_0),
mSuperClasses (argument_1),
mAttributeList (argument_2),
mMessageMap (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ClassModel * GGS_ClassModel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ClassModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_ClassModel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ClassModel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ClassModel * _p = dynamic_cast <const cPtr_ClassModel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mIsAbstract == _p->mIsAbstract).boolValue ()
         && (mSuperClasses == _p->mSuperClasses).boolValue ()
         && (mAttributeList == _p->mAttributeList).boolValue ()
         && (mMessageMap == _p->mMessageMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ClassModel::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@ClassModel:"
           << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSuperClasses.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMessageMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_ClassModel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ClassModel::
GGS_ClassModel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_ClassModel::
GGS_ClassModel (const GGS_ClassModel & inOperand)
:GGS_TypeModel () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ClassModel::
~GGS_ClassModel (void) {
  macroDetachPointer (mPointer, cPtr_ClassModel) ;
}

//---------------------------------------------------------------------------*

void GGS_ClassModel::
operator = (const GGS_ClassModel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ClassModel GGS_ClassModel::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_stringset & argument_1,
                 const GGS_typeListModel & argument_2,
                 const GGS_classMessageMap & argument_3 COMMA_LOCATION_ARGS) {
  cPtr_ClassModel * _ptr = (cPtr_ClassModel *) NULL ;
  macroMyNew (_ptr, cPtr_ClassModel (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  GGS_ClassModel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ClassModel::
reader_mIsAbstract (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ClassModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ClassModel *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset  GGS_ClassModel::
reader_mSuperClasses (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringset   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ClassModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ClassModel *) mPointer)->mSuperClasses ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListModel  GGS_ClassModel::
reader_mAttributeList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListModel   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ClassModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ClassModel *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageMap  GGS_ClassModel::
reader_mMessageMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classMessageMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ClassModel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ClassModel *) mPointer)->mMessageMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ClassModel::
operator == (const GGS_ClassModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ClassModel::
operator != (const GGS_ClassModel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ClassModel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @ClassModel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'ModelMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ModelMap::
elementOf_GGS_ModelMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_ModelMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ModelMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ModelMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_ModelMap * _p = dynamic_cast <const elementOf_GGS_ModelMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mType == _p->mInfo.mType).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ModelMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_ModelMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ModelMap * info = (e_ModelMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ModelMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ModelMap::
operator == (const GGS_ModelMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ModelMap::
operator != (const GGS_ModelMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_TypeModel & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_ModelMap info  ;
    info.mType = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_TypeModel   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_TypeModel   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '@%K' type is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ModelMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_TypeModel & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '@%K' type has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_ModelMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ModelMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ModelMap GGS_ModelMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ModelMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ModelMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @ModelMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'ActionMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ActionMap::
elementOf_GGS_ActionMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_ActionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ActionMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mIsExtern.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ActionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_ActionMap * _p = dynamic_cast <const elementOf_GGS_ActionMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mSignature == _p->mInfo.mSignature).boolValue ()
           && (mInfo.mIsExtern == _p->mInfo.mIsExtern).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ActionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_ActionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ActionMap * info = (e_ActionMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_ActionMap GGS_ActionMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ActionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ActionMap::
operator == (const GGS_ActionMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ActionMap::
operator != (const GGS_ActionMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_signature & inParameter0,
                const GGS_bool& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_ActionMap info  ;
    info.mSignature = inParameter0 ;
    info.mIsExtern = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mSignature ;
    outParameter1 = node->mInfo.mIsExtern ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' action is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ActionMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' extern action has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_ActionMap GGS_ActionMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_ActionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ActionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ActionMap GGS_ActionMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ActionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ActionMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @ActionMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Class for 'localConstantBuildStyleEnum' Enumeration             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator == (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator != (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator <= (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator >= (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator < (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator > (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localConstantBuildStyleEnum::
reader_description (C_Lexique & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @localConstantBuildStyleEnum" ;
  switch (mValue) {
case enum_listStyle:
  s << " listStyle>" ;
    break ;
case enum_mapStyle:
  s << " mapStyle>" ;
    break ;
case enum_firstIsKeyOtherMapStyle:
  s << " firstIsKeyOtherMapStyle>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_AC_galgasType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_galgasType::
cPtr_AC_galgasType (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_galgasType * GGS_AC_galgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_acceptToBeSortKeyInSortedListDefinition (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this attribute cannot be used for sorting") SOURCE_FILE_AT_LINE (414)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_acceptAssignmentFromHere (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "assignment from 'here' is not allowed for variables of this type") SOURCE_FILE_AT_LINE (420)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_acceptForeachInstruction (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type cannot be enumerated by in 'foreach' instruction") SOURCE_FILE_AT_LINE (430)) ;
  var_cas_outForeachList._drop_operation () ;
  var_cas_outStyle._drop_operation () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") SOURCE_FILE_AT_LINE (440)) ;
  var_cas_outModifierSignature._drop_operation () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleMethodInstructionCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inReadObjectName */,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_EXsignature & var_cas_outReaderSignature COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support reader instruction") SOURCE_FILE_AT_LINE (451)) ;
  var_cas_outReaderSignature._drop_operation () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (459)) ;
  var_cas_outAccessorTypesList._drop_operation () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleMinusAssignOperatorCall (C_Lexique & _inLexique,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support call of '-=' operator") SOURCE_FILE_AT_LINE (469)) ;
  var_cas_outParametersList._drop_operation () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleAddAssignOperatorCall (C_Lexique & _inLexique,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support call of '+=' operator") SOURCE_FILE_AT_LINE (480)) ;
  var_cas_outParametersList._drop_operation () ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleIncrementOperatorCall (C_Lexique & _inLexique,
                                GGS_location  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support call of '++' operator") SOURCE_FILE_AT_LINE (488)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_handleDecrementOperatorCall (C_Lexique & _inLexique,
                                GGS_location  var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support call of '--' operator") SOURCE_FILE_AT_LINE (496)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & _inLexique COMMA_UNUSED_LOCATION_ARGS) {
  GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type cannot be silently converted to @location value") SOURCE_FILE_AT_LINE (502)) ;
}

//---------------------------------------------------------------------------*

void cPtr_AC_galgasType::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_galgasType:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType
::static_string_message_messageGalgasType (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_galgasType::
message_messageGalgasType (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_galgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
GGS_AC_galgasType (const GGS_AC_galgasType & inOperand) {
  mPointer = (cPtr_AC_galgasType *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType::
~GGS_AC_galgasType (void) {
  macroDetachPointer (mPointer, cPtr_AC_galgasType) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_galgasType::
operator = (const GGS_AC_galgasType & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_galgasType::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_galgasType::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_galgasType) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_galgasType::
operator == (const GGS_AC_galgasType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_galgasType::
operator != (const GGS_AC_galgasType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_galgasType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @AC_galgasType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_metamodelProperty'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelProperty::
cPtr_metamodelProperty (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelProperty * GGS_metamodelProperty::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_metamodelProperty::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@metamodelProperty:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelProperty
::static_string_message_messageProperty (void) {
  return "any property" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelProperty::
message_messageProperty (void) const {
  return "any property" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_metamodelProperty'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelProperty::
GGS_metamodelProperty (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelProperty::
GGS_metamodelProperty (const GGS_metamodelProperty & inOperand) {
  mPointer = (cPtr_metamodelProperty *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelProperty::
~GGS_metamodelProperty (void) {
  macroDetachPointer (mPointer, cPtr_metamodelProperty) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelProperty::
operator = (const GGS_metamodelProperty & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelProperty::
reader_messageProperty (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageProperty ())) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelProperty::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_metamodelProperty) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelProperty::
operator == (const GGS_metamodelProperty & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelProperty::
operator != (const GGS_metamodelProperty & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelProperty::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelProperty" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@metamodelPropertyList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_metamodelPropertyList::
elementOf_GGS_metamodelPropertyList (const GGS_metamodelProperty & argument_0):
mProperty (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_metamodelPropertyList::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_metamodelPropertyList * _p = dynamic_cast <const elementOf_GGS_metamodelPropertyList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mProperty == _p->mProperty).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_metamodelPropertyList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mProperty.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@metamodelPropertyList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelPropertyList::GGS_metamodelPropertyList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_metamodelPropertyList::
GGS_metamodelPropertyList (const GGS_metamodelPropertyList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelPropertyList::
operator == (const GGS_metamodelPropertyList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelPropertyList::
operator != (const GGS_metamodelPropertyList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelPropertyList::
_internalAppendValues (const GGS_metamodelProperty & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelPropertyList::
_internalPrependValues (const GGS_metamodelProperty & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelPropertyList::
_addAssign_operation (const GGS_metamodelProperty & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelPropertyList GGS_metamodelPropertyList::
operator + (const GGS_metamodelPropertyList & inOperand) const {
  GGS_metamodelPropertyList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_metamodelPropertyList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_metamodelProperty  p_0 = p->mProperty ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelPropertyList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_metamodelProperty & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelPropertyList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mProperty) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelPropertyList  GGS_metamodelPropertyList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_metamodelPropertyList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelPropertyList  GGS_metamodelPropertyList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_metamodelProperty & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_metamodelPropertyList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelPropertyList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@metamodelPropertyList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelPropertyList::
method_first (C_Lexique & _inLexique,
              GGS_metamodelProperty & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mProperty ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelPropertyList::
method_last (C_Lexique & _inLexique,
             GGS_metamodelProperty & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mProperty ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelPropertyList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_metamodelProperty & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mProperty ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelPropertyList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_metamodelProperty & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mProperty ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_metamodelAttributeProperty'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelAttributeProperty::
cPtr_metamodelAttributeProperty (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_metamodelProperty (THERE),
mAttributeTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelAttributeProperty * GGS_metamodelAttributeProperty::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelAttributeProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_metamodelAttributeProperty *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_metamodelAttributeProperty::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_metamodelAttributeProperty * _p = dynamic_cast <const cPtr_metamodelAttributeProperty *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mAttributeTypeName == _p->mAttributeTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelAttributeProperty::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelAttributeProperty:"
           << mAttributeTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelAttributeProperty
::static_string_message_messageProperty (void) {
  return "an attribute property" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelAttributeProperty::
message_messageProperty (void) const {
  return "an attribute property" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_metamodelAttributeProperty'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelAttributeProperty::
GGS_metamodelAttributeProperty (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelAttributeProperty::
GGS_metamodelAttributeProperty (const GGS_metamodelAttributeProperty & inOperand)
:GGS_metamodelProperty () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelAttributeProperty::
~GGS_metamodelAttributeProperty (void) {
  macroDetachPointer (mPointer, cPtr_metamodelAttributeProperty) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelAttributeProperty::
operator = (const GGS_metamodelAttributeProperty & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelAttributeProperty GGS_metamodelAttributeProperty::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_metamodelAttributeProperty * _ptr = (cPtr_metamodelAttributeProperty *) NULL ;
  macroMyNew (_ptr, cPtr_metamodelAttributeProperty (argument_0 COMMA_THERE)) ;
  GGS_metamodelAttributeProperty result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelAttributeProperty::
reader_messageProperty (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageProperty ())) ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelAttributeProperty::
reader_mAttributeTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelAttributeProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelAttributeProperty *) mPointer)->mAttributeTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelAttributeProperty::
operator == (const GGS_metamodelAttributeProperty & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelAttributeProperty::
operator != (const GGS_metamodelAttributeProperty & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelAttributeProperty::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelAttributeProperty" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_metamodelSingleReferenceProperty'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelSingleReferenceProperty::
cPtr_metamodelSingleReferenceProperty (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_metamodelProperty (THERE),
mReferenceEntityName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelSingleReferenceProperty * GGS_metamodelSingleReferenceProperty::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelSingleReferenceProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_metamodelSingleReferenceProperty *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_metamodelSingleReferenceProperty::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_metamodelSingleReferenceProperty * _p = dynamic_cast <const cPtr_metamodelSingleReferenceProperty *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mReferenceEntityName == _p->mReferenceEntityName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelSingleReferenceProperty::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelSingleReferenceProperty:"
           << mReferenceEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelSingleReferenceProperty
::static_string_message_messageProperty (void) {
  return "a single reference property" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelSingleReferenceProperty::
message_messageProperty (void) const {
  return "a single reference property" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_metamodelSingleReferenceProperty'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelSingleReferenceProperty::
GGS_metamodelSingleReferenceProperty (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelSingleReferenceProperty::
GGS_metamodelSingleReferenceProperty (const GGS_metamodelSingleReferenceProperty & inOperand)
:GGS_metamodelProperty () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelSingleReferenceProperty::
~GGS_metamodelSingleReferenceProperty (void) {
  macroDetachPointer (mPointer, cPtr_metamodelSingleReferenceProperty) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelSingleReferenceProperty::
operator = (const GGS_metamodelSingleReferenceProperty & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelSingleReferenceProperty GGS_metamodelSingleReferenceProperty::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_metamodelSingleReferenceProperty * _ptr = (cPtr_metamodelSingleReferenceProperty *) NULL ;
  macroMyNew (_ptr, cPtr_metamodelSingleReferenceProperty (argument_0 COMMA_THERE)) ;
  GGS_metamodelSingleReferenceProperty result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelSingleReferenceProperty::
reader_messageProperty (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageProperty ())) ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelSingleReferenceProperty::
reader_mReferenceEntityName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelSingleReferenceProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelSingleReferenceProperty *) mPointer)->mReferenceEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelSingleReferenceProperty::
operator == (const GGS_metamodelSingleReferenceProperty & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelSingleReferenceProperty::
operator != (const GGS_metamodelSingleReferenceProperty & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelSingleReferenceProperty::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelSingleReferenceProperty" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         abstract class 'cPtr_metamodelMultipleReferenceProperty'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelMultipleReferenceProperty::
cPtr_metamodelMultipleReferenceProperty (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_metamodelProperty (THERE),
mReferenceEntityName (argument_0),
mLowerBound (argument_1),
mHigherBound (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelMultipleReferenceProperty * GGS_metamodelMultipleReferenceProperty::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelMultipleReferenceProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_metamodelMultipleReferenceProperty *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_metamodelMultipleReferenceProperty::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_metamodelMultipleReferenceProperty * _p = dynamic_cast <const cPtr_metamodelMultipleReferenceProperty *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mReferenceEntityName == _p->mReferenceEntityName).boolValue ()
         && (mLowerBound == _p->mLowerBound).boolValue ()
         && (mHigherBound == _p->mHigherBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelMultipleReferenceProperty::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelMultipleReferenceProperty:"
           << mReferenceEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLowerBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mHigherBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelMultipleReferenceProperty
::static_string_message_messageProperty (void) {
  return "a multiple reference property" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelMultipleReferenceProperty::
message_messageProperty (void) const {
  return "a multiple reference property" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_metamodelMultipleReferenceProperty'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelMultipleReferenceProperty::
GGS_metamodelMultipleReferenceProperty (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelMultipleReferenceProperty::
GGS_metamodelMultipleReferenceProperty (const GGS_metamodelMultipleReferenceProperty & inOperand)
:GGS_metamodelProperty () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelMultipleReferenceProperty::
~GGS_metamodelMultipleReferenceProperty (void) {
  macroDetachPointer (mPointer, cPtr_metamodelMultipleReferenceProperty) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelMultipleReferenceProperty::
operator = (const GGS_metamodelMultipleReferenceProperty & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelMultipleReferenceProperty GGS_metamodelMultipleReferenceProperty::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_metamodelMultipleReferenceProperty * _ptr = (cPtr_metamodelMultipleReferenceProperty *) NULL ;
  macroMyNew (_ptr, cPtr_metamodelMultipleReferenceProperty (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_metamodelMultipleReferenceProperty result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelMultipleReferenceProperty::
reader_messageProperty (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageProperty ())) ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelMultipleReferenceProperty::
reader_mReferenceEntityName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelMultipleReferenceProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelMultipleReferenceProperty *) mPointer)->mReferenceEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_metamodelMultipleReferenceProperty::
reader_mLowerBound (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelMultipleReferenceProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelMultipleReferenceProperty *) mPointer)->mLowerBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_metamodelMultipleReferenceProperty::
reader_mHigherBound (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelMultipleReferenceProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelMultipleReferenceProperty *) mPointer)->mHigherBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelMultipleReferenceProperty::
operator == (const GGS_metamodelMultipleReferenceProperty & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelMultipleReferenceProperty::
operator != (const GGS_metamodelMultipleReferenceProperty & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelMultipleReferenceProperty::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelMultipleReferenceProperty" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_metamodelMapProperty'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelMapProperty::
cPtr_metamodelMapProperty (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_metamodelProperty (THERE),
mMapTypeName (argument_0),
mMapElementName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelMapProperty * GGS_metamodelMapProperty::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelMapProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_metamodelMapProperty *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_metamodelMapProperty::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_metamodelMapProperty * _p = dynamic_cast <const cPtr_metamodelMapProperty *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMapTypeName == _p->mMapTypeName).boolValue ()
         && (mMapElementName == _p->mMapElementName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelMapProperty::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelMapProperty:"
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapElementName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelMapProperty
::static_string_message_messageProperty (void) {
  return "a map property" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelMapProperty::
message_messageProperty (void) const {
  return "a map property" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_metamodelMapProperty'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelMapProperty::
GGS_metamodelMapProperty (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelMapProperty::
GGS_metamodelMapProperty (const GGS_metamodelMapProperty & inOperand)
:GGS_metamodelProperty () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelMapProperty::
~GGS_metamodelMapProperty (void) {
  macroDetachPointer (mPointer, cPtr_metamodelMapProperty) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelMapProperty::
operator = (const GGS_metamodelMapProperty & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelMapProperty GGS_metamodelMapProperty::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_metamodelMapProperty * _ptr = (cPtr_metamodelMapProperty *) NULL ;
  macroMyNew (_ptr, cPtr_metamodelMapProperty (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_metamodelMapProperty result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelMapProperty::
reader_messageProperty (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageProperty ())) ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelMapProperty::
reader_mMapTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelMapProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelMapProperty *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelMapProperty::
reader_mMapElementName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelMapProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelMapProperty *) mPointer)->mMapElementName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelMapProperty::
operator == (const GGS_metamodelMapProperty & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelMapProperty::
operator != (const GGS_metamodelMapProperty & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelMapProperty::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelMapProperty" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_mapIndexProperty'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapIndexProperty::
cPtr_mapIndexProperty (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_metamodelProperty (THERE),
mMapTypeName (argument_0),
mMapName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapIndexProperty * GGS_mapIndexProperty::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapIndexProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_mapIndexProperty *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapIndexProperty::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapIndexProperty * _p = dynamic_cast <const cPtr_mapIndexProperty *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMapTypeName == _p->mMapTypeName).boolValue ()
         && (mMapName == _p->mMapName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapIndexProperty::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@mapIndexProperty:"
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapIndexProperty
::static_string_message_messageProperty (void) {
  return "a map index property" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapIndexProperty::
message_messageProperty (void) const {
  return "a map index property" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_mapIndexProperty'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapIndexProperty::
GGS_mapIndexProperty (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_mapIndexProperty::
GGS_mapIndexProperty (const GGS_mapIndexProperty & inOperand)
:GGS_metamodelProperty () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapIndexProperty::
~GGS_mapIndexProperty (void) {
  macroDetachPointer (mPointer, cPtr_mapIndexProperty) ;
}

//---------------------------------------------------------------------------*

void GGS_mapIndexProperty::
operator = (const GGS_mapIndexProperty & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapIndexProperty GGS_mapIndexProperty::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_mapIndexProperty * _ptr = (cPtr_mapIndexProperty *) NULL ;
  macroMyNew (_ptr, cPtr_mapIndexProperty (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_mapIndexProperty result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapIndexProperty::
reader_messageProperty (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageProperty ())) ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapIndexProperty::
reader_mMapTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapIndexProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapIndexProperty *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapIndexProperty::
reader_mMapName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapIndexProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapIndexProperty *) mPointer)->mMapName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapIndexProperty::
operator == (const GGS_mapIndexProperty & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapIndexProperty::
operator != (const GGS_mapIndexProperty & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapIndexProperty::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @mapIndexProperty" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_metamodelSharedMapProperty'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelSharedMapProperty::
cPtr_metamodelSharedMapProperty (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_metamodelProperty (THERE),
mMapTypeName (argument_0),
mMapElementName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelSharedMapProperty * GGS_metamodelSharedMapProperty::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelSharedMapProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_metamodelSharedMapProperty *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_metamodelSharedMapProperty::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_metamodelSharedMapProperty * _p = dynamic_cast <const cPtr_metamodelSharedMapProperty *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMapTypeName == _p->mMapTypeName).boolValue ()
         && (mMapElementName == _p->mMapElementName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelSharedMapProperty::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelSharedMapProperty:"
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapElementName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelSharedMapProperty
::static_string_message_messageProperty (void) {
  return "a shared map property" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_metamodelSharedMapProperty::
message_messageProperty (void) const {
  return "a shared map property" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_metamodelSharedMapProperty'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelSharedMapProperty::
GGS_metamodelSharedMapProperty (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelSharedMapProperty::
GGS_metamodelSharedMapProperty (const GGS_metamodelSharedMapProperty & inOperand)
:GGS_metamodelProperty () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelSharedMapProperty::
~GGS_metamodelSharedMapProperty (void) {
  macroDetachPointer (mPointer, cPtr_metamodelSharedMapProperty) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelSharedMapProperty::
operator = (const GGS_metamodelSharedMapProperty & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelSharedMapProperty GGS_metamodelSharedMapProperty::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_metamodelSharedMapProperty * _ptr = (cPtr_metamodelSharedMapProperty *) NULL ;
  macroMyNew (_ptr, cPtr_metamodelSharedMapProperty (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_metamodelSharedMapProperty result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelSharedMapProperty::
reader_messageProperty (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageProperty ())) ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelSharedMapProperty::
reader_mMapTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelSharedMapProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelSharedMapProperty *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelSharedMapProperty::
reader_mMapElementName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelSharedMapProperty *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelSharedMapProperty *) mPointer)->mMapElementName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelSharedMapProperty::
operator == (const GGS_metamodelSharedMapProperty & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelSharedMapProperty::
operator != (const GGS_metamodelSharedMapProperty & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelSharedMapProperty::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelSharedMapProperty" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_propertyPath'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_propertyPath::
elementOf_GGS_L_propertyPath (const GGS_lstring & argument_0):
mPathElement (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_propertyPath::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_propertyPath * _p = dynamic_cast <const elementOf_GGS_L_propertyPath *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mPathElement == _p->mPathElement).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_propertyPath::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mPathElement.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_propertyPath'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_propertyPath::GGS_L_propertyPath (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_propertyPath::
GGS_L_propertyPath (const GGS_L_propertyPath & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_propertyPath::
operator == (const GGS_L_propertyPath & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_propertyPath::
operator != (const GGS_L_propertyPath & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
_addAssign_operation (const GGS_lstring & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_propertyPath GGS_L_propertyPath::
operator + (const GGS_L_propertyPath & inOperand) const {
  GGS_L_propertyPath result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_propertyPath * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mPathElement ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mPathElement) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_propertyPath  GGS_L_propertyPath::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_propertyPath result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_propertyPath  GGS_L_propertyPath::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_propertyPath result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_propertyPath::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_propertyPath", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mPathElement ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mPathElement ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mPathElement ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_propertyPath::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mPathElement ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@L_ListOfPropertyPathes'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_ListOfPropertyPathes::
elementOf_GGS_L_ListOfPropertyPathes (const GGS_L_propertyPath & argument_0,
                                const GGS_location & argument_1):
mPath (argument_0),
mEndOfPathLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_ListOfPropertyPathes::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_ListOfPropertyPathes * _p = dynamic_cast <const elementOf_GGS_L_ListOfPropertyPathes *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mPath == _p->mPath).boolValue ()
         && (mEndOfPathLocation == _p->mEndOfPathLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_ListOfPropertyPathes::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mPath.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfPathLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@L_ListOfPropertyPathes'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes::GGS_L_ListOfPropertyPathes (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes::
GGS_L_ListOfPropertyPathes (const GGS_L_ListOfPropertyPathes & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_ListOfPropertyPathes::
operator == (const GGS_L_ListOfPropertyPathes & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_ListOfPropertyPathes::
operator != (const GGS_L_ListOfPropertyPathes & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
_internalAppendValues (const GGS_L_propertyPath & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
_internalPrependValues (const GGS_L_propertyPath & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
_addAssign_operation (const GGS_L_propertyPath & argument_0,
                                const GGS_location & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes GGS_L_ListOfPropertyPathes::
operator + (const GGS_L_ListOfPropertyPathes & inOperand) const {
  GGS_L_ListOfPropertyPathes result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_ListOfPropertyPathes * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_L_propertyPath  p_0 = p->mPath ;
          GGS_location  p_1 = p->mEndOfPathLocation ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_L_propertyPath & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mPath,
                                _p->mEndOfPathLocation) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes  GGS_L_ListOfPropertyPathes::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_ListOfPropertyPathes result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_ListOfPropertyPathes  GGS_L_ListOfPropertyPathes::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_L_propertyPath & argument_0,
                           const GGS_location & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_ListOfPropertyPathes result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_ListOfPropertyPathes::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_ListOfPropertyPathes", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
method_first (C_Lexique & _inLexique,
              GGS_L_propertyPath & _out_0,
              GGS_location & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mPath ;
    _out_1 = _p->mEndOfPathLocation ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
method_last (C_Lexique & _inLexique,
             GGS_L_propertyPath & _out_0,
             GGS_location & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mPath ;
    _out_1 = _p->mEndOfPathLocation ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_L_propertyPath & _out_0,
                 GGS_location & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mPath ;
    _out_1 = _p->mEndOfPathLocation ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ListOfPropertyPathes::
modifier_popLast (C_Lexique & _inLexique,
                GGS_L_propertyPath & _out_0,
                GGS_location & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mPath ;
    _out_1 = _p->mEndOfPathLocation ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'entityPropertyMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_entityPropertyMap::
elementOf_GGS_entityPropertyMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_entityPropertyMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_entityPropertyMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mProperty.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_entityPropertyMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_entityPropertyMap * _p = dynamic_cast <const elementOf_GGS_entityPropertyMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mProperty == _p->mInfo.mProperty).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_entityPropertyMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_entityPropertyMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_entityPropertyMap * info = (e_entityPropertyMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_entityPropertyMap GGS_entityPropertyMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_entityPropertyMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_entityPropertyMap::
operator == (const GGS_entityPropertyMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_entityPropertyMap::
operator != (const GGS_entityPropertyMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_metamodelProperty & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_entityPropertyMap info  ;
    info.mProperty = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_metamodelProperty   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mProperty ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_metamodelProperty   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' property is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_entityPropertyMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_metamodelProperty & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' property has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_entityPropertyMap GGS_entityPropertyMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_entityPropertyMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_entityPropertyMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_entityPropertyMap GGS_entityPropertyMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_entityPropertyMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_entityPropertyMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @entityPropertyMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'contextPropertyMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_contextPropertyMap::
elementOf_GGS_contextPropertyMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_contextPropertyMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_contextPropertyMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mIsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_contextPropertyMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_contextPropertyMap * _p = dynamic_cast <const elementOf_GGS_contextPropertyMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mTypeName == _p->mInfo.mTypeName).boolValue ()
           && (mInfo.mIsMap == _p->mInfo.mIsMap).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_contextPropertyMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_contextPropertyMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_contextPropertyMap * info = (e_contextPropertyMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_contextPropertyMap GGS_contextPropertyMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_contextPropertyMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_contextPropertyMap::
operator == (const GGS_contextPropertyMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_contextPropertyMap::
operator != (const GGS_contextPropertyMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                const GGS_bool& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_contextPropertyMap info  ;
    info.mTypeName = inParameter0 ;
    info.mIsMap = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mTypeName ;
    outParameter1 = node->mInfo.mIsMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' context property is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_contextPropertyMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' context property has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_contextPropertyMap GGS_contextPropertyMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_contextPropertyMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_contextPropertyMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_contextPropertyMap GGS_contextPropertyMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_contextPropertyMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_contextPropertyMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @contextPropertyMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'contextParameterMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_contextParameterMap::
elementOf_GGS_contextParameterMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_contextParameterMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_contextParameterMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mContextParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_contextParameterMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_contextParameterMap * _p = dynamic_cast <const elementOf_GGS_contextParameterMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mContextParameterList == _p->mInfo.mContextParameterList).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_contextParameterMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_contextParameterMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_contextParameterMap * info = (e_contextParameterMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_contextParameterMap GGS_contextParameterMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_contextParameterMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_contextParameterMap::
operator == (const GGS_contextParameterMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_contextParameterMap::
operator != (const GGS_contextParameterMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_contextParameterMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_contextParameterMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_lstringList & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_contextParameterMap info  ;
    info.mContextParameterList = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_contextParameterMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_lstringList   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mContextParameterList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_contextParameterMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_lstringList   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' context property is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_contextParameterMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_lstringList & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "context parameter are already defined for the '%K' property",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_contextParameterMap GGS_contextParameterMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_contextParameterMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_contextParameterMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_contextParameterMap GGS_contextParameterMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_contextParameterMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_contextParameterMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @contextParameterMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'mapPropertyMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapPropertyMap::
elementOf_GGS_mapPropertyMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapPropertyMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapPropertyMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapPropertyMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_mapPropertyMap * _p = dynamic_cast <const elementOf_GGS_mapPropertyMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mTypeName == _p->mInfo.mTypeName).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapPropertyMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapPropertyMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapPropertyMap * info = (e_mapPropertyMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_mapPropertyMap GGS_mapPropertyMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapPropertyMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapPropertyMap::
operator == (const GGS_mapPropertyMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapPropertyMap::
operator != (const GGS_mapPropertyMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_mapPropertyMap info  ;
    info.mTypeName = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mTypeName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' map property is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapPropertyMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' map property has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapPropertyMap GGS_mapPropertyMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_mapPropertyMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapPropertyMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapPropertyMap GGS_mapPropertyMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapPropertyMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapPropertyMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @mapPropertyMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'insertionMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_insertionMap::
elementOf_GGS_insertionMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_insertionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_insertionMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mIndexName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_insertionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_insertionMap * _p = dynamic_cast <const elementOf_GGS_insertionMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mIndexName == _p->mInfo.mIndexName).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_insertionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_insertionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_insertionMap * info = (e_insertionMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_insertionMap GGS_insertionMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_insertionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_insertionMap::
operator == (const GGS_insertionMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_insertionMap::
operator != (const GGS_insertionMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_insertionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_insertionMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_insertionMap info  ;
    info.mIndexName = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertionMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mIndexName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertionMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the attribute is already inserted in the '%K' map",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_insertionMap GGS_insertionMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_insertionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_insertionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertionMap GGS_insertionMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertionMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @insertionMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'relationVarMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_relationVarMap::
elementOf_GGS_relationVarMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_relationVarMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_relationVarMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDomainVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_relationVarMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_relationVarMap * _p = dynamic_cast <const elementOf_GGS_relationVarMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mDomainVariableName == _p->mInfo.mDomainVariableName).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_relationVarMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_relationVarMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_relationVarMap * info = (e_relationVarMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_relationVarMap GGS_relationVarMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_relationVarMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_relationVarMap::
operator == (const GGS_relationVarMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_relationVarMap::
operator != (const GGS_relationVarMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_relationVarMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_relationVarMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_relationVarMap info  ;
    info.mDomainVariableName = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_relationVarMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mDomainVariableName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_relationVarMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' relation variable is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_relationVarMap::
method_searchKeyAndGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' relation variable is not declared",
                  inKey,
                  outParameter0,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_relationVarMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' relation variable has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_relationVarMap GGS_relationVarMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_relationVarMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_relationVarMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_relationVarMap GGS_relationVarMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_relationVarMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_relationVarMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @relationVarMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_metamodelRelationExpression'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationExpression::
cPtr_metamodelRelationExpression (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationExpression * GGS_metamodelRelationExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationExpression::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_metamodelRelationExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelRelationExpression::
GGS_metamodelRelationExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationExpression::
GGS_metamodelRelationExpression (const GGS_metamodelRelationExpression & inOperand) {
  mPointer = (cPtr_metamodelRelationExpression *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationExpression::
~GGS_metamodelRelationExpression (void) {
  macroDetachPointer (mPointer, cPtr_metamodelRelationExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationExpression::
operator = (const GGS_metamodelRelationExpression & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationExpression::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_metamodelRelationExpression) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationExpression::
operator == (const GGS_metamodelRelationExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationExpression::
operator != (const GGS_metamodelRelationExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelRelationExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelRelationExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_metamodelRelationAnd'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationAnd::
cPtr_metamodelRelationAnd (const GGS_metamodelRelationExpression & argument_0,
                                const GGS_metamodelRelationExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_metamodelRelationExpression (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationAnd * GGS_metamodelRelationAnd::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationAnd *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_metamodelRelationAnd *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_metamodelRelationAnd::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_metamodelRelationAnd * _p = dynamic_cast <const cPtr_metamodelRelationAnd *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftOperand == _p->mLeftOperand).boolValue ()
         && (mRightOperand == _p->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationAnd::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationAnd:"
           << mLeftOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_metamodelRelationAnd'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelRelationAnd::
GGS_metamodelRelationAnd (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationAnd::
GGS_metamodelRelationAnd (const GGS_metamodelRelationAnd & inOperand)
:GGS_metamodelRelationExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationAnd::
~GGS_metamodelRelationAnd (void) {
  macroDetachPointer (mPointer, cPtr_metamodelRelationAnd) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationAnd::
operator = (const GGS_metamodelRelationAnd & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationAnd GGS_metamodelRelationAnd::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_metamodelRelationExpression & argument_0,
                 const GGS_metamodelRelationExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_metamodelRelationAnd * _ptr = (cPtr_metamodelRelationAnd *) NULL ;
  macroMyNew (_ptr, cPtr_metamodelRelationAnd (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_metamodelRelationAnd result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationExpression  GGS_metamodelRelationAnd::
reader_mLeftOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_metamodelRelationExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationAnd *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelRelationAnd *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationExpression  GGS_metamodelRelationAnd::
reader_mRightOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_metamodelRelationExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationAnd *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelRelationAnd *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationAnd::
operator == (const GGS_metamodelRelationAnd & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationAnd::
operator != (const GGS_metamodelRelationAnd & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelRelationAnd::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelRelationAnd" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_metamodelRelationOr'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationOr::
cPtr_metamodelRelationOr (const GGS_metamodelRelationExpression & argument_0,
                                const GGS_metamodelRelationExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_metamodelRelationExpression (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationOr * GGS_metamodelRelationOr::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationOr *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_metamodelRelationOr *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_metamodelRelationOr::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_metamodelRelationOr * _p = dynamic_cast <const cPtr_metamodelRelationOr *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftOperand == _p->mLeftOperand).boolValue ()
         && (mRightOperand == _p->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationOr::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationOr:"
           << mLeftOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_metamodelRelationOr'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelRelationOr::
GGS_metamodelRelationOr (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationOr::
GGS_metamodelRelationOr (const GGS_metamodelRelationOr & inOperand)
:GGS_metamodelRelationExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationOr::
~GGS_metamodelRelationOr (void) {
  macroDetachPointer (mPointer, cPtr_metamodelRelationOr) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationOr::
operator = (const GGS_metamodelRelationOr & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationOr GGS_metamodelRelationOr::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_metamodelRelationExpression & argument_0,
                 const GGS_metamodelRelationExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_metamodelRelationOr * _ptr = (cPtr_metamodelRelationOr *) NULL ;
  macroMyNew (_ptr, cPtr_metamodelRelationOr (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_metamodelRelationOr result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationExpression  GGS_metamodelRelationOr::
reader_mLeftOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_metamodelRelationExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationOr *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelRelationOr *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationExpression  GGS_metamodelRelationOr::
reader_mRightOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_metamodelRelationExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationOr *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelRelationOr *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationOr::
operator == (const GGS_metamodelRelationOr & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationOr::
operator != (const GGS_metamodelRelationOr & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelRelationOr::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelRelationOr" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_metamodelRelationNot'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationNot::
cPtr_metamodelRelationNot (const GGS_metamodelRelationExpression & argument_0 COMMA_LOCATION_ARGS)
:cPtr_metamodelRelationExpression (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationNot * GGS_metamodelRelationNot::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationNot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_metamodelRelationNot *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_metamodelRelationNot::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_metamodelRelationNot * _p = dynamic_cast <const cPtr_metamodelRelationNot *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mOperand == _p->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationNot::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationNot:"
           << mOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_metamodelRelationNot'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelRelationNot::
GGS_metamodelRelationNot (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationNot::
GGS_metamodelRelationNot (const GGS_metamodelRelationNot & inOperand)
:GGS_metamodelRelationExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationNot::
~GGS_metamodelRelationNot (void) {
  macroDetachPointer (mPointer, cPtr_metamodelRelationNot) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationNot::
operator = (const GGS_metamodelRelationNot & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationNot GGS_metamodelRelationNot::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_metamodelRelationExpression & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_metamodelRelationNot * _ptr = (cPtr_metamodelRelationNot *) NULL ;
  macroMyNew (_ptr, cPtr_metamodelRelationNot (argument_0 COMMA_THERE)) ;
  GGS_metamodelRelationNot result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationExpression  GGS_metamodelRelationNot::
reader_mOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_metamodelRelationExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationNot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelRelationNot *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationNot::
operator == (const GGS_metamodelRelationNot & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationNot::
operator != (const GGS_metamodelRelationNot & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelRelationNot::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelRelationNot" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_metamodelRelationTrue'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationTrue::
cPtr_metamodelRelationTrue (LOCATION_ARGS)
:cPtr_metamodelRelationExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationTrue * GGS_metamodelRelationTrue::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationTrue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_metamodelRelationTrue *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_metamodelRelationTrue::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationTrue::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationTrue:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_metamodelRelationTrue'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelRelationTrue::
GGS_metamodelRelationTrue (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationTrue::
GGS_metamodelRelationTrue (const GGS_metamodelRelationTrue & inOperand)
:GGS_metamodelRelationExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationTrue::
~GGS_metamodelRelationTrue (void) {
  macroDetachPointer (mPointer, cPtr_metamodelRelationTrue) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationTrue::
operator = (const GGS_metamodelRelationTrue & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationTrue GGS_metamodelRelationTrue::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_metamodelRelationTrue * _ptr = (cPtr_metamodelRelationTrue *) NULL ;
  macroMyNew (_ptr, cPtr_metamodelRelationTrue (THERE)) ;
  GGS_metamodelRelationTrue result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationTrue::
operator == (const GGS_metamodelRelationTrue & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationTrue::
operator != (const GGS_metamodelRelationTrue & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelRelationTrue::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelRelationTrue" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_metamodelRelationFalse'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationFalse::
cPtr_metamodelRelationFalse (LOCATION_ARGS)
:cPtr_metamodelRelationExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationFalse * GGS_metamodelRelationFalse::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationFalse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_metamodelRelationFalse *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_metamodelRelationFalse::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationFalse::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationFalse:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_metamodelRelationFalse'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelRelationFalse::
GGS_metamodelRelationFalse (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationFalse::
GGS_metamodelRelationFalse (const GGS_metamodelRelationFalse & inOperand)
:GGS_metamodelRelationExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationFalse::
~GGS_metamodelRelationFalse (void) {
  macroDetachPointer (mPointer, cPtr_metamodelRelationFalse) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationFalse::
operator = (const GGS_metamodelRelationFalse & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationFalse GGS_metamodelRelationFalse::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_metamodelRelationFalse * _ptr = (cPtr_metamodelRelationFalse *) NULL ;
  macroMyNew (_ptr, cPtr_metamodelRelationFalse (THERE)) ;
  GGS_metamodelRelationFalse result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationFalse::
operator == (const GGS_metamodelRelationFalse & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationFalse::
operator != (const GGS_metamodelRelationFalse & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelRelationFalse::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelRelationFalse" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_metamodelRelationPrimary'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationPrimary::
cPtr_metamodelRelationPrimary (const GGS_relationVarMap & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstring & argument_4 COMMA_LOCATION_ARGS)
:cPtr_metamodelRelationExpression (THERE),
mRelationVariableMap (argument_0),
mVariable (argument_1),
mVariableIndex (argument_2),
mVariableMap (argument_3),
mDomainName (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationPrimary * GGS_metamodelRelationPrimary::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationPrimary *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_metamodelRelationPrimary *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_metamodelRelationPrimary::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_metamodelRelationPrimary * _p = dynamic_cast <const cPtr_metamodelRelationPrimary *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mRelationVariableMap == _p->mRelationVariableMap).boolValue ()
         && (mVariable == _p->mVariable).boolValue ()
         && (mVariableIndex == _p->mVariableIndex).boolValue ()
         && (mVariableMap == _p->mVariableMap).boolValue ()
         && (mDomainName == _p->mDomainName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationPrimary::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationPrimary:"
           << mRelationVariableMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVariableIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVariableMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDomainName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_metamodelRelationPrimary'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelRelationPrimary::
GGS_metamodelRelationPrimary (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationPrimary::
GGS_metamodelRelationPrimary (const GGS_metamodelRelationPrimary & inOperand)
:GGS_metamodelRelationExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationPrimary::
~GGS_metamodelRelationPrimary (void) {
  macroDetachPointer (mPointer, cPtr_metamodelRelationPrimary) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationPrimary::
operator = (const GGS_metamodelRelationPrimary & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationPrimary GGS_metamodelRelationPrimary::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_relationVarMap & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_luint & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_lstring & argument_4 COMMA_LOCATION_ARGS) {
  cPtr_metamodelRelationPrimary * _ptr = (cPtr_metamodelRelationPrimary *) NULL ;
  macroMyNew (_ptr, cPtr_metamodelRelationPrimary (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  GGS_metamodelRelationPrimary result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_relationVarMap  GGS_metamodelRelationPrimary::
reader_mRelationVariableMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_relationVarMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationPrimary *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelRelationPrimary *) mPointer)->mRelationVariableMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelRelationPrimary::
reader_mVariable (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationPrimary *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelRelationPrimary *) mPointer)->mVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_metamodelRelationPrimary::
reader_mVariableIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationPrimary *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelRelationPrimary *) mPointer)->mVariableIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelRelationPrimary::
reader_mVariableMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationPrimary *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelRelationPrimary *) mPointer)->mVariableMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelRelationPrimary::
reader_mDomainName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationPrimary *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelRelationPrimary *) mPointer)->mDomainName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationPrimary::
operator == (const GGS_metamodelRelationPrimary & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationPrimary::
operator != (const GGS_metamodelRelationPrimary & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelRelationPrimary::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelRelationPrimary" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@metamodelRelationParameterList'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_metamodelRelationParameterList::
elementOf_GGS_metamodelRelationParameterList (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_lstring & argument_2):
mParameter (argument_0),
mParameterIndex (argument_1),
mDomainVariable (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_metamodelRelationParameterList::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_metamodelRelationParameterList * _p = dynamic_cast <const elementOf_GGS_metamodelRelationParameterList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mParameter == _p->mParameter).boolValue ()
         && (mParameterIndex == _p->mParameterIndex).boolValue ()
         && (mDomainVariable == _p->mDomainVariable).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_metamodelRelationParameterList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mParameter.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mParameterIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDomainVariable.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@metamodelRelationParameterList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelRelationParameterList::GGS_metamodelRelationParameterList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationParameterList::
GGS_metamodelRelationParameterList (const GGS_metamodelRelationParameterList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationParameterList::
operator == (const GGS_metamodelRelationParameterList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationParameterList::
operator != (const GGS_metamodelRelationParameterList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationParameterList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_lstring & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationParameterList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_lstring & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationParameterList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_lstring & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationParameterList GGS_metamodelRelationParameterList::
operator + (const GGS_metamodelRelationParameterList & inOperand) const {
  GGS_metamodelRelationParameterList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_metamodelRelationParameterList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mParameter ;
          GGS_luint  p_1 = p->mParameterIndex ;
          GGS_lstring  p_2 = p->mDomainVariable ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationParameterList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_luint & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationParameterList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mParameter,
                                _p->mParameterIndex,
                                _p->mDomainVariable) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationParameterList  GGS_metamodelRelationParameterList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_metamodelRelationParameterList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationParameterList  GGS_metamodelRelationParameterList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_luint & argument_1,
                           const GGS_lstring & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_metamodelRelationParameterList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelRelationParameterList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@metamodelRelationParameterList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationParameterList::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0,
              GGS_luint & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mParameter ;
    _out_1 = _p->mParameterIndex ;
    _out_2 = _p->mDomainVariable ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationParameterList::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0,
             GGS_luint & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mParameter ;
    _out_1 = _p->mParameterIndex ;
    _out_2 = _p->mDomainVariable ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationParameterList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_luint & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mParameter ;
    _out_1 = _p->mParameterIndex ;
    _out_2 = _p->mDomainVariable ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationParameterList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0,
                GGS_luint & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mParameter ;
    _out_1 = _p->mParameterIndex ;
    _out_2 = _p->mDomainVariable ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_metamodelRelationDo'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelRelationDo::
cPtr_metamodelRelationDo (const GGS_relationVarMap & argument_0,
                                const GGS_metamodelRelationParameterList & argument_1,
                                const GGS_L_propertyPath & argument_2,
                                const GGS_lbool & argument_3 COMMA_LOCATION_ARGS)
:cPtr_metamodelRelationExpression (THERE),
mRelationVariableMap (argument_0),
mParameterList (argument_1),
mPath (argument_2),
mOperationIsAnd (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelRelationDo * GGS_metamodelRelationDo::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationDo *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_metamodelRelationDo *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_metamodelRelationDo::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_metamodelRelationDo * _p = dynamic_cast <const cPtr_metamodelRelationDo *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mRelationVariableMap == _p->mRelationVariableMap).boolValue ()
         && (mParameterList == _p->mParameterList).boolValue ()
         && (mPath == _p->mPath).boolValue ()
         && (mOperationIsAnd == _p->mOperationIsAnd).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelRelationDo::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@metamodelRelationDo:"
           << mRelationVariableMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mPath.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperationIsAnd.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_metamodelRelationDo'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelRelationDo::
GGS_metamodelRelationDo (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationDo::
GGS_metamodelRelationDo (const GGS_metamodelRelationDo & inOperand)
:GGS_metamodelRelationExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationDo::
~GGS_metamodelRelationDo (void) {
  macroDetachPointer (mPointer, cPtr_metamodelRelationDo) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelRelationDo::
operator = (const GGS_metamodelRelationDo & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationDo GGS_metamodelRelationDo::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_relationVarMap & argument_0,
                 const GGS_metamodelRelationParameterList & argument_1,
                 const GGS_L_propertyPath & argument_2,
                 const GGS_lbool & argument_3 COMMA_LOCATION_ARGS) {
  cPtr_metamodelRelationDo * _ptr = (cPtr_metamodelRelationDo *) NULL ;
  macroMyNew (_ptr, cPtr_metamodelRelationDo (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  GGS_metamodelRelationDo result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_relationVarMap  GGS_metamodelRelationDo::
reader_mRelationVariableMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_relationVarMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationDo *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelRelationDo *) mPointer)->mRelationVariableMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelRelationParameterList  GGS_metamodelRelationDo::
reader_mParameterList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_metamodelRelationParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationDo *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelRelationDo *) mPointer)->mParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_propertyPath  GGS_metamodelRelationDo::
reader_mPath (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_propertyPath   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationDo *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelRelationDo *) mPointer)->mPath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lbool  GGS_metamodelRelationDo::
reader_mOperationIsAnd (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lbool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_metamodelRelationDo *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_metamodelRelationDo *) mPointer)->mOperationIsAnd ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationDo::
operator == (const GGS_metamodelRelationDo & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelRelationDo::
operator != (const GGS_metamodelRelationDo & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelRelationDo::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelRelationDo" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'relationMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_relationMap::
elementOf_GGS_relationMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_relationMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_relationMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mRelationVarMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_relationMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_relationMap * _p = dynamic_cast <const elementOf_GGS_relationMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mRelationVarMap == _p->mInfo.mRelationVarMap).boolValue ()
           && (mInfo.mExpression == _p->mInfo.mExpression).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_relationMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_relationMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_relationMap * info = (e_relationMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_relationMap GGS_relationMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_relationMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_relationMap::
operator == (const GGS_relationMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_relationMap::
operator != (const GGS_relationMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_relationMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_relationMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_relationVarMap & inParameter0,
                const GGS_metamodelRelationExpression & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_relationMap info  ;
    info.mRelationVarMap = inParameter0 ;
    info.mExpression = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_relationMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_relationVarMap   & outParameter0,
               GGS_metamodelRelationExpression   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mRelationVarMap ;
    outParameter1 = node->mInfo.mExpression ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_relationMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_relationVarMap   & outParameter0,
                                GGS_metamodelRelationExpression   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' relation property is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_relationMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_relationVarMap & inParameter0,
                                const GGS_metamodelRelationExpression & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' relation property has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_relationMap GGS_relationMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_relationMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_relationMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_relationMap GGS_relationMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_relationMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_relationMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @relationMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'mapEntityMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapEntityMap::
elementOf_GGS_mapEntityMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapEntityMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapEntityMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mElementEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mInsertErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSearchErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapEntityMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_mapEntityMap * _p = dynamic_cast <const elementOf_GGS_mapEntityMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mElementEntityName == _p->mInfo.mElementEntityName).boolValue ()
           && (mInfo.mInsertErrorMessage == _p->mInfo.mInsertErrorMessage).boolValue ()
           && (mInfo.mSearchErrorMessage == _p->mInfo.mSearchErrorMessage).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapEntityMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapEntityMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapEntityMap * info = (e_mapEntityMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_mapEntityMap GGS_mapEntityMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapEntityMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapEntityMap::
operator == (const GGS_mapEntityMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapEntityMap::
operator != (const GGS_mapEntityMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapEntityMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapEntityMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                const GGS_lstring & inParameter1,
                const GGS_lstring & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_mapEntityMap info  ;
    info.mElementEntityName = inParameter0 ;
    info.mInsertErrorMessage = inParameter1 ;
    info.mSearchErrorMessage = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapEntityMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mElementEntityName ;
    outParameter1 = node->mInfo.mInsertErrorMessage ;
    outParameter2 = node->mInfo.mSearchErrorMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapEntityMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_lstring   & outParameter2 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' map is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapEntityMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_lstring & inParameter2 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' map has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapEntityMap GGS_mapEntityMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_mapEntityMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapEntityMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapEntityMap GGS_mapEntityMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapEntityMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapEntityMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @mapEntityMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'mapAndEntityUniqueMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapAndEntityUniqueMap::
elementOf_GGS_mapAndEntityUniqueMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapAndEntityUniqueMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapAndEntityUniqueMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapAndEntityUniqueMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapAndEntityUniqueMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapAndEntityUniqueMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapAndEntityUniqueMap * info = (e_mapAndEntityUniqueMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_mapAndEntityUniqueMap GGS_mapAndEntityUniqueMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapAndEntityUniqueMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAndEntityUniqueMap::
operator == (const GGS_mapAndEntityUniqueMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAndEntityUniqueMap::
operator != (const GGS_mapAndEntityUniqueMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAndEntityUniqueMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAndEntityUniqueMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_mapAndEntityUniqueMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapAndEntityUniqueMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapAndEntityUniqueMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' entity or map is not declared",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAndEntityUniqueMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' entity or map has been already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapAndEntityUniqueMap GGS_mapAndEntityUniqueMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_mapAndEntityUniqueMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapAndEntityUniqueMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapAndEntityUniqueMap GGS_mapAndEntityUniqueMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapAndEntityUniqueMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapAndEntityUniqueMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @mapAndEntityUniqueMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'indexMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_indexMap::
elementOf_GGS_indexMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_indexMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_indexMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMapAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_indexMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_indexMap * _p = dynamic_cast <const elementOf_GGS_indexMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mMapAttributeName == _p->mInfo.mMapAttributeName).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_indexMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_indexMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_indexMap * info = (e_indexMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_indexMap GGS_indexMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_indexMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_indexMap::
operator == (const GGS_indexMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_indexMap::
operator != (const GGS_indexMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_indexMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_indexMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_indexMap info  ;
    info.mMapAttributeName = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_indexMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMapAttributeName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_indexMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' map index attribute is not defined",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_indexMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' map index is already defined in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_indexMap GGS_indexMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_indexMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_indexMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_indexMap GGS_indexMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_indexMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_indexMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @indexMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'entityToImplementMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_entityToImplementMap::
elementOf_GGS_entityToImplementMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_entityToImplementMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_entityToImplementMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAllMetamodelPropertyMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mCurrentMetamodelPropertyMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSuperEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mCurrentConstraintPropertyMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSuperEntitySet.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAllConstraintPropertyMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAllAvailablePropertyMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_entityToImplementMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_entityToImplementMap * _p = dynamic_cast <const elementOf_GGS_entityToImplementMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mAllMetamodelPropertyMap == _p->mInfo.mAllMetamodelPropertyMap).boolValue ()
           && (mInfo.mIsAbstract == _p->mInfo.mIsAbstract).boolValue ()
           && (mInfo.mCurrentMetamodelPropertyMap == _p->mInfo.mCurrentMetamodelPropertyMap).boolValue ()
           && (mInfo.mSuperEntityName == _p->mInfo.mSuperEntityName).boolValue ()
           && (mInfo.mCurrentConstraintPropertyMap == _p->mInfo.mCurrentConstraintPropertyMap).boolValue ()
           && (mInfo.mSuperEntitySet == _p->mInfo.mSuperEntitySet).boolValue ()
           && (mInfo.mAllConstraintPropertyMap == _p->mInfo.mAllConstraintPropertyMap).boolValue ()
           && (mInfo.mAllAvailablePropertyMap == _p->mInfo.mAllAvailablePropertyMap).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_entityToImplementMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_entityToImplementMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_entityToImplementMap * info = (e_entityToImplementMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_entityToImplementMap GGS_entityToImplementMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_entityToImplementMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_entityToImplementMap::
operator == (const GGS_entityToImplementMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_entityToImplementMap::
operator != (const GGS_entityToImplementMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_entityPropertyMap & inParameter0,
                const GGS_bool& inParameter1,
                const GGS_entityPropertyMap & inParameter2,
                const GGS_lstring & inParameter3,
                const GGS_entityPropertyMap & inParameter4,
                const GGS_stringset & inParameter5,
                const GGS_entityPropertyMap & inParameter6,
                const GGS_entityPropertyMap & inParameter7,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inParameter3._isBuilt ()
   && inParameter4._isBuilt ()
   && inParameter5._isBuilt ()
   && inParameter6._isBuilt ()
   && inParameter7._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_entityToImplementMap info  ;
    info.mAllMetamodelPropertyMap = inParameter0 ;
    info.mIsAbstract = inParameter1 ;
    info.mCurrentMetamodelPropertyMap = inParameter2 ;
    info.mSuperEntityName = inParameter3 ;
    info.mCurrentConstraintPropertyMap = inParameter4 ;
    info.mSuperEntitySet = inParameter5 ;
    info.mAllConstraintPropertyMap = inParameter6 ;
    info.mAllAvailablePropertyMap = inParameter7 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_entityPropertyMap   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_entityPropertyMap   & outParameter2,
               GGS_lstring   & outParameter3,
               GGS_entityPropertyMap   & outParameter4,
               GGS_stringset   & outParameter5,
               GGS_entityPropertyMap   & outParameter6,
               GGS_entityPropertyMap   & outParameter7,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    outParameter3._drop_operation () ;
    outParameter4._drop_operation () ;
    outParameter5._drop_operation () ;
    outParameter6._drop_operation () ;
    outParameter7._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAllMetamodelPropertyMap ;
    outParameter1 = node->mInfo.mIsAbstract ;
    outParameter2 = node->mInfo.mCurrentMetamodelPropertyMap ;
    outParameter3 = node->mInfo.mSuperEntityName ;
    outParameter4 = node->mInfo.mCurrentConstraintPropertyMap ;
    outParameter5 = node->mInfo.mSuperEntitySet ;
    outParameter6 = node->mInfo.mAllConstraintPropertyMap ;
    outParameter7 = node->mInfo.mAllAvailablePropertyMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_entityPropertyMap   & outParameter0,
                                GGS_bool  & outParameter1,
                                GGS_entityPropertyMap   & outParameter2,
                                GGS_lstring   & outParameter3,
                                GGS_entityPropertyMap   & outParameter4,
                                GGS_stringset   & outParameter5,
                                GGS_entityPropertyMap   & outParameter6,
                                GGS_entityPropertyMap   & outParameter7 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '@%K' entity is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  outParameter5,
                  outParameter6,
                  outParameter7,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_entityToImplementMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_entityPropertyMap & inParameter0,
                                const GGS_bool& inParameter1,
                                const GGS_entityPropertyMap & inParameter2,
                                const GGS_lstring & inParameter3,
                                const GGS_entityPropertyMap & inParameter4,
                                const GGS_stringset & inParameter5,
                                const GGS_entityPropertyMap & inParameter6,
                                const GGS_entityPropertyMap & inParameter7 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '@%K' entity has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_entityToImplementMap GGS_entityToImplementMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_entityToImplementMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_entityToImplementMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_entityToImplementMap GGS_entityToImplementMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_entityToImplementMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_entityToImplementMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @entityToImplementMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeGalgas_singleEntity'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_singleEntity::
cPtr_typeGalgas_singleEntity (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEntityName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_singleEntity * GGS_typeGalgas_singleEntity::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_singleEntity *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_singleEntity *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_singleEntity::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgas_singleEntity * _p = dynamic_cast <const cPtr_typeGalgas_singleEntity *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mEntityName == _p->mEntityName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_singleEntity::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mEntityName.reader_string (_inLexique SOURCE_FILE_AT_LINE (776)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_singleEntity::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_singleEntity:"
           << mEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_singleEntity
::static_string_message_messageGalgasType (void) {
  return "an entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_singleEntity::
message_messageGalgasType (void) const {
  return "an entity" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeGalgas_singleEntity'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_singleEntity::
GGS_typeGalgas_singleEntity (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_singleEntity::
GGS_typeGalgas_singleEntity (const GGS_typeGalgas_singleEntity & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_singleEntity::
~GGS_typeGalgas_singleEntity (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_singleEntity) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_singleEntity::
operator = (const GGS_typeGalgas_singleEntity & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_singleEntity GGS_typeGalgas_singleEntity::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_singleEntity * _ptr = (cPtr_typeGalgas_singleEntity *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_singleEntity (argument_0 COMMA_THERE)) ;
  GGS_typeGalgas_singleEntity result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_singleEntity::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgas_singleEntity::
reader_mEntityName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_singleEntity *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_singleEntity *) mPointer)->mEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_singleEntity::
operator == (const GGS_typeGalgas_singleEntity & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_singleEntity::
operator != (const GGS_typeGalgas_singleEntity & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_singleEntity::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_singleEntity" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeGalgas_multipleEntity'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_multipleEntity::
cPtr_typeGalgas_multipleEntity (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEntityName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_multipleEntity * GGS_typeGalgas_multipleEntity::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_multipleEntity *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_multipleEntity *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_multipleEntity::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgas_multipleEntity * _p = dynamic_cast <const cPtr_typeGalgas_multipleEntity *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mEntityName == _p->mEntityName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_multipleEntity::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = ((GGS_string (true, "_listOf_")) + (mEntityName.reader_string (_inLexique SOURCE_FILE_AT_LINE (789)))) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_multipleEntity::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_multipleEntity:"
           << mEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_multipleEntity
::static_string_message_messageGalgasType (void) {
  return "a list of entities" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_multipleEntity::
message_messageGalgasType (void) const {
  return "a list of entities" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeGalgas_multipleEntity'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_multipleEntity::
GGS_typeGalgas_multipleEntity (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_multipleEntity::
GGS_typeGalgas_multipleEntity (const GGS_typeGalgas_multipleEntity & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_multipleEntity::
~GGS_typeGalgas_multipleEntity (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_multipleEntity) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_multipleEntity::
operator = (const GGS_typeGalgas_multipleEntity & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_multipleEntity GGS_typeGalgas_multipleEntity::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_multipleEntity * _ptr = (cPtr_typeGalgas_multipleEntity *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_multipleEntity (argument_0 COMMA_THERE)) ;
  GGS_typeGalgas_multipleEntity result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_multipleEntity::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgas_multipleEntity::
reader_mEntityName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_multipleEntity *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_multipleEntity *) mPointer)->mEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_multipleEntity::
operator == (const GGS_typeGalgas_multipleEntity & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_multipleEntity::
operator != (const GGS_typeGalgas_multipleEntity & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_multipleEntity::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_multipleEntity" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeAttributsSemantiques'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeAttributsSemantiques::
elementOf_GGS_typeListeAttributsSemantiques (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1):
mAttributType (argument_0),
aNomAttribut (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeAttributsSemantiques::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeAttributsSemantiques * _p = dynamic_cast <const elementOf_GGS_typeListeAttributsSemantiques *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mAttributType == _p->mAttributType).boolValue ()
         && (aNomAttribut == _p->aNomAttribut).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeAttributsSemantiques::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aNomAttribut.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeAttributsSemantiques'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::GGS_typeListeAttributsSemantiques (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques::
GGS_typeListeAttributsSemantiques (const GGS_typeListeAttributsSemantiques & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeAttributsSemantiques::
operator == (const GGS_typeListeAttributsSemantiques & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeAttributsSemantiques::
operator != (const GGS_typeListeAttributsSemantiques & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
_addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques GGS_typeListeAttributsSemantiques::
operator + (const GGS_typeListeAttributsSemantiques & inOperand) const {
  GGS_typeListeAttributsSemantiques result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeAttributsSemantiques * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mAttributType ;
          GGS_lstring  p_1 = p->aNomAttribut ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributType,
                                _p->aNomAttribut) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeListeAttributsSemantiques::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeAttributsSemantiques result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeListeAttributsSemantiques::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_AC_galgasType & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeAttributsSemantiques result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeAttributsSemantiques::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeAttributsSemantiques", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
method_first (C_Lexique & _inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributType ;
    _out_1 = _p->aNomAttribut ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
method_last (C_Lexique & _inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributType ;
    _out_1 = _p->aNomAttribut ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributType ;
    _out_1 = _p->aNomAttribut ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsSemantiques::
modifier_popLast (C_Lexique & _inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributType ;
    _out_1 = _p->aNomAttribut ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@typeTypesList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTypesList::
elementOf_GGS_typeTypesList (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1):
mType (argument_0),
mEndOfExpressionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTypesList::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeTypesList * _p = dynamic_cast <const elementOf_GGS_typeTypesList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mType == _p->mType).boolValue ()
         && (mEndOfExpressionLocation == _p->mEndOfExpressionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTypesList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfExpressionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@typeTypesList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTypesList::GGS_typeTypesList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeTypesList::
GGS_typeTypesList (const GGS_typeTypesList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTypesList::
operator == (const GGS_typeTypesList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTypesList::
operator != (const GGS_typeTypesList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
_addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_location & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeTypesList GGS_typeTypesList::
operator + (const GGS_typeTypesList & inOperand) const {
  GGS_typeTypesList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeTypesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_location  p_1 = p->mEndOfExpressionLocation ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mEndOfExpressionLocation) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeTypesList  GGS_typeTypesList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTypesList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTypesList  GGS_typeTypesList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_AC_galgasType & argument_0,
                           const GGS_location & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTypesList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTypesList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeTypesList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
method_first (C_Lexique & _inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_location & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mEndOfExpressionLocation ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
method_last (C_Lexique & _inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_location & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mEndOfExpressionLocation ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_location & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mEndOfExpressionLocation ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTypesList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_location & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mEndOfExpressionLocation ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_EXsignature'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_EXsignature::
elementOf_GGS_L_EXsignature (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1):
mType (argument_0),
mFormalArgumentPassingMode (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_EXsignature::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_EXsignature * _p = dynamic_cast <const elementOf_GGS_L_EXsignature *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mType == _p->mType).boolValue ()
         && (mFormalArgumentPassingMode == _p->mFormalArgumentPassingMode).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_EXsignature::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_EXsignature'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_EXsignature::GGS_L_EXsignature (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature::
GGS_L_EXsignature (const GGS_L_EXsignature & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_EXsignature::
operator == (const GGS_L_EXsignature & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_EXsignature::
operator != (const GGS_L_EXsignature & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_formalArgumentPassingMode& argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_formalArgumentPassingMode& argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
_addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature GGS_L_EXsignature::
operator + (const GGS_L_EXsignature & inOperand) const {
  GGS_L_EXsignature result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_EXsignature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_formalArgumentPassingMode p_1 = p->mFormalArgumentPassingMode ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_formalArgumentPassingMode& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mFormalArgumentPassingMode) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_L_EXsignature::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_EXsignature result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_L_EXsignature::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_AC_galgasType & argument_0,
                           const GGS_formalArgumentPassingMode& argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_EXsignature result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_EXsignature::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_EXsignature", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
method_first (C_Lexique & _inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_formalArgumentPassingMode& _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
method_last (C_Lexique & _inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_formalArgumentPassingMode& _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_formalArgumentPassingMode& _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_EXsignature::
modifier_popLast (C_Lexique & _inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_formalArgumentPassingMode& _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_actualParametersSignature'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_actualParametersSignature::
elementOf_GGS_L_actualParametersSignature (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1):
mType (argument_0),
mFormalArgumentPassingMode (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_actualParametersSignature::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_actualParametersSignature * _p = dynamic_cast <const elementOf_GGS_L_actualParametersSignature *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mType == _p->mType).boolValue ()
         && (mFormalArgumentPassingMode == _p->mFormalArgumentPassingMode).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_actualParametersSignature::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@L_actualParametersSignature'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::GGS_L_actualParametersSignature (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature::
GGS_L_actualParametersSignature (const GGS_L_actualParametersSignature & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_actualParametersSignature::
operator == (const GGS_L_actualParametersSignature & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_actualParametersSignature::
operator != (const GGS_L_actualParametersSignature & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_actualParametersPassingMode& argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_actualParametersPassingMode& argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
_addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_actualParametersPassingMode& argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature GGS_L_actualParametersSignature::
operator + (const GGS_L_actualParametersSignature & inOperand) const {
  GGS_L_actualParametersSignature result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_actualParametersSignature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_actualParametersPassingMode p_1 = p->mFormalArgumentPassingMode ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_actualParametersPassingMode& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mFormalArgumentPassingMode) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature  GGS_L_actualParametersSignature::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_actualParametersSignature result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_actualParametersSignature  GGS_L_actualParametersSignature::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_AC_galgasType & argument_0,
                           const GGS_actualParametersPassingMode& argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_actualParametersSignature result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_actualParametersSignature::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_actualParametersSignature", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
method_first (C_Lexique & _inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_actualParametersPassingMode& _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
method_last (C_Lexique & _inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_actualParametersPassingMode& _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_actualParametersPassingMode& _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_actualParametersSignature::
modifier_popLast (C_Lexique & _inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_actualParametersPassingMode& _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'M_accessors_map'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_accessors_map::
elementOf_GGS_M_accessors_map (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_accessors_map & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_accessors_map::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAccessorSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mReturnedType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_accessors_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_accessors_map * _p = dynamic_cast <const elementOf_GGS_M_accessors_map *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mAccessorSignature == _p->mInfo.mAccessorSignature).boolValue ()
           && (mInfo.mReturnedType == _p->mInfo.mReturnedType).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_accessors_map::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_accessors_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_accessors_map * info = (e_M_accessors_map *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_accessors_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_accessors_map::
operator == (const GGS_M_accessors_map & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_accessors_map::
operator != (const GGS_M_accessors_map & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                const GGS_AC_galgasType & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_accessors_map info  ;
    info.mAccessorSignature = inParameter0 ;
    info.mReturnedType = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAccessorSignature ;
    outParameter1 = node->mInfo.mReturnedType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_AC_galgasType   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' accessor is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_accessors_map::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_AC_galgasType & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' accessor has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_accessors_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_accessors_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_accessors_map GGS_M_accessors_map::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_accessors_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_accessors_map::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_accessors_map " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_stringList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_stringList::
elementOf_GGS_L_stringList (const GGS_string& argument_0):
mErrorMessageElement (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_stringList::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_stringList * _p = dynamic_cast <const elementOf_GGS_L_stringList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mErrorMessageElement == _p->mErrorMessageElement).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_stringList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessageElement.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@L_stringList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_stringList::GGS_L_stringList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_stringList::
GGS_L_stringList (const GGS_L_stringList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_stringList::
operator == (const GGS_L_stringList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_stringList::
operator != (const GGS_L_stringList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
_internalAppendValues (const GGS_string& argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
_internalPrependValues (const GGS_string& argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
_addAssign_operation (const GGS_string& argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_stringList GGS_L_stringList::
operator + (const GGS_L_stringList & inOperand) const {
  GGS_L_stringList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_stringList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mErrorMessageElement ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_string& argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mErrorMessageElement) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_stringList  GGS_L_stringList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_stringList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_stringList  GGS_L_stringList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_string& argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_stringList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_stringList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_stringList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
method_first (C_Lexique & _inLexique,
              GGS_string& _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mErrorMessageElement ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
method_last (C_Lexique & _inLexique,
             GGS_string& _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mErrorMessageElement ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_string& _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mErrorMessageElement ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stringList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_string& _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mErrorMessageElement ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_typeGalgas_jokerInParameterList'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_jokerInParameterList::
cPtr_typeGalgas_jokerInParameterList (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_jokerInParameterList * GGS_typeGalgas_jokerInParameterList::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_jokerInParameterList *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_jokerInParameterList::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_jokerInParameterList::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_jokerInParameterList::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_jokerInParameterList:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_jokerInParameterList
::static_string_message_messageGalgasType (void) {
  return "\?\?" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_jokerInParameterList::
message_messageGalgasType (void) const {
  return "\?\?" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeGalgas_jokerInParameterList'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_jokerInParameterList::
GGS_typeGalgas_jokerInParameterList (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_jokerInParameterList::
GGS_typeGalgas_jokerInParameterList (const GGS_typeGalgas_jokerInParameterList & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_jokerInParameterList::
~GGS_typeGalgas_jokerInParameterList (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_jokerInParameterList) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_jokerInParameterList::
operator = (const GGS_typeGalgas_jokerInParameterList & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_jokerInParameterList GGS_typeGalgas_jokerInParameterList::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_jokerInParameterList * _ptr = (cPtr_typeGalgas_jokerInParameterList *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_jokerInParameterList (THERE)) ;
  GGS_typeGalgas_jokerInParameterList result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_jokerInParameterList::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_jokerInParameterList::
operator == (const GGS_typeGalgas_jokerInParameterList & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_jokerInParameterList::
operator != (const GGS_typeGalgas_jokerInParameterList & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_jokerInParameterList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_jokerInParameterList" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeGalgas_bool'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_bool::
cPtr_typeGalgas_bool (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_bool * GGS_typeGalgas_bool::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_bool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_bool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_bool::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "bool") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::
method_acceptToBeSortKeyInSortedListDefinition (C_Lexique & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_bool::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_bool:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_bool
::static_string_message_messageGalgasType (void) {
  return "a '@bool' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_bool::
message_messageGalgasType (void) const {
  return "a '@bool' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_bool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_bool::
GGS_typeGalgas_bool (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_bool::
GGS_typeGalgas_bool (const GGS_typeGalgas_bool & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_bool::
~GGS_typeGalgas_bool (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_bool) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_bool::
operator = (const GGS_typeGalgas_bool & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_bool GGS_typeGalgas_bool::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_bool * _ptr = (cPtr_typeGalgas_bool *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_bool (THERE)) ;
  GGS_typeGalgas_bool result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_bool::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_bool::
operator == (const GGS_typeGalgas_bool & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_bool::
operator != (const GGS_typeGalgas_bool & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_bool::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_bool" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeGalgas_uint'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_uint::
cPtr_typeGalgas_uint (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_uint * GGS_typeGalgas_uint::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_uint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_uint *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_uint::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "uint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_acceptToBeSortKeyInSortedListDefinition (C_Lexique & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_handleIncrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_handleDecrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((((((((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (929))) == (GGS_string (true, "max"))) | ((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (930))) == (GGS_string (true, "sequenceNumber"))))) | ((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (931))) == (GGS_string (true, "errorCount"))))) | ((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (932))) == (GGS_string (true, "warningCount"))))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (936)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_uint:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint
::static_string_message_messageGalgasType (void) {
  return "a '@uint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint::
message_messageGalgasType (void) const {
  return "a '@uint' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_uint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_uint::
GGS_typeGalgas_uint (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint::
GGS_typeGalgas_uint (const GGS_typeGalgas_uint & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint::
~GGS_typeGalgas_uint (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_uint) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_uint::
operator = (const GGS_typeGalgas_uint & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint GGS_typeGalgas_uint::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_uint * _ptr = (cPtr_typeGalgas_uint *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_uint (THERE)) ;
  GGS_typeGalgas_uint result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_uint::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_uint::
operator == (const GGS_typeGalgas_uint & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_uint::
operator != (const GGS_typeGalgas_uint & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_uint::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_uint" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeGalgas_string'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_string::
cPtr_typeGalgas_string (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_string * GGS_typeGalgas_string::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_string *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_string *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_string::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "string") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_acceptToBeSortKeyInSortedListDefinition (C_Lexique & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_handleMethodInstructionCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inReadObjectName */,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_EXsignature & var_cas_outReaderSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inReaderName.reader_string (_inLexique SOURCE_FILE_AT_LINE (963))) == (GGS_string (true, "writeToFile"))).isBuiltAndTrue ()) {
    var_cas_outReaderSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outReaderSignature._addAssign_operation (GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique SOURCE_FILE_AT_LINE (966))) == (GGS_string (true, "makeDirectoryAndWriteToFile"))).isBuiltAndTrue ()) {
    var_cas_outReaderSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outReaderSignature._addAssign_operation (GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique SOURCE_FILE_AT_LINE (969))) == (GGS_string (true, "makeDirectory"))).isBuiltAndTrue ()) {
    var_cas_outReaderSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else{
    var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "this method is not defined (writeToFile, makeDirectoryAndWriteToFile")) + (GGS_string (true, " and makeDirectory methods are defined on @string objects) "))) SOURCE_FILE_AT_LINE (974)) ;
    var_cas_outReaderSignature._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (982))) == (GGS_string (true, "stringWithSourceFilePath"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (984))) == (GGS_string (true, "stringWithCurrentDirectory"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (986))) == (GGS_string (true, "stringWithMainFirstArgument"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (988))) == (GGS_string (true, "stringWithContentsOfFile"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE), GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (991))) == (GGS_string (true, "stringWithCurrentDateTime"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (995)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1005))) == (GGS_string (true, "setCapacity"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this modifier is not defined") SOURCE_FILE_AT_LINE (1011)) ;
    var_cas_outModifierSignature._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_string::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_string:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_string
::static_string_message_messageGalgasType (void) {
  return "a '@string' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_string::
message_messageGalgasType (void) const {
  return "a '@string' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_string'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_string::
GGS_typeGalgas_string (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_string::
GGS_typeGalgas_string (const GGS_typeGalgas_string & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_string::
~GGS_typeGalgas_string (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_string) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_string::
operator = (const GGS_typeGalgas_string & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_string GGS_typeGalgas_string::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_string * _ptr = (cPtr_typeGalgas_string *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_string (THERE)) ;
  GGS_typeGalgas_string result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_string::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_string::
operator == (const GGS_typeGalgas_string & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_string::
operator != (const GGS_typeGalgas_string & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_string::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_string" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeGalgas_sint'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_sint::
cPtr_typeGalgas_sint (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_sint * GGS_typeGalgas_sint::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_sint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_sint *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_sint::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "sint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_acceptToBeSortKeyInSortedListDefinition (C_Lexique & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_handleIncrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_handleDecrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1048))) == (GGS_string (true, "min"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1050))) == (GGS_string (true, "max"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1054)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_sint:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint
::static_string_message_messageGalgasType (void) {
  return "a '@sint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint::
message_messageGalgasType (void) const {
  return "a '@sint' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_sint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_sint::
GGS_typeGalgas_sint (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint::
GGS_typeGalgas_sint (const GGS_typeGalgas_sint & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint::
~GGS_typeGalgas_sint (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_sint) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_sint::
operator = (const GGS_typeGalgas_sint & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint GGS_typeGalgas_sint::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_sint * _ptr = (cPtr_typeGalgas_sint *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_sint (THERE)) ;
  GGS_typeGalgas_sint result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_sint::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_sint::
operator == (const GGS_typeGalgas_sint & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_sint::
operator != (const GGS_typeGalgas_sint & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_sint::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_sint" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeGalgas_sint64'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_sint64::
cPtr_typeGalgas_sint64 (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_sint64 * GGS_typeGalgas_sint64::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_sint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_sint64 *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_sint64::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "sint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_acceptToBeSortKeyInSortedListDefinition (C_Lexique & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_handleIncrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_handleDecrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1091))) == (GGS_string (true, "min"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1093))) == (GGS_string (true, "max"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1097)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_sint64::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_sint64:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint64
::static_string_message_messageGalgasType (void) {
  return "a '@sint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_sint64::
message_messageGalgasType (void) const {
  return "a '@sint64' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_sint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_sint64::
GGS_typeGalgas_sint64 (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint64::
GGS_typeGalgas_sint64 (const GGS_typeGalgas_sint64 & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint64::
~GGS_typeGalgas_sint64 (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_sint64) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_sint64::
operator = (const GGS_typeGalgas_sint64 & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_sint64 GGS_typeGalgas_sint64::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_sint64 * _ptr = (cPtr_typeGalgas_sint64 *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_sint64 (THERE)) ;
  GGS_typeGalgas_sint64 result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_sint64::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_sint64::
operator == (const GGS_typeGalgas_sint64 & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_sint64::
operator != (const GGS_typeGalgas_sint64 & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_sint64::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_sint64" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeGalgas_uint64'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_uint64::
cPtr_typeGalgas_uint64 (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_uint64 * GGS_typeGalgas_uint64::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_uint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_uint64 *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_uint64::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "uint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_acceptToBeSortKeyInSortedListDefinition (C_Lexique & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_handleIncrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_handleDecrementOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1134))) == (GGS_string (true, "max"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1138)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_uint64::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_uint64:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint64
::static_string_message_messageGalgasType (void) {
  return "a '@uint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_uint64::
message_messageGalgasType (void) const {
  return "a '@uint64' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_uint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_uint64::
GGS_typeGalgas_uint64 (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint64::
GGS_typeGalgas_uint64 (const GGS_typeGalgas_uint64 & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint64::
~GGS_typeGalgas_uint64 (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_uint64) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_uint64::
operator = (const GGS_typeGalgas_uint64 & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_uint64 GGS_typeGalgas_uint64::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_uint64 * _ptr = (cPtr_typeGalgas_uint64 *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_uint64 (THERE)) ;
  GGS_typeGalgas_uint64 result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_uint64::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_uint64::
operator == (const GGS_typeGalgas_uint64 & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_uint64::
operator != (const GGS_typeGalgas_uint64 & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_uint64::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_uint64" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeGalgas_char'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_char::
cPtr_typeGalgas_char (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_char * GGS_typeGalgas_char::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_char *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_char *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_char::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "char") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::
method_acceptToBeSortKeyInSortedListDefinition (C_Lexique & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_char::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_char:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_char
::static_string_message_messageGalgasType (void) {
  return "a '@char' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_char::
message_messageGalgasType (void) const {
  return "a '@char' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_char'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_char::
GGS_typeGalgas_char (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_char::
GGS_typeGalgas_char (const GGS_typeGalgas_char & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_char::
~GGS_typeGalgas_char (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_char) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_char::
operator = (const GGS_typeGalgas_char & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_char GGS_typeGalgas_char::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_char * _ptr = (cPtr_typeGalgas_char *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_char (THERE)) ;
  GGS_typeGalgas_char result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_char::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_char::
operator == (const GGS_typeGalgas_char & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_char::
operator != (const GGS_typeGalgas_char & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_char::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_char" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeGalgas_double'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_double::
cPtr_typeGalgas_double (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_double * GGS_typeGalgas_double::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_double *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_double *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_double::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_double::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "double") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_double::
method_acceptToBeSortKeyInSortedListDefinition (C_Lexique & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_double::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_double:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_double
::static_string_message_messageGalgasType (void) {
  return "a '@double' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_double::
message_messageGalgasType (void) const {
  return "a '@double' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_double'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_double::
GGS_typeGalgas_double (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_double::
GGS_typeGalgas_double (const GGS_typeGalgas_double & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_double::
~GGS_typeGalgas_double (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_double) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_double::
operator = (const GGS_typeGalgas_double & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_double GGS_typeGalgas_double::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_double * _ptr = (cPtr_typeGalgas_double *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_double (THERE)) ;
  GGS_typeGalgas_double result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_double::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_double::
operator == (const GGS_typeGalgas_double & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_double::
operator != (const GGS_typeGalgas_double & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_double::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_double" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_galgasPrimitiveType'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_galgasPrimitiveType::
cPtr_C_galgasPrimitiveType (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_galgasPrimitiveType * GGS_C_galgasPrimitiveType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_galgasPrimitiveType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_galgasPrimitiveType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_C_galgasPrimitiveType::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@C_galgasPrimitiveType:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType
::static_string_message_messageGalgasType (void) {
  return "any primitive type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_galgasPrimitiveType::
message_messageGalgasType (void) const {
  return "any primitive type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_galgasPrimitiveType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
GGS_C_galgasPrimitiveType (const GGS_C_galgasPrimitiveType & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_galgasPrimitiveType::
~GGS_C_galgasPrimitiveType (void) {
  macroDetachPointer (mPointer, cPtr_C_galgasPrimitiveType) ;
}

//---------------------------------------------------------------------------*

void GGS_C_galgasPrimitiveType::
operator = (const GGS_C_galgasPrimitiveType & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_galgasPrimitiveType::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_galgasPrimitiveType::
operator == (const GGS_C_galgasPrimitiveType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_galgasPrimitiveType::
operator != (const GGS_C_galgasPrimitiveType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_galgasPrimitiveType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_galgasPrimitiveType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeGalgas_location'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_location::
cPtr_typeGalgas_location (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_location * GGS_typeGalgas_location::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_location *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_location *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_location::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "location") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
method_acceptAssignmentFromHere (C_Lexique & /* _inLexique */,
                                GGS_lstring  /* var_cas_inErrorLocation */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_location::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_location:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_location
::static_string_message_messageGalgasType (void) {
  return "a '@location' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_location::
message_messageGalgasType (void) const {
  return "a '@location' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_location'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_location::
GGS_typeGalgas_location (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_location::
GGS_typeGalgas_location (const GGS_typeGalgas_location & inOperand)
:GGS_C_galgasPrimitiveType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_location::
~GGS_typeGalgas_location (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_location) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_location::
operator = (const GGS_typeGalgas_location & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_location GGS_typeGalgas_location::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_location * _ptr = (cPtr_typeGalgas_location *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_location (THERE)) ;
  GGS_typeGalgas_location result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_location::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_location::
operator == (const GGS_typeGalgas_location & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_location::
operator != (const GGS_typeGalgas_location & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_location::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_location" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeGalgas_lstring'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lstring::
cPtr_typeGalgas_lstring (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lstring * GGS_typeGalgas_lstring::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lstring *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lstring *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lstring::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "lstring") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1225))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE), GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE), GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1231)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1241))) == (GGS_string (true, "setString"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1244))) == (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") SOURCE_FILE_AT_LINE (1250)) ;
    var_cas_outModifierSignature._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lstring::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lstring:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lstring
::static_string_message_messageGalgasType (void) {
  return "a '@lstring' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lstring::
message_messageGalgasType (void) const {
  return "a '@lstring' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_lstring'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_lstring::
GGS_typeGalgas_lstring (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lstring::
GGS_typeGalgas_lstring (const GGS_typeGalgas_lstring & inOperand)
:GGS_C_galgasPrimitiveType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lstring::
~GGS_typeGalgas_lstring (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_lstring) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_lstring::
operator = (const GGS_typeGalgas_lstring & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lstring GGS_typeGalgas_lstring::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_lstring * _ptr = (cPtr_typeGalgas_lstring *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_lstring (THERE)) ;
  GGS_typeGalgas_lstring result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lstring::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_lstring::
operator == (const GGS_typeGalgas_lstring & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_lstring::
operator != (const GGS_typeGalgas_lstring & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lstring::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_lstring" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeGalgas_lchar'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lchar::
cPtr_typeGalgas_lchar (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lchar * GGS_typeGalgas_lchar::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lchar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lchar *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lchar::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "lchar") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1273))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_char::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1281)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1291))) == (GGS_string (true, "setChar"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_char::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1294))) == (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") SOURCE_FILE_AT_LINE (1300)) ;
    var_cas_outModifierSignature._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lchar::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lchar:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lchar
::static_string_message_messageGalgasType (void) {
  return "a '@lchar' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lchar::
message_messageGalgasType (void) const {
  return "a '@lchar' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lchar'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_lchar::
GGS_typeGalgas_lchar (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lchar::
GGS_typeGalgas_lchar (const GGS_typeGalgas_lchar & inOperand)
:GGS_C_galgasPrimitiveType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lchar::
~GGS_typeGalgas_lchar (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_lchar) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_lchar::
operator = (const GGS_typeGalgas_lchar & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lchar GGS_typeGalgas_lchar::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_lchar * _ptr = (cPtr_typeGalgas_lchar *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_lchar (THERE)) ;
  GGS_typeGalgas_lchar result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lchar::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_lchar::
operator == (const GGS_typeGalgas_lchar & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_lchar::
operator != (const GGS_typeGalgas_lchar & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lchar::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_lchar" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeGalgas_lbool'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lbool::
cPtr_typeGalgas_lbool (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lbool * GGS_typeGalgas_lbool::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lbool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lbool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lbool::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "lbool") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1323))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_bool::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1331)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1341))) == (GGS_string (true, "setBool"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_bool::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1344))) == (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") SOURCE_FILE_AT_LINE (1350)) ;
    var_cas_outModifierSignature._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lbool::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lbool:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lbool
::static_string_message_messageGalgasType (void) {
  return "a '@lbool' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lbool::
message_messageGalgasType (void) const {
  return "a '@lbool' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lbool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_lbool::
GGS_typeGalgas_lbool (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lbool::
GGS_typeGalgas_lbool (const GGS_typeGalgas_lbool & inOperand)
:GGS_C_galgasPrimitiveType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lbool::
~GGS_typeGalgas_lbool (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_lbool) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_lbool::
operator = (const GGS_typeGalgas_lbool & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lbool GGS_typeGalgas_lbool::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_lbool * _ptr = (cPtr_typeGalgas_lbool *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_lbool (THERE)) ;
  GGS_typeGalgas_lbool result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lbool::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_lbool::
operator == (const GGS_typeGalgas_lbool & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_lbool::
operator != (const GGS_typeGalgas_lbool & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lbool::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_lbool" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeGalgas_luint'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_luint::
cPtr_typeGalgas_luint (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_luint * GGS_typeGalgas_luint::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_luint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_luint *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_luint::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "luint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1372))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1380)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1390))) == (GGS_string (true, "setUint"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1393))) == (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") SOURCE_FILE_AT_LINE (1399)) ;
    var_cas_outModifierSignature._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_luint:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint
::static_string_message_messageGalgasType (void) {
  return "a '@luint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint::
message_messageGalgasType (void) const {
  return "a '@luint' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_luint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_luint::
GGS_typeGalgas_luint (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint::
GGS_typeGalgas_luint (const GGS_typeGalgas_luint & inOperand)
:GGS_C_galgasPrimitiveType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint::
~GGS_typeGalgas_luint (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_luint) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_luint::
operator = (const GGS_typeGalgas_luint & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint GGS_typeGalgas_luint::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_luint * _ptr = (cPtr_typeGalgas_luint *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_luint (THERE)) ;
  GGS_typeGalgas_luint result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_luint::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_luint::
operator == (const GGS_typeGalgas_luint & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_luint::
operator != (const GGS_typeGalgas_luint & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_luint::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_luint" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeGalgas_luint64'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_luint64::
cPtr_typeGalgas_luint64 (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_luint64 * GGS_typeGalgas_luint64::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_luint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_luint64 *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_luint64::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "luint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1421))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_uint64::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1429)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1439))) == (GGS_string (true, "setUint64"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_uint64::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1442))) == (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") SOURCE_FILE_AT_LINE (1448)) ;
    var_cas_outModifierSignature._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_luint64::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_luint64:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint64
::static_string_message_messageGalgasType (void) {
  return "a '@luint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_luint64::
message_messageGalgasType (void) const {
  return "a '@luint64' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_luint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_luint64::
GGS_typeGalgas_luint64 (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint64::
GGS_typeGalgas_luint64 (const GGS_typeGalgas_luint64 & inOperand)
:GGS_C_galgasPrimitiveType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint64::
~GGS_typeGalgas_luint64 (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_luint64) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_luint64::
operator = (const GGS_typeGalgas_luint64 & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_luint64 GGS_typeGalgas_luint64::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_luint64 * _ptr = (cPtr_typeGalgas_luint64 *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_luint64 (THERE)) ;
  GGS_typeGalgas_luint64 result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_luint64::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_luint64::
operator == (const GGS_typeGalgas_luint64 & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_luint64::
operator != (const GGS_typeGalgas_luint64 & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_luint64::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_luint64" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeGalgas_lsint'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lsint::
cPtr_typeGalgas_lsint (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lsint * GGS_typeGalgas_lsint::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lsint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lsint *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lsint::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "lsint") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1470))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_sint::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1478)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1488))) == (GGS_string (true, "setSint"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_sint::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1491))) == (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") SOURCE_FILE_AT_LINE (1497)) ;
    var_cas_outModifierSignature._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lsint:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint
::static_string_message_messageGalgasType (void) {
  return "a '@lsint' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint::
message_messageGalgasType (void) const {
  return "a '@lsint' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgas_lsint'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint::
GGS_typeGalgas_lsint (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint::
GGS_typeGalgas_lsint (const GGS_typeGalgas_lsint & inOperand)
:GGS_C_galgasPrimitiveType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint::
~GGS_typeGalgas_lsint (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_lsint) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_lsint::
operator = (const GGS_typeGalgas_lsint & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint GGS_typeGalgas_lsint::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_lsint * _ptr = (cPtr_typeGalgas_lsint *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_lsint (THERE)) ;
  GGS_typeGalgas_lsint result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lsint::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_lsint::
operator == (const GGS_typeGalgas_lsint & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_lsint::
operator != (const GGS_typeGalgas_lsint & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lsint::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_lsint" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeGalgas_lsint64'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_lsint64::
cPtr_typeGalgas_lsint64 (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_lsint64 * GGS_typeGalgas_lsint64::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_lsint64 *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_lsint64 *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_lsint64::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "lsint64") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1519))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_sint64::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1527)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1537))) == (GGS_string (true, "setSint64"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_sint64::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1540))) == (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") SOURCE_FILE_AT_LINE (1546)) ;
    var_cas_outModifierSignature._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_lsint64::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_lsint64:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint64
::static_string_message_messageGalgasType (void) {
  return "a '@lsint64' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_lsint64::
message_messageGalgasType (void) const {
  return "a '@lsint64' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_lsint64'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint64::
GGS_typeGalgas_lsint64 (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint64::
GGS_typeGalgas_lsint64 (const GGS_typeGalgas_lsint64 & inOperand)
:GGS_C_galgasPrimitiveType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint64::
~GGS_typeGalgas_lsint64 (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_lsint64) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_lsint64::
operator = (const GGS_typeGalgas_lsint64 & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_lsint64 GGS_typeGalgas_lsint64::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_lsint64 * _ptr = (cPtr_typeGalgas_lsint64 *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_lsint64 (THERE)) ;
  GGS_typeGalgas_lsint64 result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lsint64::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_lsint64::
operator == (const GGS_typeGalgas_lsint64 & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_lsint64::
operator != (const GGS_typeGalgas_lsint64 & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_lsint64::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_lsint64" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeGalgas_ldouble'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_ldouble::
cPtr_typeGalgas_ldouble (LOCATION_ARGS)
:cPtr_C_galgasPrimitiveType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_ldouble * GGS_typeGalgas_ldouble::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_ldouble *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_ldouble *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_ldouble::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "ldouble") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1568))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_double::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1576)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1586))) == (GGS_string (true, "setDouble"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_double::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1589))) == (GGS_string (true, "setLocation"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentIn (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support modifier call") SOURCE_FILE_AT_LINE (1595)) ;
    var_cas_outModifierSignature._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
method_checkAbilityToBeSilentlyConvertedToLocation (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_ldouble::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_ldouble:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_ldouble
::static_string_message_messageGalgasType (void) {
  return "a '@ldouble' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_ldouble::
message_messageGalgasType (void) const {
  return "a '@ldouble' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgas_ldouble'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_ldouble::
GGS_typeGalgas_ldouble (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_ldouble::
GGS_typeGalgas_ldouble (const GGS_typeGalgas_ldouble & inOperand)
:GGS_C_galgasPrimitiveType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_ldouble::
~GGS_typeGalgas_ldouble (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_ldouble) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_ldouble::
operator = (const GGS_typeGalgas_ldouble & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_ldouble GGS_typeGalgas_ldouble::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_ldouble * _ptr = (cPtr_typeGalgas_ldouble *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_ldouble (THERE)) ;
  GGS_typeGalgas_ldouble result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_ldouble::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_ldouble::
operator == (const GGS_typeGalgas_ldouble & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_ldouble::
operator != (const GGS_typeGalgas_ldouble & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_ldouble::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_ldouble" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeGalgas_stringset'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_stringset::
cPtr_typeGalgas_stringset (LOCATION_ARGS)
:cPtr_AC_galgasType (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_stringset * GGS_typeGalgas_stringset::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_stringset *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_stringset *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_stringset::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "stringset") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1621))) == (GGS_string (true, "emptySet"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1623))) == (GGS_string (true, "setWithString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1627))) == (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "in GALGAS 1.3.0 and later, use 'emptySet' constructor instead of 'empty' constructor") SOURCE_FILE_AT_LINE (1629)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (1631)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_handleAddAssignOperatorCall (C_Lexique & _inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outParametersList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  var_cas_outParametersList._addAssign_operation (GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE), GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_handleMinusAssignOperatorCall (C_Lexique & _inLexique,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outParametersList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  GGS_AC_galgasType  var_cas_t ;
  var_cas_t = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_outParametersList._addAssign_operation (var_cas_t, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
method_acceptForeachInstruction (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle COMMA_UNUSED_LOCATION_ARGS) {
  GGS_AC_galgasType  var_cas_keyType ;
  var_cas_keyType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_outForeachList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  var_cas_outForeachList._addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "mKey"), GGS_location (_inLexique) COMMA_HERE)) ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (_inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_stringset::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_stringset:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_stringset
::static_string_message_messageGalgasType (void) {
  return "a '@stringset' type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_stringset::
message_messageGalgasType (void) const {
  return "a '@stringset' type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgas_stringset'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_stringset::
GGS_typeGalgas_stringset (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_stringset::
GGS_typeGalgas_stringset (const GGS_typeGalgas_stringset & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_stringset::
~GGS_typeGalgas_stringset (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_stringset) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_stringset::
operator = (const GGS_typeGalgas_stringset & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_stringset GGS_typeGalgas_stringset::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_stringset * _ptr = (cPtr_typeGalgas_stringset *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_stringset (THERE)) ;
  GGS_typeGalgas_stringset result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_stringset::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_stringset::
operator == (const GGS_typeGalgas_stringset & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_stringset::
operator != (const GGS_typeGalgas_stringset & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_stringset::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_stringset" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'typeTableMethodes'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableMethodes::
elementOf_GGS_typeTableMethodes (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableMethodes & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableMethodes::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aListeTypesParametres.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableMethodes::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableMethodes * _p = dynamic_cast <const elementOf_GGS_typeTableMethodes *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aListeTypesParametres == _p->mInfo.aListeTypesParametres).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableMethodes::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableMethodes *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableMethodes * info = (e_typeTableMethodes *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodes result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMethodes::
operator == (const GGS_typeTableMethodes & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMethodes::
operator != (const GGS_typeTableMethodes & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableMethodes info  ;
    info.aListeTypesParametres = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeTypesParametres ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no reader named '%K'",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodes::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a reader named '%K' is already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableMethodes & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodes result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes GGS_typeTableMethodes::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMethodes::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableMethodes " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           abstract class 'cPtr_typeGalgasUndefinedExternType'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedExternType::
cPtr_typeGalgasUndefinedExternType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mGalgasClassName (argument_0),
mCppClassName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedExternType * GGS_typeGalgasUndefinedExternType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedExternType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedExternType::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedExternType * _p = dynamic_cast <const cPtr_typeGalgasUndefinedExternType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mGalgasClassName == _p->mGalgasClassName).boolValue ()
         && (mCppClassName == _p->mCppClassName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedExternType::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mGalgasClassName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1699)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedExternType::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedExternType:"
           << mGalgasClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mCppClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedExternType
::static_string_message_messageGalgasType (void) {
  return "an undefined extern type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedExternType::
message_messageGalgasType (void) const {
  return "an undefined extern type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedExternType'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedExternType::
GGS_typeGalgasUndefinedExternType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedExternType::
GGS_typeGalgasUndefinedExternType (const GGS_typeGalgasUndefinedExternType & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedExternType::
~GGS_typeGalgasUndefinedExternType (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgasUndefinedExternType) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgasUndefinedExternType::
operator = (const GGS_typeGalgasUndefinedExternType & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedExternType GGS_typeGalgasUndefinedExternType::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgasUndefinedExternType * _ptr = (cPtr_typeGalgasUndefinedExternType *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgasUndefinedExternType (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeGalgasUndefinedExternType result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedExternType::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasUndefinedExternType::
reader_mGalgasClassName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasUndefinedExternType *) mPointer)->mGalgasClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasUndefinedExternType::
reader_mCppClassName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasUndefinedExternType *) mPointer)->mCppClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasUndefinedExternType::
operator == (const GGS_typeGalgasUndefinedExternType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasUndefinedExternType::
operator != (const GGS_typeGalgasUndefinedExternType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedExternType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgasUndefinedExternType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_externTypeConstructorMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_externTypeConstructorMap::
elementOf_GGS_M_externTypeConstructorMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_externTypeConstructorMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_externTypeConstructorMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aListeDesAttributs.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_externTypeConstructorMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_externTypeConstructorMap * _p = dynamic_cast <const elementOf_GGS_M_externTypeConstructorMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aListeDesAttributs == _p->mInfo.aListeDesAttributs).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_externTypeConstructorMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_externTypeConstructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_externTypeConstructorMap * info = (e_M_externTypeConstructorMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_externTypeConstructorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_externTypeConstructorMap::
operator == (const GGS_M_externTypeConstructorMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_externTypeConstructorMap::
operator != (const GGS_M_externTypeConstructorMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeListeAttributsSemantiques & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_externTypeConstructorMap info  ;
    info.aListeDesAttributs = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDesAttributs ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' constructor is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_externTypeConstructorMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' constructor is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_externTypeConstructorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_externTypeConstructorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap GGS_M_externTypeConstructorMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_externTypeConstructorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_externTypeConstructorMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_externTypeConstructorMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeGalgasExternType'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasExternType::
cPtr_typeGalgasExternType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_M_externTypeConstructorMap & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodes & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_typeListeAttributsSemantiques & argument_6 COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedExternType (argument_0, argument_1 COMMA_THERE),
mConstructorMap (argument_2),
mModifiersMap (argument_3),
mReadersInInstructionMap (argument_4),
mAcceptAddAssignOperatorCall (argument_5),
mAddAssignOperatorCallTypeList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasExternType * GGS_typeGalgasExternType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasExternType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasExternType::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasExternType * _p = dynamic_cast <const cPtr_typeGalgasExternType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mGalgasClassName == _p->mGalgasClassName).boolValue ()
         && (mCppClassName == _p->mCppClassName).boolValue ()
         && (mConstructorMap == _p->mConstructorMap).boolValue ()
         && (mModifiersMap == _p->mModifiersMap).boolValue ()
         && (mReadersInInstructionMap == _p->mReadersInInstructionMap).boolValue ()
         && (mAcceptAddAssignOperatorCall == _p->mAcceptAddAssignOperatorCall).boolValue ()
         && (mAddAssignOperatorCallTypeList == _p->mAddAssignOperatorCallTypeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (mConstructorMap._isBuilt ()) {
    mConstructorMap (HERE)->method_searchKey (_inLexique, var_cas_inClassMethodName, var_cas_outAccessorTypesList SOURCE_FILE_AT_LINE (1743)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (mModifiersMap._isBuilt ()) {
    mModifiersMap (HERE)->method_searchKey (_inLexique, var_cas_inModifierName, var_cas_outModifierSignature SOURCE_FILE_AT_LINE (1752)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleMethodInstructionCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inReadObjectName */,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_EXsignature & var_cas_outReaderSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (mReadersInInstructionMap._isBuilt ()) {
    mReadersInInstructionMap (HERE)->method_searchKey (_inLexique, var_cas_inReaderName, var_cas_outReaderSignature SOURCE_FILE_AT_LINE (1761)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
method_handleAddAssignOperatorCall (C_Lexique & _inLexique,
                                GGS_location  var_cas_inErrorLocation,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) {
  if (((! (mAcceptAddAssignOperatorCall))).isBuiltAndTrue ()) {
    inherited::method_handleAddAssignOperatorCall (_inLexique, var_cas_inErrorLocation, var_cas_outParametersList SOURCE_FILE_AT_LINE (1770)) ;
  }else{
    var_cas_outParametersList = mAddAssignOperatorCallTypeList ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasExternType::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasExternType:"
           << mGalgasClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mCppClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstructorMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModifiersMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReadersInInstructionMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAcceptAddAssignOperatorCall.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAddAssignOperatorCallTypeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasExternType
::static_string_message_messageGalgasType (void) {
  return "an extern type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasExternType::
message_messageGalgasType (void) const {
  return "an extern type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeGalgasExternType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasExternType::
GGS_typeGalgasExternType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasExternType::
GGS_typeGalgasExternType (const GGS_typeGalgasExternType & inOperand)
:GGS_typeGalgasUndefinedExternType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasExternType::
~GGS_typeGalgasExternType (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgasExternType) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgasExternType::
operator = (const GGS_typeGalgasExternType & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasExternType GGS_typeGalgasExternType::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_M_externTypeConstructorMap & argument_2,
                 const GGS_typeTableMethodes & argument_3,
                 const GGS_typeTableMethodes & argument_4,
                 const GGS_bool& argument_5,
                 const GGS_typeListeAttributsSemantiques & argument_6 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgasExternType * _ptr = (cPtr_typeGalgasExternType *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgasExternType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  GGS_typeGalgasExternType result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasExternType::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap  GGS_typeGalgasExternType::
reader_mConstructorMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_externTypeConstructorMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasExternType *) mPointer)->mConstructorMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes  GGS_typeGalgasExternType::
reader_mModifiersMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasExternType *) mPointer)->mModifiersMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes  GGS_typeGalgasExternType::
reader_mReadersInInstructionMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasExternType *) mPointer)->mReadersInInstructionMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasExternType::
reader_mAcceptAddAssignOperatorCall (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasExternType *) mPointer)->mAcceptAddAssignOperatorCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasExternType::
reader_mAddAssignOperatorCallTypeList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasExternType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasExternType *) mPointer)->mAddAssignOperatorCallTypeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasExternType::
operator == (const GGS_typeGalgasExternType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasExternType::
operator != (const GGS_typeGalgasExternType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasExternType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgasExternType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_terminalSymbolsMapForUse'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_terminalSymbolsMapForUse::
elementOf_GGS_M_terminalSymbolsMapForUse (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_terminalSymbolsMapForUse & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_terminalSymbolsMapForUse::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aListeDesAttributs.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_terminalSymbolsMapForUse::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_terminalSymbolsMapForUse * _p = dynamic_cast <const elementOf_GGS_M_terminalSymbolsMapForUse *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aListeDesAttributs == _p->mInfo.aListeDesAttributs).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_terminalSymbolsMapForUse::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_terminalSymbolsMapForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_terminalSymbolsMapForUse * info = (e_M_terminalSymbolsMapForUse *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_terminalSymbolsMapForUse result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_terminalSymbolsMapForUse::
operator == (const GGS_M_terminalSymbolsMapForUse & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_terminalSymbolsMapForUse::
operator != (const GGS_M_terminalSymbolsMapForUse & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeListeAttributsSemantiques & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_terminalSymbolsMapForUse info  ;
    info.aListeDesAttributs = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeAttributsSemantiques   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDesAttributs ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeAttributsSemantiques   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the terminal symbol '$%K$' is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_typeListeAttributsSemantiques   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the terminal symbol '$%K$' is not declared",
                  inKey,
                  outParameter0,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_terminalSymbolsMapForUse::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeAttributsSemantiques & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the terminal symbol '$%K$' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_terminalSymbolsMapForUse & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_terminalSymbolsMapForUse result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_terminalSymbolsMapForUse GGS_M_terminalSymbolsMapForUse::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_terminalSymbolsMapForUse result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_terminalSymbolsMapForUse::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_terminalSymbolsMapForUse " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'M_lexiqueComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_lexiqueComponents::
elementOf_GGS_M_lexiqueComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_lexiqueComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_lexiqueComponents::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mTerminalSymbolMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_lexiqueComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_lexiqueComponents * _p = dynamic_cast <const elementOf_GGS_M_lexiqueComponents *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mTerminalSymbolMap == _p->mInfo.mTerminalSymbolMap).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_lexiqueComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_lexiqueComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_lexiqueComponents * info = (e_M_lexiqueComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_lexiqueComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_lexiqueComponents::
operator == (const GGS_M_lexiqueComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_lexiqueComponents::
operator != (const GGS_M_lexiqueComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_terminalSymbolsMapForUse & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_lexiqueComponents info  ;
    info.mTerminalSymbolMap = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_terminalSymbolsMapForUse   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mTerminalSymbolMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_terminalSymbolsMapForUse   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' lexique is not defined",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_lexiqueComponents::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_terminalSymbolsMapForUse & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' lexique is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_lexiqueComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_lexiqueComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_lexiqueComponents GGS_M_lexiqueComponents::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_lexiqueComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_lexiqueComponents::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_lexiqueComponents " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map 'typeTableEnAvant'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableEnAvant::
elementOf_GGS_typeTableEnAvant (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableEnAvant & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableEnAvant::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableEnAvant::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableEnAvant * _p = dynamic_cast <const elementOf_GGS_typeTableEnAvant *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mType == _p->mInfo.mType).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableEnAvant::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableEnAvant *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableEnAvant * info = (e_typeTableEnAvant *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableEnAvant result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableEnAvant::
operator == (const GGS_typeTableEnAvant & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableEnAvant::
operator != (const GGS_typeTableEnAvant & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_galgasType & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableEnAvant info  ;
    info.mType = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the type '%K' is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableEnAvant::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the type '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableEnAvant & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableEnAvant result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableEnAvant GGS_typeTableEnAvant::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableEnAvant result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableEnAvant::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableEnAvant " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map 'M_nonterminalSymbolAlts'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonterminalSymbolAlts::
elementOf_GGS_M_nonterminalSymbolAlts (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonterminalSymbolAlts & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonterminalSymbolAlts::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mFormalParametersList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mReturnedEntity.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_nonterminalSymbolAlts::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_nonterminalSymbolAlts * _p = dynamic_cast <const elementOf_GGS_M_nonterminalSymbolAlts *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mFormalParametersList == _p->mInfo.mFormalParametersList).boolValue ()
           && (mInfo.mReturnedEntity == _p->mInfo.mReturnedEntity).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonterminalSymbolAlts::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonterminalSymbolAlts *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonterminalSymbolAlts * info = (e_M_nonterminalSymbolAlts *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAlts result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonterminalSymbolAlts::
operator == (const GGS_M_nonterminalSymbolAlts & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonterminalSymbolAlts::
operator != (const GGS_M_nonterminalSymbolAlts & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                const GGS_lstring & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_nonterminalSymbolAlts info  ;
    info.mFormalParametersList = inParameter0 ;
    info.mReturnedEntity = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalParametersList ;
    outParameter1 = node->mInfo.mReturnedEntity ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the label '%K' is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAlts::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the label '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_nonterminalSymbolAlts & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAlts result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts GGS_M_nonterminalSymbolAlts::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonterminalSymbolAlts result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonterminalSymbolAlts::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_nonterminalSymbolAlts " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_AC_semanticsEntity'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_semanticsEntity::
cPtr_AC_semanticsEntity (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_semanticsEntity * GGS_AC_semanticsEntity::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_semanticsEntity::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_semanticsEntity:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity
::static_string_message_messageTypeEntite (void) {
  return "any entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_semanticsEntity::
message_messageTypeEntite (void) const {
  return "any entity" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_AC_semanticsEntity'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
GGS_AC_semanticsEntity (const GGS_AC_semanticsEntity & inOperand) {
  mPointer = (cPtr_AC_semanticsEntity *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_semanticsEntity::
~GGS_AC_semanticsEntity (void) {
  macroDetachPointer (mPointer, cPtr_AC_semanticsEntity) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_semanticsEntity::
operator = (const GGS_AC_semanticsEntity & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_semanticsEntity::
reader_messageTypeEntite (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageTypeEntite ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_semanticsEntity::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_semanticsEntity) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_semanticsEntity::
operator == (const GGS_AC_semanticsEntity & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_semanticsEntity::
operator != (const GGS_AC_semanticsEntity & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_semanticsEntity::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @AC_semanticsEntity" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_grammarForSemantics'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarForSemantics::
cPtr_C_grammarForSemantics (const GGS_M_nonterminalSymbolAlts & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
mGrammarAltMap (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_grammarForSemantics * GGS_C_grammarForSemantics::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarForSemantics *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_grammarForSemantics *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_grammarForSemantics::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_grammarForSemantics * _p = dynamic_cast <const cPtr_C_grammarForSemantics *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mGrammarAltMap == _p->mGrammarAltMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_grammarForSemantics::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_grammarForSemantics:"
           << mGrammarAltMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_grammarForSemantics
::static_string_message_messageTypeEntite (void) {
  return "a grammar entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_grammarForSemantics::
message_messageTypeEntite (void) const {
  return "a grammar entity" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarForSemantics'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_grammarForSemantics::
GGS_C_grammarForSemantics (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarForSemantics::
GGS_C_grammarForSemantics (const GGS_C_grammarForSemantics & inOperand)
:GGS_AC_semanticsEntity () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarForSemantics::
~GGS_C_grammarForSemantics (void) {
  macroDetachPointer (mPointer, cPtr_C_grammarForSemantics) ;
}

//---------------------------------------------------------------------------*

void GGS_C_grammarForSemantics::
operator = (const GGS_C_grammarForSemantics & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarForSemantics GGS_C_grammarForSemantics::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_M_nonterminalSymbolAlts & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_C_grammarForSemantics * _ptr = (cPtr_C_grammarForSemantics *) NULL ;
  macroMyNew (_ptr, cPtr_C_grammarForSemantics (argument_0 COMMA_THERE)) ;
  GGS_C_grammarForSemantics result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_grammarForSemantics::
reader_messageTypeEntite (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageTypeEntite ())) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts  GGS_C_grammarForSemantics::
reader_mGrammarAltMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonterminalSymbolAlts   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarForSemantics *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarForSemantics *) mPointer)->mGrammarAltMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_grammarForSemantics::
operator == (const GGS_C_grammarForSemantics & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_grammarForSemantics::
operator != (const GGS_C_grammarForSemantics & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_grammarForSemantics::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_grammarForSemantics" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_semanticsEntitiesForUse'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_semanticsEntitiesForUse::
elementOf_GGS_M_semanticsEntitiesForUse (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_semanticsEntitiesForUse & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_semanticsEntitiesForUse::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aDefEntite.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_semanticsEntitiesForUse::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_semanticsEntitiesForUse * _p = dynamic_cast <const elementOf_GGS_M_semanticsEntitiesForUse *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aDefEntite == _p->mInfo.aDefEntite).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_semanticsEntitiesForUse::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_semanticsEntitiesForUse *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_semanticsEntitiesForUse * info = (e_M_semanticsEntitiesForUse *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsEntitiesForUse result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_semanticsEntitiesForUse::
operator == (const GGS_M_semanticsEntitiesForUse & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_semanticsEntitiesForUse::
operator != (const GGS_M_semanticsEntitiesForUse & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_semanticsEntity & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_semanticsEntitiesForUse info  ;
    info.aDefEntite = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_semanticsEntity   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aDefEntite ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_semanticsEntity   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no semantics entity named '%K'",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsEntitiesForUse::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_semanticsEntity & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a semantics entity named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_semanticsEntitiesForUse & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsEntitiesForUse result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsEntitiesForUse GGS_M_semanticsEntitiesForUse::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_semanticsEntitiesForUse result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_semanticsEntitiesForUse::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_semanticsEntitiesForUse " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_AC_typeForGrammarComponent'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_typeForGrammarComponent::
cPtr_AC_typeForGrammarComponent (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_typeForGrammarComponent * GGS_AC_typeForGrammarComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_typeForGrammarComponent::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_typeForGrammarComponent:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent
::static_string_message_typeForGrammarComponentMessage (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_typeForGrammarComponent::
message_typeForGrammarComponentMessage (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_AC_typeForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
GGS_AC_typeForGrammarComponent (const GGS_AC_typeForGrammarComponent & inOperand) {
  mPointer = (cPtr_AC_typeForGrammarComponent *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_typeForGrammarComponent::
~GGS_AC_typeForGrammarComponent (void) {
  macroDetachPointer (mPointer, cPtr_AC_typeForGrammarComponent) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_typeForGrammarComponent::
operator = (const GGS_AC_typeForGrammarComponent & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_typeForGrammarComponent::
reader_typeForGrammarComponentMessage (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_typeForGrammarComponentMessage ())) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_typeForGrammarComponent::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_typeForGrammarComponent) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_typeForGrammarComponent::
operator == (const GGS_AC_typeForGrammarComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_typeForGrammarComponent::
operator != (const GGS_AC_typeForGrammarComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_typeForGrammarComponent::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @AC_typeForGrammarComponent" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'M_typesForGrammarComponent'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_typesForGrammarComponent::
elementOf_GGS_M_typesForGrammarComponent (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_typesForGrammarComponent & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_typesForGrammarComponent::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_typesForGrammarComponent::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_typesForGrammarComponent * _p = dynamic_cast <const elementOf_GGS_M_typesForGrammarComponent *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mType == _p->mInfo.mType).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_typesForGrammarComponent::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_typesForGrammarComponent *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_typesForGrammarComponent * info = (e_M_typesForGrammarComponent *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_typesForGrammarComponent result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_typesForGrammarComponent::
operator == (const GGS_M_typesForGrammarComponent & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_typesForGrammarComponent::
operator != (const GGS_M_typesForGrammarComponent & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_typeForGrammarComponent & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_typesForGrammarComponent info  ;
    info.mType = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_typeForGrammarComponent   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_typeForGrammarComponent   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '@%K' type is not defined",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_typesForGrammarComponent::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_typeForGrammarComponent & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '@%K' type is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_typesForGrammarComponent & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_typesForGrammarComponent result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_typesForGrammarComponent GGS_M_typesForGrammarComponent::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_typesForGrammarComponent result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_typesForGrammarComponent::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_typesForGrammarComponent " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "checkSignature_ForGrammarComponent"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkSignature_ForGrammarComponent (C_Lexique & _inLexique,
                                const GGS_L_signature  & var_cas_inFormalReferenceSignature,
                                const GGS_L_signature  & var_cas_inFormalTestedSignature,
                                const GGS_location  & var_cas_inFormalTestedLocation,
                                const GGS_location  & var_cas_inFormalReferenceLocation COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkSignature_ForGrammarComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (((var_cas_inFormalReferenceSignature.reader_length (_inLexique SOURCE_FILE_AT_LINE (1888))) < (var_cas_inFormalTestedSignature.reader_length (_inLexique SOURCE_FILE_AT_LINE (1888)))).isBuiltAndTrue ()) {
    var_cas_inFormalTestedLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "too much formal parameters (from prototype in ")) + (var_cas_inFormalReferenceLocation.reader_locationString (_inLexique SOURCE_FILE_AT_LINE (1889))))) + (GGS_string (true, ")"))) SOURCE_FILE_AT_LINE (1890)) ;
  }else if (((var_cas_inFormalReferenceSignature.reader_length (_inLexique SOURCE_FILE_AT_LINE (1890))) > (var_cas_inFormalTestedSignature.reader_length (_inLexique SOURCE_FILE_AT_LINE (1890)))).isBuiltAndTrue ()) {
    var_cas_inFormalTestedLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "too much formal parameters (from prototype in ")) + (var_cas_inFormalReferenceLocation.reader_locationString (_inLexique SOURCE_FILE_AT_LINE (1891))))) + (GGS_string (true, ")"))) SOURCE_FILE_AT_LINE (1892)) ;
  }else{
    GGS_L_signature::element_type * operand_74504 = var_cas_inFormalReferenceSignature.firstObject () ;
    GGS_L_signature::element_type * operand_74599 = var_cas_inFormalTestedSignature.firstObject () ;
    while ((operand_74504 != NULL)
        && (operand_74599 != NULL)) {
      macroValidPointer (operand_74504) ;
      macroValidPointer (operand_74599) ;
      if (((operand_74504->mFormalArgumentPassingMode) != (operand_74599->mFormalArgumentPassingMode)).isBuiltAndTrue ()) {
        operand_74599->mGalgasTypeName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "Prototype has ")) + (operand_74504->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique SOURCE_FILE_AT_LINE (1896))))) + (GGS_string (true, ", and ")))) + (operand_74504->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique SOURCE_FILE_AT_LINE (1897))))) + (GGS_string (true, " has been found"))) SOURCE_FILE_AT_LINE (1898)) ;
      }
      if (((operand_74504->mGalgasTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1899))) != (operand_74599->mGalgasTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1899)))).isBuiltAndTrue ()) {
        operand_74599->mGalgasTypeName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting the '@")) + (operand_74504->mGalgasTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1900))))) + (GGS_string (true, "' type, I have got the '@")))) + (operand_74599->mGalgasTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (1900))))) + (GGS_string (true, "' type"))) SOURCE_FILE_AT_LINE (1901)) ;
      }
      operand_74504 = operand_74504->nextObject () ;
      operand_74599 = operand_74599->nextObject () ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkSignature_ForGrammarComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_AC_instruction_ForGrammar'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_instruction_ForGrammar::
cPtr_AC_instruction_ForGrammar (const GGS_location & argument_0 COMMA_LOCATION_ARGS)
:C_GGS_Object (THERE),
mStartLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_instruction_ForGrammar * GGS_AC_instruction_ForGrammar::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_instruction_ForGrammar::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@AC_instruction_ForGrammar:"
           << mStartLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_AC_instruction_ForGrammar'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
GGS_AC_instruction_ForGrammar (const GGS_AC_instruction_ForGrammar & inOperand) {
  mPointer = (cPtr_AC_instruction_ForGrammar *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_instruction_ForGrammar::
~GGS_AC_instruction_ForGrammar (void) {
  macroDetachPointer (mPointer, cPtr_AC_instruction_ForGrammar) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_instruction_ForGrammar::
operator = (const GGS_AC_instruction_ForGrammar & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_AC_instruction_ForGrammar::
reader_mStartLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mStartLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_AC_instruction_ForGrammar::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_instruction_ForGrammar) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_instruction_ForGrammar::
operator == (const GGS_AC_instruction_ForGrammar & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_instruction_ForGrammar::
operator != (const GGS_AC_instruction_ForGrammar & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_instruction_ForGrammar::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @AC_instruction_ForGrammar" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@L_ruleSyntaxSignature'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_ruleSyntaxSignature::
elementOf_GGS_L_ruleSyntaxSignature (const GGS_AC_instruction_ForGrammar & argument_0):
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_ruleSyntaxSignature::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_ruleSyntaxSignature * _p = dynamic_cast <const elementOf_GGS_L_ruleSyntaxSignature *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mInstruction == _p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_ruleSyntaxSignature::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@L_ruleSyntaxSignature'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::GGS_L_ruleSyntaxSignature (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature::
GGS_L_ruleSyntaxSignature (const GGS_L_ruleSyntaxSignature & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_ruleSyntaxSignature::
operator == (const GGS_L_ruleSyntaxSignature & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_ruleSyntaxSignature::
operator != (const GGS_L_ruleSyntaxSignature & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
_internalAppendValues (const GGS_AC_instruction_ForGrammar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
_internalPrependValues (const GGS_AC_instruction_ForGrammar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
_addAssign_operation (const GGS_AC_instruction_ForGrammar & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature GGS_L_ruleSyntaxSignature::
operator + (const GGS_L_ruleSyntaxSignature & inOperand) const {
  GGS_L_ruleSyntaxSignature result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_ruleSyntaxSignature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_instruction_ForGrammar  p_0 = p->mInstruction ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_AC_instruction_ForGrammar & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature  GGS_L_ruleSyntaxSignature::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_ruleSyntaxSignature result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature  GGS_L_ruleSyntaxSignature::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_AC_instruction_ForGrammar & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_ruleSyntaxSignature result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_ruleSyntaxSignature::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_ruleSyntaxSignature", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
method_first (C_Lexique & _inLexique,
              GGS_AC_instruction_ForGrammar & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
method_last (C_Lexique & _inLexique,
             GGS_AC_instruction_ForGrammar & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_AC_instruction_ForGrammar & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_ruleSyntaxSignature::
modifier_popLast (C_Lexique & _inLexique,
                GGS_AC_instruction_ForGrammar & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'L_grammarsMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_grammarsMap::
elementOf_GGS_L_grammarsMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_L_grammarsMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_grammarsMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mStartSymbolParametersMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_grammarsMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_L_grammarsMap * _p = dynamic_cast <const elementOf_GGS_L_grammarsMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mStartSymbolParametersMap == _p->mInfo.mStartSymbolParametersMap).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_L_grammarsMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_L_grammarsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_L_grammarsMap * info = (e_L_grammarsMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_grammarsMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_grammarsMap::
operator == (const GGS_L_grammarsMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_grammarsMap::
operator != (const GGS_L_grammarsMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_nonterminalSymbolAlts & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_L_grammarsMap info  ;
    info.mStartSymbolParametersMap = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAlts   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mStartSymbolParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' grammar is not defined",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarsMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' grammar is already defined in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_L_grammarsMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_grammarsMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarsMap GGS_L_grammarsMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_grammarsMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_grammarsMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @L_grammarsMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class map 'M_nonterminalSymbolAltsForGrammar'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonterminalSymbolAltsForGrammar::
elementOf_GGS_M_nonterminalSymbolAltsForGrammar (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonterminalSymbolAltsForGrammar & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonterminalSymbolAltsForGrammar::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mFormalParametersList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mReturnedEntityTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_nonterminalSymbolAltsForGrammar::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_nonterminalSymbolAltsForGrammar * _p = dynamic_cast <const elementOf_GGS_M_nonterminalSymbolAltsForGrammar *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mFormalParametersList == _p->mInfo.mFormalParametersList).boolValue ()
           && (mInfo.mReturnedEntityTypeName == _p->mInfo.mReturnedEntityTypeName).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonterminalSymbolAltsForGrammar::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonterminalSymbolAltsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonterminalSymbolAltsForGrammar * info = (e_M_nonterminalSymbolAltsForGrammar *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAltsForGrammar GGS_M_nonterminalSymbolAltsForGrammar::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAltsForGrammar result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonterminalSymbolAltsForGrammar::
operator == (const GGS_M_nonterminalSymbolAltsForGrammar & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonterminalSymbolAltsForGrammar::
operator != (const GGS_M_nonterminalSymbolAltsForGrammar & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_signature & inParameter0,
                const GGS_lstring & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_nonterminalSymbolAltsForGrammar info  ;
    info.mFormalParametersList = inParameter0 ;
    info.mReturnedEntityTypeName = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_signature   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalParametersList ;
    outParameter1 = node->mInfo.mReturnedEntityTypeName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_signature   & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the rule label '%K' is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonterminalSymbolAltsForGrammar::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_signature & inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the rule label '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAltsForGrammar GGS_M_nonterminalSymbolAltsForGrammar::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_nonterminalSymbolAltsForGrammar & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonterminalSymbolAltsForGrammar result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAltsForGrammar GGS_M_nonterminalSymbolAltsForGrammar::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonterminalSymbolAltsForGrammar result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonterminalSymbolAltsForGrammar::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_nonterminalSymbolAltsForGrammar " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@L_productionRules_ForGrammarComponent'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_productionRules_ForGrammarComponent::
elementOf_GGS_L_productionRules_ForGrammarComponent (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2):
mLeftNonterminalSymbol (argument_0),
mLeftNonterminalSymbolIndex (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_productionRules_ForGrammarComponent::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_productionRules_ForGrammarComponent * _p = dynamic_cast <const elementOf_GGS_L_productionRules_ForGrammarComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftNonterminalSymbol == _p->mLeftNonterminalSymbol).boolValue ()
         && (mLeftNonterminalSymbolIndex == _p->mLeftNonterminalSymbolIndex).boolValue ()
         && (mInstructionList == _p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_productionRules_ForGrammarComponent::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftNonterminalSymbol.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftNonterminalSymbolIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@L_productionRules_ForGrammarComponent'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::GGS_L_productionRules_ForGrammarComponent (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent::
GGS_L_productionRules_ForGrammarComponent (const GGS_L_productionRules_ForGrammarComponent & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_productionRules_ForGrammarComponent::
operator == (const GGS_L_productionRules_ForGrammarComponent & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_productionRules_ForGrammarComponent::
operator != (const GGS_L_productionRules_ForGrammarComponent & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1,
                    const GGS_L_ruleSyntaxSignature & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1,
                    const GGS_L_ruleSyntaxSignature & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_L_ruleSyntaxSignature & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent GGS_L_productionRules_ForGrammarComponent::
operator + (const GGS_L_productionRules_ForGrammarComponent & inOperand) const {
  GGS_L_productionRules_ForGrammarComponent result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_productionRules_ForGrammarComponent * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLeftNonterminalSymbol ;
          GGS_uint  p_1 = p->mLeftNonterminalSymbolIndex ;
          GGS_L_ruleSyntaxSignature  p_2 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_uint & argument_1,
                     const GGS_L_ruleSyntaxSignature & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLeftNonterminalSymbol,
                                _p->mLeftNonterminalSymbolIndex,
                                _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent  GGS_L_productionRules_ForGrammarComponent::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_productionRules_ForGrammarComponent result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_productionRules_ForGrammarComponent  GGS_L_productionRules_ForGrammarComponent::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_uint & argument_1,
                           const GGS_L_ruleSyntaxSignature & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_productionRules_ForGrammarComponent result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_productionRules_ForGrammarComponent::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_productionRules_ForGrammarComponent", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0,
              GGS_uint & _out_1,
              GGS_L_ruleSyntaxSignature & _out_2
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftNonterminalSymbol ;
    _out_1 = _p->mLeftNonterminalSymbolIndex ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0,
             GGS_uint & _out_1,
             GGS_L_ruleSyntaxSignature & _out_2
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftNonterminalSymbol ;
    _out_1 = _p->mLeftNonterminalSymbolIndex ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_uint & _out_1,
                 GGS_L_ruleSyntaxSignature & _out_2
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftNonterminalSymbol ;
    _out_1 = _p->mLeftNonterminalSymbolIndex ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_productionRules_ForGrammarComponent::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0,
                GGS_uint & _out_1,
                GGS_L_ruleSyntaxSignature & _out_2
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftNonterminalSymbol ;
    _out_1 = _p->mLeftNonterminalSymbolIndex ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'M_nonTerminalSymbolsForGrammar'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonTerminalSymbolsForGrammar::
elementOf_GGS_M_nonTerminalSymbolsForGrammar (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonTerminalSymbolsForGrammar & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonTerminalSymbolsForGrammar::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mNonterminalSymbolParametersMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_nonTerminalSymbolsForGrammar::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_nonTerminalSymbolsForGrammar * _p = dynamic_cast <const elementOf_GGS_M_nonTerminalSymbolsForGrammar *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mNonterminalSymbolParametersMap == _p->mInfo.mNonterminalSymbolParametersMap).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonTerminalSymbolsForGrammar::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolsForGrammar *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonTerminalSymbolsForGrammar * info = (e_M_nonTerminalSymbolsForGrammar *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolsForGrammar GGS_M_nonTerminalSymbolsForGrammar::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolsForGrammar result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonTerminalSymbolsForGrammar::
operator == (const GGS_M_nonTerminalSymbolsForGrammar & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonTerminalSymbolsForGrammar::
operator != (const GGS_M_nonTerminalSymbolsForGrammar & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_nonTerminalSymbolsForGrammar info  ;
    info.mNonterminalSymbolParametersMap = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "internal search error",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "internal search error",
                  inKey,
                  outParameter0,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolsForGrammar::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "internal insert error",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolsForGrammar GGS_M_nonTerminalSymbolsForGrammar::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_nonTerminalSymbolsForGrammar & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolsForGrammar result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolsForGrammar GGS_M_nonTerminalSymbolsForGrammar::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonTerminalSymbolsForGrammar result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonTerminalSymbolsForGrammar::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_nonTerminalSymbolsForGrammar " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'M_syntaxComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_syntaxComponents::
elementOf_GGS_M_syntaxComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_syntaxComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_syntaxComponents::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mNonterminalSymbolsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mProductionRulesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mLexiqueComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_syntaxComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_syntaxComponents * _p = dynamic_cast <const elementOf_GGS_M_syntaxComponents *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mNonterminalSymbolsMap == _p->mInfo.mNonterminalSymbolsMap).boolValue ()
           && (mInfo.mProductionRulesList == _p->mInfo.mProductionRulesList).boolValue ()
           && (mInfo.mLexiqueComponentName == _p->mInfo.mLexiqueComponentName).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_syntaxComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_syntaxComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_syntaxComponents * info = (e_M_syntaxComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_syntaxComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_syntaxComponents::
operator == (const GGS_M_syntaxComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_syntaxComponents::
operator != (const GGS_M_syntaxComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_nonTerminalSymbolsForGrammar & inParameter0,
                const GGS_L_productionRules_ForGrammarComponent & inParameter1,
                const GGS_lstring & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_syntaxComponents info  ;
    info.mNonterminalSymbolsMap = inParameter0 ;
    info.mProductionRulesList = inParameter1 ;
    info.mLexiqueComponentName = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonTerminalSymbolsForGrammar   & outParameter0,
               GGS_L_productionRules_ForGrammarComponent   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolsMap ;
    outParameter1 = node->mInfo.mProductionRulesList ;
    outParameter2 = node->mInfo.mLexiqueComponentName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonTerminalSymbolsForGrammar   & outParameter0,
                                GGS_L_productionRules_ForGrammarComponent   & outParameter1,
                                GGS_lstring   & outParameter2 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no syntax component named '%K'",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_syntaxComponents::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonTerminalSymbolsForGrammar & inParameter0,
                                const GGS_L_productionRules_ForGrammarComponent & inParameter1,
                                const GGS_lstring & inParameter2 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a syntax component named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_syntaxComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_syntaxComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_syntaxComponents GGS_M_syntaxComponents::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_syntaxComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_syntaxComponents::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_syntaxComponents " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     abstract class 'cPtr_T_terminalInstruction_forGrammarComponent'       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_terminalInstruction_forGrammarComponent::
cPtr_T_terminalInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mTerminalSymbolName (argument_1),
mTerminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_T_terminalInstruction_forGrammarComponent * GGS_T_terminalInstruction_forGrammarComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_terminalInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_T_terminalInstruction_forGrammarComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_T_terminalInstruction_forGrammarComponent::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_T_terminalInstruction_forGrammarComponent * _p = dynamic_cast <const cPtr_T_terminalInstruction_forGrammarComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mStartLocation == _p->mStartLocation).boolValue ()
         && (mTerminalSymbolName == _p->mTerminalSymbolName).boolValue ()
         && (mTerminalSymbolIndex == _p->mTerminalSymbolIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_T_terminalInstruction_forGrammarComponent::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@T_terminalInstruction_forGrammarComponent:"
           << mStartLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTerminalSymbolName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTerminalSymbolIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_T_terminalInstruction_forGrammarComponent'        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_T_terminalInstruction_forGrammarComponent::
GGS_T_terminalInstruction_forGrammarComponent (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_T_terminalInstruction_forGrammarComponent::
GGS_T_terminalInstruction_forGrammarComponent (const GGS_T_terminalInstruction_forGrammarComponent & inOperand)
:GGS_AC_instruction_ForGrammar () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_T_terminalInstruction_forGrammarComponent::
~GGS_T_terminalInstruction_forGrammarComponent (void) {
  macroDetachPointer (mPointer, cPtr_T_terminalInstruction_forGrammarComponent) ;
}

//---------------------------------------------------------------------------*

void GGS_T_terminalInstruction_forGrammarComponent::
operator = (const GGS_T_terminalInstruction_forGrammarComponent & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_T_terminalInstruction_forGrammarComponent GGS_T_terminalInstruction_forGrammarComponent::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_uint & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_T_terminalInstruction_forGrammarComponent * _ptr = (cPtr_T_terminalInstruction_forGrammarComponent *) NULL ;
  macroMyNew (_ptr, cPtr_T_terminalInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_T_terminalInstruction_forGrammarComponent result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_T_terminalInstruction_forGrammarComponent::
reader_mTerminalSymbolName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_terminalInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_terminalInstruction_forGrammarComponent *) mPointer)->mTerminalSymbolName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_T_terminalInstruction_forGrammarComponent::
reader_mTerminalSymbolIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_terminalInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_terminalInstruction_forGrammarComponent *) mPointer)->mTerminalSymbolIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_T_terminalInstruction_forGrammarComponent::
operator == (const GGS_T_terminalInstruction_forGrammarComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_T_terminalInstruction_forGrammarComponent::
operator != (const GGS_T_terminalInstruction_forGrammarComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_T_terminalInstruction_forGrammarComponent::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @T_terminalInstruction_forGrammarComponent" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//    abstract class 'cPtr_T_nonterminalInstruction_forGrammarComponent'     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_nonterminalInstruction_forGrammarComponent::
cPtr_T_nonterminalInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mNonterminalSymbolName (argument_1),
mNonterminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_T_nonterminalInstruction_forGrammarComponent * GGS_T_nonterminalInstruction_forGrammarComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_nonterminalInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_T_nonterminalInstruction_forGrammarComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_T_nonterminalInstruction_forGrammarComponent::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_T_nonterminalInstruction_forGrammarComponent * _p = dynamic_cast <const cPtr_T_nonterminalInstruction_forGrammarComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mStartLocation == _p->mStartLocation).boolValue ()
         && (mNonterminalSymbolName == _p->mNonterminalSymbolName).boolValue ()
         && (mNonterminalSymbolIndex == _p->mNonterminalSymbolIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_T_nonterminalInstruction_forGrammarComponent::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@T_nonterminalInstruction_forGrammarComponent:"
           << mStartLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonterminalSymbolName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonterminalSymbolIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_T_nonterminalInstruction_forGrammarComponent'       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_T_nonterminalInstruction_forGrammarComponent::
GGS_T_nonterminalInstruction_forGrammarComponent (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_T_nonterminalInstruction_forGrammarComponent::
GGS_T_nonterminalInstruction_forGrammarComponent (const GGS_T_nonterminalInstruction_forGrammarComponent & inOperand)
:GGS_AC_instruction_ForGrammar () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_T_nonterminalInstruction_forGrammarComponent::
~GGS_T_nonterminalInstruction_forGrammarComponent (void) {
  macroDetachPointer (mPointer, cPtr_T_nonterminalInstruction_forGrammarComponent) ;
}

//---------------------------------------------------------------------------*

void GGS_T_nonterminalInstruction_forGrammarComponent::
operator = (const GGS_T_nonterminalInstruction_forGrammarComponent & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_T_nonterminalInstruction_forGrammarComponent GGS_T_nonterminalInstruction_forGrammarComponent::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_uint & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_T_nonterminalInstruction_forGrammarComponent * _ptr = (cPtr_T_nonterminalInstruction_forGrammarComponent *) NULL ;
  macroMyNew (_ptr, cPtr_T_nonterminalInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_T_nonterminalInstruction_forGrammarComponent result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_T_nonterminalInstruction_forGrammarComponent::
reader_mNonterminalSymbolName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_nonterminalInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_nonterminalInstruction_forGrammarComponent *) mPointer)->mNonterminalSymbolName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_T_nonterminalInstruction_forGrammarComponent::
reader_mNonterminalSymbolIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_nonterminalInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_nonterminalInstruction_forGrammarComponent *) mPointer)->mNonterminalSymbolIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_T_nonterminalInstruction_forGrammarComponent::
operator == (const GGS_T_nonterminalInstruction_forGrammarComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_T_nonterminalInstruction_forGrammarComponent::
operator != (const GGS_T_nonterminalInstruction_forGrammarComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_T_nonterminalInstruction_forGrammarComponent::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @T_nonterminalInstruction_forGrammarComponent" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@L_branchList_ForGrammarComponent'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_branchList_ForGrammarComponent::
elementOf_GGS_L_branchList_ForGrammarComponent (const GGS_L_ruleSyntaxSignature & argument_0):
mInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_branchList_ForGrammarComponent::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_branchList_ForGrammarComponent * _p = dynamic_cast <const elementOf_GGS_L_branchList_ForGrammarComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mInstructionList == _p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_branchList_ForGrammarComponent::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@L_branchList_ForGrammarComponent'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::GGS_L_branchList_ForGrammarComponent (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent::
GGS_L_branchList_ForGrammarComponent (const GGS_L_branchList_ForGrammarComponent & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_branchList_ForGrammarComponent::
operator == (const GGS_L_branchList_ForGrammarComponent & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_branchList_ForGrammarComponent::
operator != (const GGS_L_branchList_ForGrammarComponent & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
_internalAppendValues (const GGS_L_ruleSyntaxSignature & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
_internalPrependValues (const GGS_L_ruleSyntaxSignature & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
_addAssign_operation (const GGS_L_ruleSyntaxSignature & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent GGS_L_branchList_ForGrammarComponent::
operator + (const GGS_L_branchList_ForGrammarComponent & inOperand) const {
  GGS_L_branchList_ForGrammarComponent result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_branchList_ForGrammarComponent * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_L_ruleSyntaxSignature  p_0 = p->mInstructionList ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_L_ruleSyntaxSignature & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent  GGS_L_branchList_ForGrammarComponent::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_branchList_ForGrammarComponent result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent  GGS_L_branchList_ForGrammarComponent::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_L_ruleSyntaxSignature & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_branchList_ForGrammarComponent result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_branchList_ForGrammarComponent::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_branchList_ForGrammarComponent", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
method_first (C_Lexique & _inLexique,
              GGS_L_ruleSyntaxSignature & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
method_last (C_Lexique & _inLexique,
             GGS_L_ruleSyntaxSignature & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_L_ruleSyntaxSignature & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_branchList_ForGrammarComponent::
modifier_popLast (C_Lexique & _inLexique,
                GGS_L_ruleSyntaxSignature & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//      abstract class 'cPtr_T_selectInstruction_forGrammarComponent'        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_selectInstruction_forGrammarComponent::
cPtr_T_selectInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mSelectList (argument_1),
mAddedNonterminalmSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_T_selectInstruction_forGrammarComponent * GGS_T_selectInstruction_forGrammarComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_selectInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_T_selectInstruction_forGrammarComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_T_selectInstruction_forGrammarComponent::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_T_selectInstruction_forGrammarComponent * _p = dynamic_cast <const cPtr_T_selectInstruction_forGrammarComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mStartLocation == _p->mStartLocation).boolValue ()
         && (mSelectList == _p->mSelectList).boolValue ()
         && (mAddedNonterminalmSymbolIndex == _p->mAddedNonterminalmSymbolIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_T_selectInstruction_forGrammarComponent::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@T_selectInstruction_forGrammarComponent:"
           << mStartLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSelectList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAddedNonterminalmSymbolIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_T_selectInstruction_forGrammarComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_T_selectInstruction_forGrammarComponent::
GGS_T_selectInstruction_forGrammarComponent (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_T_selectInstruction_forGrammarComponent::
GGS_T_selectInstruction_forGrammarComponent (const GGS_T_selectInstruction_forGrammarComponent & inOperand)
:GGS_AC_instruction_ForGrammar () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_T_selectInstruction_forGrammarComponent::
~GGS_T_selectInstruction_forGrammarComponent (void) {
  macroDetachPointer (mPointer, cPtr_T_selectInstruction_forGrammarComponent) ;
}

//---------------------------------------------------------------------------*

void GGS_T_selectInstruction_forGrammarComponent::
operator = (const GGS_T_selectInstruction_forGrammarComponent & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_T_selectInstruction_forGrammarComponent GGS_T_selectInstruction_forGrammarComponent::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_L_branchList_ForGrammarComponent & argument_1,
                 const GGS_uint & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_T_selectInstruction_forGrammarComponent * _ptr = (cPtr_T_selectInstruction_forGrammarComponent *) NULL ;
  macroMyNew (_ptr, cPtr_T_selectInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_T_selectInstruction_forGrammarComponent result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent  GGS_T_selectInstruction_forGrammarComponent::
reader_mSelectList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_branchList_ForGrammarComponent   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_selectInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_selectInstruction_forGrammarComponent *) mPointer)->mSelectList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_T_selectInstruction_forGrammarComponent::
reader_mAddedNonterminalmSymbolIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_selectInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_selectInstruction_forGrammarComponent *) mPointer)->mAddedNonterminalmSymbolIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_T_selectInstruction_forGrammarComponent::
operator == (const GGS_T_selectInstruction_forGrammarComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_T_selectInstruction_forGrammarComponent::
operator != (const GGS_T_selectInstruction_forGrammarComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_T_selectInstruction_forGrammarComponent::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @T_selectInstruction_forGrammarComponent" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      abstract class 'cPtr_T_repeatInstruction_forGrammarComponent'        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_T_repeatInstruction_forGrammarComponent::
cPtr_T_repeatInstruction_forGrammarComponent (const GGS_location & argument_0,
                                const GGS_L_branchList_ForGrammarComponent & argument_1,
                                const GGS_uint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_instruction_ForGrammar (argument_0 COMMA_THERE),
mRepeatList (argument_1),
mAddedNonterminalmSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_T_repeatInstruction_forGrammarComponent * GGS_T_repeatInstruction_forGrammarComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_repeatInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_T_repeatInstruction_forGrammarComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_T_repeatInstruction_forGrammarComponent::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_T_repeatInstruction_forGrammarComponent * _p = dynamic_cast <const cPtr_T_repeatInstruction_forGrammarComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mStartLocation == _p->mStartLocation).boolValue ()
         && (mRepeatList == _p->mRepeatList).boolValue ()
         && (mAddedNonterminalmSymbolIndex == _p->mAddedNonterminalmSymbolIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_T_repeatInstruction_forGrammarComponent::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@T_repeatInstruction_forGrammarComponent:"
           << mStartLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRepeatList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAddedNonterminalmSymbolIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_T_repeatInstruction_forGrammarComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_T_repeatInstruction_forGrammarComponent::
GGS_T_repeatInstruction_forGrammarComponent (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_T_repeatInstruction_forGrammarComponent::
GGS_T_repeatInstruction_forGrammarComponent (const GGS_T_repeatInstruction_forGrammarComponent & inOperand)
:GGS_AC_instruction_ForGrammar () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_T_repeatInstruction_forGrammarComponent::
~GGS_T_repeatInstruction_forGrammarComponent (void) {
  macroDetachPointer (mPointer, cPtr_T_repeatInstruction_forGrammarComponent) ;
}

//---------------------------------------------------------------------------*

void GGS_T_repeatInstruction_forGrammarComponent::
operator = (const GGS_T_repeatInstruction_forGrammarComponent & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_T_repeatInstruction_forGrammarComponent GGS_T_repeatInstruction_forGrammarComponent::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_L_branchList_ForGrammarComponent & argument_1,
                 const GGS_uint & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_T_repeatInstruction_forGrammarComponent * _ptr = (cPtr_T_repeatInstruction_forGrammarComponent *) NULL ;
  macroMyNew (_ptr, cPtr_T_repeatInstruction_forGrammarComponent (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_T_repeatInstruction_forGrammarComponent result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_branchList_ForGrammarComponent  GGS_T_repeatInstruction_forGrammarComponent::
reader_mRepeatList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_branchList_ForGrammarComponent   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_repeatInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_repeatInstruction_forGrammarComponent *) mPointer)->mRepeatList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_T_repeatInstruction_forGrammarComponent::
reader_mAddedNonterminalmSymbolIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_T_repeatInstruction_forGrammarComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_T_repeatInstruction_forGrammarComponent *) mPointer)->mAddedNonterminalmSymbolIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_T_repeatInstruction_forGrammarComponent::
operator == (const GGS_T_repeatInstruction_forGrammarComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_T_repeatInstruction_forGrammarComponent::
operator != (const GGS_T_repeatInstruction_forGrammarComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_T_repeatInstruction_forGrammarComponent::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @T_repeatInstruction_forGrammarComponent" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_syntaxComponents_ForGrammar'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_syntaxComponents_ForGrammar::
elementOf_GGS_L_syntaxComponents_ForGrammar (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_lstring & argument_2):
mNonterminalSymbolsMap (argument_0),
mProductionRulesList (argument_1),
mSyntaxComponentName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_syntaxComponents_ForGrammar::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_syntaxComponents_ForGrammar * _p = dynamic_cast <const elementOf_GGS_L_syntaxComponents_ForGrammar *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mNonterminalSymbolsMap == _p->mNonterminalSymbolsMap).boolValue ()
         && (mProductionRulesList == _p->mProductionRulesList).boolValue ()
         && (mSyntaxComponentName == _p->mSyntaxComponentName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_syntaxComponents_ForGrammar::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNonterminalSymbolsMap.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mProductionRulesList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_syntaxComponents_ForGrammar'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::GGS_L_syntaxComponents_ForGrammar (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar::
GGS_L_syntaxComponents_ForGrammar (const GGS_L_syntaxComponents_ForGrammar & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_syntaxComponents_ForGrammar::
operator == (const GGS_L_syntaxComponents_ForGrammar & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_syntaxComponents_ForGrammar::
operator != (const GGS_L_syntaxComponents_ForGrammar & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
_internalAppendValues (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                    const GGS_L_productionRules_ForGrammarComponent & argument_1,
                    const GGS_lstring & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
_internalPrependValues (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                    const GGS_L_productionRules_ForGrammarComponent & argument_1,
                    const GGS_lstring & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
_addAssign_operation (const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                                const GGS_L_productionRules_ForGrammarComponent & argument_1,
                                const GGS_lstring & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar GGS_L_syntaxComponents_ForGrammar::
operator + (const GGS_L_syntaxComponents_ForGrammar & inOperand) const {
  GGS_L_syntaxComponents_ForGrammar result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_syntaxComponents_ForGrammar * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_M_nonTerminalSymbolsForGrammar  p_0 = p->mNonterminalSymbolsMap ;
          GGS_L_productionRules_ForGrammarComponent  p_1 = p->mProductionRulesList ;
          GGS_lstring  p_2 = p->mSyntaxComponentName ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                     const GGS_L_productionRules_ForGrammarComponent & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mNonterminalSymbolsMap,
                                _p->mProductionRulesList,
                                _p->mSyntaxComponentName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar  GGS_L_syntaxComponents_ForGrammar::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_syntaxComponents_ForGrammar result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_syntaxComponents_ForGrammar  GGS_L_syntaxComponents_ForGrammar::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_M_nonTerminalSymbolsForGrammar & argument_0,
                           const GGS_L_productionRules_ForGrammarComponent & argument_1,
                           const GGS_lstring & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_syntaxComponents_ForGrammar result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_syntaxComponents_ForGrammar::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_syntaxComponents_ForGrammar", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
method_first (C_Lexique & _inLexique,
              GGS_M_nonTerminalSymbolsForGrammar & _out_0,
              GGS_L_productionRules_ForGrammarComponent & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mNonterminalSymbolsMap ;
    _out_1 = _p->mProductionRulesList ;
    _out_2 = _p->mSyntaxComponentName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
method_last (C_Lexique & _inLexique,
             GGS_M_nonTerminalSymbolsForGrammar & _out_0,
             GGS_L_productionRules_ForGrammarComponent & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mNonterminalSymbolsMap ;
    _out_1 = _p->mProductionRulesList ;
    _out_2 = _p->mSyntaxComponentName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_M_nonTerminalSymbolsForGrammar & _out_0,
                 GGS_L_productionRules_ForGrammarComponent & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mNonterminalSymbolsMap ;
    _out_1 = _p->mProductionRulesList ;
    _out_2 = _p->mSyntaxComponentName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_syntaxComponents_ForGrammar::
modifier_popLast (C_Lexique & _inLexique,
                GGS_M_nonTerminalSymbolsForGrammar & _out_0,
                GGS_L_productionRules_ForGrammarComponent & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mNonterminalSymbolsMap ;
    _out_1 = _p->mProductionRulesList ;
    _out_2 = _p->mSyntaxComponentName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//               class map 'M_startSymbolEntityAndMetamodel'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_startSymbolEntityAndMetamodel::
elementOf_GGS_M_startSymbolEntityAndMetamodel (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_startSymbolEntityAndMetamodel & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_startSymbolEntityAndMetamodel::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mReturnedEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mReturnedMetamodelName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_startSymbolEntityAndMetamodel::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_startSymbolEntityAndMetamodel * _p = dynamic_cast <const elementOf_GGS_M_startSymbolEntityAndMetamodel *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mReturnedEntityName == _p->mInfo.mReturnedEntityName).boolValue ()
           && (mInfo.mReturnedMetamodelName == _p->mInfo.mReturnedMetamodelName).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_startSymbolEntityAndMetamodel::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_startSymbolEntityAndMetamodel *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_startSymbolEntityAndMetamodel * info = (e_M_startSymbolEntityAndMetamodel *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_startSymbolEntityAndMetamodel GGS_M_startSymbolEntityAndMetamodel::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_startSymbolEntityAndMetamodel result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_startSymbolEntityAndMetamodel::
operator == (const GGS_M_startSymbolEntityAndMetamodel & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_startSymbolEntityAndMetamodel::
operator != (const GGS_M_startSymbolEntityAndMetamodel & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                const GGS_lstring & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_startSymbolEntityAndMetamodel info  ;
    info.mReturnedEntityName = inParameter0 ;
    info.mReturnedMetamodelName = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mReturnedEntityName ;
    outParameter1 = node->mInfo.mReturnedMetamodelName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the label '%K' is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_startSymbolEntityAndMetamodel::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the label '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_startSymbolEntityAndMetamodel GGS_M_startSymbolEntityAndMetamodel::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_startSymbolEntityAndMetamodel & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_startSymbolEntityAndMetamodel result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_startSymbolEntityAndMetamodel GGS_M_startSymbolEntityAndMetamodel::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_startSymbolEntityAndMetamodel result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_startSymbolEntityAndMetamodel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_startSymbolEntityAndMetamodel " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@L_identifiers'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_identifiers::
elementOf_GGS_L_identifiers (const GGS_lstring & argument_0):
aIdentificateur (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_identifiers::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_identifiers * _p = dynamic_cast <const elementOf_GGS_L_identifiers *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aIdentificateur == _p->aIdentificateur).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_identifiers::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aIdentificateur.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_identifiers'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_identifiers::GGS_L_identifiers (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_identifiers::
GGS_L_identifiers (const GGS_L_identifiers & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_identifiers::
operator == (const GGS_L_identifiers & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_identifiers::
operator != (const GGS_L_identifiers & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
_addAssign_operation (const GGS_lstring & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_identifiers GGS_L_identifiers::
operator + (const GGS_L_identifiers & inOperand) const {
  GGS_L_identifiers result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_identifiers * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->aIdentificateur ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->aIdentificateur) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_identifiers  GGS_L_identifiers::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_identifiers result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_identifiers  GGS_L_identifiers::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_identifiers result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_identifiers::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_identifiers", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aIdentificateur ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aIdentificateur ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aIdentificateur ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_identifiers::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aIdentificateur ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'typeSuperClassesMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSuperClassesMap::
elementOf_GGS_typeSuperClassesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeSuperClassesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSuperClassesMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeSuperClassesMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeSuperClassesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeSuperClassesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeSuperClassesMap * info = (e_typeSuperClassesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSuperClassesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSuperClassesMap::
operator == (const GGS_typeSuperClassesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSuperClassesMap::
operator != (const GGS_typeSuperClassesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeSuperClassesMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSuperClassesMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the class '%K' is already a super class of the current class",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeSuperClassesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSuperClassesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap GGS_typeSuperClassesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSuperClassesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSuperClassesMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeSuperClassesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeClassInheritedMessagesMap'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeClassInheritedMessagesMap::
elementOf_GGS_typeClassInheritedMessagesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeClassInheritedMessagesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeClassInheritedMessagesMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeClassInheritedMessagesMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassInheritedMessagesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeClassInheritedMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeClassInheritedMessagesMap * info = (e_typeClassInheritedMessagesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassInheritedMessagesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassInheritedMessagesMap::
operator == (const GGS_typeClassInheritedMessagesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassInheritedMessagesMap::
operator != (const GGS_typeClassInheritedMessagesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeClassInheritedMessagesMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the message '%K' is not declared",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassInheritedMessagesMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the message '%K' is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeClassInheritedMessagesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassInheritedMessagesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap GGS_typeClassInheritedMessagesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassInheritedMessagesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeClassInheritedMessagesMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeClassInheritedMessagesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'typeSemanticAttributesMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSemanticAttributesMap::
elementOf_GGS_typeSemanticAttributesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeSemanticAttributesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSemanticAttributesMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAttributType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeSemanticAttributesMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeSemanticAttributesMap * _p = dynamic_cast <const elementOf_GGS_typeSemanticAttributesMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mAttributType == _p->mInfo.mAttributType).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeSemanticAttributesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeSemanticAttributesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeSemanticAttributesMap * info = (e_typeSemanticAttributesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticAttributesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSemanticAttributesMap::
operator == (const GGS_typeSemanticAttributesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSemanticAttributesMap::
operator != (const GGS_typeSemanticAttributesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_galgasType & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeSemanticAttributesMap info  ;
    info.mAttributType = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no attribut named '%K'",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticAttributesMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "an attribut named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeSemanticAttributesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticAttributesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap GGS_typeSemanticAttributesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSemanticAttributesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSemanticAttributesMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeSemanticAttributesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@insertOrSearchMethodList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_insertOrSearchMethodList::
elementOf_GGS_insertOrSearchMethodList (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2,
                                const GGS_string& argument_3):
mMethodName (argument_0),
mErrorMessage (argument_1),
mIsGetIndexMethod (argument_2),
mShadowErrorMessage (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_insertOrSearchMethodList::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_insertOrSearchMethodList * _p = dynamic_cast <const elementOf_GGS_insertOrSearchMethodList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMethodName == _p->mMethodName).boolValue ()
         && (mErrorMessage == _p->mErrorMessage).boolValue ()
         && (mIsGetIndexMethod == _p->mIsGetIndexMethod).boolValue ()
         && (mShadowErrorMessage == _p->mShadowErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_insertOrSearchMethodList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsGetIndexMethod.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mShadowErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@insertOrSearchMethodList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList::GGS_insertOrSearchMethodList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList::
GGS_insertOrSearchMethodList (const GGS_insertOrSearchMethodList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_insertOrSearchMethodList::
operator == (const GGS_insertOrSearchMethodList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_insertOrSearchMethodList::
operator != (const GGS_insertOrSearchMethodList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_bool& argument_2,
                    const GGS_string& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_bool& argument_2,
                    const GGS_string& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2,
                                const GGS_string& argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList GGS_insertOrSearchMethodList::
operator + (const GGS_insertOrSearchMethodList & inOperand) const {
  GGS_insertOrSearchMethodList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_insertOrSearchMethodList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_string p_1 = p->mErrorMessage ;
          GGS_bool p_2 = p->mIsGetIndexMethod ;
          GGS_string p_3 = p->mShadowErrorMessage ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_string& argument_1,
                     const GGS_bool& argument_2,
                     const GGS_string& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mErrorMessage,
                                _p->mIsGetIndexMethod,
                                _p->mShadowErrorMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_insertOrSearchMethodList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_insertOrSearchMethodList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_insertOrSearchMethodList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_string& argument_1,
                           const GGS_bool& argument_2,
                           const GGS_string& argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_insertOrSearchMethodList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertOrSearchMethodList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@insertOrSearchMethodList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0,
              GGS_string& _out_1,
              GGS_bool& _out_2,
              GGS_string& _out_3
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mErrorMessage ;
    _out_2 = _p->mIsGetIndexMethod ;
    _out_3 = _p->mShadowErrorMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0,
             GGS_string& _out_1,
             GGS_bool& _out_2,
             GGS_string& _out_3
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mErrorMessage ;
    _out_2 = _p->mIsGetIndexMethod ;
    _out_3 = _p->mShadowErrorMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_string& _out_1,
                 GGS_bool& _out_2,
                 GGS_string& _out_3
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mErrorMessage ;
    _out_2 = _p->mIsGetIndexMethod ;
    _out_3 = _p->mShadowErrorMessage ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrSearchMethodList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0,
                GGS_string& _out_1,
                GGS_bool& _out_2,
                GGS_string& _out_3
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mErrorMessage ;
    _out_2 = _p->mIsGetIndexMethod ;
    _out_3 = _p->mShadowErrorMessage ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeDefEntiteUtilisable'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefEntiteUtilisable::
cPtr_typeDefEntiteUtilisable (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefEntiteUtilisable * GGS_typeDefEntiteUtilisable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeDefEntiteUtilisable::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeDefEntiteUtilisable:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable
::static_string_message_messageTypeEntite (void) {
  return "any type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefEntiteUtilisable::
message_messageTypeEntite (void) const {
  return "any type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeDefEntiteUtilisable'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
GGS_typeDefEntiteUtilisable (const GGS_typeDefEntiteUtilisable & inOperand) {
  mPointer = (cPtr_typeDefEntiteUtilisable *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefEntiteUtilisable::
~GGS_typeDefEntiteUtilisable (void) {
  macroDetachPointer (mPointer, cPtr_typeDefEntiteUtilisable) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefEntiteUtilisable::
operator = (const GGS_typeDefEntiteUtilisable & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDefEntiteUtilisable::
reader_messageTypeEntite (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageTypeEntite ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefEntiteUtilisable::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeDefEntiteUtilisable) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDefEntiteUtilisable::
operator == (const GGS_typeDefEntiteUtilisable & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDefEntiteUtilisable::
operator != (const GGS_typeDefEntiteUtilisable & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDefEntiteUtilisable::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDefEntiteUtilisable" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeGalgasUndefinedListType'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedListType::
cPtr_typeGalgasUndefinedListType (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mListTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedListType * GGS_typeGalgasUndefinedListType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedListType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedListType::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedListType * _p = dynamic_cast <const cPtr_typeGalgasUndefinedListType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mListTypeName == _p->mListTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedListType::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mListTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2146)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedListType::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedListType:"
           << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedListType
::static_string_message_messageGalgasType (void) {
  return "an undefined list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedListType::
message_messageGalgasType (void) const {
  return "an undefined list type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedListType'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedListType::
GGS_typeGalgasUndefinedListType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedListType::
GGS_typeGalgasUndefinedListType (const GGS_typeGalgasUndefinedListType & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedListType::
~GGS_typeGalgasUndefinedListType (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgasUndefinedListType) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgasUndefinedListType::
operator = (const GGS_typeGalgasUndefinedListType & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedListType GGS_typeGalgasUndefinedListType::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgasUndefinedListType * _ptr = (cPtr_typeGalgasUndefinedListType *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgasUndefinedListType (argument_0 COMMA_THERE)) ;
  GGS_typeGalgasUndefinedListType result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedListType::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasUndefinedListType::
reader_mListTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasUndefinedListType *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasUndefinedListType::
operator == (const GGS_typeGalgasUndefinedListType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasUndefinedListType::
operator != (const GGS_typeGalgasUndefinedListType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedListType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgasUndefinedListType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeGalgasListType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasListType::
cPtr_typeGalgasListType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_EXsignature & argument_2,
                                const GGS_L_EXsignature & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedListType (argument_0 COMMA_THERE),
mNonExternAttributesList (argument_1),
mExtractSignature (argument_2),
mInputSignature (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasListType * GGS_typeGalgasListType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasListType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasListType::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasListType * _p = dynamic_cast <const cPtr_typeGalgasListType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mListTypeName == _p->mListTypeName).boolValue ()
         && (mNonExternAttributesList == _p->mNonExternAttributesList).boolValue ()
         && (mExtractSignature == _p->mExtractSignature).boolValue ()
         && (mInputSignature == _p->mInputSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_acceptForeachInstruction (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outForeachList = mNonExternAttributesList ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_listStyle (_inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2184))) == (GGS_string (true, "prependValue"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = mInputSignature ;
  }else if (((((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2186))) == (GGS_string (true, "popFirst"))) | ((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2186))) == (GGS_string (true, "popLast"))))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = mExtractSignature ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a list accepts only 'popFirst' and 'popLast' modifiers") SOURCE_FILE_AT_LINE (2190)) ;
    var_cas_outModifierSignature._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_handleMethodInstructionCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inReadObjectName */,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_EXsignature & var_cas_outReaderSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((((var_cas_inReaderName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2201))) != (GGS_string (true, "first"))) & ((var_cas_inReaderName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2201))) != (GGS_string (true, "last"))))).isBuiltAndTrue ()) {
    var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a list accepts only 'first' and 'last' methods") SOURCE_FILE_AT_LINE (2203)) ;
  }
  var_cas_outReaderSignature = mExtractSignature ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_handleAddAssignOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outParametersList = mNonExternAttributesList ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2220))) == (GGS_string (true, "emptyList"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2222))) == (GGS_string (true, "listWithValue"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = mNonExternAttributesList ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (2226)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListType::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasListType:"
           << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExtractSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInputSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListType
::static_string_message_messageGalgasType (void) {
  return "a list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListType::
message_messageGalgasType (void) const {
  return "a list type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasListType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasListType::
GGS_typeGalgasListType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListType::
GGS_typeGalgasListType (const GGS_typeGalgasListType & inOperand)
:GGS_typeGalgasUndefinedListType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListType::
~GGS_typeGalgasListType (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgasListType) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgasListType::
operator = (const GGS_typeGalgasListType & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListType GGS_typeGalgasListType::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_L_EXsignature & argument_2,
                 const GGS_L_EXsignature & argument_3 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgasListType * _ptr = (cPtr_typeGalgasListType *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgasListType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  GGS_typeGalgasListType result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasListType::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasListType::
reader_mNonExternAttributesList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasListType *) mPointer)->mNonExternAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeGalgasListType::
reader_mExtractSignature (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasListType *) mPointer)->mExtractSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeGalgasListType::
reader_mInputSignature (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasListType *) mPointer)->mInputSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasListType::
operator == (const GGS_typeGalgasListType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasListType::
operator != (const GGS_typeGalgasListType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasListType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgasListType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         abstract class 'cPtr_typeGalgasUndefinedSortedListType'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedSortedListType::
cPtr_typeGalgasUndefinedSortedListType (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mListTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedSortedListType * GGS_typeGalgasUndefinedSortedListType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedSortedListType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedSortedListType::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedSortedListType * _p = dynamic_cast <const cPtr_typeGalgasUndefinedSortedListType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mListTypeName == _p->mListTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedSortedListType::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mListTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2243)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedSortedListType::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedSortedListType:"
           << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedSortedListType
::static_string_message_messageGalgasType (void) {
  return "a predeclared sorted list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedSortedListType::
message_messageGalgasType (void) const {
  return "a predeclared sorted list type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeGalgasUndefinedSortedListType'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedSortedListType::
GGS_typeGalgasUndefinedSortedListType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedSortedListType::
GGS_typeGalgasUndefinedSortedListType (const GGS_typeGalgasUndefinedSortedListType & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedSortedListType::
~GGS_typeGalgasUndefinedSortedListType (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgasUndefinedSortedListType) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgasUndefinedSortedListType::
operator = (const GGS_typeGalgasUndefinedSortedListType & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedSortedListType GGS_typeGalgasUndefinedSortedListType::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgasUndefinedSortedListType * _ptr = (cPtr_typeGalgasUndefinedSortedListType *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgasUndefinedSortedListType (argument_0 COMMA_THERE)) ;
  GGS_typeGalgasUndefinedSortedListType result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedSortedListType::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasUndefinedSortedListType::
reader_mListTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasUndefinedSortedListType *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasUndefinedSortedListType::
operator == (const GGS_typeGalgasUndefinedSortedListType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasUndefinedSortedListType::
operator != (const GGS_typeGalgasUndefinedSortedListType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedSortedListType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgasUndefinedSortedListType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeGalgasSortedListType'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasSortedListType::
cPtr_typeGalgasSortedListType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_EXsignature & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedSortedListType (argument_0 COMMA_THERE),
mNonExternAttributesList (argument_1),
mExtractSignature (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasSortedListType * GGS_typeGalgasSortedListType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasSortedListType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasSortedListType::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasSortedListType * _p = dynamic_cast <const cPtr_typeGalgasSortedListType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mListTypeName == _p->mListTypeName).boolValue ()
         && (mNonExternAttributesList == _p->mNonExternAttributesList).boolValue ()
         && (mExtractSignature == _p->mExtractSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_acceptForeachInstruction (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outForeachList = mNonExternAttributesList ;
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_listStyle (_inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2279))) == (GGS_string (true, "popSmallest"))) | ((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2279))) == (GGS_string (true, "popGreatest"))))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = mExtractSignature ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a sorted list accepts only 'popSmallest' and 'popGreatest' modifiers") SOURCE_FILE_AT_LINE (2283)) ;
    var_cas_outModifierSignature._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_handleMethodInstructionCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inReadObjectName */,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_EXsignature & var_cas_outReaderSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((((var_cas_inReaderName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2294))) != (GGS_string (true, "smallest"))) & ((var_cas_inReaderName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2294))) != (GGS_string (true, "greatest"))))).isBuiltAndTrue ()) {
    var_cas_inReaderName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a sorted list accepts only 'smallest' and 'greatest' methods") SOURCE_FILE_AT_LINE (2296)) ;
  }
  var_cas_outReaderSignature = mExtractSignature ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_handleAddAssignOperatorCall (C_Lexique & /* _inLexique */,
                                GGS_location  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outParametersList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outParametersList = mNonExternAttributesList ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2313))) == (GGS_string (true, "emptySortedList"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2315))) == (GGS_string (true, "sortedListWithValue"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = mNonExternAttributesList ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (2319)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasSortedListType::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasSortedListType:"
           << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExtractSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasSortedListType
::static_string_message_messageGalgasType (void) {
  return "a sorted list type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasSortedListType::
message_messageGalgasType (void) const {
  return "a sorted list type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeGalgasSortedListType'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasSortedListType::
GGS_typeGalgasSortedListType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasSortedListType::
GGS_typeGalgasSortedListType (const GGS_typeGalgasSortedListType & inOperand)
:GGS_typeGalgasUndefinedSortedListType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasSortedListType::
~GGS_typeGalgasSortedListType (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgasSortedListType) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgasSortedListType::
operator = (const GGS_typeGalgasSortedListType & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasSortedListType GGS_typeGalgasSortedListType::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_L_EXsignature & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgasSortedListType * _ptr = (cPtr_typeGalgasSortedListType *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgasSortedListType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeGalgasSortedListType result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasSortedListType::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasSortedListType::
reader_mNonExternAttributesList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasSortedListType *) mPointer)->mNonExternAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeGalgasSortedListType::
reader_mExtractSignature (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasSortedListType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasSortedListType *) mPointer)->mExtractSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasSortedListType::
operator == (const GGS_typeGalgasSortedListType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasSortedListType::
operator != (const GGS_typeGalgasSortedListType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasSortedListType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgasSortedListType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'typeTableBlocsDeTable'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableBlocsDeTable::
elementOf_GGS_typeTableBlocsDeTable (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableBlocsDeTable & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableBlocsDeTable::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aSignatureDebut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aSignatureFin.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableBlocsDeTable::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableBlocsDeTable * _p = dynamic_cast <const elementOf_GGS_typeTableBlocsDeTable *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aSignatureDebut == _p->mInfo.aSignatureDebut).boolValue ()
           && (mInfo.aSignatureFin == _p->mInfo.aSignatureFin).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableBlocsDeTable::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableBlocsDeTable *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableBlocsDeTable * info = (e_typeTableBlocsDeTable *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableBlocsDeTable result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableBlocsDeTable::
operator == (const GGS_typeTableBlocsDeTable & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableBlocsDeTable::
operator != (const GGS_typeTableBlocsDeTable & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                const GGS_L_EXsignature & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableBlocsDeTable info  ;
    info.aSignatureDebut = inParameter0 ;
    info.aSignatureFin = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_L_EXsignature   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aSignatureDebut ;
    outParameter1 = node->mInfo.aSignatureFin ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_L_EXsignature   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no block method named '%K'",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableBlocsDeTable::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_L_EXsignature & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a block method named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableBlocsDeTable & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableBlocsDeTable result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable GGS_typeTableBlocsDeTable::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableBlocsDeTable result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableBlocsDeTable::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableBlocsDeTable " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeGalgasUndefinedMapType'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedMapType::
cPtr_typeGalgasUndefinedMapType (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mMapTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedMapType * GGS_typeGalgasUndefinedMapType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedMapType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedMapType::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedMapType * _p = dynamic_cast <const cPtr_typeGalgasUndefinedMapType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMapTypeName == _p->mMapTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapType::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mMapTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2349)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedMapType::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedMapType:"
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapType
::static_string_message_messageGalgasType (void) {
  return "an undefined map type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedMapType::
message_messageGalgasType (void) const {
  return "an undefined map type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeGalgasUndefinedMapType'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapType::
GGS_typeGalgasUndefinedMapType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapType::
GGS_typeGalgasUndefinedMapType (const GGS_typeGalgasUndefinedMapType & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapType::
~GGS_typeGalgasUndefinedMapType (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgasUndefinedMapType) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgasUndefinedMapType::
operator = (const GGS_typeGalgasUndefinedMapType & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedMapType GGS_typeGalgasUndefinedMapType::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgasUndefinedMapType * _ptr = (cPtr_typeGalgasUndefinedMapType *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgasUndefinedMapType (argument_0 COMMA_THERE)) ;
  GGS_typeGalgasUndefinedMapType result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedMapType::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasUndefinedMapType::
reader_mMapTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasUndefinedMapType *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasUndefinedMapType::
operator == (const GGS_typeGalgasUndefinedMapType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasUndefinedMapType::
operator != (const GGS_typeGalgasUndefinedMapType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedMapType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgasUndefinedMapType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'mapModifierMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapModifierMap::
elementOf_GGS_mapModifierMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapModifierMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapModifierMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMethodSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapModifierMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_mapModifierMap * _p = dynamic_cast <const elementOf_GGS_mapModifierMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mMethodSignature == _p->mInfo.mMethodSignature).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapModifierMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapModifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapModifierMap * info = (e_mapModifierMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_mapModifierMap GGS_mapModifierMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapModifierMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapModifierMap::
operator == (const GGS_mapModifierMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapModifierMap::
operator != (const GGS_mapModifierMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_mapModifierMap info  ;
    info.mMethodSignature = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMethodSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no insert nor modifier named '%K'",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapModifierMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "an insert or a remove modifier named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapModifierMap GGS_mapModifierMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_mapModifierMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapModifierMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapModifierMap GGS_mapModifierMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapModifierMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapModifierMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @mapModifierMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'mapMethodMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapMethodMap::
elementOf_GGS_mapMethodMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapMethodMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMethodSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapMethodMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_mapMethodMap * _p = dynamic_cast <const elementOf_GGS_mapMethodMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mMethodSignature == _p->mInfo.mMethodSignature).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapMethodMap * info = (e_mapMethodMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapMethodMap::
operator == (const GGS_mapMethodMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapMethodMap::
operator != (const GGS_mapMethodMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_mapMethodMap info  ;
    info.mMethodSignature = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMethodSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no search method named '%K'",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a search method named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_mapMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap GGS_mapMethodMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapMethodMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @mapMethodMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeGalgasMapType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasMapType::
cPtr_typeGalgasMapType (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableBlocsDeTable & argument_2,
                                const GGS_mapModifierMap & argument_3,
                                const GGS_mapMethodMap & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedMapType (argument_0 COMMA_THERE),
mNonExternAttributesList (argument_1),
aTableMethodesSurcharger (argument_2),
mModifierMethodMap (argument_3),
mReaderMethodMap (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasMapType * GGS_typeGalgasMapType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasMapType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasMapType::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasMapType * _p = dynamic_cast <const cPtr_typeGalgasMapType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMapTypeName == _p->mMapTypeName).boolValue ()
         && (mNonExternAttributesList == _p->mNonExternAttributesList).boolValue ()
         && (aTableMethodesSurcharger == _p->aTableMethodesSurcharger).boolValue ()
         && (mModifierMethodMap == _p->mModifierMethodMap).boolValue ()
         && (mReaderMethodMap == _p->mReaderMethodMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inModifiedObjectName */,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (mModifierMethodMap._isBuilt ()) {
    mModifierMethodMap (HERE)->method_searchKey (_inLexique, var_cas_inModifierName, var_cas_outModifierSignature SOURCE_FILE_AT_LINE (2393)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_handleMethodInstructionCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inReadObjectName */,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_EXsignature & var_cas_outReaderSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (mReaderMethodMap._isBuilt ()) {
    mReaderMethodMap (HERE)->method_searchKey (_inLexique, var_cas_inReaderName, var_cas_outReaderSignature SOURCE_FILE_AT_LINE (2403)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_acceptForeachInstruction (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inErrorLocation */,
                                GGS_typeListeAttributsSemantiques & var_cas_outForeachList,
                                GGS_localConstantBuildStyleEnum& var_cas_outStyle COMMA_UNUSED_LOCATION_ARGS) {
  GGS_AC_galgasType  var_cas_keyType ;
  var_cas_keyType = GGS_typeGalgas_lstring::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_outForeachList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  var_cas_outForeachList._addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "\?\?\?"), GGS_location (_inLexique) COMMA_HERE)) ;
  GGS_typeListeAttributsSemantiques::element_type * operand_97429 = mNonExternAttributesList.firstObject () ;
  while ((operand_97429 != NULL)) {
    macroValidPointer (operand_97429) ;
    var_cas_outForeachList._addAssign_operation (operand_97429->mAttributType, operand_97429->aNomAttribut) ;
    operand_97429 = operand_97429->nextObject () ;
  }
  var_cas_outStyle = GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (_inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2428))) == (GGS_string (true, "emptyMap"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2430))) == (GGS_string (true, "mapWithMapToOverride"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgasUndefinedMapType::constructor_new (_inLexique, mMapTypeName COMMA_HERE), GGS_lstring::constructor_new (_inLexique, GGS_string (true, "\?\?\?"), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2433))) == (GGS_string (true, "empty"))).isBuiltAndTrue ()) {
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "in GALGAS 1.3.0 and later, use 'emptyMap' constructor instead of 'empty' constructor") SOURCE_FILE_AT_LINE (2435)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (2437)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasMapType::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasMapType:"
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aTableMethodesSurcharger.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModifierMethodMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReaderMethodMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapType
::static_string_message_messageGalgasType (void) {
  return "a map type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasMapType::
message_messageGalgasType (void) const {
  return "a map type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeGalgasMapType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasMapType::
GGS_typeGalgasMapType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasMapType::
GGS_typeGalgasMapType (const GGS_typeGalgasMapType & inOperand)
:GGS_typeGalgasUndefinedMapType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasMapType::
~GGS_typeGalgasMapType (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgasMapType) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgasMapType::
operator = (const GGS_typeGalgasMapType & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasMapType GGS_typeGalgasMapType::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_typeTableBlocsDeTable & argument_2,
                 const GGS_mapModifierMap & argument_3,
                 const GGS_mapMethodMap & argument_4 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgasMapType * _ptr = (cPtr_typeGalgasMapType *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgasMapType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  GGS_typeGalgasMapType result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasMapType::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasMapType::
reader_mNonExternAttributesList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapType *) mPointer)->mNonExternAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable  GGS_typeGalgasMapType::
reader_aTableMethodesSurcharger (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableBlocsDeTable   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapType *) mPointer)->aTableMethodesSurcharger ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapModifierMap  GGS_typeGalgasMapType::
reader_mModifierMethodMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapModifierMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapType *) mPointer)->mModifierMethodMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodMap  GGS_typeGalgasMapType::
reader_mReaderMethodMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasMapType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasMapType *) mPointer)->mReaderMethodMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasMapType::
operator == (const GGS_typeGalgasMapType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasMapType::
operator != (const GGS_typeGalgasMapType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasMapType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgasMapType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeGalgasUndefinedClassType'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasUndefinedClassType::
cPtr_typeGalgasUndefinedClassType (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mClassTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasUndefinedClassType * GGS_typeGalgasUndefinedClassType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasUndefinedClassType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasUndefinedClassType::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasUndefinedClassType * _p = dynamic_cast <const cPtr_typeGalgasUndefinedClassType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mClassTypeName == _p->mClassTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedClassType::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mClassTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2454)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasUndefinedClassType::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasUndefinedClassType:"
           << mClassTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedClassType
::static_string_message_messageGalgasType (void) {
  return "an undefined class type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasUndefinedClassType::
message_messageGalgasType (void) const {
  return "an undefined class type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasUndefinedClassType'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedClassType::
GGS_typeGalgasUndefinedClassType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedClassType::
GGS_typeGalgasUndefinedClassType (const GGS_typeGalgasUndefinedClassType & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedClassType::
~GGS_typeGalgasUndefinedClassType (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgasUndefinedClassType) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgasUndefinedClassType::
operator = (const GGS_typeGalgasUndefinedClassType & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasUndefinedClassType GGS_typeGalgasUndefinedClassType::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgasUndefinedClassType * _ptr = (cPtr_typeGalgasUndefinedClassType *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgasUndefinedClassType (argument_0 COMMA_THERE)) ;
  GGS_typeGalgasUndefinedClassType result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedClassType::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgasUndefinedClassType::
reader_mClassTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasUndefinedClassType *) mPointer)->mClassTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasUndefinedClassType::
operator == (const GGS_typeGalgasUndefinedClassType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasUndefinedClassType::
operator != (const GGS_typeGalgasUndefinedClassType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasUndefinedClassType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgasUndefinedClassType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeGalgasNewClassType'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasNewClassType::
cPtr_typeGalgasNewClassType (const GGS_lstring & argument_0,
                                const GGS_typeSuperClassesMap & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedClassType (argument_0 COMMA_THERE),
mSuperClassMap (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasNewClassType * GGS_typeGalgasNewClassType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasNewClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasNewClassType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasNewClassType::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasNewClassType * _p = dynamic_cast <const cPtr_typeGalgasNewClassType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mClassTypeName == _p->mClassTypeName).boolValue ()
         && (mSuperClassMap == _p->mSuperClassMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasNewClassType::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasNewClassType:"
           << mClassTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSuperClassMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeGalgasNewClassType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasNewClassType::
GGS_typeGalgasNewClassType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasNewClassType::
GGS_typeGalgasNewClassType (const GGS_typeGalgasNewClassType & inOperand)
:GGS_typeGalgasUndefinedClassType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasNewClassType::
~GGS_typeGalgasNewClassType (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgasNewClassType) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgasNewClassType::
operator = (const GGS_typeGalgasNewClassType & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasNewClassType GGS_typeGalgasNewClassType::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeSuperClassesMap & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgasNewClassType * _ptr = (cPtr_typeGalgasNewClassType *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgasNewClassType (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeGalgasNewClassType result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap  GGS_typeGalgasNewClassType::
reader_mSuperClassMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSuperClassesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasNewClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasNewClassType *) mPointer)->mSuperClassMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasNewClassType::
operator == (const GGS_typeGalgasNewClassType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasNewClassType::
operator != (const GGS_typeGalgasNewClassType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasNewClassType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgasNewClassType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeGalgasClassType'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasClassType::
cPtr_typeGalgasClassType (const GGS_lstring & argument_0,
                                const GGS_typeTableMethodes & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeSuperClassesMap & argument_3,
                                const GGS_typeClassInheritedMessagesMap & argument_4,
                                const GGS_typeSemanticAttributesMap & argument_5,
                                const GGS_bool& argument_6 COMMA_LOCATION_ARGS)
:cPtr_typeGalgasUndefinedClassType (argument_0 COMMA_THERE),
mReaderMap (argument_1),
mNonExternAttributesList (argument_2),
mAncestorClassesMap (argument_3),
mMessagesMap (argument_4),
mNonExternAttributesMap (argument_5),
mClassIsAbstract (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasClassType * GGS_typeGalgasClassType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasClassType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasClassType::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasClassType * _p = dynamic_cast <const cPtr_typeGalgasClassType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mClassTypeName == _p->mClassTypeName).boolValue ()
         && (mReaderMap == _p->mReaderMap).boolValue ()
         && (mNonExternAttributesList == _p->mNonExternAttributesList).boolValue ()
         && (mAncestorClassesMap == _p->mAncestorClassesMap).boolValue ()
         && (mMessagesMap == _p->mMessagesMap).boolValue ()
         && (mNonExternAttributesMap == _p->mNonExternAttributesMap).boolValue ()
         && (mClassIsAbstract == _p->mClassIsAbstract).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
method_handleMethodInstructionCall (C_Lexique & _inLexique,
                                GGS_lstring  /* var_cas_inReadObjectName */,
                                GGS_lstring  var_cas_inMethodName,
                                GGS_L_EXsignature & var_cas_outMethodSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (mReaderMap._isBuilt ()) {
    mReaderMap (HERE)->method_searchKey (_inLexique, var_cas_inMethodName, var_cas_outMethodSignature SOURCE_FILE_AT_LINE (2495)) ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if ((mClassIsAbstract).isBuiltAndTrue ()) {
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "an abstract class cannot be instancied") SOURCE_FILE_AT_LINE (2505)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }else if (((var_cas_inClassMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2505))) == (GGS_string (true, "new"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = mNonExternAttributesList ;
  }else{
    var_cas_inClassMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "This constructor is not defined") SOURCE_FILE_AT_LINE (2509)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasClassType::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasClassType:"
           << mClassTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReaderMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAncestorClassesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMessagesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mClassIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasClassType
::static_string_message_messageGalgasType (void) {
  return "a class type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasClassType::
message_messageGalgasType (void) const {
  return "a class type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeGalgasClassType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasClassType::
GGS_typeGalgasClassType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasClassType::
GGS_typeGalgasClassType (const GGS_typeGalgasClassType & inOperand)
:GGS_typeGalgasUndefinedClassType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasClassType::
~GGS_typeGalgasClassType (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgasClassType) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgasClassType::
operator = (const GGS_typeGalgasClassType & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasClassType GGS_typeGalgasClassType::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeTableMethodes & argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_typeSuperClassesMap & argument_3,
                 const GGS_typeClassInheritedMessagesMap & argument_4,
                 const GGS_typeSemanticAttributesMap & argument_5,
                 const GGS_bool& argument_6 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgasClassType * _ptr = (cPtr_typeGalgasClassType *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgasClassType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  GGS_typeGalgasClassType result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasClassType::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes  GGS_typeGalgasClassType::
reader_mReaderMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mReaderMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeGalgasClassType::
reader_mNonExternAttributesList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mNonExternAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap  GGS_typeGalgasClassType::
reader_mAncestorClassesMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSuperClassesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mAncestorClassesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassInheritedMessagesMap  GGS_typeGalgasClassType::
reader_mMessagesMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassInheritedMessagesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mMessagesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticAttributesMap  GGS_typeGalgasClassType::
reader_mNonExternAttributesMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSemanticAttributesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mNonExternAttributesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasClassType::
reader_mClassIsAbstract (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasClassType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgasClassType *) mPointer)->mClassIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasClassType::
operator == (const GGS_typeGalgasClassType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgasClassType::
operator != (const GGS_typeGalgasClassType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgasClassType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgasClassType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeEntiteType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteType::
cPtr_typeEntiteType (const GGS_AC_galgasType & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aDefType (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteType * GGS_typeEntiteType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteType::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteType * _p = dynamic_cast <const cPtr_typeEntiteType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aDefType == _p->aDefType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteType::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteType:"
           << aDefType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteType
::static_string_message_messageTypeEntite (void) {
  return "a type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteType::
message_messageTypeEntite (void) const {
  return "a type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntiteType::
GGS_typeEntiteType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteType::
GGS_typeEntiteType (const GGS_typeEntiteType & inOperand)
:GGS_AC_semanticsEntity () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteType::
~GGS_typeEntiteType (void) {
  macroDetachPointer (mPointer, cPtr_typeEntiteType) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntiteType::
operator = (const GGS_typeEntiteType & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteType GGS_typeEntiteType::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_galgasType & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeEntiteType * _ptr = (cPtr_typeEntiteType *) NULL ;
  macroMyNew (_ptr, cPtr_typeEntiteType (argument_0 COMMA_THERE)) ;
  GGS_typeEntiteType result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteType::
reader_messageTypeEntite (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageTypeEntite ())) ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeEntiteType::
reader_aDefType (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteType *) mPointer)->aDefType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEntiteType::
operator == (const GGS_typeEntiteType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEntiteType::
operator != (const GGS_typeEntiteType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeEntiteType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeEntiteRoutine'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteRoutine::
cPtr_typeEntiteRoutine (const GGS_L_EXsignature & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aListeArgumentsFormels (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteRoutine * GGS_typeEntiteRoutine::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteRoutine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteRoutine *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteRoutine::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteRoutine * _p = dynamic_cast <const cPtr_typeEntiteRoutine *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aListeArgumentsFormels == _p->aListeArgumentsFormels).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteRoutine::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteRoutine:"
           << aListeArgumentsFormels.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutine
::static_string_message_messageTypeEntite (void) {
  return "a routine" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutine::
message_messageTypeEntite (void) const {
  return "a routine" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeEntiteRoutine'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntiteRoutine::
GGS_typeEntiteRoutine (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutine::
GGS_typeEntiteRoutine (const GGS_typeEntiteRoutine & inOperand)
:GGS_AC_semanticsEntity () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutine::
~GGS_typeEntiteRoutine (void) {
  macroDetachPointer (mPointer, cPtr_typeEntiteRoutine) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntiteRoutine::
operator = (const GGS_typeEntiteRoutine & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutine GGS_typeEntiteRoutine::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_L_EXsignature & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeEntiteRoutine * _ptr = (cPtr_typeEntiteRoutine *) NULL ;
  macroMyNew (_ptr, cPtr_typeEntiteRoutine (argument_0 COMMA_THERE)) ;
  GGS_typeEntiteRoutine result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteRoutine::
reader_messageTypeEntite (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageTypeEntite ())) ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeEntiteRoutine::
reader_aListeArgumentsFormels (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteRoutine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteRoutine *) mPointer)->aListeArgumentsFormels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEntiteRoutine::
operator == (const GGS_typeEntiteRoutine & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEntiteRoutine::
operator != (const GGS_typeEntiteRoutine & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteRoutine::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeEntiteRoutine" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           abstract class 'cPtr_typeGalgas_entityInInstruction'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_entityInInstruction::
cPtr_typeGalgas_entityInInstruction (const GGS_string& argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEntityName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_entityInInstruction * GGS_typeGalgas_entityInInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_entityInInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_entityInInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_entityInInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgas_entityInInstruction * _p = dynamic_cast <const cPtr_typeGalgas_entityInInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mEntityName == _p->mEntityName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_entityInInstruction::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mEntityName ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_entityInInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_entityInInstruction:"
           << mEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_entityInInstruction
::static_string_message_messageGalgasType (void) {
  return "an entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_entityInInstruction::
message_messageGalgasType (void) const {
  return "an entity" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeGalgas_entityInInstruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_entityInInstruction::
GGS_typeGalgas_entityInInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_entityInInstruction::
GGS_typeGalgas_entityInInstruction (const GGS_typeGalgas_entityInInstruction & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_entityInInstruction::
~GGS_typeGalgas_entityInInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_entityInInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_entityInInstruction::
operator = (const GGS_typeGalgas_entityInInstruction & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_entityInInstruction GGS_typeGalgas_entityInInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_string& argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_entityInInstruction * _ptr = (cPtr_typeGalgas_entityInInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_entityInInstruction (argument_0 COMMA_THERE)) ;
  GGS_typeGalgas_entityInInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_entityInInstruction::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_entityInInstruction::
reader_mEntityName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_entityInInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_entityInInstruction *) mPointer)->mEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_entityInInstruction::
operator == (const GGS_typeGalgas_entityInInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_entityInInstruction::
operator != (const GGS_typeGalgas_entityInInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_entityInInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_entityInInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_typeGalgas_mapIndexInInstruction'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_mapIndexInInstruction::
cPtr_typeGalgas_mapIndexInInstruction (const GGS_string& argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mMapTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_mapIndexInInstruction * GGS_typeGalgas_mapIndexInInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_mapIndexInInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_mapIndexInInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_mapIndexInInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgas_mapIndexInInstruction * _p = dynamic_cast <const cPtr_typeGalgas_mapIndexInInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMapTypeName == _p->mMapTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_mapIndexInInstruction::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = GGS_string (true, "") ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_mapIndexInInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_mapIndexInInstruction:"
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_mapIndexInInstruction
::static_string_message_messageGalgasType (void) {
  return "a map index" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_mapIndexInInstruction::
message_messageGalgasType (void) const {
  return "a map index" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeGalgas_mapIndexInInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_mapIndexInInstruction::
GGS_typeGalgas_mapIndexInInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_mapIndexInInstruction::
GGS_typeGalgas_mapIndexInInstruction (const GGS_typeGalgas_mapIndexInInstruction & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_mapIndexInInstruction::
~GGS_typeGalgas_mapIndexInInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_mapIndexInInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_mapIndexInInstruction::
operator = (const GGS_typeGalgas_mapIndexInInstruction & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_mapIndexInInstruction GGS_typeGalgas_mapIndexInInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_string& argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_mapIndexInInstruction * _ptr = (cPtr_typeGalgas_mapIndexInInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_mapIndexInInstruction (argument_0 COMMA_THERE)) ;
  GGS_typeGalgas_mapIndexInInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_mapIndexInInstruction::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_mapIndexInInstruction::
reader_mMapTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_mapIndexInInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_mapIndexInInstruction *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_mapIndexInInstruction::
operator == (const GGS_typeGalgas_mapIndexInInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_mapIndexInInstruction::
operator != (const GGS_typeGalgas_mapIndexInInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_mapIndexInInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_mapIndexInInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         abstract class 'cPtr_typeGalgas_mapEntityInInstruction'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_mapEntityInInstruction::
cPtr_typeGalgas_mapEntityInInstruction (const GGS_string& argument_0,
                                const GGS_string& argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEntityName (argument_0),
mElementTypeName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_mapEntityInInstruction * GGS_typeGalgas_mapEntityInInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_mapEntityInInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_mapEntityInInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_mapEntityInInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgas_mapEntityInInstruction * _p = dynamic_cast <const cPtr_typeGalgas_mapEntityInInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mEntityName == _p->mEntityName).boolValue ()
         && (mElementTypeName == _p->mElementTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_mapEntityInInstruction::
method_getTypeName (C_Lexique & /* _inLexique */,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mEntityName ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_mapEntityInInstruction::
method_handleModifierCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inModifiedObjectName,
                                GGS_lstring  var_cas_inModifierName,
                                GGS_L_EXsignature & var_cas_outModifierSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2588))) == (GGS_string (true, "insertKey"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_lstring::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_entityInInstruction::constructor_new (_inLexique, mElementTypeName COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inModifierName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2594))) == (GGS_string (true, "insertKeyAndGetIndex"))).isBuiltAndTrue ()) {
    var_cas_outModifierSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_lstring::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_entityInInstruction::constructor_new (_inLexique, mElementTypeName COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_mapIndexInInstruction::constructor_new (_inLexique, var_cas_inModifiedObjectName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2600)) COMMA_HERE) ;
    var_cas_outModifierSignature._addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inModifierName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type only accept 'insertKey' and 'insertKey' modifier calls") SOURCE_FILE_AT_LINE (2605)) ;
    var_cas_outModifierSignature._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_mapEntityInInstruction::
method_handleMethodInstructionCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inReadObjectName,
                                GGS_lstring  var_cas_inReaderName,
                                GGS_L_EXsignature & var_cas_outReaderSignature COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_inReaderName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2615))) == (GGS_string (true, "searchKey"))).isBuiltAndTrue ()) {
    var_cas_outReaderSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_lstring::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outReaderSignature._addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_entityInInstruction::constructor_new (_inLexique, mElementTypeName COMMA_HERE) ;
    var_cas_outReaderSignature._addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
  }else if (((var_cas_inReaderName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2621))) == (GGS_string (true, "searchKeyAndGetIndex"))).isBuiltAndTrue ()) {
    var_cas_outReaderSignature = GGS_L_EXsignature::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_AC_galgasType  var_cas_t ;
    var_cas_t = GGS_typeGalgas_lstring::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outReaderSignature._addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentConstantIn (_inLexique COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_entityInInstruction::constructor_new (_inLexique, mElementTypeName COMMA_HERE) ;
    var_cas_outReaderSignature._addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
    var_cas_t = GGS_typeGalgas_mapIndexInInstruction::constructor_new (_inLexique, var_cas_inReadObjectName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2627)) COMMA_HERE) ;
    var_cas_outReaderSignature._addAssign_operation (var_cas_t, GGS_formalArgumentPassingMode::constructor_argumentOut (_inLexique COMMA_HERE)) ;
  }else{
    var_cas_inReadObjectName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type  only accept 'searchKey'  'searchKeyAndGetIndex' reader calls") SOURCE_FILE_AT_LINE (2633)) ;
    var_cas_outReaderSignature._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_mapEntityInInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_mapEntityInInstruction:"
           << mEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElementTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_mapEntityInInstruction
::static_string_message_messageGalgasType (void) {
  return "a map entity" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_mapEntityInInstruction::
message_messageGalgasType (void) const {
  return "a map entity" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeGalgas_mapEntityInInstruction'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_mapEntityInInstruction::
GGS_typeGalgas_mapEntityInInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_mapEntityInInstruction::
GGS_typeGalgas_mapEntityInInstruction (const GGS_typeGalgas_mapEntityInInstruction & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_mapEntityInInstruction::
~GGS_typeGalgas_mapEntityInInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_mapEntityInInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_mapEntityInInstruction::
operator = (const GGS_typeGalgas_mapEntityInInstruction & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_mapEntityInInstruction GGS_typeGalgas_mapEntityInInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_string& argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_mapEntityInInstruction * _ptr = (cPtr_typeGalgas_mapEntityInInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_mapEntityInInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeGalgas_mapEntityInInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_mapEntityInInstruction::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_mapEntityInInstruction::
reader_mEntityName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_mapEntityInInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_mapEntityInInstruction *) mPointer)->mEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_mapEntityInInstruction::
reader_mElementTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_mapEntityInInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_mapEntityInInstruction *) mPointer)->mElementTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_mapEntityInInstruction::
operator == (const GGS_typeGalgas_mapEntityInInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_mapEntityInInstruction::
operator != (const GGS_typeGalgas_mapEntityInInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_mapEntityInInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_mapEntityInInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'typeEnumMessageMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumMessageMap::
elementOf_GGS_typeEnumMessageMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumMessageMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEnumMessageMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMessageStringList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeEnumMessageMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeEnumMessageMap * _p = dynamic_cast <const elementOf_GGS_typeEnumMessageMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mMessageStringList == _p->mInfo.mMessageStringList).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumMessageMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeEnumMessageMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumMessageMap * info = (e_typeEnumMessageMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumMessageMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumMessageMap::
operator == (const GGS_typeEnumMessageMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumMessageMap::
operator != (const GGS_typeEnumMessageMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_lstringList & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeEnumMessageMap info  ;
    info.mMessageStringList = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_lstringList   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessageStringList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_lstringList   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' message name is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumMessageMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_lstringList & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' message name is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeEnumMessageMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumMessageMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap GGS_typeEnumMessageMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumMessageMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEnumMessageMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeEnumMessageMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeGalgas_enum'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgas_enum::
cPtr_typeGalgas_enum (const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_galgasType (THERE),
mEnumTypeName (argument_0),
mEnumConstantesMap (argument_1),
mMessagesMap (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgas_enum * GGS_typeGalgas_enum::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgas_enum *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgas_enum::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgas_enum * _p = dynamic_cast <const cPtr_typeGalgas_enum *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mEnumTypeName == _p->mEnumTypeName).boolValue ()
         && (mEnumConstantesMap == _p->mEnumConstantesMap).boolValue ()
         && (mMessagesMap == _p->mMessagesMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
method_getTypeName (C_Lexique & _inLexique,
                                GGS_string& var_cas_outTypeName COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outTypeName = mEnumTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2666)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
method_handleConstructorCall (C_Lexique & _inLexique,
                                GGS_lstring  var_cas_inClassMethodName,
                                GGS_typeListeAttributsSemantiques & var_cas_outAccessorTypesList COMMA_UNUSED_LOCATION_ARGS) {
  if (mEnumConstantesMap._isBuilt ()) {
    mEnumConstantesMap (HERE)->method_searchKey (_inLexique, var_cas_inClassMethodName SOURCE_FILE_AT_LINE (2674)) ;
  }
  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgas_enum::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgas_enum:"
           << mEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEnumConstantesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMessagesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_enum
::static_string_message_messageGalgasType (void) {
  return "an enum type" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgas_enum::
message_messageGalgasType (void) const {
  return "an enum type" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeGalgas_enum'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgas_enum::
GGS_typeGalgas_enum (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_enum::
GGS_typeGalgas_enum (const GGS_typeGalgas_enum & inOperand)
:GGS_AC_galgasType () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_enum::
~GGS_typeGalgas_enum (void) {
  macroDetachPointer (mPointer, cPtr_typeGalgas_enum) ;
}

//---------------------------------------------------------------------------*

void GGS_typeGalgas_enum::
operator = (const GGS_typeGalgas_enum & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgas_enum GGS_typeGalgas_enum::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_enumConstantMap & argument_1,
                 const GGS_typeEnumMessageMap & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeGalgas_enum * _ptr = (cPtr_typeGalgas_enum *) NULL ;
  macroMyNew (_ptr, cPtr_typeGalgas_enum (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeGalgas_enum result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_enum::
reader_messageGalgasType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageGalgasType ())) ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeGalgas_enum::
reader_mEnumTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_enum *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap  GGS_typeGalgas_enum::
reader_mEnumConstantesMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumConstantMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_enum *) mPointer)->mEnumConstantesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap  GGS_typeGalgas_enum::
reader_mMessagesMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumMessageMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgas_enum *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeGalgas_enum *) mPointer)->mMessagesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_enum::
operator == (const GGS_typeGalgas_enum & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeGalgas_enum::
operator != (const GGS_typeGalgas_enum & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeGalgas_enum::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeGalgas_enum" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "checkAssignmentTypesCompatibility"        *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkAssignmentTypesCompatibility (C_Lexique & _inLexique,
                                const GGS_AC_galgasType  & var_cas_inFormalType,
                                const GGS_AC_galgasType  & var_cas_inEffectiveType,
                                const GGS_location  & var_cas_inErrorLocation,
                                const GGS_bool & var_cas_inAcceptPolymorphism COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkAssignmentTypesCompatibility at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (var_cas_inFormalType._isBuilt () && var_cas_inEffectiveType._isBuilt ()) {
    cPtr_AC_galgasType * ptr_108254 = var_cas_inFormalType (HERE) ;
    cPtr_AC_galgasType * ptr_108273 = var_cas_inEffectiveType (HERE) ;
    cPtr_typeGalgas_stringset * operand_108254 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_108254) ;
    cPtr_typeGalgas_stringset * operand_108273 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_108273) ;
    if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
    }else{
      cPtr_typeGalgas_uint * operand_108254 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_108254) ;
      cPtr_typeGalgas_uint * operand_108273 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_108273) ;
      if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
      }else{
        cPtr_typeGalgas_sint * operand_108254 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_108254) ;
        cPtr_typeGalgas_sint * operand_108273 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_108273) ;
        if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
        }else{
          cPtr_typeGalgas_uint64 * operand_108254 = dynamic_cast <cPtr_typeGalgas_uint64 *> (ptr_108254) ;
          cPtr_typeGalgas_uint64 * operand_108273 = dynamic_cast <cPtr_typeGalgas_uint64 *> (ptr_108273) ;
          if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
          }else{
            cPtr_typeGalgas_sint64 * operand_108254 = dynamic_cast <cPtr_typeGalgas_sint64 *> (ptr_108254) ;
            cPtr_typeGalgas_sint64 * operand_108273 = dynamic_cast <cPtr_typeGalgas_sint64 *> (ptr_108273) ;
            if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
            }else{
              cPtr_typeGalgas_char * operand_108254 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_108254) ;
              cPtr_typeGalgas_char * operand_108273 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_108273) ;
              if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
              }else{
                cPtr_typeGalgas_string * operand_108254 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_108254) ;
                cPtr_typeGalgas_string * operand_108273 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_108273) ;
                if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                }else{
                  cPtr_typeGalgas_bool * operand_108254 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_108254) ;
                  cPtr_typeGalgas_bool * operand_108273 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_108273) ;
                  if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                  }else{
                    cPtr_typeGalgas_double * operand_108254 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_108254) ;
                    cPtr_typeGalgas_double * operand_108273 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_108273) ;
                    if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                    }else{
                      cPtr_typeGalgas_lbool * operand_108254 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_108254) ;
                      cPtr_typeGalgas_lbool * operand_108273 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_108273) ;
                      if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                      }else{
                        cPtr_typeGalgas_lchar * operand_108254 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_108254) ;
                        cPtr_typeGalgas_lchar * operand_108273 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_108273) ;
                        if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                        }else{
                          cPtr_typeGalgas_luint * operand_108254 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_108254) ;
                          cPtr_typeGalgas_luint * operand_108273 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_108273) ;
                          if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                          }else{
                            cPtr_typeGalgas_lsint * operand_108254 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_108254) ;
                            cPtr_typeGalgas_lsint * operand_108273 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_108273) ;
                            if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                            }else{
                              cPtr_typeGalgas_luint64 * operand_108254 = dynamic_cast <cPtr_typeGalgas_luint64 *> (ptr_108254) ;
                              cPtr_typeGalgas_luint64 * operand_108273 = dynamic_cast <cPtr_typeGalgas_luint64 *> (ptr_108273) ;
                              if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                              }else{
                                cPtr_typeGalgas_lsint64 * operand_108254 = dynamic_cast <cPtr_typeGalgas_lsint64 *> (ptr_108254) ;
                                cPtr_typeGalgas_lsint64 * operand_108273 = dynamic_cast <cPtr_typeGalgas_lsint64 *> (ptr_108273) ;
                                if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                                }else{
                                  cPtr_typeGalgas_ldouble * operand_108254 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_108254) ;
                                  cPtr_typeGalgas_ldouble * operand_108273 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_108273) ;
                                  if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                                  }else{
                                    cPtr_typeGalgas_lstring * operand_108254 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_108254) ;
                                    cPtr_typeGalgas_lstring * operand_108273 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_108273) ;
                                    if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                                    }else{
                                      cPtr_typeGalgas_location * operand_108254 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_108254) ;
                                      cPtr_typeGalgas_location * operand_108273 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_108273) ;
                                      if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                                      }else{
                                        cPtr_typeGalgasUndefinedListType * operand_108254 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_108254) ;
                                        cPtr_typeGalgasUndefinedListType * operand_108273 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_108273) ;
                                        if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                                          if (((operand_108254->mListTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2714))) != (operand_108273->mListTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2714)))).isBuiltAndTrue ()) {
                                            var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting the list type '@")) + (operand_108254->mListTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2715))))) + (GGS_string (true, "', I have got the list type '@")))) + (operand_108273->mListTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2716))))) + (GGS_string (true, "\""))) SOURCE_FILE_AT_LINE (2717)) ;
                                          }
                                        }else{
                                          cPtr_typeGalgasUndefinedSortedListType * operand_108254 = dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (ptr_108254) ;
                                          cPtr_typeGalgasUndefinedSortedListType * operand_108273 = dynamic_cast <cPtr_typeGalgasUndefinedSortedListType *> (ptr_108273) ;
                                          if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                                            if (((operand_108254->mListTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2720))) != (operand_108273->mListTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2720)))).isBuiltAndTrue ()) {
                                              var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting the sorted list type '@")) + (operand_108254->mListTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2721))))) + (GGS_string (true, "', I have got the sorted list type '@")))) + (operand_108273->mListTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2722))))) + (GGS_string (true, "\""))) SOURCE_FILE_AT_LINE (2723)) ;
                                            }
                                          }else{
                                            cPtr_typeGalgasUndefinedMapType * operand_108254 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_108254) ;
                                            cPtr_typeGalgasUndefinedMapType * operand_108273 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_108273) ;
                                            if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                                              if (((operand_108254->mMapTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2726))) != (operand_108273->mMapTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2726)))).isBuiltAndTrue ()) {
                                                var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting the map type '@")) + (operand_108254->mMapTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2727))))) + (GGS_string (true, "', I have got the map type '@")))) + (operand_108273->mMapTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2728))))) + (GGS_string (true, "\""))) SOURCE_FILE_AT_LINE (2729)) ;
                                              }
                                            }else{
                                              cPtr_typeGalgasUndefinedClassType * operand_108254 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_108254) ;
                                              cPtr_typeGalgasClassType * operand_108273 = dynamic_cast <cPtr_typeGalgasClassType *> (ptr_108273) ;
                                              if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                                                GGS_bool var_cas_accept ;
                                                var_cas_accept = (operand_108254->mClassTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2733))) == (operand_108273->mClassTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2733))) ;
                                                if (((((! (var_cas_accept))) & (var_cas_inAcceptPolymorphism))).isBuiltAndTrue ()) {
                                                  var_cas_accept = operand_108273->mAncestorClassesMap.reader_hasKey (_inLexique, operand_108254->mClassTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2735)) SOURCE_FILE_AT_LINE (2735)) ;
                                                }
                                                if (((! (var_cas_accept))).isBuiltAndTrue ()) {
                                                  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting the class type '@")) + (operand_108254->mClassTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2738))))) + (GGS_string (true, "', I have got the class type '@")))) + (operand_108273->mClassTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2739))))) + (GGS_string (true, "\""))) SOURCE_FILE_AT_LINE (2740)) ;
                                                }
                                              }else{
                                                cPtr_typeGalgasUndefinedClassType * operand_108254 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_108254) ;
                                                cPtr_typeGalgasUndefinedClassType * operand_108273 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_108273) ;
                                                if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                                                  if (((operand_108254->mClassTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2743))) != (operand_108273->mClassTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2743)))).isBuiltAndTrue ()) {
                                                    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting the class type '@")) + (operand_108254->mClassTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2744))))) + (GGS_string (true, "', I have got the class type '@")))) + (operand_108273->mClassTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2745))))) + (GGS_string (true, "\""))) SOURCE_FILE_AT_LINE (2746)) ;
                                                  }
                                                }else{
                                                  cPtr_typeGalgasUndefinedExternType * operand_108254 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_108254) ;
                                                  cPtr_typeGalgasUndefinedExternType * operand_108273 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_108273) ;
                                                  if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                                                    if (((operand_108254->mGalgasClassName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2750))) != (operand_108273->mGalgasClassName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2750)))).isBuiltAndTrue ()) {
                                                      var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting an extern variable of extern '@")) + (operand_108254->mGalgasClassName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2751))))) + (GGS_string (true, "' type variable, and I got an extern '@")))) + (operand_108273->mGalgasClassName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2752))))) + (GGS_string (true, "' type variable"))) SOURCE_FILE_AT_LINE (2753)) ;
                                                    }
                                                  }else{
                                                    cPtr_typeGalgas_enum * operand_108254 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_108254) ;
                                                    cPtr_typeGalgas_enum * operand_108273 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_108273) ;
                                                    if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                                                      if (((operand_108254->mEnumTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2757))) != (operand_108273->mEnumTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2757)))).isBuiltAndTrue ()) {
                                                        var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting an enum variable of  '@")) + (operand_108254->mEnumTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2758))))) + (GGS_string (true, "' type variable, and I got an enum '@")))) + (operand_108273->mEnumTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2759))))) + (GGS_string (true, "' type variable"))) SOURCE_FILE_AT_LINE (2760)) ;
                                                      }
                                                    }else{
                                                      cPtr_typeGalgas_entityInInstruction * operand_108254 = dynamic_cast <cPtr_typeGalgas_entityInInstruction *> (ptr_108254) ;
                                                      cPtr_typeGalgas_entityInInstruction * operand_108273 = dynamic_cast <cPtr_typeGalgas_entityInInstruction *> (ptr_108273) ;
                                                      if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                                                        if (((operand_108254->mEntityName) != (operand_108273->mEntityName)).isBuiltAndTrue ()) {
                                                          var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting an entity instance of  '@")) + (operand_108254->mEntityName))) + (GGS_string (true, "' type variable, and I got an entity instance of type '@")))) + (operand_108273->mEntityName))) + (GGS_string (true, "'"))) SOURCE_FILE_AT_LINE (2767)) ;
                                                        }
                                                      }else{
                                                        cPtr_typeGalgas_mapIndexInInstruction * operand_108254 = dynamic_cast <cPtr_typeGalgas_mapIndexInInstruction *> (ptr_108254) ;
                                                        cPtr_typeGalgas_mapIndexInInstruction * operand_108273 = dynamic_cast <cPtr_typeGalgas_mapIndexInInstruction *> (ptr_108273) ;
                                                        if ((operand_108254 != NULL) && (operand_108273 != NULL)) {
                                                          if (((operand_108254->mMapTypeName) != (operand_108273->mMapTypeName)).isBuiltAndTrue ()) {
                                                            var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting a map index of  '")) + (operand_108254->mMapTypeName))) + (GGS_string (true, "' map property, and I got a map index of '")))) + (operand_108273->mMapTypeName))) + (GGS_string (true, "' map property"))) SOURCE_FILE_AT_LINE (2774)) ;
                                                          }
                                                        }else{
                                                          var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((var_cas_inFormalType.reader_messageGalgasType (_inLexique SOURCE_FILE_AT_LINE (2777))) + (GGS_string (true, " is not compatible with ")))) + (var_cas_inEffectiveType.reader_messageGalgasType (_inLexique SOURCE_FILE_AT_LINE (2777)))) SOURCE_FILE_AT_LINE (2778)) ;
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkAssignmentTypesCompatibility\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of routine "verifierCompatibiliteSignatures"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteSignatures (C_Lexique & _inLexique,
                                const GGS_L_EXsignature  & var_cas_signatureReference,
                                const GGS_L_EXsignature  & var_cas_signatureTestee,
                                const GGS_location  & var_cas_ouSignalerErreur COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_verifierCompatibiliteSignatures at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (((var_cas_signatureReference.reader_length (_inLexique SOURCE_FILE_AT_LINE (2792))) < (var_cas_signatureTestee.reader_length (_inLexique SOURCE_FILE_AT_LINE (2792)))).isBuiltAndTrue ()) {
    var_cas_ouSignalerErreur.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "there are too much parameters") SOURCE_FILE_AT_LINE (2794)) ;
  }else if (((var_cas_signatureReference.reader_length (_inLexique SOURCE_FILE_AT_LINE (2794))) > (var_cas_signatureTestee.reader_length (_inLexique SOURCE_FILE_AT_LINE (2794)))).isBuiltAndTrue ()) {
    var_cas_ouSignalerErreur.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more parameters missing") SOURCE_FILE_AT_LINE (2796)) ;
  }else{
    GGS_L_EXsignature::element_type * operand_114023 = var_cas_signatureReference.firstObject () ;
    GGS_L_EXsignature::element_type * operand_114118 = var_cas_signatureTestee.firstObject () ;
    while ((operand_114023 != NULL)
        && (operand_114118 != NULL)) {
      macroValidPointer (operand_114023) ;
      macroValidPointer (operand_114118) ;
      ::routine_checkAssignmentTypesCompatibility (_inLexique,  operand_114023->mType,  operand_114118->mType,  var_cas_ouSignalerErreur,  GGS_bool (true, false) SOURCE_FILE_AT_LINE (2799)) ;
      if (((operand_114023->mFormalArgumentPassingMode) != (operand_114118->mFormalArgumentPassingMode)).isBuiltAndTrue ()) {
        var_cas_ouSignalerErreur.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((operand_114118->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique SOURCE_FILE_AT_LINE (2806))) + (GGS_string (true, " is not compatible with ")))) + (operand_114118->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique SOURCE_FILE_AT_LINE (2807)))) SOURCE_FILE_AT_LINE (2808)) ;
      }
      operand_114023 = operand_114023->nextObject () ;
      operand_114118 = operand_114118->nextObject () ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_verifierCompatibiliteSignatures\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'M_cli_options'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_cli_options::
elementOf_GGS_M_cli_options (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_cli_options & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_cli_options::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mOptionChar.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mOptionString.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mComment.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDefaultValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_cli_options::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_cli_options * _p = dynamic_cast <const elementOf_GGS_M_cli_options *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mOptionChar == _p->mInfo.mOptionChar).boolValue ()
           && (mInfo.mOptionString == _p->mInfo.mOptionString).boolValue ()
           && (mInfo.mComment == _p->mInfo.mComment).boolValue ()
           && (mInfo.mDefaultValue == _p->mInfo.mDefaultValue).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_cli_options::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_cli_options *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_cli_options * info = (e_M_cli_options *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_cli_options result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_cli_options::
operator == (const GGS_M_cli_options & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_cli_options::
operator != (const GGS_M_cli_options & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lchar & inParameter0,
                const GGS_lstring & inParameter1,
                const GGS_lstring & inParameter2,
                const GGS_uint & inParameter3,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inParameter3._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_cli_options info  ;
    info.mOptionChar = inParameter0 ;
    info.mOptionString = inParameter1 ;
    info.mComment = inParameter2 ;
    info.mDefaultValue = inParameter3 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lchar   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_uint   & outParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    outParameter3._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mOptionChar ;
    outParameter1 = node->mInfo.mOptionString ;
    outParameter2 = node->mInfo.mComment ;
    outParameter3 = node->mInfo.mDefaultValue ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lchar   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_lstring   & outParameter2,
                                GGS_uint   & outParameter3 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' command line option is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_cli_options::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lchar & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_lstring & inParameter2,
                                const GGS_uint & inParameter3 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' command line option has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_cli_options & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_cli_options result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_cli_options GGS_M_cli_options::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_cli_options result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_cli_options::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_cli_options " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'M_optionComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_optionComponents::
elementOf_GGS_M_optionComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_optionComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_optionComponents::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mBoolOptionsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mUintOptionsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mStringOptionsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_optionComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_optionComponents * _p = dynamic_cast <const elementOf_GGS_M_optionComponents *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mBoolOptionsMap == _p->mInfo.mBoolOptionsMap).boolValue ()
           && (mInfo.mUintOptionsMap == _p->mInfo.mUintOptionsMap).boolValue ()
           && (mInfo.mStringOptionsMap == _p->mInfo.mStringOptionsMap).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_optionComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_optionComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_optionComponents * info = (e_M_optionComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_optionComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_optionComponents::
operator == (const GGS_M_optionComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_optionComponents::
operator != (const GGS_M_optionComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_cli_options & inParameter0,
                const GGS_M_cli_options & inParameter1,
                const GGS_M_cli_options & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_optionComponents info  ;
    info.mBoolOptionsMap = inParameter0 ;
    info.mUintOptionsMap = inParameter1 ;
    info.mStringOptionsMap = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_cli_options   & outParameter0,
               GGS_M_cli_options   & outParameter1,
               GGS_M_cli_options   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mBoolOptionsMap ;
    outParameter1 = node->mInfo.mUintOptionsMap ;
    outParameter2 = node->mInfo.mStringOptionsMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_cli_options   & outParameter0,
                                GGS_M_cli_options   & outParameter1,
                                GGS_M_cli_options   & outParameter2 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no '%K' option component",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_optionComponents::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_cli_options & inParameter0,
                                const GGS_M_cli_options & inParameter1,
                                const GGS_M_cli_options & inParameter2 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' option component named is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_optionComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_optionComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_optionComponents GGS_M_optionComponents::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_optionComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_optionComponents::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_optionComponents " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'M_grammarComponents'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_grammarComponents::
elementOf_GGS_M_grammarComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_grammarComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_grammarComponents::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mNonterminalSymbolParametersMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mLexiqueName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mOptionsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_grammarComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_grammarComponents * _p = dynamic_cast <const elementOf_GGS_M_grammarComponents *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mNonterminalSymbolParametersMap == _p->mInfo.mNonterminalSymbolParametersMap).boolValue ()
           && (mInfo.mLexiqueName == _p->mInfo.mLexiqueName).boolValue ()
           && (mInfo.mOptionsMap == _p->mInfo.mOptionsMap).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_grammarComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_grammarComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_grammarComponents * info = (e_M_grammarComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_grammarComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_grammarComponents::
operator == (const GGS_M_grammarComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_grammarComponents::
operator != (const GGS_M_grammarComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0,
                const GGS_lstring & inParameter1,
                const GGS_M_optionComponents & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_grammarComponents info  ;
    info.mNonterminalSymbolParametersMap = inParameter0 ;
    info.mLexiqueName = inParameter1 ;
    info.mOptionsMap = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_M_optionComponents   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonterminalSymbolParametersMap ;
    outParameter1 = node->mInfo.mLexiqueName ;
    outParameter2 = node->mInfo.mOptionsMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAltsForGrammar   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_M_optionComponents   & outParameter2 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' grammar component is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_grammarComponents::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAltsForGrammar & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_M_optionComponents & inParameter2 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' grammar component has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_grammarComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_grammarComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_grammarComponents GGS_M_grammarComponents::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_grammarComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_grammarComponents::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_grammarComponents " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'M_semanticsComponents'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_semanticsComponents::
elementOf_GGS_M_semanticsComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_semanticsComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_semanticsComponents::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mModelMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mActionMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mImportedSemanticsComponents.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mImportedMetamodelComponents.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mImportedOptionsComponents.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mOptionsComponents.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSemanticsEntitiesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_semanticsComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_semanticsComponents * _p = dynamic_cast <const elementOf_GGS_M_semanticsComponents *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mModelMap == _p->mInfo.mModelMap).boolValue ()
           && (mInfo.mActionMap == _p->mInfo.mActionMap).boolValue ()
           && (mInfo.mImportedSemanticsComponents == _p->mInfo.mImportedSemanticsComponents).boolValue ()
           && (mInfo.mImportedMetamodelComponents == _p->mInfo.mImportedMetamodelComponents).boolValue ()
           && (mInfo.mImportedOptionsComponents == _p->mInfo.mImportedOptionsComponents).boolValue ()
           && (mInfo.mOptionsComponents == _p->mInfo.mOptionsComponents).boolValue ()
           && (mInfo.mSemanticsEntitiesMap == _p->mInfo.mSemanticsEntitiesMap).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_semanticsComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_semanticsComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_semanticsComponents * info = (e_M_semanticsComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_semanticsComponents::
operator == (const GGS_M_semanticsComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_semanticsComponents::
operator != (const GGS_M_semanticsComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_ModelMap & inParameter0,
                const GGS_ActionMap & inParameter1,
                const GGS_stringset & inParameter2,
                const GGS_stringset & inParameter3,
                const GGS_stringset & inParameter4,
                const GGS_M_optionComponents & inParameter5,
                const GGS_M_semanticsEntitiesForUse & inParameter6,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inParameter3._isBuilt ()
   && inParameter4._isBuilt ()
   && inParameter5._isBuilt ()
   && inParameter6._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_semanticsComponents info  ;
    info.mModelMap = inParameter0 ;
    info.mActionMap = inParameter1 ;
    info.mImportedSemanticsComponents = inParameter2 ;
    info.mImportedMetamodelComponents = inParameter3 ;
    info.mImportedOptionsComponents = inParameter4 ;
    info.mOptionsComponents = inParameter5 ;
    info.mSemanticsEntitiesMap = inParameter6 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_ModelMap   & outParameter0,
               GGS_ActionMap   & outParameter1,
               GGS_stringset   & outParameter2,
               GGS_stringset   & outParameter3,
               GGS_stringset   & outParameter4,
               GGS_M_optionComponents   & outParameter5,
               GGS_M_semanticsEntitiesForUse   & outParameter6,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    outParameter3._drop_operation () ;
    outParameter4._drop_operation () ;
    outParameter5._drop_operation () ;
    outParameter6._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mModelMap ;
    outParameter1 = node->mInfo.mActionMap ;
    outParameter2 = node->mInfo.mImportedSemanticsComponents ;
    outParameter3 = node->mInfo.mImportedMetamodelComponents ;
    outParameter4 = node->mInfo.mImportedOptionsComponents ;
    outParameter5 = node->mInfo.mOptionsComponents ;
    outParameter6 = node->mInfo.mSemanticsEntitiesMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_ModelMap   & outParameter0,
                                GGS_ActionMap   & outParameter1,
                                GGS_stringset   & outParameter2,
                                GGS_stringset   & outParameter3,
                                GGS_stringset   & outParameter4,
                                GGS_M_optionComponents   & outParameter5,
                                GGS_M_semanticsEntitiesForUse   & outParameter6 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no semantics component named '%K'",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  outParameter5,
                  outParameter6,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_semanticsComponents::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_ModelMap & inParameter0,
                                const GGS_ActionMap & inParameter1,
                                const GGS_stringset & inParameter2,
                                const GGS_stringset & inParameter3,
                                const GGS_stringset & inParameter4,
                                const GGS_M_optionComponents & inParameter5,
                                const GGS_M_semanticsEntitiesForUse & inParameter6 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a semantics component named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_semanticsComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_semanticsComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_semanticsComponents GGS_M_semanticsComponents::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_semanticsComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_semanticsComponents::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_semanticsComponents " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'M_metamodelsComponents'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_metamodelsComponents::
elementOf_GGS_M_metamodelsComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_metamodelsComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_metamodelsComponents::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mRootEntity.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mEntityMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMultiReferencedEntities.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_metamodelsComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_metamodelsComponents * _p = dynamic_cast <const elementOf_GGS_M_metamodelsComponents *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mRootEntity == _p->mInfo.mRootEntity).boolValue ()
           && (mInfo.mEntityMap == _p->mInfo.mEntityMap).boolValue ()
           && (mInfo.mMultiReferencedEntities == _p->mInfo.mMultiReferencedEntities).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_metamodelsComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_metamodelsComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_metamodelsComponents * info = (e_M_metamodelsComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_metamodelsComponents GGS_M_metamodelsComponents::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_metamodelsComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_metamodelsComponents::
operator == (const GGS_M_metamodelsComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_metamodelsComponents::
operator != (const GGS_M_metamodelsComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                const GGS_entityToImplementMap & inParameter1,
                const GGS_stringset & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_metamodelsComponents info  ;
    info.mRootEntity = inParameter0 ;
    info.mEntityMap = inParameter1 ;
    info.mMultiReferencedEntities = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_entityToImplementMap   & outParameter1,
               GGS_stringset   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mRootEntity ;
    outParameter1 = node->mInfo.mEntityMap ;
    outParameter2 = node->mInfo.mMultiReferencedEntities ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_entityToImplementMap   & outParameter1,
                                GGS_stringset   & outParameter2 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no metamodel component named '%K'",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_metamodelsComponents::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_entityToImplementMap & inParameter1,
                                const GGS_stringset & inParameter2 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a metamodel component named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_metamodelsComponents GGS_M_metamodelsComponents::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_metamodelsComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_metamodelsComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_metamodelsComponents GGS_M_metamodelsComponents::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_metamodelsComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_metamodelsComponents::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_metamodelsComponents " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'M_constraintComponents'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_constraintComponents::
elementOf_GGS_M_constraintComponents (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_constraintComponents & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_constraintComponents::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMetamodel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_constraintComponents::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_constraintComponents * _p = dynamic_cast <const elementOf_GGS_M_constraintComponents *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mMetamodel == _p->mInfo.mMetamodel).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_constraintComponents::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_constraintComponents *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_constraintComponents * info = (e_M_constraintComponents *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_constraintComponents GGS_M_constraintComponents::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_constraintComponents result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_constraintComponents::
operator == (const GGS_M_constraintComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_constraintComponents::
operator != (const GGS_M_constraintComponents & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_constraintComponents::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_constraintComponents::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_constraintComponents info  ;
    info.mMetamodel = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_constraintComponents::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMetamodel ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_constraintComponents::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no constraint component named '%K'",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_constraintComponents::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "a constraint component named '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_constraintComponents GGS_M_constraintComponents::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_constraintComponents & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_constraintComponents result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_constraintComponents GGS_M_constraintComponents::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_constraintComponents result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_constraintComponents::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_constraintComponents " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@L_nibAndClassList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_nibAndClassList::
elementOf_GGS_L_nibAndClassList (const GGS_lstring & argument_0):
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_nibAndClassList::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_nibAndClassList * _p = dynamic_cast <const elementOf_GGS_L_nibAndClassList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mValue == _p->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_nibAndClassList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@L_nibAndClassList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_nibAndClassList::GGS_L_nibAndClassList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_nibAndClassList::
GGS_L_nibAndClassList (const GGS_L_nibAndClassList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_nibAndClassList::
operator == (const GGS_L_nibAndClassList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_nibAndClassList::
operator != (const GGS_L_nibAndClassList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nibAndClassList::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nibAndClassList::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nibAndClassList::
_addAssign_operation (const GGS_lstring & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_nibAndClassList GGS_L_nibAndClassList::
operator + (const GGS_L_nibAndClassList & inOperand) const {
  GGS_L_nibAndClassList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_nibAndClassList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mValue ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_nibAndClassList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nibAndClassList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mValue) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_nibAndClassList  GGS_L_nibAndClassList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_nibAndClassList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_nibAndClassList  GGS_L_nibAndClassList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_nibAndClassList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_nibAndClassList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_nibAndClassList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nibAndClassList::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mValue ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nibAndClassList::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mValue ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nibAndClassList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mValue ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nibAndClassList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mValue ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "handleStringReaderCall"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleStringReaderCall (C_Lexique & _inLexique,
                                const GGS_lstring  & var_cas_inMethodName,
                                GGS_typeListeAttributsSemantiques  & var_cas_outAccessorTypesList,
                                GGS_AC_galgasType  & var_cas_outReturnedType COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_handleStringReaderCall at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2921))) == (GGS_string (true, "length"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2924))) == (GGS_string (true, "capacity"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2927))) == (GGS_string (true, "fileExists"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2930))) == (GGS_string (true, "characterAtIndex"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE), GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outReturnedType = GGS_typeGalgas_char::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2934))) == (GGS_string (true, "pathExtension"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2937))) == (GGS_string (true, "lastPathComponent"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2940))) == (GGS_string (true, "stringByDeletingPathExtension"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2943))) == (GGS_string (true, "stringByCapitalizingFirstCharacter"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2946))) == (GGS_string (true, "firstCharacterOrNul"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outReturnedType = GGS_typeGalgas_char::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2949))) == (GGS_string (true, "stringByDeletingLastPathComponent"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2952))) == (GGS_string (true, "stringByReplacingStringByString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_outReturnedType, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
    var_cas_outAccessorTypesList._addAssign_operation (var_cas_outReturnedType, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2957))) == (GGS_string (true, "uppercaseString"))).isBuiltAndTrue ()) {
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
    var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
  }else{
    var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (2963)) ;
    var_cas_outAccessorTypesList._drop_operation () ;
    var_cas_outReturnedType._drop_operation () ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_handleStringReaderCall\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of routine "handleReaderCall"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_handleReaderCall (C_Lexique & _inLexique,
                                const GGS_AC_galgasType  & var_cas_inReceiverType,
                                const GGS_lstring  & var_cas_inMethodName,
                                GGS_typeListeAttributsSemantiques  & var_cas_outAccessorTypesList,
                                GGS_AC_galgasType  & var_cas_outReturnedType,
                                GGS_string & var_cas_outCppConversionMethod COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_handleReaderCall at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outCppConversionMethod = GGS_string (true, "") ;
  if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2980))) == (GGS_string (true, "description"))).isBuiltAndTrue ()) {
    var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
  }else{
    if (var_cas_inReceiverType._isBuilt ()) {
      cPtr_typeGalgas_string * operand_123749 = dynamic_cast <cPtr_typeGalgas_string *> (var_cas_inReceiverType.getPtr ()) ;
      if (operand_123749 != NULL) {
        macroValidPointer (operand_123749) ; 
        ::routine_handleStringReaderCall (_inLexique,  var_cas_inMethodName,  var_cas_outAccessorTypesList,  var_cas_outReturnedType SOURCE_FILE_AT_LINE (2986)) ;
      }else{
        cPtr_typeGalgas_lstring * operand_123867 = dynamic_cast <cPtr_typeGalgas_lstring *> (var_cas_inReceiverType.getPtr ()) ;
        if (operand_123867 != NULL) {
          macroValidPointer (operand_123867) ; 
          if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2988))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
            var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2991))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
            var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
          }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (2994))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
            var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
          }else{
            ::routine_handleStringReaderCall (_inLexique,  var_cas_inMethodName,  var_cas_outAccessorTypesList,  var_cas_outReturnedType SOURCE_FILE_AT_LINE (2997)) ;
            var_cas_outCppConversionMethod = GGS_string (true, "ggs_string") ;
          }
        }else{
          cPtr_typeGalgas_location * operand_124648 = dynamic_cast <cPtr_typeGalgas_location *> (var_cas_inReceiverType.getPtr ()) ;
          if (operand_124648 != NULL) {
            macroValidPointer (operand_124648) ; 
            if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3002))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
              var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
            }else{
              var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3008)) ;
              var_cas_outAccessorTypesList._drop_operation () ;
              var_cas_outReturnedType._drop_operation () ;
            }
          }else{
            cPtr_typeGalgas_uint * operand_125007 = dynamic_cast <cPtr_typeGalgas_uint *> (var_cas_inReceiverType.getPtr ()) ;
            if (operand_125007 != NULL) {
              macroValidPointer (operand_125007) ; 
              if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3010))) == (GGS_string (true, "sint"))).isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                var_cas_outReturnedType = GGS_typeGalgas_sint::constructor_new (_inLexique COMMA_HERE) ;
              }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3013))) == (GGS_string (true, "uint64"))).isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                var_cas_outReturnedType = GGS_typeGalgas_uint64::constructor_new (_inLexique COMMA_HERE) ;
              }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3016))) == (GGS_string (true, "sint64"))).isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                var_cas_outReturnedType = GGS_typeGalgas_sint64::constructor_new (_inLexique COMMA_HERE) ;
              }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3019))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
              }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3022))) == (GGS_string (true, "hexString"))).isBuiltAndTrue ()) {
                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
              }else{
                var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3028)) ;
                var_cas_outAccessorTypesList._drop_operation () ;
                var_cas_outReturnedType._drop_operation () ;
              }
            }else{
              cPtr_typeGalgas_char * operand_126081 = dynamic_cast <cPtr_typeGalgas_char *> (var_cas_inReceiverType.getPtr ()) ;
              if (operand_126081 != NULL) {
                macroValidPointer (operand_126081) ; 
                if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3030))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                  var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                }else{
                  var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3036)) ;
                  var_cas_outAccessorTypesList._drop_operation () ;
                  var_cas_outReturnedType._drop_operation () ;
                }
              }else{
                cPtr_typeGalgas_uint64 * operand_126428 = dynamic_cast <cPtr_typeGalgas_uint64 *> (var_cas_inReceiverType.getPtr ()) ;
                if (operand_126428 != NULL) {
                  macroValidPointer (operand_126428) ; 
                  if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3038))) == (GGS_string (true, "sint64"))).isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                    var_cas_outReturnedType = GGS_typeGalgas_sint64::constructor_new (_inLexique COMMA_HERE) ;
                  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3041))) == (GGS_string (true, "sint"))).isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                    var_cas_outReturnedType = GGS_typeGalgas_sint::constructor_new (_inLexique COMMA_HERE) ;
                  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3044))) == (GGS_string (true, "uint"))).isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                    var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
                  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3047))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                    var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3050))) == (GGS_string (true, "hexString"))).isBuiltAndTrue ()) {
                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                    var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                  }else{
                    var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3056)) ;
                    var_cas_outAccessorTypesList._drop_operation () ;
                    var_cas_outReturnedType._drop_operation () ;
                  }
                }else{
                  cPtr_typeGalgas_sint * operand_127500 = dynamic_cast <cPtr_typeGalgas_sint *> (var_cas_inReceiverType.getPtr ()) ;
                  if (operand_127500 != NULL) {
                    macroValidPointer (operand_127500) ; 
                    if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3058))) == (GGS_string (true, "uint"))).isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                      var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
                    }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3061))) == (GGS_string (true, "uint64"))).isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                      var_cas_outReturnedType = GGS_typeGalgas_uint64::constructor_new (_inLexique COMMA_HERE) ;
                    }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3064))) == (GGS_string (true, "sint64"))).isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                      var_cas_outReturnedType = GGS_typeGalgas_sint64::constructor_new (_inLexique COMMA_HERE) ;
                    }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3067))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                      var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                    }else{
                      var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3073)) ;
                      var_cas_outAccessorTypesList._drop_operation () ;
                      var_cas_outReturnedType._drop_operation () ;
                    }
                  }else{
                    cPtr_typeGalgas_sint64 * operand_128389 = dynamic_cast <cPtr_typeGalgas_sint64 *> (var_cas_inReceiverType.getPtr ()) ;
                    if (operand_128389 != NULL) {
                      macroValidPointer (operand_128389) ; 
                      if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3075))) == (GGS_string (true, "uint64"))).isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                        var_cas_outReturnedType = GGS_typeGalgas_uint64::constructor_new (_inLexique COMMA_HERE) ;
                      }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3078))) == (GGS_string (true, "uint"))).isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                        var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
                      }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3081))) == (GGS_string (true, "sint"))).isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                        var_cas_outReturnedType = GGS_typeGalgas_sint::constructor_new (_inLexique COMMA_HERE) ;
                      }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3084))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                        var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                      }else{
                        var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3090)) ;
                        var_cas_outAccessorTypesList._drop_operation () ;
                        var_cas_outReturnedType._drop_operation () ;
                      }
                    }else{
                      cPtr_typeGalgas_lchar * operand_129276 = dynamic_cast <cPtr_typeGalgas_lchar *> (var_cas_inReceiverType.getPtr ()) ;
                      if (operand_129276 != NULL) {
                        macroValidPointer (operand_129276) ; 
                        if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3092))) == (GGS_string (true, "char"))).isBuiltAndTrue ()) {
                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                          var_cas_outReturnedType = GGS_typeGalgas_char::constructor_new (_inLexique COMMA_HERE) ;
                        }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3095))) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
                          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, GGS_string (true, "in GALGAS 1.4.1 and later, the 'value' reader of @lchar type  is deprecated; use 'char' instead") SOURCE_FILE_AT_LINE (3096)) ;
                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                          var_cas_outReturnedType = GGS_typeGalgas_char::constructor_new (_inLexique COMMA_HERE) ;
                        }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3099))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                          var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
                        }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3102))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                          var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                        }else{
                          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3108)) ;
                          var_cas_outAccessorTypesList._drop_operation () ;
                          var_cas_outReturnedType._drop_operation () ;
                        }
                      }else{
                        cPtr_typeGalgas_lbool * operand_130304 = dynamic_cast <cPtr_typeGalgas_lbool *> (var_cas_inReceiverType.getPtr ()) ;
                        if (operand_130304 != NULL) {
                          macroValidPointer (operand_130304) ; 
                          if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3110))) == (GGS_string (true, "bool"))).isBuiltAndTrue ()) {
                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                            var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new (_inLexique COMMA_HERE) ;
                          }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3113))) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
                            var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, GGS_string (true, "in GALGAS 1.4.1 and later, the 'value' reader of @lbool type  is deprecated; use 'bool' instead") SOURCE_FILE_AT_LINE (3114)) ;
                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                            var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new (_inLexique COMMA_HERE) ;
                          }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3117))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                            var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
                          }else{
                            var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3123)) ;
                            var_cas_outAccessorTypesList._drop_operation () ;
                            var_cas_outReturnedType._drop_operation () ;
                          }
                        }else{
                          cPtr_typeGalgas_luint * operand_131142 = dynamic_cast <cPtr_typeGalgas_luint *> (var_cas_inReceiverType.getPtr ()) ;
                          if (operand_131142 != NULL) {
                            macroValidPointer (operand_131142) ; 
                            if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3125))) == (GGS_string (true, "uint"))).isBuiltAndTrue ()) {
                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                              var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
                            }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3128))) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
                              var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, GGS_string (true, "in GALGAS 1.4.1 and later, the 'value' of @luint type  reader is deprecated; use 'uint' instead") SOURCE_FILE_AT_LINE (3129)) ;
                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                              var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
                            }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3132))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                              var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
                            }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3135))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                              var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                            }else{
                              var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3141)) ;
                              var_cas_outAccessorTypesList._drop_operation () ;
                              var_cas_outReturnedType._drop_operation () ;
                            }
                          }else{
                            cPtr_typeGalgas_luint64 * operand_132169 = dynamic_cast <cPtr_typeGalgas_luint64 *> (var_cas_inReceiverType.getPtr ()) ;
                            if (operand_132169 != NULL) {
                              macroValidPointer (operand_132169) ; 
                              if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3143))) == (GGS_string (true, "uint64"))).isBuiltAndTrue ()) {
                                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                var_cas_outReturnedType = GGS_typeGalgas_uint64::constructor_new (_inLexique COMMA_HERE) ;
                              }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3146))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
                                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
                              }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3149))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
                                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                              }else{
                                var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3155)) ;
                                var_cas_outAccessorTypesList._drop_operation () ;
                                var_cas_outReturnedType._drop_operation () ;
                              }
                            }else{
                              cPtr_typeGalgas_lsint * operand_132894 = dynamic_cast <cPtr_typeGalgas_lsint *> (var_cas_inReceiverType.getPtr ()) ;
                              if (operand_132894 != NULL) {
                                macroValidPointer (operand_132894) ; 
                                if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3157))) == (GGS_string (true, "sint"))).isBuiltAndTrue ()) {
                                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                  var_cas_outReturnedType = GGS_typeGalgas_sint::constructor_new (_inLexique COMMA_HERE) ;
                                }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3160))) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
                                  var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, GGS_string (true, "in GALGAS 1.4.1 and later, the 'value' reader of @lsint type  is deprecated; use 'sint' instead") SOURCE_FILE_AT_LINE (3161)) ;
                                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                  var_cas_outReturnedType = GGS_typeGalgas_sint::constructor_new (_inLexique COMMA_HERE) ;
                                }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3164))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
                                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                  var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                                }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3167))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
                                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                  var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
                                }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3170))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
                                  var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                  var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                                }else{
                                  var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3176)) ;
                                  var_cas_outAccessorTypesList._drop_operation () ;
                                  var_cas_outReturnedType._drop_operation () ;
                                }
                              }else{
                                cPtr_typeGalgas_lsint64 * operand_134104 = dynamic_cast <cPtr_typeGalgas_lsint64 *> (var_cas_inReceiverType.getPtr ()) ;
                                if (operand_134104 != NULL) {
                                  macroValidPointer (operand_134104) ; 
                                  if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3178))) == (GGS_string (true, "sint64"))).isBuiltAndTrue ()) {
                                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                    var_cas_outReturnedType = GGS_typeGalgas_sint64::constructor_new (_inLexique COMMA_HERE) ;
                                  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3181))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
                                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                    var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                                  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3184))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
                                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                    var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
                                  }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3187))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
                                    var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                    var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                                  }else{
                                    var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3193)) ;
                                    var_cas_outAccessorTypesList._drop_operation () ;
                                    var_cas_outReturnedType._drop_operation () ;
                                  }
                                }else{
                                  cPtr_typeGalgas_ldouble * operand_135012 = dynamic_cast <cPtr_typeGalgas_ldouble *> (var_cas_inReceiverType.getPtr ()) ;
                                  if (operand_135012 != NULL) {
                                    macroValidPointer (operand_135012) ; 
                                    if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3195))) == (GGS_string (true, "double"))).isBuiltAndTrue ()) {
                                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                      var_cas_outReturnedType = GGS_typeGalgas_double::constructor_new (_inLexique COMMA_HERE) ;
                                    }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3198))) == (GGS_string (true, "value"))).isBuiltAndTrue ()) {
                                      var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, GGS_string (true, "in GALGAS 1.4.1 and later, the 'value' reader of @ldouble type  is deprecated; use 'double' instead") SOURCE_FILE_AT_LINE (3199)) ;
                                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                      var_cas_outReturnedType = GGS_typeGalgas_double::constructor_new (_inLexique COMMA_HERE) ;
                                    }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3202))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
                                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                      var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                                    }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3205))) == (GGS_string (true, "location"))).isBuiltAndTrue ()) {
                                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                      var_cas_outReturnedType = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
                                    }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3208))) == (GGS_string (true, "locationString"))).isBuiltAndTrue ()) {
                                      var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                      var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                                    }else{
                                      var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3214)) ;
                                      var_cas_outAccessorTypesList._drop_operation () ;
                                      var_cas_outReturnedType._drop_operation () ;
                                    }
                                  }else{
                                    cPtr_typeGalgasListType * operand_136234 = dynamic_cast <cPtr_typeGalgasListType *> (var_cas_inReceiverType.getPtr ()) ;
                                    if (operand_136234 != NULL) {
                                      macroValidPointer (operand_136234) ; 
                                      if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3216))) == (GGS_string (true, "length"))).isBuiltAndTrue ()) {
                                        var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                        var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
                                      }else{
                                        var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "list supports only 'length' reader call") SOURCE_FILE_AT_LINE (3222)) ;
                                        var_cas_outAccessorTypesList._drop_operation () ;
                                        var_cas_outReturnedType._drop_operation () ;
                                      }
                                    }else{
                                      cPtr_typeGalgasSortedListType * operand_136600 = dynamic_cast <cPtr_typeGalgasSortedListType *> (var_cas_inReceiverType.getPtr ()) ;
                                      if (operand_136600 != NULL) {
                                        macroValidPointer (operand_136600) ; 
                                        if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3224))) == (GGS_string (true, "length"))).isBuiltAndTrue ()) {
                                          var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                          var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
                                        }else{
                                          var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "sorted list supports only 'length' reader call") SOURCE_FILE_AT_LINE (3230)) ;
                                          var_cas_outAccessorTypesList._drop_operation () ;
                                          var_cas_outReturnedType._drop_operation () ;
                                        }
                                      }else{
                                        cPtr_typeGalgasMapType * operand_136979 = dynamic_cast <cPtr_typeGalgasMapType *> (var_cas_inReceiverType.getPtr ()) ;
                                        if (operand_136979 != NULL) {
                                          macroValidPointer (operand_136979) ; 
                                          if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3232))) == (GGS_string (true, "hasKey"))).isBuiltAndTrue ()) {
                                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                            GGS_AC_galgasType  var_cas_keyType ;
                                            var_cas_keyType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                                            var_cas_outAccessorTypesList._addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
                                            var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new (_inLexique COMMA_HERE) ;
                                          }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3237))) == (GGS_string (true, "count"))).isBuiltAndTrue ()) {
                                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                            var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
                                          }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3240))) == (GGS_string (true, "allKeys"))).isBuiltAndTrue ()) {
                                            var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                            var_cas_outReturnedType = GGS_typeGalgas_stringset::constructor_new (_inLexique COMMA_HERE) ;
                                          }else{
                                            var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3246)) ;
                                            var_cas_outAccessorTypesList._drop_operation () ;
                                            var_cas_outReturnedType._drop_operation () ;
                                          }
                                        }else{
                                          cPtr_typeGalgas_stringset * operand_137824 = dynamic_cast <cPtr_typeGalgas_stringset *> (var_cas_inReceiverType.getPtr ()) ;
                                          if (operand_137824 != NULL) {
                                            macroValidPointer (operand_137824) ; 
                                            if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3248))) == (GGS_string (true, "hasKey"))).isBuiltAndTrue ()) {
                                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                              GGS_AC_galgasType  var_cas_keyType ;
                                              var_cas_keyType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                                              var_cas_outAccessorTypesList._addAssign_operation (var_cas_keyType, GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE)) ;
                                              var_cas_outReturnedType = GGS_typeGalgas_bool::constructor_new (_inLexique COMMA_HERE) ;
                                            }else if (((var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3253))) == (GGS_string (true, "count"))).isBuiltAndTrue ()) {
                                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                              var_cas_outReturnedType = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
                                            }else{
                                              var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined") SOURCE_FILE_AT_LINE (3259)) ;
                                              var_cas_outAccessorTypesList._drop_operation () ;
                                              var_cas_outReturnedType._drop_operation () ;
                                            }
                                          }else{
                                            cPtr_typeGalgasClassType * operand_138483 = dynamic_cast <cPtr_typeGalgasClassType *> (var_cas_inReceiverType.getPtr ()) ;
                                            if (operand_138483 != NULL) {
                                              macroValidPointer (operand_138483) ; 
                                              var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                                              var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                              if (((! (operand_138483->mMessagesMap.reader_hasKey (_inLexique, var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3263)) SOURCE_FILE_AT_LINE (3263))))).isBuiltAndTrue ()) {
                                                GGS_bool var_cas_found ;
                                                var_cas_found = GGS_bool (true, false) ;
                                                GGS_typeListeAttributsSemantiques::element_type * operand_138913 = operand_138483->mNonExternAttributesList.firstObject () ;
                                                while ((operand_138913 != NULL)
                                                    && ((! (var_cas_found)).isBuiltAndTrue ())) {
                                                  macroValidPointer (operand_138913) ;
                                                  var_cas_outReturnedType = operand_138913->mAttributType ;
                                                  var_cas_found = (var_cas_inMethodName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3268))) == (operand_138913->aNomAttribut.reader_string (_inLexique SOURCE_FILE_AT_LINE (3268))) ;
                                                  operand_138913 = operand_138913->nextObject () ;
                                                }
                                                if (((! (var_cas_found))).isBuiltAndTrue ()) {
                                                  var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "this reader is not defined (you can name as class reader class attributes and class messages)") SOURCE_FILE_AT_LINE (3272)) ;
                                                }
                                              }
                                            }else{
                                              cPtr_typeGalgas_enum * operand_139314 = dynamic_cast <cPtr_typeGalgas_enum *> (var_cas_inReceiverType.getPtr ()) ;
                                              if (operand_139314 != NULL) {
                                                macroValidPointer (operand_139314) ; 
                                                GGS_L_lstringList  automatic_var_0 ;
                                                if (operand_139314->mMessagesMap._isBuilt ()) {
                                                  operand_139314->mMessagesMap (HERE)->method_searchKey (_inLexique, var_cas_inMethodName, automatic_var_0 SOURCE_FILE_AT_LINE (3275)) ;
                                                }
                                                var_cas_outAccessorTypesList = GGS_typeListeAttributsSemantiques::constructor_emptyList (_inLexique COMMA_HERE) ;
                                                var_cas_outReturnedType = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
                                              }else{ // Else part
                                                var_cas_inMethodName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "variables of this type do not support reader call") SOURCE_FILE_AT_LINE (3282)) ;
                                                var_cas_outAccessorTypesList._drop_operation () ;
                                                var_cas_outReturnedType._drop_operation () ;
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_handleReaderCall\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "importSemanticsComponent"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_importSemanticsComponent (C_Lexique & _inLexique,
                                GGS_M_semanticsComponents  & var_cas_ioSemanticsComponentsMap,
                                GGS_M_metamodelsComponents  & var_cas_ioMetamodelComponentMap,
                                GGS_ModelMap  & var_cas_ioModelMap,
                                GGS_ActionMap  & var_cas_ioActionMap,
                                GGS_stringset  & var_cas_ioAlreadyImportedSemanticsComponents,
                                GGS_stringset  & var_cas_ioAlreadyImportedMetamodelComponents,
                                GGS_lstring   var_cas_inSemanticsComponentName COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_importSemanticsComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (((! (var_cas_ioAlreadyImportedSemanticsComponents.reader_hasKey (_inLexique, var_cas_inSemanticsComponentName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3309)) SOURCE_FILE_AT_LINE (3309))))).isBuiltAndTrue ()) {
    GGS_ModelMap  var_cas_modelMap ;
    GGS_ActionMap  var_cas_actionMap ;
    GGS_stringset  var_cas_importedSemanticsComponents ;
    GGS_stringset  var_cas_importedMetamodelComponents ;
    GGS_stringset  var_cas_importedOptionsComponents ;
    GGS_M_optionComponents  automatic_var_1 ;
    GGS_M_semanticsEntitiesForUse  automatic_var_2 ;
    if (var_cas_ioSemanticsComponentsMap._isBuilt ()) {
      var_cas_ioSemanticsComponentsMap (HERE)->method_searchKey (_inLexique, var_cas_inSemanticsComponentName, var_cas_modelMap, var_cas_actionMap, var_cas_importedSemanticsComponents, var_cas_importedMetamodelComponents, var_cas_importedOptionsComponents, automatic_var_1, automatic_var_2 SOURCE_FILE_AT_LINE (3315)) ;
    }
    var_cas_ioAlreadyImportedMetamodelComponents = ((var_cas_ioAlreadyImportedMetamodelComponents) | (var_cas_importedMetamodelComponents)) ;
    GGS_stringset::element_type * operand_141473 = var_cas_importedSemanticsComponents.firstObject () ;
    while ((operand_141473 != NULL)) {
      macroValidPointer (operand_141473) ;
      ::routine_importSemanticsComponent (_inLexique,  var_cas_ioSemanticsComponentsMap,  var_cas_ioMetamodelComponentMap,  var_cas_ioModelMap,  var_cas_ioActionMap,  var_cas_ioAlreadyImportedSemanticsComponents,  var_cas_ioAlreadyImportedMetamodelComponents,  GGS_lstring::constructor_new (_inLexique, operand_141473->mKey, GGS_location (_inLexique) COMMA_HERE) SOURCE_FILE_AT_LINE (3329)) ;
      operand_141473 = operand_141473->nextObject () ;
    }
    GGS_ModelMap::element_type * operand_141836 = var_cas_modelMap.firstObject () ;
    while ((operand_141836 != NULL)) {
      macroValidPointer (operand_141836) ;
      if (((! (var_cas_ioModelMap.reader_hasKey (_inLexique, operand_141836->mKey.reader_string (_inLexique SOURCE_FILE_AT_LINE (3341)) SOURCE_FILE_AT_LINE (3341))))).isBuiltAndTrue ()) {
        var_cas_ioModelMap.modifier_insertKey (_inLexique, operand_141836->mKey, operand_141836->mInfo.mType SOURCE_FILE_AT_LINE (3342)) ;
      }
      operand_141836 = operand_141836->nextObject () ;
    }
    GGS_ActionMap::element_type * operand_142046 = var_cas_actionMap.firstObject () ;
    while ((operand_142046 != NULL)) {
      macroValidPointer (operand_142046) ;
      if (((! (var_cas_ioActionMap.reader_hasKey (_inLexique, operand_142046->mKey.reader_string (_inLexique SOURCE_FILE_AT_LINE (3347)) SOURCE_FILE_AT_LINE (3347))))).isBuiltAndTrue ()) {
        var_cas_ioActionMap.modifier_insertKey (_inLexique, operand_142046->mKey, operand_142046->mInfo.mSignature, operand_142046->mInfo.mIsExtern SOURCE_FILE_AT_LINE (3348)) ;
      }
      operand_142046 = operand_142046->nextObject () ;
    }
    var_cas_ioAlreadyImportedSemanticsComponents._addAssign_operation (var_cas_inSemanticsComponentName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3352))) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_importSemanticsComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of routine "computeRepresentativeEntityName"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_computeRepresentativeEntityName (C_Lexique & _inLexique,
                                const GGS_entityToImplementMap  & var_cas_inMetamodelEntityMap,
                                const GGS_entityToImplementMap  & var_cas_inConstrainedEntityMap,
                                const GGS_lstring  & var_cas_inEntityName,
                                GGS_lstring  & var_cas_outRepresentativeEntityName COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_computeRepresentativeEntityName at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outRepresentativeEntityName = GGS_lstring::constructor_new (_inLexique, GGS_string (true, ""), GGS_location (_inLexique) COMMA_HERE) ;
  GGS_lstring  var_cas_searchedEntity ;
  var_cas_searchedEntity = var_cas_inEntityName ;
  GGS_uint _variant_143219 = var_cas_inMetamodelEntityMap.reader_count (_inLexique SOURCE_FILE_AT_LINE (3366))._add_operation (_inLexique, GGS_uint (true, 1U) SOURCE_FILE_AT_LINE (3366)) ;
  GGS_bool _condition_143219 (_variant_143219._isBuilt (), true) ;
  while (_condition_143219.isBuiltAndTrue ()) {
    _condition_143219 = (((var_cas_outRepresentativeEntityName.reader_string (_inLexique SOURCE_FILE_AT_LINE (3367))) == (GGS_string (true, ""))) & ((var_cas_searchedEntity.reader_string (_inLexique SOURCE_FILE_AT_LINE (3367))) != (GGS_string (true, "")))) ;
    if (_condition_143219.isBuiltAndTrue ()) {
      if (_variant_143219.uintValue () == 0) {
        _inLexique.onTheFlyRunTimeError ("loop variant error" SOURCE_FILE_AT_LINE (3375)) ;
        _condition_143219 = GGS_bool (true, false) ;
      }else{
        _variant_143219._decrement_operation (_inLexique COMMA_HERE) ;
        if ((var_cas_inConstrainedEntityMap.reader_hasKey (_inLexique, var_cas_searchedEntity.reader_string (_inLexique SOURCE_FILE_AT_LINE (3368)) SOURCE_FILE_AT_LINE (3368))).isBuiltAndTrue ()) {
          var_cas_outRepresentativeEntityName = var_cas_searchedEntity ;
        }else{
          GGS_lstring  var_cas_superEntity ;
          GGS_entityPropertyMap  automatic_var_3 ;
          GGS_bool automatic_var_4 ;
          GGS_entityPropertyMap  automatic_var_5 ;
          GGS_entityPropertyMap  automatic_var_6 ;
          GGS_stringset  automatic_var_7 ;
          GGS_entityPropertyMap  automatic_var_8 ;
          GGS_entityPropertyMap  automatic_var_9 ;
          if (var_cas_inMetamodelEntityMap._isBuilt ()) {
            var_cas_inMetamodelEntityMap (HERE)->method_searchKey (_inLexique, var_cas_searchedEntity, automatic_var_3, automatic_var_4, automatic_var_5, var_cas_superEntity, automatic_var_6, automatic_var_7, automatic_var_8, automatic_var_9 SOURCE_FILE_AT_LINE (3372)) ;
          }
          var_cas_searchedEntity = var_cas_superEntity ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_computeRepresentativeEntityName\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_loggableObject'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_loggableObject::
cPtr_loggableObject (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_loggableObject * GGS_loggableObject::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_loggableObject::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@loggableObject:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_loggableObject'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_loggableObject::
GGS_loggableObject (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_loggableObject::
GGS_loggableObject (const GGS_loggableObject & inOperand) {
  mPointer = (cPtr_loggableObject *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loggableObject::
~GGS_loggableObject (void) {
  macroDetachPointer (mPointer, cPtr_loggableObject) ;
}

//---------------------------------------------------------------------------*

void GGS_loggableObject::
operator = (const GGS_loggableObject & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_loggableObject::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_loggableObject) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_loggableObject::
operator == (const GGS_loggableObject & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_loggableObject::
operator != (const GGS_loggableObject & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_loggableObject::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @loggableObject" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_loggableMetamodel'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_loggableMetamodel::
cPtr_loggableMetamodel (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_loggableObject (THERE),
mMetamodelName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_loggableMetamodel * GGS_loggableMetamodel::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loggableMetamodel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_loggableMetamodel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_loggableMetamodel::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_loggableMetamodel * _p = dynamic_cast <const cPtr_loggableMetamodel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMetamodelName == _p->mMetamodelName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_loggableMetamodel::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@loggableMetamodel:"
           << mMetamodelName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_loggableMetamodel'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_loggableMetamodel::
GGS_loggableMetamodel (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_loggableMetamodel::
GGS_loggableMetamodel (const GGS_loggableMetamodel & inOperand)
:GGS_loggableObject () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loggableMetamodel::
~GGS_loggableMetamodel (void) {
  macroDetachPointer (mPointer, cPtr_loggableMetamodel) ;
}

//---------------------------------------------------------------------------*

void GGS_loggableMetamodel::
operator = (const GGS_loggableMetamodel & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loggableMetamodel GGS_loggableMetamodel::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_loggableMetamodel * _ptr = (cPtr_loggableMetamodel *) NULL ;
  macroMyNew (_ptr, cPtr_loggableMetamodel (argument_0 COMMA_THERE)) ;
  GGS_loggableMetamodel result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_loggableMetamodel::
reader_mMetamodelName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loggableMetamodel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loggableMetamodel *) mPointer)->mMetamodelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_loggableMetamodel::
operator == (const GGS_loggableMetamodel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_loggableMetamodel::
operator != (const GGS_loggableMetamodel & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_loggableMetamodel::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @loggableMetamodel" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_loggableAttribute'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_loggableAttribute::
cPtr_loggableAttribute (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_loggableObject (THERE),
mAttributeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_loggableAttribute * GGS_loggableAttribute::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loggableAttribute *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_loggableAttribute *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_loggableAttribute::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_loggableAttribute * _p = dynamic_cast <const cPtr_loggableAttribute *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mAttributeName == _p->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_loggableAttribute::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@loggableAttribute:"
           << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_loggableAttribute'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_loggableAttribute::
GGS_loggableAttribute (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_loggableAttribute::
GGS_loggableAttribute (const GGS_loggableAttribute & inOperand)
:GGS_loggableObject () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loggableAttribute::
~GGS_loggableAttribute (void) {
  macroDetachPointer (mPointer, cPtr_loggableAttribute) ;
}

//---------------------------------------------------------------------------*

void GGS_loggableAttribute::
operator = (const GGS_loggableAttribute & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loggableAttribute GGS_loggableAttribute::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_loggableAttribute * _ptr = (cPtr_loggableAttribute *) NULL ;
  macroMyNew (_ptr, cPtr_loggableAttribute (argument_0 COMMA_THERE)) ;
  GGS_loggableAttribute result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_loggableAttribute::
reader_mAttributeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loggableAttribute *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loggableAttribute *) mPointer)->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_loggableAttribute::
operator == (const GGS_loggableAttribute & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_loggableAttribute::
operator != (const GGS_loggableAttribute & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_loggableAttribute::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @loggableAttribute" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_loggableConstraint'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_loggableConstraint::
cPtr_loggableConstraint (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_loggableObject (THERE),
mMetamodelName (argument_0),
mConstraintName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_loggableConstraint * GGS_loggableConstraint::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loggableConstraint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_loggableConstraint *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_loggableConstraint::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_loggableConstraint * _p = dynamic_cast <const cPtr_loggableConstraint *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMetamodelName == _p->mMetamodelName).boolValue ()
         && (mConstraintName == _p->mConstraintName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_loggableConstraint::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@loggableConstraint:"
           << mMetamodelName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstraintName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_loggableConstraint'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_loggableConstraint::
GGS_loggableConstraint (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_loggableConstraint::
GGS_loggableConstraint (const GGS_loggableConstraint & inOperand)
:GGS_loggableObject () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loggableConstraint::
~GGS_loggableConstraint (void) {
  macroDetachPointer (mPointer, cPtr_loggableConstraint) ;
}

//---------------------------------------------------------------------------*

void GGS_loggableConstraint::
operator = (const GGS_loggableConstraint & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loggableConstraint GGS_loggableConstraint::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_loggableConstraint * _ptr = (cPtr_loggableConstraint *) NULL ;
  macroMyNew (_ptr, cPtr_loggableConstraint (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_loggableConstraint result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_loggableConstraint::
reader_mMetamodelName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loggableConstraint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loggableConstraint *) mPointer)->mMetamodelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_loggableConstraint::
reader_mConstraintName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loggableConstraint *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loggableConstraint *) mPointer)->mConstraintName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_loggableConstraint::
operator == (const GGS_loggableConstraint & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_loggableConstraint::
operator != (const GGS_loggableConstraint & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_loggableConstraint::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @loggableConstraint" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@loggableObjectList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_loggableObjectList::
elementOf_GGS_loggableObjectList (const GGS_loggableObject & argument_0):
mLoggableObject (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_loggableObjectList::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_loggableObjectList * _p = dynamic_cast <const elementOf_GGS_loggableObjectList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLoggableObject == _p->mLoggableObject).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_loggableObjectList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLoggableObject.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@loggableObjectList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_loggableObjectList::GGS_loggableObjectList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_loggableObjectList::
GGS_loggableObjectList (const GGS_loggableObjectList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_loggableObjectList::
operator == (const GGS_loggableObjectList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_loggableObjectList::
operator != (const GGS_loggableObjectList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_loggableObjectList::
_internalAppendValues (const GGS_loggableObject & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_loggableObjectList::
_internalPrependValues (const GGS_loggableObject & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_loggableObjectList::
_addAssign_operation (const GGS_loggableObject & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_loggableObjectList GGS_loggableObjectList::
operator + (const GGS_loggableObjectList & inOperand) const {
  GGS_loggableObjectList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_loggableObjectList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_loggableObject  p_0 = p->mLoggableObject ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_loggableObjectList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_loggableObject & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_loggableObjectList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLoggableObject) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_loggableObjectList  GGS_loggableObjectList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_loggableObjectList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_loggableObjectList  GGS_loggableObjectList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_loggableObject & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_loggableObjectList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_loggableObjectList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@loggableObjectList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_loggableObjectList::
method_first (C_Lexique & _inLexique,
              GGS_loggableObject & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLoggableObject ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_loggableObjectList::
method_last (C_Lexique & _inLexique,
             GGS_loggableObject & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLoggableObject ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_loggableObjectList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_loggableObject & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLoggableObject ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_loggableObjectList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_loggableObject & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLoggableObject ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_grammarDescriptorForProgram'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_grammarDescriptorForProgram::
elementOf_GGS_L_grammarDescriptorForProgram (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_signature & argument_2,
                                const GGS_L_lstringList & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_lstring & argument_6,
                                const GGS_L_lstringList & argument_7,
                                const GGS_lstring & argument_8,
                                const GGS_string& argument_9,
                                const GGS_M_optionComponents & argument_10,
                                const GGS_loggableObjectList & argument_11):
mGrammarPostfix (argument_0),
mGrammarName (argument_1),
mStartSymbolSignature (argument_2),
mStartSymbolAttributesList (argument_3),
mLexiqueClassName (argument_4),
mReturnedMetamodelName (argument_5),
mReturnedRootEntityName (argument_6),
mConstraintsForMetamodel (argument_7),
mSourceExtension (argument_8),
mHelpMessage (argument_9),
mOptionsComponentsMap (argument_10),
mLoggableObjectList (argument_11) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_grammarDescriptorForProgram::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_grammarDescriptorForProgram * _p = dynamic_cast <const elementOf_GGS_L_grammarDescriptorForProgram *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mGrammarPostfix == _p->mGrammarPostfix).boolValue ()
         && (mGrammarName == _p->mGrammarName).boolValue ()
         && (mStartSymbolSignature == _p->mStartSymbolSignature).boolValue ()
         && (mStartSymbolAttributesList == _p->mStartSymbolAttributesList).boolValue ()
         && (mLexiqueClassName == _p->mLexiqueClassName).boolValue ()
         && (mReturnedMetamodelName == _p->mReturnedMetamodelName).boolValue ()
         && (mReturnedRootEntityName == _p->mReturnedRootEntityName).boolValue ()
         && (mConstraintsForMetamodel == _p->mConstraintsForMetamodel).boolValue ()
         && (mSourceExtension == _p->mSourceExtension).boolValue ()
         && (mHelpMessage == _p->mHelpMessage).boolValue ()
         && (mOptionsComponentsMap == _p->mOptionsComponentsMap).boolValue ()
         && (mLoggableObjectList == _p->mLoggableObjectList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_grammarDescriptorForProgram::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGrammarPostfix.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGrammarName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStartSymbolSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStartSymbolAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexiqueClassName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedMetamodelName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedRootEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstraintsForMetamodel.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceExtension.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHelpMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionsComponentsMap.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLoggableObjectList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_grammarDescriptorForProgram'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::GGS_L_grammarDescriptorForProgram (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::
GGS_L_grammarDescriptorForProgram (const GGS_L_grammarDescriptorForProgram & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_grammarDescriptorForProgram::
operator == (const GGS_L_grammarDescriptorForProgram & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_grammarDescriptorForProgram::
operator != (const GGS_L_grammarDescriptorForProgram & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
_internalAppendValues (const GGS_string& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_L_signature & argument_2,
                    const GGS_L_lstringList & argument_3,
                    const GGS_lstring & argument_4,
                    const GGS_lstring & argument_5,
                    const GGS_lstring & argument_6,
                    const GGS_L_lstringList & argument_7,
                    const GGS_lstring & argument_8,
                    const GGS_string& argument_9,
                    const GGS_M_optionComponents & argument_10,
                    const GGS_loggableObjectList & argument_11) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10,
                                argument_11)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
_internalPrependValues (const GGS_string& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_L_signature & argument_2,
                    const GGS_L_lstringList & argument_3,
                    const GGS_lstring & argument_4,
                    const GGS_lstring & argument_5,
                    const GGS_lstring & argument_6,
                    const GGS_L_lstringList & argument_7,
                    const GGS_lstring & argument_8,
                    const GGS_string& argument_9,
                    const GGS_M_optionComponents & argument_10,
                    const GGS_loggableObjectList & argument_11) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10,
                                argument_11)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
_addAssign_operation (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_signature & argument_2,
                                const GGS_L_lstringList & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_lstring & argument_6,
                                const GGS_L_lstringList & argument_7,
                                const GGS_lstring & argument_8,
                                const GGS_string& argument_9,
                                const GGS_M_optionComponents & argument_10,
                                const GGS_loggableObjectList & argument_11) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10,
                                argument_11) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram GGS_L_grammarDescriptorForProgram::
operator + (const GGS_L_grammarDescriptorForProgram & inOperand) const {
  GGS_L_grammarDescriptorForProgram result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_grammarDescriptorForProgram * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mGrammarPostfix ;
          GGS_lstring  p_1 = p->mGrammarName ;
          GGS_L_signature  p_2 = p->mStartSymbolSignature ;
          GGS_L_lstringList  p_3 = p->mStartSymbolAttributesList ;
          GGS_lstring  p_4 = p->mLexiqueClassName ;
          GGS_lstring  p_5 = p->mReturnedMetamodelName ;
          GGS_lstring  p_6 = p->mReturnedRootEntityName ;
          GGS_L_lstringList  p_7 = p->mConstraintsForMetamodel ;
          GGS_lstring  p_8 = p->mSourceExtension ;
          GGS_string p_9 = p->mHelpMessage ;
          GGS_M_optionComponents  p_10 = p->mOptionsComponentsMap ;
          GGS_loggableObjectList  p_11 = p->mLoggableObjectList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_10, p_11) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_L_signature & argument_2,
                     const GGS_L_lstringList & argument_3,
                     const GGS_lstring & argument_4,
                     const GGS_lstring & argument_5,
                     const GGS_lstring & argument_6,
                     const GGS_L_lstringList & argument_7,
                     const GGS_lstring & argument_8,
                     const GGS_string& argument_9,
                     const GGS_M_optionComponents & argument_10,
                     const GGS_loggableObjectList & argument_11
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10,
                                argument_11) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mGrammarPostfix,
                                _p->mGrammarName,
                                _p->mStartSymbolSignature,
                                _p->mStartSymbolAttributesList,
                                _p->mLexiqueClassName,
                                _p->mReturnedMetamodelName,
                                _p->mReturnedRootEntityName,
                                _p->mConstraintsForMetamodel,
                                _p->mSourceExtension,
                                _p->mHelpMessage,
                                _p->mOptionsComponentsMap,
                                _p->mLoggableObjectList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram  GGS_L_grammarDescriptorForProgram::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_grammarDescriptorForProgram result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram  GGS_L_grammarDescriptorForProgram::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_string& argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_L_signature & argument_2,
                           const GGS_L_lstringList & argument_3,
                           const GGS_lstring & argument_4,
                           const GGS_lstring & argument_5,
                           const GGS_lstring & argument_6,
                           const GGS_L_lstringList & argument_7,
                           const GGS_lstring & argument_8,
                           const GGS_string& argument_9,
                           const GGS_M_optionComponents & argument_10,
                           const GGS_loggableObjectList & argument_11
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_grammarDescriptorForProgram result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6, argument_7, argument_8, argument_9, argument_10, argument_11) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_grammarDescriptorForProgram::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_grammarDescriptorForProgram", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
method_first (C_Lexique & _inLexique,
              GGS_string& _out_0,
              GGS_lstring & _out_1,
              GGS_L_signature & _out_2,
              GGS_L_lstringList & _out_3,
              GGS_lstring & _out_4,
              GGS_lstring & _out_5,
              GGS_lstring & _out_6,
              GGS_L_lstringList & _out_7,
              GGS_lstring & _out_8,
              GGS_string& _out_9,
              GGS_M_optionComponents & _out_10,
              GGS_loggableObjectList & _out_11
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mGrammarPostfix ;
    _out_1 = _p->mGrammarName ;
    _out_2 = _p->mStartSymbolSignature ;
    _out_3 = _p->mStartSymbolAttributesList ;
    _out_4 = _p->mLexiqueClassName ;
    _out_5 = _p->mReturnedMetamodelName ;
    _out_6 = _p->mReturnedRootEntityName ;
    _out_7 = _p->mConstraintsForMetamodel ;
    _out_8 = _p->mSourceExtension ;
    _out_9 = _p->mHelpMessage ;
    _out_10 = _p->mOptionsComponentsMap ;
    _out_11 = _p->mLoggableObjectList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
    _out_5._drop_operation () ;
    _out_6._drop_operation () ;
    _out_7._drop_operation () ;
    _out_8._drop_operation () ;
    _out_9._drop_operation () ;
    _out_10._drop_operation () ;
    _out_11._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
method_last (C_Lexique & _inLexique,
             GGS_string& _out_0,
             GGS_lstring & _out_1,
             GGS_L_signature & _out_2,
             GGS_L_lstringList & _out_3,
             GGS_lstring & _out_4,
             GGS_lstring & _out_5,
             GGS_lstring & _out_6,
             GGS_L_lstringList & _out_7,
             GGS_lstring & _out_8,
             GGS_string& _out_9,
             GGS_M_optionComponents & _out_10,
             GGS_loggableObjectList & _out_11
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mGrammarPostfix ;
    _out_1 = _p->mGrammarName ;
    _out_2 = _p->mStartSymbolSignature ;
    _out_3 = _p->mStartSymbolAttributesList ;
    _out_4 = _p->mLexiqueClassName ;
    _out_5 = _p->mReturnedMetamodelName ;
    _out_6 = _p->mReturnedRootEntityName ;
    _out_7 = _p->mConstraintsForMetamodel ;
    _out_8 = _p->mSourceExtension ;
    _out_9 = _p->mHelpMessage ;
    _out_10 = _p->mOptionsComponentsMap ;
    _out_11 = _p->mLoggableObjectList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
    _out_5._drop_operation () ;
    _out_6._drop_operation () ;
    _out_7._drop_operation () ;
    _out_8._drop_operation () ;
    _out_9._drop_operation () ;
    _out_10._drop_operation () ;
    _out_11._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_string& _out_0,
                 GGS_lstring & _out_1,
                 GGS_L_signature & _out_2,
                 GGS_L_lstringList & _out_3,
                 GGS_lstring & _out_4,
                 GGS_lstring & _out_5,
                 GGS_lstring & _out_6,
                 GGS_L_lstringList & _out_7,
                 GGS_lstring & _out_8,
                 GGS_string& _out_9,
                 GGS_M_optionComponents & _out_10,
                 GGS_loggableObjectList & _out_11
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mGrammarPostfix ;
    _out_1 = _p->mGrammarName ;
    _out_2 = _p->mStartSymbolSignature ;
    _out_3 = _p->mStartSymbolAttributesList ;
    _out_4 = _p->mLexiqueClassName ;
    _out_5 = _p->mReturnedMetamodelName ;
    _out_6 = _p->mReturnedRootEntityName ;
    _out_7 = _p->mConstraintsForMetamodel ;
    _out_8 = _p->mSourceExtension ;
    _out_9 = _p->mHelpMessage ;
    _out_10 = _p->mOptionsComponentsMap ;
    _out_11 = _p->mLoggableObjectList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
    _out_5._drop_operation () ;
    _out_6._drop_operation () ;
    _out_7._drop_operation () ;
    _out_8._drop_operation () ;
    _out_9._drop_operation () ;
    _out_10._drop_operation () ;
    _out_11._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
modifier_popLast (C_Lexique & _inLexique,
                GGS_string& _out_0,
                GGS_lstring & _out_1,
                GGS_L_signature & _out_2,
                GGS_L_lstringList & _out_3,
                GGS_lstring & _out_4,
                GGS_lstring & _out_5,
                GGS_lstring & _out_6,
                GGS_L_lstringList & _out_7,
                GGS_lstring & _out_8,
                GGS_string& _out_9,
                GGS_M_optionComponents & _out_10,
                GGS_loggableObjectList & _out_11
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mGrammarPostfix ;
    _out_1 = _p->mGrammarName ;
    _out_2 = _p->mStartSymbolSignature ;
    _out_3 = _p->mStartSymbolAttributesList ;
    _out_4 = _p->mLexiqueClassName ;
    _out_5 = _p->mReturnedMetamodelName ;
    _out_6 = _p->mReturnedRootEntityName ;
    _out_7 = _p->mConstraintsForMetamodel ;
    _out_8 = _p->mSourceExtension ;
    _out_9 = _p->mHelpMessage ;
    _out_10 = _p->mOptionsComponentsMap ;
    _out_11 = _p->mLoggableObjectList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
    _out_5._drop_operation () ;
    _out_6._drop_operation () ;
    _out_7._drop_operation () ;
    _out_8._drop_operation () ;
    _out_9._drop_operation () ;
    _out_10._drop_operation () ;
    _out_11._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

