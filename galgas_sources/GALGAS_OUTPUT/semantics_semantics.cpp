//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semantics_semantics.cpp'                       *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 1st, 2006, at 20h23'13"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semantics_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "semantics_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeCplusPlusName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCplusPlusName::
cPtr_typeCplusPlusName (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCplusPlusName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (void) {
  mPointer = (cPtr_typeCplusPlusName *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (const GGS_typeCplusPlusName & inOperand) {
  mPointer = (cPtr_typeCplusPlusName *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
~GGS_typeCplusPlusName (void) {
  macroDetachPointer (mPointer, cPtr_typeCplusPlusName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName::
operator = (const GGS_typeCplusPlusName & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName::
operator = (cPtr_typeCplusPlusName * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (cPtr_typeCplusPlusName * inSource) {
  mPointer = (cPtr_typeCplusPlusName *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCplusPlusName * GGS_typeCplusPlusName
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCplusPlusName) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCplusPlusName
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeCplusPlusName" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeDirectName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectName::cPtr_typeDirectName (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectName::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDirectName:" ;
mName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeDirectName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectName * GGS_typeDirectName::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeDirectName * ptr_ = (cPtr_typeDirectName *) NULL ;
    macroMyNew (ptr_, cPtr_typeDirectName (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeCppThisName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCppThisName::cPtr_typeCppThisName (LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCppThisName::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeCppThisName:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeCppThisName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCppThisName * GGS_typeCppThisName::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeCppThisName * ptr_ = (cPtr_typeCppThisName *) NULL ;
    macroMyNew (ptr_, cPtr_typeCppThisName (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeCppInheritedName'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCppInheritedName::cPtr_typeCppInheritedName (LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCppInheritedName::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeCppInheritedName:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCppInheritedName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCppInheritedName * GGS_typeCppInheritedName::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeCppInheritedName * ptr_ = (cPtr_typeCppInheritedName *) NULL ;
    macroMyNew (ptr_, cPtr_typeCppInheritedName (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeAutomaticName'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAutomaticName::cPtr_typeAutomaticName (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAutomaticName::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAutomaticName:" ;
mName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAutomaticName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAutomaticName * GGS_typeAutomaticName::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeAutomaticName * ptr_ = (cPtr_typeAutomaticName *) NULL ;
    macroMyNew (ptr_, cPtr_typeAutomaticName (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLocationAutomaticName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLocationAutomaticName::cPtr_typeLocationAutomaticName (const GGS_location & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLocationAutomaticName::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLocationAutomaticName:" ;
mLocation.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLocationAutomaticName'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLocationAutomaticName * GGS_typeLocationAutomaticName::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_location & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeLocationAutomaticName * ptr_ = (cPtr_typeLocationAutomaticName *) NULL ;
    macroMyNew (ptr_, cPtr_typeLocationAutomaticName (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeOperandName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOperandName::cPtr_typeOperandName (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mName (argument_0),
mLocationOffset (argument_1),
mFieldKind (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeOperandName::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeOperandName:" ;
mName.reader_description  (_inLexique COMMA_THERE) ;
mLocationOffset.reader_description  (_inLexique COMMA_THERE) ;
mFieldKind.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOperandName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOperandName * GGS_typeOperandName::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeOperandName * ptr_ = (cPtr_typeOperandName *) NULL ;
    macroMyNew (ptr_, cPtr_typeOperandName (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeKeyName'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeKeyName::cPtr_typeKeyName (const GGS_location & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mLocationOffset (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeKeyName::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeKeyName:" ;
mLocationOffset.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeKeyName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeKeyName * GGS_typeKeyName::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_location & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeKeyName * ptr_ = (cPtr_typeKeyName *) NULL ;
    macroMyNew (ptr_, cPtr_typeKeyName (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeNullName'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNullName::cPtr_typeNullName (LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeNullName::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeNullName:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeNullName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNullName * GGS_typeNullName::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeNullName * ptr_ = (cPtr_typeNullName *) NULL ;
    macroMyNew (ptr_, cPtr_typeNullName (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@typeCplusPlusNameList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeCplusPlusNameList::
elementOf_GGS_typeCplusPlusNameList (const GGS_typeCplusPlusName & argument_0):
mNextItem (NULL),
mCppName (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeCplusPlusNameList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mCppName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeCplusPlusNameList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::GGS_typeCplusPlusNameList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::~GGS_typeCplusPlusNameList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::
GGS_typeCplusPlusNameList (const GGS_typeCplusPlusNameList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
operator = (const GGS_typeCplusPlusNameList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::element_type * GGS_typeCplusPlusNameList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
internalAppendItem (const GGS_typeCplusPlusName & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCppName) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeCplusPlusNameList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeCplusPlusNameList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeCplusPlusNameList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCplusPlusNameList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeCplusPlusNameList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeCplusPlusNameList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExpression::
cPtr_typeExpression (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (void) {
  mPointer = (cPtr_typeExpression *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (const GGS_typeExpression & inOperand) {
  mPointer = (cPtr_typeExpression *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
~GGS_typeExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpression::
operator = (const GGS_typeExpression & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpression::
operator = (cPtr_typeExpression * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (cPtr_typeExpression * inSource) {
  mPointer = (cPtr_typeExpression *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeExpression * GGS_typeExpression
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeExpression
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeExpression) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeExpression
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeExpression" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'typeClassMessagesMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeClassMessagesMap::
elementOf_GGS_typeClassMessagesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeClassMessagesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeClassMessagesMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mMessage.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassMessagesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeClassMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeClassMessagesMap * info = (e_typeClassMessagesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeClassMessagesMap info  ;
    info.mMessage = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the message '%K' is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the message '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeClassMessagesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassMessagesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeClassMessagesMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeClassMessagesMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeSemanticsTypesList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSemanticsTypesList::
elementOf_GGS_typeSemanticsTypesList (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1):
mNextItem (NULL),
mType (argument_0),
mGalgasVariableName (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSemanticsTypesList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mGalgasVariableName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeSemanticsTypesList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::GGS_typeSemanticsTypesList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::~GGS_typeSemanticsTypesList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::
GGS_typeSemanticsTypesList (const GGS_typeSemanticsTypesList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
operator = (const GGS_typeSemanticsTypesList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::element_type * GGS_typeSemanticsTypesList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mGalgasVariableName) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList  GGS_typeSemanticsTypesList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticsTypesList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeSemanticsTypesList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSemanticsTypesList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeSemanticsTypesList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeSemanticsTypesList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map element 'e_typeVariablesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cGalgasVariablesMap.hh"

//---------------------------------------------------------------------------*

template class cGalgasVariablesMap <e_typeVariablesMap> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Map 'typeVariablesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariablesMap GGS_typeVariablesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeVariablesMap t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadOnlyAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadOnlyAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForDestructiveReadAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive read mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForDestructiveReadAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive read mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadWriteAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadWriteAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForWriteAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForWriteAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertListOfEntitiesLocalVariable (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertListOfEntitiesLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertListOfEntitiesLocalVariableGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertListOfEntitiesLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertSingleEntityLocalVariable (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertSingleEntityLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertSingleEntityLocalVariableGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertSingleEntityLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertEntityAttributeLocalVariable (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertEntityAttributeLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertEntityAttributeLocalVariableGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertEntityAttributeLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUnusedInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUnusedInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUnusedInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertConstInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertConstInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUsedConstInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUsedConstInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUsedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUnusedConstInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUnusedConstInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUnusedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertLocalVariable (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertLocalVariableGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertOutProperty (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertOutProperty (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertOutPropertyGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertOutProperty (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertInOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertInOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUsedInOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUsedInOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUsedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUnusedInOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUnusedInOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUnusedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariablesMap::reader_description (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeVariablesMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_assignedVariables'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_assignedVariables::
elementOf_GGS_L_assignedVariables (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1):
mNextItem (NULL),
aNomVariableCible (argument_0),
aNomAttributSource (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_assignedVariables::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << aNomVariableCible.reader_description  (_inLexique COMMA_THERE) ;
  ioString << aNomAttributSource.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@L_assignedVariables'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_assignedVariables::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables::GGS_L_assignedVariables (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables::~GGS_L_assignedVariables (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables::
GGS_L_assignedVariables (const GGS_L_assignedVariables & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
operator = (const GGS_L_assignedVariables & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables::element_type * GGS_L_assignedVariables::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
internalAppendItem (const GGS_typeCplusPlusName & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aNomVariableCible,
                                p->aNomAttributSource) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_L_assignedVariables::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_assignedVariables result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_assignedVariables::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_assignedVariables::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_assignedVariables" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_assignedVariables::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeCible'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCible::
cPtr_typeCible (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeCible'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (void) {
  mPointer = (cPtr_typeCible *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (const GGS_typeCible & inOperand) {
  mPointer = (cPtr_typeCible *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
~GGS_typeCible (void) {
  macroDetachPointer (mPointer, cPtr_typeCible) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCible::
operator = (const GGS_typeCible & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCible::
operator = (cPtr_typeCible * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (cPtr_typeCible * inSource) {
  mPointer = (cPtr_typeCible *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCible * GGS_typeCible
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeCible
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCible) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCible
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeCible" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@typeListeCibles'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCibles::
elementOf_GGS_typeListeCibles (const GGS_typeCible & argument_0):
mNextItem (NULL),
aCible (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeCibles::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << aCible.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCibles'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeCibles::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles::GGS_typeListeCibles (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles::~GGS_typeListeCibles (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles::
GGS_typeListeCibles (const GGS_typeListeCibles & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
operator = (const GGS_typeListeCibles & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles::element_type * GGS_typeListeCibles::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
internalAppendItem (const GGS_typeCible & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
addAssign_operation (const GGS_typeCible & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aCible) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles  GGS_typeListeCibles::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeCibles result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeListeCibles::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeCibles::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeListeCibles" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeListeCibles::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeListeTypesEtNomsArgMethode'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeTypesEtNomsArgMethode::
elementOf_GGS_typeListeTypesEtNomsArgMethode (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3):
mNextItem (NULL),
mType (argument_0),
mFormalArgumentPassingMode (argument_1),
mCppName (argument_2),
mModeIn (argument_3) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeTypesEtNomsArgMethode::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mFormalArgumentPassingMode.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mCppName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mModeIn.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeTypesEtNomsArgMethode'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::GGS_typeListeTypesEtNomsArgMethode (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::~GGS_typeListeTypesEtNomsArgMethode (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::
GGS_typeListeTypesEtNomsArgMethode (const GGS_typeListeTypesEtNomsArgMethode & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
operator = (const GGS_typeListeTypesEtNomsArgMethode & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::element_type * GGS_typeListeTypesEtNomsArgMethode::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                    const GGS_formalArgumentPassingMode& argument_1,
                    const GGS_typeCplusPlusName & argument_2,
                    const GGS_bool& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mFormalArgumentPassingMode,
                                p->mCppName,
                                p->mModeIn) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_typeListeTypesEtNomsArgMethode::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeTypesEtNomsArgMethode result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeListeTypesEtNomsArgMethode::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeTypesEtNomsArgMethode::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeListeTypesEtNomsArgMethode" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeListeTypesEtNomsArgMethode::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstruction::
cPtr_typeInstruction (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (void) {
  mPointer = (cPtr_typeInstruction *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (const GGS_typeInstruction & inOperand) {
  mPointer = (cPtr_typeInstruction *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
~GGS_typeInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstruction::
operator = (const GGS_typeInstruction & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstruction::
operator = (cPtr_typeInstruction * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (cPtr_typeInstruction * inSource) {
  mPointer = (cPtr_typeInstruction *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstruction * GGS_typeInstruction
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeInstruction
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeInstruction) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstruction
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeInstruction" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeInstructionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeInstructionList::
elementOf_GGS_typeInstructionList (const GGS_typeInstruction & argument_0):
mNextItem (NULL),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeInstructionList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@typeInstructionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList::GGS_typeInstructionList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList::~GGS_typeInstructionList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList::
GGS_typeInstructionList (const GGS_typeInstructionList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
operator = (const GGS_typeInstructionList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList::element_type * GGS_typeInstructionList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
internalAppendItem (const GGS_typeInstruction & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
addAssign_operation (const GGS_typeInstruction & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mInstruction) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeInstructionList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeInstructionList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeInstructionList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeInstructionList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeInstructionList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_nameWithType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_nameWithType::
elementOf_GGS_L_nameWithType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1):
mNextItem (NULL),
mType (argument_0),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_nameWithType::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_nameWithType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_nameWithType::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType::GGS_L_nameWithType (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType::~GGS_L_nameWithType (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType::
GGS_L_nameWithType (const GGS_L_nameWithType & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
operator = (const GGS_L_nameWithType & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType::element_type * GGS_L_nameWithType::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
internalAppendItem (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mName) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType  GGS_L_nameWithType::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_nameWithType result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_nameWithType::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_nameWithType::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_nameWithType" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_nameWithType::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class map element 'e_typeTableMethodesAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cTableMethodesAimplementer.hh"

//---------------------------------------------------------------------------*

template class cTableMethodesAimplementer <e_typeTableMethodesAimplementer> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map 'typeTableMethodesAimplementer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableMethodesAimplementer GGS_typeTableMethodesAimplementer::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodesAimplementer t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::method_insertAbstract (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  insertAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::method_insertAbstractGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  const sint32 index = insertAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::method_insertNotAbstract (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  insertNotAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::method_insertNotAbstractGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  const sint32 index = insertNotAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMethodesAimplementer::reader_description (C_Lexique & /* _inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeTableMethodesAimplementer " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeExpressionList::
elementOf_GGS_typeExpressionList (const GGS_typeExpression & argument_0):
mNextItem (NULL),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeExpressionList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@typeExpressionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExpressionList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList::GGS_typeExpressionList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList::~GGS_typeExpressionList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList::
GGS_typeExpressionList (const GGS_typeExpressionList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
operator = (const GGS_typeExpressionList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList::element_type * GGS_typeExpressionList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
internalAppendItem (const GGS_typeExpression & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
addAssign_operation (const GGS_typeExpression & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mExpression) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeExpressionList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeExpressionList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeExpressionList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeExpressionList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeExpressionList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeExpressionList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@varToDropList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_varToDropList::
elementOf_GGS_varToDropList (const GGS_typeCplusPlusName & argument_0):
mNextItem (NULL),
mVarToDrop (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_varToDropList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mVarToDrop.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@varToDropList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_varToDropList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_varToDropList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList::GGS_varToDropList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList::~GGS_varToDropList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList::
GGS_varToDropList (const GGS_varToDropList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
operator = (const GGS_varToDropList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList::element_type * GGS_varToDropList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
internalAppendItem (const GGS_typeCplusPlusName & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mVarToDrop) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_varToDropList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_varToDropList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_varToDropList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_varToDropList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @varToDropList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_varToDropList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeErrorInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeErrorInstruction::cPtr_typeErrorInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_varToDropList & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mErrorLocationExpression (argument_0),
mErrorMessageExpression (argument_1),
mLocation (argument_2),
mVarToDropList (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_typeErrorInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeErrorInstruction:" ;
mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE) ;
mErrorMessageExpression.reader_description  (_inLexique COMMA_THERE) ;
mLocation.reader_description  (_inLexique COMMA_THERE) ;
mVarToDropList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeErrorInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeErrorInstruction * GGS_typeErrorInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_varToDropList & argument_3 COMMA_LOCATION_ARGS) {
    cPtr_typeErrorInstruction * ptr_ = (cPtr_typeErrorInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeErrorInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeWarningInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeWarningInstruction::cPtr_typeWarningInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mWarningLocationExpression (argument_0),
mWarningMessageExpression (argument_1),
mLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeWarningInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeWarningInstruction:" ;
mWarningLocationExpression.reader_description  (_inLexique COMMA_THERE) ;
mWarningMessageExpression.reader_description  (_inLexique COMMA_THERE) ;
mLocation.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeWarningInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeWarningInstruction * GGS_typeWarningInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeWarningInstruction * ptr_ = (cPtr_typeWarningInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeWarningInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeMessageInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMessageInstruction::cPtr_typeMessageInstruction (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mMessageExpression (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMessageInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMessageInstruction:" ;
mMessageExpression.reader_description  (_inLexique COMMA_THERE) ;
mInstructionLocation.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeMessageInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMessageInstruction * GGS_typeMessageInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeMessageInstruction * ptr_ = (cPtr_typeMessageInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMessageInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeReaderCallInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeReaderCallInstruction::cPtr_typeReaderCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aNomMethodeSimple (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeReaderCallInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeReaderCallInstruction:" ;
aNomCppVariable.reader_description  (_inLexique COMMA_THERE) ;
aNomMethodeSimple.reader_description  (_inLexique COMMA_THERE) ;
mExpressionsList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeReaderCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeReaderCallInstruction * GGS_typeReaderCallInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeReaderCallInstruction * ptr_ = (cPtr_typeReaderCallInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeReaderCallInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeModifierCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModifierCallInstruction::cPtr_typeModifierCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aNomMethodeSimple (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeModifierCallInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeModifierCallInstruction:" ;
aNomCppVariable.reader_description  (_inLexique COMMA_THERE) ;
aNomMethodeSimple.reader_description  (_inLexique COMMA_THERE) ;
mExpressionsList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeModifierCallInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeModifierCallInstruction * GGS_typeModifierCallInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeModifierCallInstruction * ptr_ = (cPtr_typeModifierCallInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeModifierCallInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeInstructionAppelMethodeListe'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelMethodeListe::cPtr_typeInstructionAppelMethodeListe (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppAttribut (argument_0),
aMethodeDeListe (argument_1),
aListeNomsCppArguments (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelMethodeListe::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionAppelMethodeListe:" ;
aNomCppAttribut.reader_description  (_inLexique COMMA_THERE) ;
aMethodeDeListe.reader_description  (_inLexique COMMA_THERE) ;
aListeNomsCppArguments.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelMethodeListe'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelMethodeListe * GGS_typeInstructionAppelMethodeListe::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeInstructionAppelMethodeListe * ptr_ = (cPtr_typeInstructionAppelMethodeListe *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionAppelMethodeListe (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'typeInstructionDeclarationVarLocale'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionDeclarationVarLocale::cPtr_typeInstructionDeclarationVarLocale (const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aTypeVariable (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionDeclarationVarLocale::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionDeclarationVarLocale:" ;
aNomCppVariable.reader_description  (_inLexique COMMA_THERE) ;
aTypeVariable.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeInstructionDeclarationVarLocale'           *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionDeclarationVarLocale * GGS_typeInstructionDeclarationVarLocale::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeInstructionDeclarationVarLocale * ptr_ = (cPtr_typeInstructionDeclarationVarLocale *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionDeclarationVarLocale (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeMapBlockPrologueInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockPrologueInstruction::cPtr_typeMapBlockPrologueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mPrologueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMapBlockPrologueInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMapBlockPrologueInstruction:" ;
aNomVariableTable.reader_description  (_inLexique COMMA_THERE) ;
aNomMethodeBloc.reader_description  (_inLexique COMMA_THERE) ;
mPrologueExpressionList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockPrologueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMapBlockPrologueInstruction * GGS_typeMapBlockPrologueInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeMapBlockPrologueInstruction * ptr_ = (cPtr_typeMapBlockPrologueInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMapBlockPrologueInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeMapBlockEpilogueInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockEpilogueInstruction::cPtr_typeMapBlockEpilogueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mEpilogueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMapBlockEpilogueInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMapBlockEpilogueInstruction:" ;
aNomVariableTable.reader_description  (_inLexique COMMA_THERE) ;
aNomMethodeBloc.reader_description  (_inLexique COMMA_THERE) ;
mEpilogueExpressionList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockEpilogueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMapBlockEpilogueInstruction * GGS_typeMapBlockEpilogueInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeMapBlockEpilogueInstruction * ptr_ = (cPtr_typeMapBlockEpilogueInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMapBlockEpilogueInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeReaderCallInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeReaderCallInExpression::cPtr_typeReaderCallInExpression (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_location & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpressionValue (argument_0),
mReaderName (argument_1),
mExpressionList (argument_2),
mInstructionLocation (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_typeReaderCallInExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeReaderCallInExpression:" ;
mExpressionValue.reader_description  (_inLexique COMMA_THERE) ;
mReaderName.reader_description  (_inLexique COMMA_THERE) ;
mExpressionList.reader_description  (_inLexique COMMA_THERE) ;
mInstructionLocation.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeReaderCallInExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeReaderCallInExpression * GGS_typeReaderCallInExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_location & argument_3 COMMA_LOCATION_ARGS) {
    cPtr_typeReaderCallInExpression * ptr_ = (cPtr_typeReaderCallInExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeReaderCallInExpression (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeAndOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAndOperation::cPtr_typeAndOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAndOperation::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAndOperation:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAndOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAndOperation * GGS_typeAndOperation::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeAndOperation * ptr_ = (cPtr_typeAndOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeAndOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeOrOperation'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOrOperation::cPtr_typeOrOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeOrOperation::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeOrOperation:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOrOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOrOperation * GGS_typeOrOperation::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeOrOperation * ptr_ = (cPtr_typeOrOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeOrOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeXorOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeXorOperation::cPtr_typeXorOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeXorOperation::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeXorOperation:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeXorOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeXorOperation * GGS_typeXorOperation::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeXorOperation * ptr_ = (cPtr_typeXorOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeXorOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeConcatOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConcatOperation::cPtr_typeConcatOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeConcatOperation::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeConcatOperation:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConcatOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConcatOperation * GGS_typeConcatOperation::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeConcatOperation * ptr_ = (cPtr_typeConcatOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeConcatOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeTrueBool'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTrueBool::cPtr_typeTrueBool (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeTrueBool::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeTrueBool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeTrueBool'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTrueBool * GGS_typeTrueBool::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeTrueBool * ptr_ = (cPtr_typeTrueBool *) NULL ;
    macroMyNew (ptr_, cPtr_typeTrueBool (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFalseBool'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFalseBool::cPtr_typeFalseBool (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFalseBool::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFalseBool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFalseBool'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFalseBool * GGS_typeFalseBool::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeFalseBool * ptr_ = (cPtr_typeFalseBool *) NULL ;
    macroMyNew (ptr_, cPtr_typeFalseBool (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeLiteralStringExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralStringExpression::cPtr_typeLiteralStringExpression (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralString (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralStringExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralStringExpression:" ;
mLiteralString.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralStringExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralStringExpression * GGS_typeLiteralStringExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeLiteralStringExpression * ptr_ = (cPtr_typeLiteralStringExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralStringExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralUIntExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralUIntExpression::cPtr_typeLiteralUIntExpression (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralUIntExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralUIntExpression:" ;
mLiteralInt.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralUIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralUIntExpression * GGS_typeLiteralUIntExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeLiteralUIntExpression * ptr_ = (cPtr_typeLiteralUIntExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralUIntExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralSIntExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralSIntExpression::cPtr_typeLiteralSIntExpression (const GGS_lsint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralSIntExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralSIntExpression:" ;
mLiteralInt.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralSIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralSIntExpression * GGS_typeLiteralSIntExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lsint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeLiteralSIntExpression * ptr_ = (cPtr_typeLiteralSIntExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralSIntExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralCharExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralCharExpression::cPtr_typeLiteralCharExpression (const GGS_lchar & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralChar (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralCharExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralCharExpression:" ;
mLiteralChar.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralCharExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralCharExpression * GGS_typeLiteralCharExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lchar & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeLiteralCharExpression * ptr_ = (cPtr_typeLiteralCharExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralCharExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeHereExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeHereExpression::cPtr_typeHereExpression (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeHereExpression::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeHereExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeHereExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeHereExpression * GGS_typeHereExpression::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeHereExpression * ptr_ = (cPtr_typeHereExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeHereExpression (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeConstructorExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConstructorExpression::cPtr_typeConstructorExpression (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mClassName (argument_0),
mClassMethodName (argument_1),
mExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeConstructorExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeConstructorExpression:" ;
mClassName.reader_description  (_inLexique COMMA_THERE) ;
mClassMethodName.reader_description  (_inLexique COMMA_THERE) ;
mExpressionList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeConstructorExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConstructorExpression * GGS_typeConstructorExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeConstructorExpression * ptr_ = (cPtr_typeConstructorExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeConstructorExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeTestComplement'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTestComplement::cPtr_typeTestComplement (const GGS_typeExpression & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mTest (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeTestComplement::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeTestComplement:" ;
mTest.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeTestComplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTestComplement * GGS_typeTestComplement::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeTestComplement * ptr_ = (cPtr_typeTestComplement *) NULL ;
    macroMyNew (ptr_, cPtr_typeTestComplement (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeBoolOption'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeBoolOption::cPtr_typeBoolOption (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeBoolOption::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeBoolOption:" ;
mOptionComponentName.reader_description  (_inLexique COMMA_THERE) ;
mOptionName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeBoolOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeBoolOption * GGS_typeBoolOption::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeBoolOption * ptr_ = (cPtr_typeBoolOption *) NULL ;
    macroMyNew (ptr_, cPtr_typeBoolOption (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeUIntOption'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUIntOption::cPtr_typeUIntOption (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUIntOption::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeUIntOption:" ;
mOptionComponentName.reader_description  (_inLexique COMMA_THERE) ;
mOptionName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUIntOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUIntOption * GGS_typeUIntOption::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeUIntOption * ptr_ = (cPtr_typeUIntOption *) NULL ;
    macroMyNew (ptr_, cPtr_typeUIntOption (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeStringOption'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStringOption::cPtr_typeStringOption (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeStringOption::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStringOption:" ;
mOptionComponentName.reader_description  (_inLexique COMMA_THERE) ;
mOptionName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStringOption'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStringOption * GGS_typeStringOption::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeStringOption * ptr_ = (cPtr_typeStringOption *) NULL ;
    macroMyNew (ptr_, cPtr_typeStringOption (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeVarInExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVarInExpression::cPtr_typeVarInExpression (const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mCppVarName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeVarInExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeVarInExpression:" ;
mCppVarName.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeVarInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeVarInExpression * GGS_typeVarInExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeVarInExpression * ptr_ = (cPtr_typeVarInExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeVarInExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeJokerInExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJokerInExpression::cPtr_typeJokerInExpression (const GGS_location & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeJokerInExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeJokerInExpression:" ;
mLocation.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeJokerInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeJokerInExpression * GGS_typeJokerInExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_location & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeJokerInExpression * ptr_ = (cPtr_typeJokerInExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeJokerInExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeAddOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAddOperation::cPtr_typeAddOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAddOperation::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAddOperation:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
mInstructionLocation.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAddOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAddOperation * GGS_typeAddOperation::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeAddOperation * ptr_ = (cPtr_typeAddOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeAddOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeSubOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSubOperation::cPtr_typeSubOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeSubOperation::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeSubOperation:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
mInstructionLocation.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeSubOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSubOperation * GGS_typeSubOperation::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeSubOperation * ptr_ = (cPtr_typeSubOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeSubOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeMultiplyOperation'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMultiplyOperation::cPtr_typeMultiplyOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMultiplyOperation::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMultiplyOperation:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
mInstructionLocation.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMultiplyOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMultiplyOperation * GGS_typeMultiplyOperation::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeMultiplyOperation * ptr_ = (cPtr_typeMultiplyOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeMultiplyOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeDivideOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDivideOperation::cPtr_typeDivideOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDivideOperation::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDivideOperation:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
mInstructionLocation.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDivideOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDivideOperation * GGS_typeDivideOperation::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeDivideOperation * ptr_ = (cPtr_typeDivideOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeDivideOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeModuloOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModuloOperation::cPtr_typeModuloOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeModuloOperation::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeModuloOperation:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
mInstructionLocation.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeModuloOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeModuloOperation * GGS_typeModuloOperation::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeModuloOperation * ptr_ = (cPtr_typeModuloOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeModuloOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeUnaryMinusOperation'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUnaryMinusOperation::cPtr_typeUnaryMinusOperation (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUnaryMinusOperation::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeUnaryMinusOperation:" ;
mExpression.reader_description  (_inLexique COMMA_THERE) ;
mInstructionLocation.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeUnaryMinusOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUnaryMinusOperation * GGS_typeUnaryMinusOperation::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeUnaryMinusOperation * ptr_ = (cPtr_typeUnaryMinusOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeUnaryMinusOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEqualTest'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEqualTest::cPtr_typeEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeEqualTest::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEqualTest:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeEqualTest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEqualTest * GGS_typeEqualTest::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeEqualTest * ptr_ = (cPtr_typeEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeNonEqualTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonEqualTest::cPtr_typeNonEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeNonEqualTest::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeNonEqualTest:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeNonEqualTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNonEqualTest * GGS_typeNonEqualTest::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeNonEqualTest * ptr_ = (cPtr_typeNonEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeNonEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeStrictInfTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictInfTest::cPtr_typeStrictInfTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeStrictInfTest::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStrictInfTest:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictInfTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStrictInfTest * GGS_typeStrictInfTest::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeStrictInfTest * ptr_ = (cPtr_typeStrictInfTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeStrictInfTest (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeInfOrEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInfOrEqualTest::cPtr_typeInfOrEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInfOrEqualTest::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInfOrEqualTest:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeInfOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInfOrEqualTest * GGS_typeInfOrEqualTest::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeInfOrEqualTest * ptr_ = (cPtr_typeInfOrEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeInfOrEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeStrictSupTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictSupTest::cPtr_typeStrictSupTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeStrictSupTest::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStrictSupTest:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictSupTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStrictSupTest * GGS_typeStrictSupTest::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeStrictSupTest * ptr_ = (cPtr_typeStrictSupTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeStrictSupTest (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeSupOrEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSupOrEqualTest::cPtr_typeSupOrEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeSupOrEqualTest::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeSupOrEqualTest:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeSupOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSupOrEqualTest * GGS_typeSupOrEqualTest::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeSupOrEqualTest * ptr_ = (cPtr_typeSupOrEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeSupOrEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeTextTableCall'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTextTableCall::cPtr_typeTextTableCall (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0),
aNomMethodeTest (argument_1),
aNomCppClef (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeTextTableCall::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeTextTableCall:" ;
mExpression.reader_description  (_inLexique COMMA_THERE) ;
aNomMethodeTest.reader_description  (_inLexique COMMA_THERE) ;
aNomCppClef.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeTextTableCall'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTextTableCall * GGS_typeTextTableCall::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeTextTableCall * ptr_ = (cPtr_typeTextTableCall *) NULL ;
    macroMyNew (ptr_, cPtr_typeTextTableCall (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_assignmentInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_assignmentInstruction::cPtr_C_assignmentInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_assignmentInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_assignmentInstruction:" ;
mTargetVarCppName.reader_description  (_inLexique COMMA_THERE) ;
mSourceExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_assignmentInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_assignmentInstruction * GGS_C_assignmentInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_assignmentInstruction * ptr_ = (cPtr_C_assignmentInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_assignmentInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'C_declarationInstructionWithAssignment'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_declarationInstructionWithAssignment::cPtr_C_declarationInstructionWithAssignment (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariableType (argument_0),
mTargetVarCppName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_C_declarationInstructionWithAssignment::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_declarationInstructionWithAssignment:" ;
mVariableType.reader_description  (_inLexique COMMA_THERE) ;
mTargetVarCppName.reader_description  (_inLexique COMMA_THERE) ;
mSourceExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_declarationInstructionWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_declarationInstructionWithAssignment * GGS_C_declarationInstructionWithAssignment::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_C_declarationInstructionWithAssignment * ptr_ = (cPtr_C_declarationInstructionWithAssignment *) NULL ;
    macroMyNew (ptr_, cPtr_C_declarationInstructionWithAssignment (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_while_instruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_while_instruction::cPtr_C_while_instruction (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_typeInstructionList & argument_3,
                                const GGS_location & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariantExpression (argument_0),
mInstructionList1 (argument_1),
mWhileExpression (argument_2),
mInstructionList2 (argument_3),
mLocation (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_C_while_instruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_while_instruction:" ;
mVariantExpression.reader_description  (_inLexique COMMA_THERE) ;
mInstructionList1.reader_description  (_inLexique COMMA_THERE) ;
mWhileExpression.reader_description  (_inLexique COMMA_THERE) ;
mInstructionList2.reader_description  (_inLexique COMMA_THERE) ;
mLocation.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_while_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_while_instruction * GGS_C_while_instruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_typeInstructionList & argument_3,
                                const GGS_location & argument_4 COMMA_LOCATION_ARGS) {
    cPtr_C_while_instruction * ptr_ = (cPtr_C_while_instruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_while_instruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@L_expression_instructionsList_list'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_expression_instructionsList_list::
elementOf_GGS_L_expression_instructionsList_list (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1):
mNextItem (NULL),
mIFexpression (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_expression_instructionsList_list::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mIFexpression.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@L_expression_instructionsList_list'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::GGS_L_expression_instructionsList_list (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::~GGS_L_expression_instructionsList_list (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::
GGS_L_expression_instructionsList_list (const GGS_L_expression_instructionsList_list & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
operator = (const GGS_L_expression_instructionsList_list & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::element_type * GGS_L_expression_instructionsList_list::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
internalAppendItem (const GGS_typeExpression & argument_0,
                    const GGS_typeInstructionList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
addAssign_operation (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mIFexpression,
                                p->mInstructionList) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_L_expression_instructionsList_list::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_expression_instructionsList_list result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_expression_instructionsList_list::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_expression_instructionsList_list::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_expression_instructionsList_list" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_expression_instructionsList_list::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_if_instruction'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_if_instruction::cPtr_C_if_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_if_instruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_if_instruction:" ;
mIFbranchesList.reader_description  (_inLexique COMMA_THERE) ;
mElseInstructionsList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_if_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_if_instruction * GGS_C_if_instruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_if_instruction * ptr_ = (cPtr_C_if_instruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_if_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableRoutinesAimplementer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableRoutinesAimplementer::
elementOf_GGS_typeTableRoutinesAimplementer (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableRoutinesAimplementer & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableRoutinesAimplementer::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableRoutinesAimplementer::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableRoutinesAimplementer *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableRoutinesAimplementer * info = (e_typeTableRoutinesAimplementer *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableRoutinesAimplementer info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the routine '%K' is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableRoutinesAimplementer & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableRoutinesAimplementer result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableRoutinesAimplementer::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeTableRoutinesAimplementer " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableAttributsSemantiques'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableAttributsSemantiques::
elementOf_GGS_typeTableAttributsSemantiques (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableAttributsSemantiques & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableAttributsSemantiques::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.aNomCppAttribut.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mAttributType.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableAttributsSemantiques::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableAttributsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableAttributsSemantiques * info = (e_typeTableAttributsSemantiques *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeCplusPlusName &  inParameter0,
               const GGS_AC_galgasType &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableAttributsSemantiques info  ;
    info.aNomCppAttribut = inParameter0 ;
    info.mAttributType = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeCplusPlusName   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aNomCppAttribut ;
    outParameter1 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeCplusPlusName   & outParameter0,
                                GGS_AC_galgasType   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the attribute '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeCplusPlusName & inParameter0,
                                const GGS_AC_galgasType & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the attribute '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableAttributsSemantiques & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableAttributsSemantiques result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableAttributsSemantiques::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeTableAttributsSemantiques " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "buildMapWithLocalConstants"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildMapWithLocalConstants (C_Lexique & _inLexique,
                                GGS_L_nameWithType   var_cas_inLocalDeclarationsList,
                                GGS_typeListeAttributsSemantiques   var_cas_inSemanticAttributsList,
                                GGS_typeVariablesMap  & var_cas_ioVariablesMap,
                                GGS_location   var_cas_inLocation,
                                GGS_localConstantBuildStyleEnum  var_cas_inLocalConstantStyle,
                                GGS_bool  var_cas_inEllipsisFound COMMA_UNUSED_LOCATION_ARGS) {
  GGS_bool var_cas_mapStyle ;
  var_cas_mapStyle = (var_cas_inLocalConstantStyle) != (GGS_localConstantBuildStyleEnum::constructor_listStyle (_inLexique COMMA_HERE)) ;
  GGS_bool var_cas_firstOne ;
  var_cas_firstOne = GGS_bool (true, true) ;
  GGS_L_nameWithType::element_type * operand_29449 = var_cas_inLocalDeclarationsList.firstObject () ;
  GGS_typeListeAttributsSemantiques::element_type * operand_29538 = var_cas_inSemanticAttributsList.firstObject () ;
  while ((operand_29449 != NULL)
      && (operand_29538 != NULL)) {
    macroValidPointer (operand_29449) ;
    macroValidPointer (operand_29538) ;
    if (((operand_29449->mName.reader_value (_inLexique SOURCE_FILE_AT_LINE (710))) != (GGS_string (true, ""))).isBuiltAndTrue ()) {
      GGS_string var_cas_typeName ;
      if (operand_29538->mAttributType.isBuilt ()) {
        operand_29538->mAttributType (HERE)->method_getTypeName (_inLexique, var_cas_typeName SOURCE_FILE_AT_LINE (712)) ;
      }
      if (((operand_29449->mType.reader_value (_inLexique SOURCE_FILE_AT_LINE (713))) == (var_cas_typeName)).isBuiltAndTrue ()) {
        GGS_typeCplusPlusName  var_cas_cppName ;
        if (((((var_cas_inLocalConstantStyle) == (GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (_inLexique COMMA_HERE))) & (var_cas_firstOne))).isBuiltAndTrue ()) {
          var_cas_cppName = GGS_typeKeyName::constructor_new (_inLexique, var_cas_inLocation COMMA_HERE) ;
        }else{
          var_cas_cppName = GGS_typeOperandName::constructor_new (_inLexique, operand_29538->aNomAttribut, var_cas_inLocation, var_cas_mapStyle COMMA_HERE) ;
        }
        var_cas_ioVariablesMap.method_insertUsedConstInArgument (_inLexique, operand_29449->mName, operand_29538->mAttributType, var_cas_cppName SOURCE_FILE_AT_LINE (720)) ;
      }else{
        operand_29449->mType.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I have found the '@")) + (operand_29449->mType.reader_value (_inLexique SOURCE_FILE_AT_LINE (722))))) + (GGS_string (true, "' type, I was expected the '@")))) + (var_cas_typeName))) + (GGS_string (true, "' type"))) SOURCE_FILE_AT_LINE (724)) ;
      }
    }
    var_cas_firstOne = GGS_bool (true, false) ;
    operand_29449 = operand_29449->nextObject () ;
    operand_29538 = operand_29538->nextObject () ;
  }
  if (((((var_cas_inLocalDeclarationsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (729))) < (var_cas_inSemanticAttributsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (729)))) & ((! (var_cas_inEllipsisFound))))).isBuiltAndTrue ()) {
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "one or more parameters missing: found ")) + (var_cas_inLocalDeclarationsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (731)).reader_string (_inLexique SOURCE_FILE_AT_LINE (731))))) + (GGS_string (true, " effective parameters, while ")))) + (var_cas_inSemanticAttributsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (732)).reader_string (_inLexique SOURCE_FILE_AT_LINE (732))))) + (GGS_string (true, " are needed"))) SOURCE_FILE_AT_LINE (733)) ;
  }else if (((var_cas_inLocalDeclarationsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (733))) > (var_cas_inSemanticAttributsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (733)))).isBuiltAndTrue ()) {
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "too much parameters: found ")) + (var_cas_inLocalDeclarationsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (735)).reader_string (_inLexique SOURCE_FILE_AT_LINE (735))))) + (GGS_string (true, " effective parameters, while ")))) + (var_cas_inSemanticAttributsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (736)).reader_string (_inLexique SOURCE_FILE_AT_LINE (736))))) + (GGS_string (true, " are needed"))) SOURCE_FILE_AT_LINE (737)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "checkAssignmentTypesCompatibility"        *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkAssignmentTypesCompatibility (C_Lexique & _inLexique,
                                GGS_AC_galgasType   var_cas_targetType,
                                GGS_AC_galgasType   var_cas_sourceType,
                                GGS_location   var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  if (var_cas_targetType.isBuilt () && var_cas_sourceType.isBuilt ()) {
    cPtr_AC_galgasType * ptr_31567 = var_cas_targetType (HERE) ;
    cPtr_AC_galgasType * ptr_31581 = var_cas_sourceType (HERE) ;
    cPtr_typeGalgas_stringset * operand_31567 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_31567) ;
    cPtr_typeGalgas_stringset * operand_31581 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_31581) ;
    if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
    }else{
      cPtr_typeGalgas_uint * operand_31567 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_31567) ;
      cPtr_typeGalgas_uint * operand_31581 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_31581) ;
      if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
      }else{
        cPtr_typeGalgas_sint * operand_31567 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_31567) ;
        cPtr_typeGalgas_sint * operand_31581 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_31581) ;
        if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
        }else{
          cPtr_typeGalgas_char * operand_31567 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_31567) ;
          cPtr_typeGalgas_char * operand_31581 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_31581) ;
          if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
          }else{
            cPtr_typeGalgas_string * operand_31567 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_31567) ;
            cPtr_typeGalgas_string * operand_31581 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_31581) ;
            if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
            }else{
              cPtr_typeGalgas_bool * operand_31567 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_31567) ;
              cPtr_typeGalgas_bool * operand_31581 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_31581) ;
              if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
              }else{
                cPtr_typeGalgas_double * operand_31567 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_31567) ;
                cPtr_typeGalgas_double * operand_31581 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_31581) ;
                if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
                }else{
                  cPtr_typeGalgas_ldouble * operand_31567 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_31567) ;
                  cPtr_typeGalgas_ldouble * operand_31581 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_31581) ;
                  if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
                  }else{
                    cPtr_typeGalgas_location * operand_31567 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_31567) ;
                    cPtr_typeGalgas_location * operand_31581 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_31581) ;
                    if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
                    }else{
                      cPtr_typeGalgas_lchar * operand_31567 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_31567) ;
                      cPtr_typeGalgas_lchar * operand_31581 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_31581) ;
                      if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
                      }else{
                        cPtr_typeGalgas_luint * operand_31567 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_31567) ;
                        cPtr_typeGalgas_luint * operand_31581 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_31581) ;
                        if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
                        }else{
                          cPtr_typeGalgas_lsint * operand_31567 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_31567) ;
                          cPtr_typeGalgas_lsint * operand_31581 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_31581) ;
                          if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
                          }else{
                            cPtr_typeGalgas_lstring * operand_31567 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_31567) ;
                            cPtr_typeGalgas_lstring * operand_31581 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_31581) ;
                            if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
                            }else{
                              cPtr_typeGalgas_lbool * operand_31567 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_31567) ;
                              cPtr_typeGalgas_lbool * operand_31581 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_31581) ;
                              if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
                              }else{
                                cPtr_typeGalgasUndefinedExternType * operand_31567 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_31567) ;
                                cPtr_typeGalgasUndefinedExternType * operand_31581 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_31581) ;
                                if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
                                  if (((operand_31567->mGalgasClassName.reader_value (_inLexique SOURCE_FILE_AT_LINE (775))) != (operand_31581->mGalgasClassName.reader_value (_inLexique SOURCE_FILE_AT_LINE (775)))).isBuiltAndTrue ()) {
                                    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting an extern variable of extern '")) + (operand_31567->mGalgasClassName.reader_value (_inLexique SOURCE_FILE_AT_LINE (776))))) + (GGS_string (true, "' type variable, and I got an extern '")))) + (operand_31581->mGalgasClassName.reader_value (_inLexique SOURCE_FILE_AT_LINE (777))))) + (GGS_string (true, "' type variable"))) SOURCE_FILE_AT_LINE (778)) ;
                                  }
                                }else{
                                  cPtr_typeGalgasUndefinedListType * operand_31567 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_31567) ;
                                  cPtr_typeGalgasUndefinedListType * operand_31581 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_31581) ;
                                  if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
                                    if (((operand_31567->mListTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (781))) != (operand_31581->mListTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (781)))).isBuiltAndTrue ()) {
                                      var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting a '")) + (operand_31567->mListTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (782))))) + (GGS_string (true, "' list type variable, and I got a '")))) + (operand_31581->mListTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (783))))) + (GGS_string (true, "' list type variable"))) SOURCE_FILE_AT_LINE (784)) ;
                                    }
                                  }else{
                                    cPtr_typeGalgasClassType * operand_31567 = dynamic_cast <cPtr_typeGalgasClassType *> (ptr_31567) ;
                                    cPtr_typeGalgasClassType * operand_31581 = dynamic_cast <cPtr_typeGalgasClassType *> (ptr_31581) ;
                                    if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
                                      if (((operand_31567->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (788))) == (operand_31581->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (788)))).isBuiltAndTrue ()) {
                                      }else if (((! (operand_31581->mAncestorClassesMap.reader_hasKey (_inLexique, operand_31567->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (789)) SOURCE_FILE_AT_LINE (789))))).isBuiltAndTrue ()) {
                                        var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "The '")) + (operand_31581->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (790))))) + (GGS_string (true, "' does not inherit from '")))) + (operand_31581->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (791))))) + (GGS_string (true, "' class"))) SOURCE_FILE_AT_LINE (792)) ;
                                      }
                                    }else{
                                      cPtr_typeGalgasUndefinedClassType * operand_31567 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_31567) ;
                                      cPtr_typeGalgasUndefinedClassType * operand_31581 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_31581) ;
                                      if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
                                        if (((operand_31567->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (795))) != (operand_31581->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (795)))).isBuiltAndTrue ()) {
                                          var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting a '")) + (operand_31567->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (796))))) + (GGS_string (true, "' class type variable, and I got a '")))) + (operand_31581->mClassTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (797))))) + (GGS_string (true, "' class type variable"))) SOURCE_FILE_AT_LINE (798)) ;
                                        }
                                      }else{
                                        cPtr_typeGalgasUndefinedMapType * operand_31567 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_31567) ;
                                        cPtr_typeGalgasUndefinedMapType * operand_31581 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_31581) ;
                                        if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
                                          if (((operand_31567->mMapTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (801))) != (operand_31581->mMapTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (801)))).isBuiltAndTrue ()) {
                                            var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting a '")) + (operand_31567->mMapTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (802))))) + (GGS_string (true, "' map type variable, and I got a '")))) + (operand_31581->mMapTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (803))))) + (GGS_string (true, "' map type variable"))) SOURCE_FILE_AT_LINE (805)) ;
                                          }
                                        }else{
                                          cPtr_typeGalgas_enum * operand_31567 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_31567) ;
                                          cPtr_typeGalgas_enum * operand_31581 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_31581) ;
                                          if ((operand_31567 != NULL) && (operand_31581 != NULL)) {
                                            if (((operand_31567->mEnumTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (809))) != (operand_31581->mEnumTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (809)))).isBuiltAndTrue ()) {
                                              var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting an enum variable of  '")) + (operand_31567->mEnumTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (810))))) + (GGS_string (true, "' type variable, and I got an enum '")))) + (operand_31581->mEnumTypeName.reader_value (_inLexique SOURCE_FILE_AT_LINE (811))))) + (GGS_string (true, "' type variable"))) SOURCE_FILE_AT_LINE (813)) ;
                                            }
                                          }else{
                                            var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((var_cas_targetType.reader_messageGalgasType (_inLexique SOURCE_FILE_AT_LINE (815))) + (GGS_string (true, " cannot be assigned from ")))) + (var_cas_sourceType.reader_messageGalgasType (_inLexique SOURCE_FILE_AT_LINE (816)))) SOURCE_FILE_AT_LINE (817)) ;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "verifierCompatibiliteTypes"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteTypes (C_Lexique & _inLexique,
                                const GGS_typeSemanticsTypesList  & var_cas_t1,
                                const GGS_typeListeAttributsSemantiques  & var_cas_t2,
                                const GGS_location  & var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_t1.reader_length (_inLexique SOURCE_FILE_AT_LINE (832))) < (var_cas_t2.reader_length (_inLexique SOURCE_FILE_AT_LINE (832)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more identifiers missing") SOURCE_FILE_AT_LINE (834)) ;
  }else if (((var_cas_t1.reader_length (_inLexique SOURCE_FILE_AT_LINE (834))) > (var_cas_t2.reader_length (_inLexique SOURCE_FILE_AT_LINE (834)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "too much identifiers") SOURCE_FILE_AT_LINE (836)) ;
  }else{
    GGS_typeSemanticsTypesList::element_type * operand_36016 = var_cas_t1.firstObject () ;
    GGS_typeListeAttributsSemantiques::element_type * operand_36101 = var_cas_t2.firstObject () ;
    while ((operand_36016 != NULL)
        && (operand_36101 != NULL)) {
      macroValidPointer (operand_36016) ;
      macroValidPointer (operand_36101) ;
      ::routine_verifierCompatibiliteTypesSemantiques (_inLexique,  operand_36016->mType,  operand_36101->mAttributType,  operand_36016->mGalgasVariableName.reader_location (_inLexique SOURCE_FILE_AT_LINE (842)),  GGS_bool (true, false) SOURCE_FILE_AT_LINE (840)) ;
      operand_36016 = operand_36016->nextObject () ;
      operand_36101 = operand_36101->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Implementation of routine "verifierCompatibiliteArgEffectifsSignature"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteArgEffectifsSignature (C_Lexique & _inLexique,
                                const GGS_L_EXsignature  & var_cas_signatureReference,
                                const GGS_L_actualParametersSignature  & var_cas_inEffectiveArgumentsSignature,
                                const GGS_location  & var_cas_inErrorLocation,
                                GGS_typeInstructionList  & var_cas_ioInstructionsList,
                                GGS_typeExpressionList  & var_cas_ioExpressionList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_signatureReference.reader_length (_inLexique SOURCE_FILE_AT_LINE (862))) > (var_cas_inEffectiveArgumentsSignature.reader_length (_inLexique SOURCE_FILE_AT_LINE (862)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more arguments missing") SOURCE_FILE_AT_LINE (864)) ;
  }else if (((var_cas_signatureReference.reader_length (_inLexique SOURCE_FILE_AT_LINE (864))) < (var_cas_inEffectiveArgumentsSignature.reader_length (_inLexique SOURCE_FILE_AT_LINE (864)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "too much arguments") SOURCE_FILE_AT_LINE (866)) ;
  }else{
    GGS_L_EXsignature::element_type * operand_37382 = var_cas_signatureReference.firstObject () ;
    GGS_L_actualParametersSignature::element_type * operand_37511 = var_cas_inEffectiveArgumentsSignature.firstObject () ;
    while ((operand_37382 != NULL)
        && (operand_37511 != NULL)) {
      macroValidPointer (operand_37382) ;
      macroValidPointer (operand_37511) ;
      if (operand_37382->mFormalArgumentPassingMode.isBuilt () && operand_37511->mFormalArgumentPassingMode.isBuilt ()) {
        if ((operand_37382->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentConstantIn) && (operand_37511->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOut)) {
          ::routine_verifierCompatibiliteTypesSemantiques (_inLexique,  operand_37382->mType,  operand_37511->mType,  var_cas_inErrorLocation,  GGS_bool (true, true) SOURCE_FILE_AT_LINE (872)) ;
        }else{
          if ((operand_37382->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentIn) && (operand_37511->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOut)) {
            ::routine_verifierCompatibiliteTypesSemantiques (_inLexique,  operand_37382->mType,  operand_37511->mType,  var_cas_inErrorLocation,  GGS_bool (true, false) SOURCE_FILE_AT_LINE (874)) ;
          }else{
            if ((operand_37382->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentInOut) && (operand_37511->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOutIn)) {
              ::routine_verifierCompatibiliteTypesSemantiques (_inLexique,  operand_37382->mType,  operand_37511->mType,  var_cas_inErrorLocation,  GGS_bool (true, false) SOURCE_FILE_AT_LINE (876)) ;
            }else{
              if ((operand_37382->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentOut) && (operand_37511->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterIn)) {
                if (operand_37511->mType.isBuilt ()) {
                  if (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (operand_37511->mType.getPtr ()) != NULL) {
                  }else{ // Else part
                    ::routine_verifierCompatibiliteTypesSemantiques (_inLexique,  operand_37382->mType,  operand_37511->mType,  var_cas_inErrorLocation,  GGS_bool (true, false) SOURCE_FILE_AT_LINE (881)) ;
                  }
                }
              }else{
                var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((operand_37511->mFormalArgumentPassingMode.reader_actualArgumentMessage (_inLexique SOURCE_FILE_AT_LINE (884))) + (GGS_string (true, " is not compatible with ")))) + (operand_37382->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique SOURCE_FILE_AT_LINE (885)))) SOURCE_FILE_AT_LINE (886)) ;
              }
            }
          }
        }
      }
      operand_37382 = operand_37382->nextObject () ;
      operand_37511 = operand_37511->nextObject () ;
    }
    GGS_typeExpressionList  var_cas_expressionList ;
    var_cas_expressionList = var_cas_ioExpressionList ;
    var_cas_ioExpressionList = GGS_typeExpressionList::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_L_EXsignature::element_type * operand_38799 = var_cas_signatureReference.firstObject () ;
    GGS_typeExpressionList::element_type * operand_38867 = var_cas_expressionList.firstObject () ;
    while ((operand_38799 != NULL)
        && (operand_38867 != NULL)) {
      macroValidPointer (operand_38799) ;
      macroValidPointer (operand_38867) ;
      if (operand_38867->mExpression.isBuilt ()) {
        if (dynamic_cast <cPtr_typeJokerInExpression *> (operand_38867->mExpression.getPtr ()) != NULL) {
          cPtr_typeJokerInExpression * operand_38952 = dynamic_cast <cPtr_typeJokerInExpression *> (operand_38867->mExpression.getPtr ()) ;
          macroValidPointer (operand_38952) ; 
          GGS_typeCplusPlusName  var_cas_cppVarName ;
          var_cas_cppVarName = GGS_typeLocationAutomaticName::constructor_new (_inLexique, operand_38952->mLocation COMMA_HERE) ;
          GGS_typeExpression  var_cas_e ;
          var_cas_e = GGS_typeVarInExpression::constructor_new (_inLexique, var_cas_cppVarName COMMA_HERE) ;
          var_cas_ioExpressionList.addAssign_operation (var_cas_e) ;
          GGS_typeInstruction  var_cas_i ;
          var_cas_i = GGS_typeInstructionDeclarationVarLocale::constructor_new (_inLexique, var_cas_cppVarName, operand_38799->mType COMMA_HERE) ;
          var_cas_ioInstructionsList.addAssign_operation (var_cas_i) ;
        }else{ // Else part
          var_cas_ioExpressionList.addAssign_operation (operand_38867->mExpression) ;
        }
      }
      operand_38799 = operand_38799->nextObject () ;
      operand_38867 = operand_38867->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'typeJoker'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJoker::cPtr_typeJoker (LOCATION_ARGS)
:cPtr_typeCible (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::
method_verifierType (C_Lexique & _inLexique,
                                GGS_AC_galgasType  /* var_cas_typeArgumentFormel */,
                                GGS_lstring & /* var_cas_nomAttributSource */,
                                GGS_L_assignedVariables & /* var_cas_listeAffectations */,
                                GGS_typeCplusPlusNameList & var_cas_outAllVariablesList COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeCplusPlusName  var_cas_nullName ;
  var_cas_nullName = GGS_typeNullName::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_outAllVariablesList.addAssign_operation (var_cas_nullName) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeJoker:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeJoker'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeJoker * GGS_typeJoker::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeJoker * ptr_ = (cPtr_typeJoker *) NULL ;
    macroMyNew (ptr_, cPtr_typeJoker (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEntiteDest'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteDest::cPtr_typeEntiteDest (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeCible (THERE),
aTypeVarDest (argument_0),
mCppName (argument_1),
aPositionVariableCible (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::
method_verifierType (C_Lexique & _inLexique,
                                GGS_AC_galgasType  var_cas_typeArgumentFormel,
                                GGS_lstring & var_cas_nomAttributSource,
                                GGS_L_assignedVariables & var_cas_listeAffectations,
                                GGS_typeCplusPlusNameList & var_cas_ioAllVariablesList COMMA_UNUSED_LOCATION_ARGS) {
  ::routine_verifierCompatibiliteTypesSemantiques (_inLexique,  aTypeVarDest,  var_cas_typeArgumentFormel,  aPositionVariableCible,  GGS_bool (true, false) SOURCE_FILE_AT_LINE (940)) ;
  var_cas_listeAffectations.addAssign_operation (mCppName, var_cas_nomAttributSource) ;
  var_cas_ioAllVariablesList.addAssign_operation (mCppName) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteDest:" ;
aTypeVarDest.reader_description  (_inLexique COMMA_THERE) ;
mCppName.reader_description  (_inLexique COMMA_THERE) ;
aPositionVariableCible.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteDest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteDest * GGS_typeEntiteDest::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeEntiteDest * ptr_ = (cPtr_typeEntiteDest *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteDest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map 'M_nonTerminalSymbolForSyntax'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonTerminalSymbolForSyntax::
elementOf_GGS_M_nonTerminalSymbolForSyntax (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonTerminalSymbolForSyntax & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonTerminalSymbolForSyntax::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mAltParametersMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonTerminalSymbolForSyntax::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolForSyntax *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonTerminalSymbolForSyntax * info = (e_M_nonTerminalSymbolForSyntax *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAlts &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_nonTerminalSymbolForSyntax info  ;
    info.mAltParametersMap = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAlts   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAltParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' non terminal symbol is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' non terminal symbol is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_nonTerminalSymbolForSyntax & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonTerminalSymbolForSyntax result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonTerminalSymbolForSyntax::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_nonTerminalSymbolForSyntax " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_grammarInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarInstruction::cPtr_C_grammarInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_lstring & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mSourceFileCppName (argument_0),
mGrammarName (argument_1),
mExpressionsList (argument_2),
mAltSymbol (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_C_grammarInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_grammarInstruction:" ;
mSourceFileCppName.reader_description  (_inLexique COMMA_THERE) ;
mGrammarName.reader_description  (_inLexique COMMA_THERE) ;
mExpressionsList.reader_description  (_inLexique COMMA_THERE) ;
mAltSymbol.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_grammarInstruction * GGS_C_grammarInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_lstring & argument_3 COMMA_LOCATION_ARGS) {
    cPtr_C_grammarInstruction * ptr_ = (cPtr_C_grammarInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_grammarInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeAppendInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAppendInstruction::cPtr_typeAppendInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mSourceExpressions (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAppendInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAppendInstruction:" ;
mTargetVarCppName.reader_description  (_inLexique COMMA_THERE) ;
mSourceExpressions.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeAppendInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAppendInstruction * GGS_typeAppendInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeAppendInstruction * ptr_ = (cPtr_typeAppendInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeAppendInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeRemoveInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRemoveInstruction::cPtr_typeRemoveInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mSourceExpressions (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeRemoveInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRemoveInstruction:" ;
mTargetVarCppName.reader_description  (_inLexique COMMA_THERE) ;
mSourceExpressions.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRemoveInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRemoveInstruction * GGS_typeRemoveInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeRemoveInstruction * ptr_ = (cPtr_typeRemoveInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeRemoveInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeIncrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeIncrementInstruction::cPtr_typeIncrementInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeIncrementInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeIncrementInstruction:" ;
mTargetVarCppName.reader_description  (_inLexique COMMA_THERE) ;
mInstructionLocation.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeIncrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeIncrementInstruction * GGS_typeIncrementInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeIncrementInstruction * ptr_ = (cPtr_typeIncrementInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeIncrementInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeDecrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDecrementInstruction::cPtr_typeDecrementInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDecrementInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDecrementInstruction:" ;
mTargetVarCppName.reader_description  (_inLexique COMMA_THERE) ;
mInstructionLocation.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDecrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDecrementInstruction * GGS_typeDecrementInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeDecrementInstruction * ptr_ = (cPtr_typeDecrementInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeDecrementInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeInstructionAppelActionExterne'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelActionExterne::cPtr_typeInstructionAppelActionExterne (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_EXsignature & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomAction (argument_0),
mExpressionsList (argument_1),
aListeTypesParametresFormels (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelActionExterne::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionAppelActionExterne:" ;
aNomAction.reader_description  (_inLexique COMMA_THERE) ;
mExpressionsList.reader_description  (_inLexique COMMA_THERE) ;
aListeTypesParametresFormels.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelActionExterne'            *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelActionExterne * GGS_typeInstructionAppelActionExterne::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_EXsignature & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeInstructionAppelActionExterne * ptr_ = (cPtr_typeInstructionAppelActionExterne *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionAppelActionExterne (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_matchInstructionCasesList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_matchInstructionCasesList::
elementOf_GGS_L_matchInstructionCasesList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2):
mNextItem (NULL),
mCase1_name (argument_0),
mCase2_name (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_matchInstructionCasesList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mCase1_name.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mCase2_name.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@L_matchInstructionCasesList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::GGS_L_matchInstructionCasesList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::~GGS_L_matchInstructionCasesList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::
GGS_L_matchInstructionCasesList (const GGS_L_matchInstructionCasesList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
operator = (const GGS_L_matchInstructionCasesList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::element_type * GGS_L_matchInstructionCasesList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
internalAppendItem (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCase1_name,
                                p->mCase2_name,
                                p->mInstructionList) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_L_matchInstructionCasesList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_matchInstructionCasesList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_matchInstructionCasesList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_matchInstructionCasesList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_matchInstructionCasesList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_matchInstructionCasesList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeMatchInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMatchInstruction::cPtr_typeMatchInstruction (const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionList & argument_9 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aIndicatif1 (argument_0),
aIndicatif2 (argument_1),
aNomCppVariable1 (argument_2),
aNomCppVariable2 (argument_3),
aNomTypeBase1 (argument_4),
aNomTypeBase2 (argument_5),
mOperand1_isEnumeration (argument_6),
mOperand2_isEnumeration (argument_7),
aListeCas (argument_8),
mElseInstructionsList (argument_9) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMatchInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMatchInstruction:" ;
aIndicatif1.reader_description  (_inLexique COMMA_THERE) ;
aIndicatif2.reader_description  (_inLexique COMMA_THERE) ;
aNomCppVariable1.reader_description  (_inLexique COMMA_THERE) ;
aNomCppVariable2.reader_description  (_inLexique COMMA_THERE) ;
aNomTypeBase1.reader_description  (_inLexique COMMA_THERE) ;
aNomTypeBase2.reader_description  (_inLexique COMMA_THERE) ;
mOperand1_isEnumeration.reader_description  (_inLexique COMMA_THERE) ;
mOperand2_isEnumeration.reader_description  (_inLexique COMMA_THERE) ;
aListeCas.reader_description  (_inLexique COMMA_THERE) ;
mElseInstructionsList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMatchInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMatchInstruction * GGS_typeMatchInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionList & argument_9 COMMA_LOCATION_ARGS) {
    cPtr_typeMatchInstruction * ptr_ = (cPtr_typeMatchInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMatchInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@foreachEnumerationList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachEnumerationList::
elementOf_GGS_foreachEnumerationList (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2):
mNextItem (NULL),
mCppEnumeratedVariableName (argument_0),
mLocationOffset (argument_1),
mCppTypeName (argument_2) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachEnumerationList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mCppEnumeratedVariableName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mLocationOffset.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mCppTypeName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@foreachEnumerationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::GGS_foreachEnumerationList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::~GGS_foreachEnumerationList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::
GGS_foreachEnumerationList (const GGS_foreachEnumerationList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
operator = (const GGS_foreachEnumerationList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::element_type * GGS_foreachEnumerationList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
internalAppendItem (const GGS_typeCplusPlusName & argument_0,
                    const GGS_location & argument_1,
                    const GGS_string& argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCppEnumeratedVariableName,
                                p->mLocationOffset,
                                p->mCppTypeName) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_foreachEnumerationList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_foreachEnumerationList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_foreachEnumerationList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachEnumerationList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @foreachEnumerationList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_foreachEnumerationList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeForeachInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeForeachInstruction::cPtr_typeForeachInstruction (const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mForeachEnumerationList (argument_0),
mWhileExpression (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeForeachInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeForeachInstruction:" ;
mForeachEnumerationList.reader_description  (_inLexique COMMA_THERE) ;
mWhileExpression.reader_description  (_inLexique COMMA_THERE) ;
mInstructionList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeForeachInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeForeachInstruction * GGS_typeForeachInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeForeachInstruction * ptr_ = (cPtr_typeForeachInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeForeachInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeSimpleExtractInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSimpleExtractInstruction::cPtr_typeSimpleExtractInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariable (argument_0),
aNomClasse (argument_1),
aListeAffectationParametresEffectifs (argument_2),
mErrorLocationExpression (argument_3),
aNomMessage (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_typeSimpleExtractInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeSimpleExtractInstruction:" ;
aNomVariable.reader_description  (_inLexique COMMA_THERE) ;
aNomClasse.reader_description  (_inLexique COMMA_THERE) ;
aListeAffectationParametresEffectifs.reader_description  (_inLexique COMMA_THERE) ;
mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE) ;
aNomMessage.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeSimpleExtractInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSimpleExtractInstruction * GGS_typeSimpleExtractInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4 COMMA_LOCATION_ARGS) {
    cPtr_typeSimpleExtractInstruction * ptr_ = (cPtr_typeSimpleExtractInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeSimpleExtractInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeStructuredExtractCasesList'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeStructuredExtractCasesList::
elementOf_GGS_typeStructuredExtractCasesList (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3):
mNextItem (NULL),
mClassName (argument_0),
mResultVarID (argument_1),
mInstructionList (argument_2),
mNoUsedParameter (argument_3) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeStructuredExtractCasesList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mClassName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mResultVarID.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mNoUsedParameter.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeStructuredExtractCasesList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::GGS_typeStructuredExtractCasesList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::~GGS_typeStructuredExtractCasesList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::
GGS_typeStructuredExtractCasesList (const GGS_typeStructuredExtractCasesList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
operator = (const GGS_typeStructuredExtractCasesList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::element_type * GGS_typeStructuredExtractCasesList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
internalAppendItem (const GGS_lstring & argument_0,
                    const GGS_location & argument_1,
                    const GGS_typeInstructionList & argument_2,
                    const GGS_bool& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mClassName,
                                p->mResultVarID,
                                p->mInstructionList,
                                p->mNoUsedParameter) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractCasesList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeStructuredExtractCasesList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeStructuredExtractCasesList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStructuredExtractCasesList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeStructuredExtractCasesList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeStructuredExtractCasesList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'typeStructuredExtractInstructionWithElse'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStructuredExtractInstructionWithElse::cPtr_typeStructuredExtractInstructionWithElse (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariableName (argument_0),
mCasesList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeStructuredExtractInstructionWithElse::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStructuredExtractInstructionWithElse:" ;
mVariableName.reader_description  (_inLexique COMMA_THERE) ;
mCasesList.reader_description  (_inLexique COMMA_THERE) ;
mElseInstructionList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_typeStructuredExtractInstructionWithElse'         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStructuredExtractInstructionWithElse * GGS_typeStructuredExtractInstructionWithElse::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeStructuredExtractInstructionWithElse * ptr_ = (cPtr_typeStructuredExtractInstructionWithElse *) NULL ;
    macroMyNew (ptr_, cPtr_typeStructuredExtractInstructionWithElse (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeRoutineCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineCallInstruction::cPtr_typeRoutineCallInstruction (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomRoutine (argument_0),
mExpressionsList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineCallInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRoutineCallInstruction:" ;
aNomRoutine.reader_description  (_inLexique COMMA_THERE) ;
mExpressionsList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeRoutineCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineCallInstruction * GGS_typeRoutineCallInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeRoutineCallInstruction * ptr_ = (cPtr_typeRoutineCallInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeRoutineCallInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeDropInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDropInstruction::cPtr_typeDropInstruction (const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aVariableConsommee (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDropInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDropInstruction:" ;
aVariableConsommee.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDropInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDropInstruction * GGS_typeDropInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeDropInstruction * ptr_ = (cPtr_typeDropInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeDropInstruction (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableNomRoutinesDeclarees'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableNomRoutinesDeclarees::
elementOf_GGS_typeTableNomRoutinesDeclarees (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableNomRoutinesDeclarees & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableNomRoutinesDeclarees::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableNomRoutinesDeclarees::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableNomRoutinesDeclarees *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableNomRoutinesDeclarees * info = (e_typeTableNomRoutinesDeclarees *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableNomRoutinesDeclarees info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the routine '%K' is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableNomRoutinesDeclarees & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableNomRoutinesDeclarees result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableNomRoutinesDeclarees::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeTableNomRoutinesDeclarees " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeEntityToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntityToGenerate::
cPtr_typeEntityToGenerate (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEntityToGenerate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (void) {
  mPointer = (cPtr_typeEntityToGenerate *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (const GGS_typeEntityToGenerate & inOperand) {
  mPointer = (cPtr_typeEntityToGenerate *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
~GGS_typeEntityToGenerate (void) {
  macroDetachPointer (mPointer, cPtr_typeEntityToGenerate) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate::
operator = (const GGS_typeEntityToGenerate & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate::
operator = (cPtr_typeEntityToGenerate * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (cPtr_typeEntityToGenerate * inSource) {
  mPointer = (cPtr_typeEntityToGenerate *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntityToGenerate * GGS_typeEntityToGenerate
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeEntityToGenerate) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntityToGenerate
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeEntityToGenerate" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeExternTypeToGenerate'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExternTypeToGenerate::cPtr_typeExternTypeToGenerate (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mGalgasName (argument_0),
mCppClassName (argument_1),
mIncludePath (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeExternTypeToGenerate::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeExternTypeToGenerate:" ;
mGalgasName.reader_description  (_inLexique COMMA_THERE) ;
mCppClassName.reader_description  (_inLexique COMMA_THERE) ;
mIncludePath.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeExternTypeToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeExternTypeToGenerate * GGS_typeExternTypeToGenerate::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeExternTypeToGenerate * ptr_ = (cPtr_typeExternTypeToGenerate *) NULL ;
    macroMyNew (ptr_, cPtr_typeExternTypeToGenerate (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeRoutineAengendrer'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineAengendrer::cPtr_typeRoutineAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomRoutine (argument_0),
aListeTypeEtNomsArguments (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineAengendrer::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRoutineAengendrer:" ;
aNomRoutine.reader_description  (_inLexique COMMA_THERE) ;
aListeTypeEtNomsArguments.reader_description  (_inLexique COMMA_THERE) ;
mInstructionList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRoutineAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineAengendrer * GGS_typeRoutineAengendrer::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeRoutineAengendrer * ptr_ = (cPtr_typeRoutineAengendrer *) NULL ;
    macroMyNew (ptr_, cPtr_typeRoutineAengendrer (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_listTypeToImplement'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_listTypeToImplement::cPtr_C_listTypeToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomListe (argument_0),
mNonExternAttributesList (argument_1),
mExternAttributesList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_C_listTypeToImplement::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_listTypeToImplement:" ;
aNomListe.reader_description  (_inLexique COMMA_THERE) ;
mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE) ;
mExternAttributesList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_listTypeToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_listTypeToImplement * GGS_C_listTypeToImplement::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_C_listTypeToImplement * ptr_ = (cPtr_C_listTypeToImplement *) NULL ;
    macroMyNew (ptr_, cPtr_C_listTypeToImplement (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeDefinitionTableAimplementer'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefinitionTableAimplementer::cPtr_typeDefinitionTableAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_insertOrSearchMethodList & argument_5,
                                const GGS_typeTableBlocsDeTable & argument_6 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomTable (argument_0),
mNonExternAttributesList (argument_1),
mExternAttributesList (argument_2),
aNomClasseGenerique (argument_3),
mInsertMethodList (argument_4),
mSearchMethodList (argument_5),
aTableMethodesSurcharger (argument_6) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDefinitionTableAimplementer::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDefinitionTableAimplementer:" ;
aNomTable.reader_description  (_inLexique COMMA_THERE) ;
mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE) ;
mExternAttributesList.reader_description  (_inLexique COMMA_THERE) ;
aNomClasseGenerique.reader_description  (_inLexique COMMA_THERE) ;
mInsertMethodList.reader_description  (_inLexique COMMA_THERE) ;
mSearchMethodList.reader_description  (_inLexique COMMA_THERE) ;
aTableMethodesSurcharger.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeDefinitionTableAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefinitionTableAimplementer * GGS_typeDefinitionTableAimplementer::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_insertOrSearchMethodList & argument_5,
                                const GGS_typeTableBlocsDeTable & argument_6 COMMA_LOCATION_ARGS) {
    cPtr_typeDefinitionTableAimplementer * ptr_ = (cPtr_typeDefinitionTableAimplementer *) NULL ;
    macroMyNew (ptr_, cPtr_typeDefinitionTableAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_mapToImplement'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_mapToImplement::cPtr_C_mapToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_insertOrSearchMethodList & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomTable (argument_0),
mNonExternAttributesList (argument_1),
mExternAttributesList (argument_2),
mInsertMethodList (argument_3),
mSearchMethodList (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_C_mapToImplement::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_mapToImplement:" ;
aNomTable.reader_description  (_inLexique COMMA_THERE) ;
mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE) ;
mExternAttributesList.reader_description  (_inLexique COMMA_THERE) ;
mInsertMethodList.reader_description  (_inLexique COMMA_THERE) ;
mSearchMethodList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_mapToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_mapToImplement * GGS_C_mapToImplement::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_insertOrSearchMethodList & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4 COMMA_LOCATION_ARGS) {
    cPtr_C_mapToImplement * ptr_ = (cPtr_C_mapToImplement *) NULL ;
    macroMyNew (ptr_, cPtr_C_mapToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeDefClasseAbstraiteAimplementer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefClasseAbstraiteAimplementer::cPtr_typeDefClasseAbstraiteAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomClasse (argument_0),
aListeTousAttributsNonExternes (argument_1),
aTableToutesMethodes (argument_2),
mMethodsMap (argument_3),
aListeAttributsCourants (argument_4),
aListeExternesCourants (argument_5),
mAncestorClassesMap (argument_6),
mMessagesMap (argument_7) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDefClasseAbstraiteAimplementer::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDefClasseAbstraiteAimplementer:" ;
aNomClasse.reader_description  (_inLexique COMMA_THERE) ;
aListeTousAttributsNonExternes.reader_description  (_inLexique COMMA_THERE) ;
aTableToutesMethodes.reader_description  (_inLexique COMMA_THERE) ;
mMethodsMap.reader_description  (_inLexique COMMA_THERE) ;
aListeAttributsCourants.reader_description  (_inLexique COMMA_THERE) ;
aListeExternesCourants.reader_description  (_inLexique COMMA_THERE) ;
mAncestorClassesMap.reader_description  (_inLexique COMMA_THERE) ;
mMessagesMap.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeDefClasseAbstraiteAimplementer'            *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefClasseAbstraiteAimplementer * GGS_typeDefClasseAbstraiteAimplementer::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS) {
    cPtr_typeDefClasseAbstraiteAimplementer * ptr_ = (cPtr_typeDefClasseAbstraiteAimplementer *) NULL ;
    macroMyNew (ptr_, cPtr_typeDefClasseAbstraiteAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'typeDefClasseNonAbstraiteAimplementer'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefClasseNonAbstraiteAimplementer::cPtr_typeDefClasseNonAbstraiteAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomClasse (argument_0),
aListeTousAttributsNonExternes (argument_1),
aTableToutesMethodes (argument_2),
mMethodsMap (argument_3),
aListeAttributsCourants (argument_4),
aListeExternesCourants (argument_5),
mAncestorClassesMap (argument_6),
mMessagesMap (argument_7) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDefClasseNonAbstraiteAimplementer::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDefClasseNonAbstraiteAimplementer:" ;
aNomClasse.reader_description  (_inLexique COMMA_THERE) ;
aListeTousAttributsNonExternes.reader_description  (_inLexique COMMA_THERE) ;
aTableToutesMethodes.reader_description  (_inLexique COMMA_THERE) ;
mMethodsMap.reader_description  (_inLexique COMMA_THERE) ;
aListeAttributsCourants.reader_description  (_inLexique COMMA_THERE) ;
aListeExternesCourants.reader_description  (_inLexique COMMA_THERE) ;
mAncestorClassesMap.reader_description  (_inLexique COMMA_THERE) ;
mMessagesMap.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_typeDefClasseNonAbstraiteAimplementer'          *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefClasseNonAbstraiteAimplementer * GGS_typeDefClasseNonAbstraiteAimplementer::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS) {
    cPtr_typeDefClasseNonAbstraiteAimplementer * ptr_ = (cPtr_typeDefClasseNonAbstraiteAimplementer *) NULL ;
    macroMyNew (ptr_, cPtr_typeDefClasseNonAbstraiteAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeEntiteActionExterne'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteActionExterne::cPtr_typeEntiteActionExterne (const GGS_L_EXsignature & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aSignature (argument_0) {
}


const char * cPtr_typeEntiteActionExterne::message_messageTypeEntite (void) const {
  return "an external action" ;
}

const char * cPtr_typeEntiteActionExterne::static_string_message_messageTypeEntite (void) {
  return "an external action" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteActionExterne::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteActionExterne:" ;
aSignature.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeEntiteActionExterne'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteActionExterne * GGS_typeEntiteActionExterne::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_L_EXsignature & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeEntiteActionExterne * ptr_ = (cPtr_typeEntiteActionExterne *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteActionExterne (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeActionExterneAengendrer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeActionExterneAengendrer::cPtr_typeActionExterneAengendrer (const GGS_lstring & argument_0,
                                const GGS_L_EXsignature & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomAction (argument_0),
aSignature (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeActionExterneAengendrer::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeActionExterneAengendrer:" ;
aNomAction.reader_description  (_inLexique COMMA_THERE) ;
aSignature.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeActionExterneAengendrer'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeActionExterneAengendrer * GGS_typeActionExterneAengendrer::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_L_EXsignature & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeActionExterneAengendrer * ptr_ = (cPtr_typeActionExterneAengendrer *) NULL ;
    macroMyNew (ptr_, cPtr_typeActionExterneAengendrer (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@typeEntitiesToGenerateList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEntitiesToGenerateList::
elementOf_GGS_typeEntitiesToGenerateList (const GGS_typeEntityToGenerate & argument_0):
mNextItem (NULL),
mEntityToGenerate (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEntitiesToGenerateList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mEntityToGenerate.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@typeEntitiesToGenerateList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::GGS_typeEntitiesToGenerateList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::~GGS_typeEntitiesToGenerateList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::
GGS_typeEntitiesToGenerateList (const GGS_typeEntitiesToGenerateList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
operator = (const GGS_typeEntitiesToGenerateList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::element_type * GGS_typeEntitiesToGenerateList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
internalAppendItem (const GGS_typeEntityToGenerate & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
addAssign_operation (const GGS_typeEntityToGenerate & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mEntityToGenerate) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList  GGS_typeEntitiesToGenerateList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEntitiesToGenerateList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeEntitiesToGenerateList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntitiesToGenerateList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeEntitiesToGenerateList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeEntitiesToGenerateList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "enterBuiltinTypes"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterBuiltinTypes (C_Lexique & _inLexique,
                                GGS_M_semanticsEntitiesForUse  & var_cas_ioComponentSemanticsEntitiesMap COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_ioComponentSemanticsEntitiesMap = GGS_M_semanticsEntitiesForUse::constructor_emptyMap (_inLexique COMMA_HERE) ;
  GGS_lstring  var_cas_name ;
  var_cas_name = GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lstring"), GGS_location (_inLexique) COMMA_HERE) ;
  GGS_AC_galgasType  var_cas_t ;
  var_cas_t = GGS_typeGalgas_lstring::constructor_new (_inLexique COMMA_HERE) ;
  GGS_AC_semanticsEntity  var_cas_e ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1296)) ;
  var_cas_name = GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lbool"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_lbool::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1301)) ;
  var_cas_name = GGS_lstring::constructor_new (_inLexique, GGS_string (true, "luint"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_luint::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1306)) ;
  var_cas_name = GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lsint"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_lsint::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1311)) ;
  var_cas_name = GGS_lstring::constructor_new (_inLexique, GGS_string (true, "ldouble"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_ldouble::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1316)) ;
  var_cas_name = GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lchar"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_lchar::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1321)) ;
  var_cas_name = GGS_lstring::constructor_new (_inLexique, GGS_string (true, "location"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1326)) ;
  var_cas_name = GGS_lstring::constructor_new (_inLexique, GGS_string (true, "uint"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1331)) ;
  var_cas_name = GGS_lstring::constructor_new (_inLexique, GGS_string (true, "sint"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_sint::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1336)) ;
  var_cas_name = GGS_lstring::constructor_new (_inLexique, GGS_string (true, "char"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_char::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1341)) ;
  var_cas_name = GGS_lstring::constructor_new (_inLexique, GGS_string (true, "string"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1346)) ;
  var_cas_name = GGS_lstring::constructor_new (_inLexique, GGS_string (true, "bool"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_bool::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1351)) ;
  var_cas_name = GGS_lstring::constructor_new (_inLexique, GGS_string (true, "double"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_double::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1356)) ;
  var_cas_name = GGS_lstring::constructor_new (_inLexique, GGS_string (true, "stringset"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_stringset::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1361)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map 'typeEnumCstMessageStringMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumCstMessageStringMap::
elementOf_GGS_typeEnumCstMessageStringMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumCstMessageStringMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEnumCstMessageStringMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mMessageString.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumCstMessageStringMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeEnumCstMessageStringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumCstMessageStringMap * info = (e_typeEnumCstMessageStringMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeEnumCstMessageStringMap info  ;
    info.mMessageString = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessageString ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the message for '%K' constant is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the message for '%K' constant is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeEnumCstMessageStringMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumCstMessageStringMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEnumCstMessageStringMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeEnumCstMessageStringMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'enumGalgasType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumGalgasType::cPtr_enumGalgasType (const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mEnumTypeName (argument_0),
mConstantMap (argument_1),
mEnumMessageMap (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_enumGalgasType::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@enumGalgasType:" ;
mEnumTypeName.reader_description  (_inLexique COMMA_THERE) ;
mConstantMap.reader_description  (_inLexique COMMA_THERE) ;
mEnumMessageMap.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_enumGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumGalgasType * GGS_enumGalgasType::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_enumGalgasType * ptr_ = (cPtr_enumGalgasType *) NULL ;
    macroMyNew (ptr_, cPtr_enumGalgasType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'mapAsConstraintPropertyMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapAsConstraintPropertyMap::
elementOf_GGS_mapAsConstraintPropertyMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapAsConstraintPropertyMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapAsConstraintPropertyMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mMapTypeName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mElementTypeName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mPassIndex.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mPassName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mIsShared.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapAsConstraintPropertyMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapAsConstraintPropertyMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapAsConstraintPropertyMap * info = (e_mapAsConstraintPropertyMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_mapAsConstraintPropertyMap GGS_mapAsConstraintPropertyMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapAsConstraintPropertyMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapAsConstraintPropertyMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAsConstraintPropertyMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               const GGS_lstring &  inParameter1,
               const GGS_uint &  inParameter2,
               const GGS_string&  inParameter3,
               const GGS_bool&  inParameter4,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_mapAsConstraintPropertyMap info  ;
    info.mMapTypeName = inParameter0 ;
    info.mElementTypeName = inParameter1 ;
    info.mPassIndex = inParameter2 ;
    info.mPassName = inParameter3 ;
    info.mIsShared = inParameter4 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapAsConstraintPropertyMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_uint   & outParameter2,
               GGS_string  & outParameter3,
               GGS_bool  & outParameter4,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    outParameter4.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMapTypeName ;
    outParameter1 = node->mInfo.mElementTypeName ;
    outParameter2 = node->mInfo.mPassIndex ;
    outParameter3 = node->mInfo.mPassName ;
    outParameter4 = node->mInfo.mIsShared ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapAsConstraintPropertyMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_uint   & outParameter2,
                                GGS_string  & outParameter3,
                                GGS_bool  & outParameter4 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' map property is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAsConstraintPropertyMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_uint & inParameter2,
                                const GGS_string& inParameter3,
                                const GGS_bool& inParameter4 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' map property has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapAsConstraintPropertyMap GGS_mapAsConstraintPropertyMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_mapAsConstraintPropertyMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapAsConstraintPropertyMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapAsConstraintPropertyMap GGS_mapAsConstraintPropertyMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapAsConstraintPropertyMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapAsConstraintPropertyMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @mapAsConstraintPropertyMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'passMap'                             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_passMap::
elementOf_GGS_passMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_passMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_passMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_passMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_passMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_passMap * info = (e_passMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_passMap GGS_passMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_passMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_passMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_passMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_passMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_passMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_passMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' pass name is not declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_passMap::method_searchKeyAndGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' pass name is not declared",
                 inKey,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_passMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' pass name has been already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_passMap GGS_passMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_passMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_passMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_passMap GGS_passMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_passMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_passMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @passMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@sharedPropertyList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sharedPropertyList::
elementOf_GGS_sharedPropertyList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1):
mNextItem (NULL),
mSharedPropertyTypeName (argument_0),
mSharedPropertyName (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sharedPropertyList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mSharedPropertyTypeName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mSharedPropertyName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@sharedPropertyList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sharedPropertyList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_sharedPropertyList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_sharedPropertyList::GGS_sharedPropertyList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_sharedPropertyList::~GGS_sharedPropertyList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_sharedPropertyList::
GGS_sharedPropertyList (const GGS_sharedPropertyList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sharedPropertyList::
operator = (const GGS_sharedPropertyList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sharedPropertyList::element_type * GGS_sharedPropertyList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_sharedPropertyList::
internalAppendItem (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sharedPropertyList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sharedPropertyList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mSharedPropertyTypeName,
                                p->mSharedPropertyName) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sharedPropertyList  GGS_sharedPropertyList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_sharedPropertyList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_sharedPropertyList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sharedPropertyList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @sharedPropertyList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_sharedPropertyList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_sharedPropertyList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class map 'callInstructionSharedPropertySignatureMap'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_callInstructionSharedPropertySignatureMap::
elementOf_GGS_callInstructionSharedPropertySignatureMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_callInstructionSharedPropertySignatureMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_callInstructionSharedPropertySignatureMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mSignature.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mSignatureLocation.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_callInstructionSharedPropertySignatureMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_callInstructionSharedPropertySignatureMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_callInstructionSharedPropertySignatureMap * info = (e_callInstructionSharedPropertySignatureMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_callInstructionSharedPropertySignatureMap GGS_callInstructionSharedPropertySignatureMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_callInstructionSharedPropertySignatureMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_sharedPropertyList &  inParameter0,
               const GGS_location &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_callInstructionSharedPropertySignatureMap info  ;
    info.mSignature = inParameter0 ;
    info.mSignatureLocation = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_sharedPropertyList   & outParameter0,
               GGS_location   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mSignature ;
    outParameter1 = node->mInfo.mSignatureLocation ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_sharedPropertyList   & outParameter0,
                                GGS_location   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "internal error: the '%K' property is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_sharedPropertyList & inParameter0,
                                const GGS_location & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "internal error: the '%K' property has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_callInstructionSharedPropertySignatureMap GGS_callInstructionSharedPropertySignatureMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_callInstructionSharedPropertySignatureMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_callInstructionSharedPropertySignatureMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_callInstructionSharedPropertySignatureMap GGS_callInstructionSharedPropertySignatureMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_callInstructionSharedPropertySignatureMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_callInstructionSharedPropertySignatureMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @callInstructionSharedPropertySignatureMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map 'constrainedEntityPassMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_constrainedEntityPassMap::
elementOf_GGS_constrainedEntityPassMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_constrainedEntityPassMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constrainedEntityPassMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mInstructionList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mSharedPropertyList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mConstraintPropertyDefinitionSet.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mCallInstructionSharedPropertySignatureMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constrainedEntityPassMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_constrainedEntityPassMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constrainedEntityPassMap * info = (e_constrainedEntityPassMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_constrainedEntityPassMap GGS_constrainedEntityPassMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constrainedEntityPassMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityPassMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityPassMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeInstructionList &  inParameter0,
               const GGS_sharedPropertyList &  inParameter1,
               const GGS_stringset &  inParameter2,
               const GGS_callInstructionSharedPropertySignatureMap &  inParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_constrainedEntityPassMap info  ;
    info.mInstructionList = inParameter0 ;
    info.mSharedPropertyList = inParameter1 ;
    info.mConstraintPropertyDefinitionSet = inParameter2 ;
    info.mCallInstructionSharedPropertySignatureMap = inParameter3 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityPassMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeInstructionList   & outParameter0,
               GGS_sharedPropertyList   & outParameter1,
               GGS_stringset   & outParameter2,
               GGS_callInstructionSharedPropertySignatureMap   & outParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mInstructionList ;
    outParameter1 = node->mInfo.mSharedPropertyList ;
    outParameter2 = node->mInfo.mConstraintPropertyDefinitionSet ;
    outParameter3 = node->mInfo.mCallInstructionSharedPropertySignatureMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityPassMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeInstructionList   & outParameter0,
                                GGS_sharedPropertyList   & outParameter1,
                                GGS_stringset   & outParameter2,
                                GGS_callInstructionSharedPropertySignatureMap   & outParameter3 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' pass name is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityPassMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeInstructionList & inParameter0,
                                const GGS_sharedPropertyList & inParameter1,
                                const GGS_stringset & inParameter2,
                                const GGS_callInstructionSharedPropertySignatureMap & inParameter3 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' pass name has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_constrainedEntityPassMap GGS_constrainedEntityPassMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_constrainedEntityPassMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constrainedEntityPassMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constrainedEntityPassMap GGS_constrainedEntityPassMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constrainedEntityPassMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constrainedEntityPassMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @constrainedEntityPassMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'constraintAllPropertiesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_constraintAllPropertiesMap::
elementOf_GGS_constraintAllPropertiesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_constraintAllPropertiesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constraintAllPropertiesMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constraintAllPropertiesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_constraintAllPropertiesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constraintAllPropertiesMap * info = (e_constraintAllPropertiesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_constraintAllPropertiesMap GGS_constraintAllPropertiesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constraintAllPropertiesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constraintAllPropertiesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_constraintAllPropertiesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_constraintAllPropertiesMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constraintAllPropertiesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_constraintAllPropertiesMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' constraint attribute has been already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_constraintAllPropertiesMap GGS_constraintAllPropertiesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_constraintAllPropertiesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constraintAllPropertiesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constraintAllPropertiesMap GGS_constraintAllPropertiesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constraintAllPropertiesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constraintAllPropertiesMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @constraintAllPropertiesMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'indexMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_indexMap::
elementOf_GGS_indexMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_indexMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_indexMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mMapTypeName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mPassIndex.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_indexMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_indexMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_indexMap * info = (e_indexMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_indexMap GGS_indexMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_indexMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_indexMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_indexMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               const GGS_uint &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_indexMap info  ;
    info.mMapTypeName = inParameter0 ;
    info.mPassIndex = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_indexMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_uint   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMapTypeName ;
    outParameter1 = node->mInfo.mPassIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_indexMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_uint   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' constraint attribute is not defined",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_indexMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_uint & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' constraint attribute is already defined in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_indexMap GGS_indexMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_indexMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_indexMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_indexMap GGS_indexMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_indexMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_indexMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @indexMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'constrainedEntityMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_constrainedEntityMap::
elementOf_GGS_constrainedEntityMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_constrainedEntityMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constrainedEntityMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mPassesDefinedByInheritanceTreeRootEntity.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mConstrainedEntityPassMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mSuperEntityName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mEntityPropertiesMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mDescendantEntitySet.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mEndOfConstraintLocation.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mMapAsConstraintPropertyCurrentMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mAllMapsAsConstraintPropertyMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mConstraintAllPropertiesMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mCurrentIndexMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mInheritedIndexMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constrainedEntityMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_constrainedEntityMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constrainedEntityMap * info = (e_constrainedEntityMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_constrainedEntityMap GGS_constrainedEntityMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constrainedEntityMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_stringset &  inParameter0,
               const GGS_constrainedEntityPassMap &  inParameter1,
               const GGS_lstring &  inParameter2,
               const GGS_entityPropertyMap &  inParameter3,
               const GGS_stringset &  inParameter4,
               const GGS_location &  inParameter5,
               const GGS_mapAsConstraintPropertyMap &  inParameter6,
               const GGS_mapAsConstraintPropertyMap &  inParameter7,
               const GGS_constraintAllPropertiesMap &  inParameter8,
               const GGS_indexMap &  inParameter9,
               const GGS_indexMap &  inParameter10,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_constrainedEntityMap info  ;
    info.mPassesDefinedByInheritanceTreeRootEntity = inParameter0 ;
    info.mConstrainedEntityPassMap = inParameter1 ;
    info.mSuperEntityName = inParameter2 ;
    info.mEntityPropertiesMap = inParameter3 ;
    info.mDescendantEntitySet = inParameter4 ;
    info.mEndOfConstraintLocation = inParameter5 ;
    info.mMapAsConstraintPropertyCurrentMap = inParameter6 ;
    info.mAllMapsAsConstraintPropertyMap = inParameter7 ;
    info.mConstraintAllPropertiesMap = inParameter8 ;
    info.mCurrentIndexMap = inParameter9 ;
    info.mInheritedIndexMap = inParameter10 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_stringset   & outParameter0,
               GGS_constrainedEntityPassMap   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_entityPropertyMap   & outParameter3,
               GGS_stringset   & outParameter4,
               GGS_location   & outParameter5,
               GGS_mapAsConstraintPropertyMap   & outParameter6,
               GGS_mapAsConstraintPropertyMap   & outParameter7,
               GGS_constraintAllPropertiesMap   & outParameter8,
               GGS_indexMap   & outParameter9,
               GGS_indexMap   & outParameter10,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    outParameter4.drop_operation () ;
    outParameter5.drop_operation () ;
    outParameter6.drop_operation () ;
    outParameter7.drop_operation () ;
    outParameter8.drop_operation () ;
    outParameter9.drop_operation () ;
    outParameter10.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mPassesDefinedByInheritanceTreeRootEntity ;
    outParameter1 = node->mInfo.mConstrainedEntityPassMap ;
    outParameter2 = node->mInfo.mSuperEntityName ;
    outParameter3 = node->mInfo.mEntityPropertiesMap ;
    outParameter4 = node->mInfo.mDescendantEntitySet ;
    outParameter5 = node->mInfo.mEndOfConstraintLocation ;
    outParameter6 = node->mInfo.mMapAsConstraintPropertyCurrentMap ;
    outParameter7 = node->mInfo.mAllMapsAsConstraintPropertyMap ;
    outParameter8 = node->mInfo.mConstraintAllPropertiesMap ;
    outParameter9 = node->mInfo.mCurrentIndexMap ;
    outParameter10 = node->mInfo.mInheritedIndexMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_stringset   & outParameter0,
                                GGS_constrainedEntityPassMap   & outParameter1,
                                GGS_lstring   & outParameter2,
                                GGS_entityPropertyMap   & outParameter3,
                                GGS_stringset   & outParameter4,
                                GGS_location   & outParameter5,
                                GGS_mapAsConstraintPropertyMap   & outParameter6,
                                GGS_mapAsConstraintPropertyMap   & outParameter7,
                                GGS_constraintAllPropertiesMap   & outParameter8,
                                GGS_indexMap   & outParameter9,
                                GGS_indexMap   & outParameter10 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "no constraint has been defined for the '@%K' entity",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 outParameter8,
                 outParameter9,
                 outParameter10,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_stringset & inParameter0,
                                const GGS_constrainedEntityPassMap & inParameter1,
                                const GGS_lstring & inParameter2,
                                const GGS_entityPropertyMap & inParameter3,
                                const GGS_stringset & inParameter4,
                                const GGS_location & inParameter5,
                                const GGS_mapAsConstraintPropertyMap & inParameter6,
                                const GGS_mapAsConstraintPropertyMap & inParameter7,
                                const GGS_constraintAllPropertiesMap & inParameter8,
                                const GGS_indexMap & inParameter9,
                                const GGS_indexMap & inParameter10 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "constraints for '@%K' entity has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 inParameter8,
                 inParameter9,
                 inParameter10,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_constrainedEntityMap GGS_constrainedEntityMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_constrainedEntityMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constrainedEntityMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constrainedEntityMap GGS_constrainedEntityMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constrainedEntityMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constrainedEntityMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @constrainedEntityMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'callInstruction'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_callInstruction::cPtr_callInstruction (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_metamodelPropertyKind& argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_L_lstringList & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mCurrentPassName (argument_0),
mCalledPropertyName (argument_1),
mPropertyKind (argument_2),
mPropertyTypeName (argument_3),
mParameterList (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_callInstruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@callInstruction:" ;
mCurrentPassName.reader_description  (_inLexique COMMA_THERE) ;
mCalledPropertyName.reader_description  (_inLexique COMMA_THERE) ;
mPropertyKind.reader_description  (_inLexique COMMA_THERE) ;
mPropertyTypeName.reader_description  (_inLexique COMMA_THERE) ;
mParameterList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_callInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_callInstruction * GGS_callInstruction::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_metamodelPropertyKind& argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_L_lstringList & argument_4 COMMA_LOCATION_ARGS) {
    cPtr_callInstruction * ptr_ = (cPtr_callInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_callInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "displayConstraintDefinitionErrors"        *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_displayConstraintDefinitionErrors (C_Lexique & _inLexique,
                                GGS_stringset   var_cas_inFirstBranchconstraintDefinitionSet,
                                GGS_stringset   var_cas_inCurrentBranchconstraintDefinitionSet COMMA_UNUSED_LOCATION_ARGS) {
  GGS_stringset  var_cas_missingDefinition ;
  var_cas_missingDefinition = var_cas_inFirstBranchconstraintDefinitionSet.substract_operation (_inLexique, var_cas_inCurrentBranchconstraintDefinitionSet SOURCE_FILE_AT_LINE (1515)) ;
  GGS_stringset::element_type * operand_63989 = var_cas_missingDefinition.firstObject () ;
  while ((operand_63989 != NULL)) {
    macroValidPointer (operand_63989) ;
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "the '")) + (operand_63989->mKey))) + (GGS_string (true, "' property is initialized by first branch, but not by this one"))) SOURCE_FILE_AT_LINE (1518)) ;
    operand_63989 = operand_63989->nextObject () ;
  }
  GGS_stringset  var_cas_unexpectedDefinition ;
  var_cas_unexpectedDefinition = var_cas_inCurrentBranchconstraintDefinitionSet.substract_operation (_inLexique, var_cas_inFirstBranchconstraintDefinitionSet SOURCE_FILE_AT_LINE (1519)) ;
  GGS_stringset::element_type * operand_64286 = var_cas_unexpectedDefinition.firstObject () ;
  while ((operand_64286 != NULL)) {
    macroValidPointer (operand_64286) ;
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "the '")) + (operand_64286->mKey))) + (GGS_string (true, "' property is not initialized by first branch, but by this one"))) SOURCE_FILE_AT_LINE (1522)) ;
    operand_64286 = operand_64286->nextObject () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Implementation of routine "displayConstraintDefinitionErrorsNoElse"     *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_displayConstraintDefinitionErrorsNoElse (C_Lexique & _inLexique,
                                GGS_stringset   var_cas_inFirstBranchConstraintDefinitionSet,
                                GGS_stringset   var_cas_inInheritedConstraintDefinitionSet COMMA_UNUSED_LOCATION_ARGS) {
  GGS_stringset  var_cas_missingDefinition ;
  var_cas_missingDefinition = var_cas_inFirstBranchConstraintDefinitionSet.substract_operation (_inLexique, var_cas_inInheritedConstraintDefinitionSet SOURCE_FILE_AT_LINE (1531)) ;
  GGS_stringset::element_type * operand_64822 = var_cas_missingDefinition.firstObject () ;
  while ((operand_64822 != NULL)) {
    macroValidPointer (operand_64822) ;
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "the '")) + (operand_64822->mKey))) + (GGS_string (true, "' property is initialized by first branch, but there is no else branch"))) SOURCE_FILE_AT_LINE (1534)) ;
    operand_64822 = operand_64822->nextObject () ;
  }
}

//---------------------------------------------------------------------------*

