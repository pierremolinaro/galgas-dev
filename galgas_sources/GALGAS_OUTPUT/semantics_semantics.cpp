//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semantics_semantics.cpp'                       *
//               Generated by version 0.14.1 (LL(1) grammar)                 *
//                     august 31th, 2005, at 11h57'11"                       *
//                                                                           *
// This program is free software; you can redistribute it and/or modify it   *
// under the terms of the GNU General Public License as published by the     *
// Free Software Foundation.                                                 *
//                                                                           *
// This program is distributed in the hope it will be useful, but WITHOUT    *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *
// more details.                                                             *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semantics_semantics.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               Include directives generated by extern types                *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cGalgasVariablesMap.hh"
#include "cTableMethodesAimplementer.hh"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeCplusPlusName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCplusPlusName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (void) {
  mPointer = (cPtr_typeCplusPlusName *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (const GGS_typeCplusPlusName & inOperand) {
  mPointer = (cPtr_typeCplusPlusName *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
~GGS_typeCplusPlusName (void) {
  macroDetachPointer (mPointer, cPtr_typeCplusPlusName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName::
operator = (const GGS_typeCplusPlusName & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeCplusPlusName::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName::
operator = (cPtr_typeCplusPlusName * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (cPtr_typeCplusPlusName * inSource) {
  mPointer = (cPtr_typeCplusPlusName *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeCplusPlusName * GGS_typeCplusPlusName
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCplusPlusName) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeDirectName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectName::cPtr_typeDirectName (const GGS_lstring & argument_0)
:mName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeDirectName::isBuilt (void) const {
  return mName.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeDirectName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDirectName * GGS_typeDirectName::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeDirectName * ptr_ = (cPtr_typeDirectName *) NULL ;
    macroMyNew (ptr_, cPtr_typeDirectName (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeCppThisName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeCppThisName::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeCppThisName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeCppThisName * GGS_typeCppThisName::
    constructor_new () {
    cPtr_typeCppThisName * ptr_ = (cPtr_typeCppThisName *) NULL ;
    macroMyNew (ptr_, cPtr_typeCppThisName ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeCppInheritedName'                        *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeCppInheritedName::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCppInheritedName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeCppInheritedName * GGS_typeCppInheritedName::
    constructor_new () {
    cPtr_typeCppInheritedName * ptr_ = (cPtr_typeCppInheritedName *) NULL ;
    macroMyNew (ptr_, cPtr_typeCppInheritedName ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeAutomaticName'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAutomaticName::cPtr_typeAutomaticName (const GGS_lstring & argument_0)
:mName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeAutomaticName::isBuilt (void) const {
  return mName.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAutomaticName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeAutomaticName * GGS_typeAutomaticName::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeAutomaticName * ptr_ = (cPtr_typeAutomaticName *) NULL ;
    macroMyNew (ptr_, cPtr_typeAutomaticName (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLocationAutomaticName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLocationAutomaticName::cPtr_typeLocationAutomaticName (const GGS_location & argument_0)
:mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeLocationAutomaticName::isBuilt (void) const {
  return mLocation.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLocationAutomaticName'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeLocationAutomaticName * GGS_typeLocationAutomaticName::
    constructor_new (const GGS_location & argument_0) {
    cPtr_typeLocationAutomaticName * ptr_ = (cPtr_typeLocationAutomaticName *) NULL ;
    macroMyNew (ptr_, cPtr_typeLocationAutomaticName (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeOperandName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOperandName::cPtr_typeOperandName (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2)
:mName (argument_0),
mLocationOffset (argument_1),
mFieldKind (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeOperandName::isBuilt (void) const {
  return mName.isBuilt () &&
       mLocationOffset.isBuilt () &&
       mFieldKind.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOperandName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeOperandName * GGS_typeOperandName::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2) {
    cPtr_typeOperandName * ptr_ = (cPtr_typeOperandName *) NULL ;
    macroMyNew (ptr_, cPtr_typeOperandName (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeKeyName'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeKeyName::cPtr_typeKeyName (const GGS_location & argument_0)
:mLocationOffset (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeKeyName::isBuilt (void) const {
  return mLocationOffset.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeKeyName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeKeyName * GGS_typeKeyName::
    constructor_new (const GGS_location & argument_0) {
    cPtr_typeKeyName * ptr_ = (cPtr_typeKeyName *) NULL ;
    macroMyNew (ptr_, cPtr_typeKeyName (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeNullName'                            *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeNullName::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeNullName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeNullName * GGS_typeNullName::
    constructor_new () {
    cPtr_typeNullName * ptr_ = (cPtr_typeNullName *) NULL ;
    macroMyNew (ptr_, cPtr_typeNullName ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Class element of list 'typeCplusPlusNameList'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::element_type::
element_type (const GGS_typeCplusPlusName & argument_0) {
  mNextItem = (element_type *) NULL ;
  mCppName = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class list 'typeCplusPlusNameList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList
::GGS_typeCplusPlusNameList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::~GGS_typeCplusPlusNameList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::GGS_typeCplusPlusNameList (const GGS_typeCplusPlusNameList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList
::operator = (const GGS_typeCplusPlusNameList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
internalAppendItem (const GGS_typeCplusPlusName & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCppName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeCplusPlusNameList::
constructor_empty (void) {
  GGS_typeCplusPlusNameList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (void) {
  mPointer = (cPtr_typeExpression *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (const GGS_typeExpression & inOperand) {
  mPointer = (cPtr_typeExpression *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
~GGS_typeExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpression::
operator = (const GGS_typeExpression & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeExpression::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpression::
operator = (cPtr_typeExpression * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (cPtr_typeExpression * inSource) {
  mPointer = (cPtr_typeExpression *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeExpression * GGS_typeExpression
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpression
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeExpression) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'typeClassMessagesMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeClassMessagesMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassMessagesMap::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeClassMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeClassMessagesMap * info = (e_typeClassMessagesMap *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeClassMessagesMap::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_typeClassMessagesMap::element_type::stringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::constructor_empty (void) {
  GGS_typeClassMessagesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassMessagesMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_typeClassMessagesMap info  ;
    info.mMessage = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_lstring   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mMessage ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeClassMessagesMap (C_Lexique & inLexique,
                                GGS_typeClassMessagesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_lstring   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the message '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeClassMessagesMap (C_Lexique & lexique_var_,
                                GGS_typeClassMessagesMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the message '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Class element of list 'typeSemanticsTypesList'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::element_type::
element_type (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (element_type *) NULL ;
  mType = argument_0 ;
  mGalgasVariableName = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class list 'typeSemanticsTypesList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList
::GGS_typeSemanticsTypesList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::~GGS_typeSemanticsTypesList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::GGS_typeSemanticsTypesList (const GGS_typeSemanticsTypesList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList
::operator = (const GGS_typeSemanticsTypesList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mGalgasVariableName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList  GGS_typeSemanticsTypesList::
constructor_empty (void) {
  GGS_typeSemanticsTypesList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map element 'e_typeVariablesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

template class cGalgasVariablesMap <e_typeVariablesMap, GGS_lstring> ;

//---------------------------------------------------------------------------*

bool e_typeVariablesMap::isBuilt (void) const {
  return mArgumentType.isBuilt () &&
       mCplusPlusName.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          Map 'typeVariablesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void searchForReadOnlyAccess_typeVariablesMap (C_Lexique & inLexique,
                                GGS_typeVariablesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   * outParameter0,
                                GGS_typeCplusPlusName   * outParameter1,
                                GGS_luint * outIndex) {
  const char * errorMessage_0 = "the variable '%' is not declared" ;
  const char * errorMessage_1 = "the variable '%' cannot be accessed in read only mode" ;
  GGS_typeVariablesMap::element_type * info = ioMap.searchForReadOnlyAccess (inLexique, inKey, inKey, errorMessage_0, errorMessage_1) ;
  if (info == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
    }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = info->mInfo.mArgumentType ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = info->mInfo.mCplusPlusName ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchForDestructiveReadAccess_typeVariablesMap (C_Lexique & inLexique,
                                GGS_typeVariablesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   * outParameter0,
                                GGS_typeCplusPlusName   * outParameter1,
                                GGS_luint * outIndex) {
  const char * errorMessage_0 = "the variable '%' is not declared" ;
  const char * errorMessage_1 = "the variable '%' cannot be accessed in destructive read mode" ;
  GGS_typeVariablesMap::element_type * info = ioMap.searchForDestructiveReadAccess (inLexique, inKey, inKey, errorMessage_0, errorMessage_1) ;
  if (info == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
    }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = info->mInfo.mArgumentType ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = info->mInfo.mCplusPlusName ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchForReadWriteAccess_typeVariablesMap (C_Lexique & inLexique,
                                GGS_typeVariablesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   * outParameter0,
                                GGS_typeCplusPlusName   * outParameter1,
                                GGS_luint * outIndex) {
  const char * errorMessage_0 = "the variable '%' is not declared" ;
  const char * errorMessage_1 = "the variable '%' cannot be accessed in read/write mode" ;
  GGS_typeVariablesMap::element_type * info = ioMap.searchForReadWriteAccess (inLexique, inKey, inKey, errorMessage_0, errorMessage_1) ;
  if (info == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
    }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = info->mInfo.mArgumentType ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = info->mInfo.mCplusPlusName ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchForWriteAccess_typeVariablesMap (C_Lexique & inLexique,
                                GGS_typeVariablesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   * outParameter0,
                                GGS_typeCplusPlusName   * outParameter1,
                                GGS_luint * outIndex) {
  const char * errorMessage_0 = "the variable '%' is not declared" ;
  const char * errorMessage_1 = "the variable '%' cannot be accessed in write mode" ;
  GGS_typeVariablesMap::element_type * info = ioMap.searchForWriteAccess (inLexique, inKey, inKey, errorMessage_0, errorMessage_1) ;
  if (info == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
    }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = info->mInfo.mArgumentType ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = info->mInfo.mCplusPlusName ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void insertInArgument_typeVariablesMap (C_Lexique & lexique_var_,
                                GGS_typeVariablesMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage_0 = "the variable '%' is already declared" ;
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = ioMap.insertInArgument (lexique_var_, info, inKey, inKey, kErrorMessage_0) ;
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void insertConstInArgument_typeVariablesMap (C_Lexique & lexique_var_,
                                GGS_typeVariablesMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage_0 = "the variable '%' is already declared" ;
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = ioMap.insertConstInArgument (lexique_var_, info, inKey, inKey, kErrorMessage_0) ;
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void insertUsedConstInArgument_typeVariablesMap (C_Lexique & lexique_var_,
                                GGS_typeVariablesMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage_0 = "the variable '%' is already declared" ;
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = ioMap.insertUsedConstInArgument (lexique_var_, info, inKey, inKey, kErrorMessage_0) ;
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void insertUnusedConstInArgument_typeVariablesMap (C_Lexique & lexique_var_,
                                GGS_typeVariablesMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage_0 = "the variable '%' is already declared" ;
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = ioMap.insertUnusedConstInArgument (lexique_var_, info, inKey, inKey, kErrorMessage_0) ;
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void insertLocalVariable_typeVariablesMap (C_Lexique & lexique_var_,
                                GGS_typeVariablesMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage_0 = "the variable '%' is already declared" ;
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = ioMap.insertLocalVariable (lexique_var_, info, inKey, inKey, kErrorMessage_0) ;
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void insertOutArgument_typeVariablesMap (C_Lexique & lexique_var_,
                                GGS_typeVariablesMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage_0 = "the variable '%' is already declared" ;
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = ioMap.insertOutArgument (lexique_var_, info, inKey, inKey, kErrorMessage_0) ;
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void insertInOutArgument_typeVariablesMap (C_Lexique & lexique_var_,
                                GGS_typeVariablesMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage_0 = "the variable '%' is already declared" ;
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = ioMap.insertInOutArgument (lexique_var_, info, inKey, inKey, kErrorMessage_0) ;
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void insertUnusedInOutArgument_typeVariablesMap (C_Lexique & lexique_var_,
                                GGS_typeVariablesMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage_0 = "the variable '%' is already declared" ;
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = ioMap.insertUnusedInOutArgument (lexique_var_, info, inKey, inKey, kErrorMessage_0) ;
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Class element of list 'L_assignedVariables'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_assignedVariables::element_type::
element_type (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (element_type *) NULL ;
  aNomVariableCible = argument_0 ;
  aNomAttributSource = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class list 'L_assignedVariables'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_assignedVariables
::GGS_L_assignedVariables (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables::~GGS_L_assignedVariables (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables::GGS_L_assignedVariables (const GGS_L_assignedVariables & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables
::operator = (const GGS_L_assignedVariables & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
internalAppendItem (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aNomVariableCible,
                                p->aNomAttributSource) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_L_assignedVariables::
constructor_empty (void) {
  GGS_L_assignedVariables result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeCible'                       *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeCible'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (void) {
  mPointer = (cPtr_typeCible *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (const GGS_typeCible & inOperand) {
  mPointer = (cPtr_typeCible *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
~GGS_typeCible (void) {
  macroDetachPointer (mPointer, cPtr_typeCible) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCible::
operator = (const GGS_typeCible & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeCible::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCible::
operator = (cPtr_typeCible * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (cPtr_typeCible * inSource) {
  mPointer = (cPtr_typeCible *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeCible * GGS_typeCible
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_typeCible
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCible) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Class element of list 'typeListeCibles'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeCibles::element_type::
element_type (const GGS_typeCible & argument_0) {
  mNextItem = (element_type *) NULL ;
  aCible = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class list 'typeListeCibles'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeCibles
::GGS_typeListeCibles (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles::~GGS_typeListeCibles (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles::GGS_typeListeCibles (const GGS_typeListeCibles & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles
::operator = (const GGS_typeListeCibles & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
internalAppendItem (const GGS_typeCible & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
addAssign_operation (const GGS_typeCible & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aCible) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles  GGS_typeListeCibles::
constructor_empty (void) {
  GGS_typeListeCibles result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Class element of list 'typeListeTypesEtNomsArgMethode'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::element_type::
element_type (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) {
  mNextItem = (element_type *) NULL ;
  mType = argument_0 ;
  mFormalArgumentPassingMode = argument_1 ;
  mCppName = argument_2 ;
  aModeIn = argument_3 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class list 'typeListeTypesEtNomsArgMethode'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode
::GGS_typeListeTypesEtNomsArgMethode (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::~GGS_typeListeTypesEtNomsArgMethode (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::GGS_typeListeTypesEtNomsArgMethode (const GGS_typeListeTypesEtNomsArgMethode & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode
::operator = (const GGS_typeListeTypesEtNomsArgMethode & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()
                 && argument_2.isBuilt ()
                 && argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mFormalArgumentPassingMode,
                                p->mCppName,
                                p->aModeIn) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_typeListeTypesEtNomsArgMethode::
constructor_empty (void) {
  GGS_typeListeTypesEtNomsArgMethode result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (void) {
  mPointer = (cPtr_typeInstruction *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (const GGS_typeInstruction & inOperand) {
  mPointer = (cPtr_typeInstruction *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
~GGS_typeInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstruction::
operator = (const GGS_typeInstruction & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeInstruction::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstruction::
operator = (cPtr_typeInstruction * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (cPtr_typeInstruction * inSource) {
  mPointer = (cPtr_typeInstruction *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeInstruction * GGS_typeInstruction
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstruction
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeInstruction) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Class element of list 'typeInstructionsList'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionsList::element_type::
element_type (const GGS_typeInstruction & argument_0) {
  mNextItem = (element_type *) NULL ;
  aInstruction = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class list 'typeInstructionsList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionsList
::GGS_typeInstructionsList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionsList::~GGS_typeInstructionsList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionsList::GGS_typeInstructionsList (const GGS_typeInstructionsList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionsList
::operator = (const GGS_typeInstructionsList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionsList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionsList::
internalAppendItem (const GGS_typeInstruction & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionsList::
addAssign_operation (const GGS_typeInstruction & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionsList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aInstruction) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionsList  GGS_typeInstructionsList::
constructor_empty (void) {
  GGS_typeInstructionsList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionsList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Class element of list 'L_nameWithType'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_nameWithType::element_type::
element_type (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (element_type *) NULL ;
  mType = argument_0 ;
  mName = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class list 'L_nameWithType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_nameWithType
::GGS_L_nameWithType (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType::~GGS_L_nameWithType (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType::GGS_L_nameWithType (const GGS_L_nameWithType & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType
::operator = (const GGS_L_nameWithType & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType  GGS_L_nameWithType::
constructor_empty (void) {
  GGS_L_nameWithType result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class map element 'e_typeTableMethodesAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

template class cTableMethodesAimplementer <e_typeTableMethodesAimplementer, GGS_lstring> ;

//---------------------------------------------------------------------------*

bool e_typeTableMethodesAimplementer::isBuilt (void) const {
  return aListeTypesParametres.isBuilt () &&
       aListeTypeEtNomsArguments.isBuilt () &&
       mInstructionsList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map 'typeTableMethodesAimplementer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void insertAbstract_typeTableMethodesAimplementer (C_Lexique & lexique_var_,
                                GGS_typeTableMethodesAimplementer & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionsList &  inParameter2,
                                GGS_luint * outIndex) {
  const char * kErrorMessage_0 = "the method '%' is already declared" ;
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionsList = inParameter2 ;
  const sint32 index = ioMap.insertAbstract (lexique_var_, info, inKey, inKey, kErrorMessage_0) ;
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void insertNotAbstract_typeTableMethodesAimplementer (C_Lexique & lexique_var_,
                                GGS_typeTableMethodesAimplementer & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionsList &  inParameter2,
                                GGS_luint * outIndex) {
  const char * kErrorMessage_0 = "the method '%' is already declared" ;
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionsList = inParameter2 ;
  const sint32 index = ioMap.insertNotAbstract (lexique_var_, info, inKey, inKey, kErrorMessage_0) ;
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Class element of list 'typeExpressionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExpressionList::element_type::
element_type (const GGS_typeExpression & argument_0) {
  mNextItem = (element_type *) NULL ;
  mExpression = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class list 'typeExpressionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExpressionList
::GGS_typeExpressionList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList::~GGS_typeExpressionList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList::GGS_typeExpressionList (const GGS_typeExpressionList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList
::operator = (const GGS_typeExpressionList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
internalAppendItem (const GGS_typeExpression & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
addAssign_operation (const GGS_typeExpression & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mExpression) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeExpressionList::
constructor_empty (void) {
  GGS_typeExpressionList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeErrorInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeErrorInstruction::cPtr_typeErrorInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mErrorLocationExpression (argument_0),
mErrorMessageExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeErrorInstruction::isBuilt (void) const {
  return mErrorLocationExpression.isBuilt () &&
       mErrorMessageExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeErrorInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeErrorInstruction * GGS_typeErrorInstruction::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeErrorInstruction * ptr_ = (cPtr_typeErrorInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeErrorInstruction (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeWarningInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeWarningInstruction::cPtr_typeWarningInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mWarningLocationExpression (argument_0),
mWarningMessageExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeWarningInstruction::isBuilt (void) const {
  return mWarningLocationExpression.isBuilt () &&
       mWarningMessageExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeWarningInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeWarningInstruction * GGS_typeWarningInstruction::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeWarningInstruction * ptr_ = (cPtr_typeWarningInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeWarningInstruction (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeMessageInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMessageInstruction::cPtr_typeMessageInstruction (const GGS_typeExpression & argument_0)
:mMessageExpression (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeMessageInstruction::isBuilt (void) const {
  return mMessageExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeMessageInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeMessageInstruction * GGS_typeMessageInstruction::
    constructor_new (const GGS_typeExpression & argument_0) {
    cPtr_typeMessageInstruction * ptr_ = (cPtr_typeMessageInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMessageInstruction (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeReaderCallInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeReaderCallInstruction::cPtr_typeReaderCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2)
:aNomCppVariable (argument_0),
aNomMethodeSimple (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeReaderCallInstruction::isBuilt (void) const {
  return aNomCppVariable.isBuilt () &&
       aNomMethodeSimple.isBuilt () &&
       mExpressionsList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeReaderCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeReaderCallInstruction * GGS_typeReaderCallInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
    cPtr_typeReaderCallInstruction * ptr_ = (cPtr_typeReaderCallInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeReaderCallInstruction (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeModifierCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModifierCallInstruction::cPtr_typeModifierCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2)
:aNomCppVariable (argument_0),
aNomMethodeSimple (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeModifierCallInstruction::isBuilt (void) const {
  return aNomCppVariable.isBuilt () &&
       aNomMethodeSimple.isBuilt () &&
       mExpressionsList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeModifierCallInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeModifierCallInstruction * GGS_typeModifierCallInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
    cPtr_typeModifierCallInstruction * ptr_ = (cPtr_typeModifierCallInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeModifierCallInstruction (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeMapInsertInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapInsertInstruction::cPtr_typeMapInsertInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_typeCplusPlusNameList & argument_4,
                                const GGS_typeCplusPlusName & argument_5)
:aNomVariableTable (argument_0),
aNomMethodeInsertion (argument_1),
aNomTypeTable (argument_2),
aNomVariableClef (argument_3),
aListeParametresEffectifs (argument_4),
mOptionalIndexVariable (argument_5) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeMapInsertInstruction::isBuilt (void) const {
  return aNomVariableTable.isBuilt () &&
       aNomMethodeInsertion.isBuilt () &&
       aNomTypeTable.isBuilt () &&
       aNomVariableClef.isBuilt () &&
       aListeParametresEffectifs.isBuilt () &&
       mOptionalIndexVariable.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeMapInsertInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeMapInsertInstruction * GGS_typeMapInsertInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_typeCplusPlusNameList & argument_4,
                                const GGS_typeCplusPlusName & argument_5) {
    cPtr_typeMapInsertInstruction * ptr_ = (cPtr_typeMapInsertInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMapInsertInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeMapSearchInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapSearchInstruction::cPtr_typeMapSearchInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_typeCplusPlusNameList & argument_4,
                                const GGS_typeCplusPlusName & argument_5)
:aNomVariableTable (argument_0),
aNomMethodeRecherche (argument_1),
aNomTypeTable (argument_2),
aNomVariableClef (argument_3),
mAllVariablesList (argument_4),
mOptionalIndexVariable (argument_5) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeMapSearchInstruction::isBuilt (void) const {
  return aNomVariableTable.isBuilt () &&
       aNomMethodeRecherche.isBuilt () &&
       aNomTypeTable.isBuilt () &&
       aNomVariableClef.isBuilt () &&
       mAllVariablesList.isBuilt () &&
       mOptionalIndexVariable.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeMapSearchInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeMapSearchInstruction * GGS_typeMapSearchInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_typeCplusPlusNameList & argument_4,
                                const GGS_typeCplusPlusName & argument_5) {
    cPtr_typeMapSearchInstruction * ptr_ = (cPtr_typeMapSearchInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMapSearchInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeInstructionAppelMethodeListe'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelMethodeListe::cPtr_typeInstructionAppelMethodeListe (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2)
:aNomCppAttribut (argument_0),
aMethodeDeListe (argument_1),
aListeNomsCppArguments (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionAppelMethodeListe::isBuilt (void) const {
  return aNomCppAttribut.isBuilt () &&
       aMethodeDeListe.isBuilt () &&
       aListeNomsCppArguments.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelMethodeListe'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInstructionAppelMethodeListe * GGS_typeInstructionAppelMethodeListe::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2) {
    cPtr_typeInstructionAppelMethodeListe * ptr_ = (cPtr_typeInstructionAppelMethodeListe *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionAppelMethodeListe (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'typeInstructionDeclarationVarLocale'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionDeclarationVarLocale::cPtr_typeInstructionDeclarationVarLocale (const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1)
:aNomCppVariable (argument_0),
aTypeVariable (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionDeclarationVarLocale::isBuilt (void) const {
  return aNomCppVariable.isBuilt () &&
       aTypeVariable.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeInstructionDeclarationVarLocale'           *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInstructionDeclarationVarLocale * GGS_typeInstructionDeclarationVarLocale::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1) {
    cPtr_typeInstructionDeclarationVarLocale * ptr_ = (cPtr_typeInstructionDeclarationVarLocale *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionDeclarationVarLocale (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeMapBlockPrologueInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockPrologueInstruction::cPtr_typeMapBlockPrologueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2)
:aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mPrologueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeMapBlockPrologueInstruction::isBuilt (void) const {
  return aNomVariableTable.isBuilt () &&
       aNomMethodeBloc.isBuilt () &&
       mPrologueExpressionList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockPrologueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeMapBlockPrologueInstruction * GGS_typeMapBlockPrologueInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
    cPtr_typeMapBlockPrologueInstruction * ptr_ = (cPtr_typeMapBlockPrologueInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMapBlockPrologueInstruction (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeMapBlockEpilogueInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockEpilogueInstruction::cPtr_typeMapBlockEpilogueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2)
:aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mEpilogueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeMapBlockEpilogueInstruction::isBuilt (void) const {
  return aNomVariableTable.isBuilt () &&
       aNomMethodeBloc.isBuilt () &&
       mEpilogueExpressionList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockEpilogueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeMapBlockEpilogueInstruction * GGS_typeMapBlockEpilogueInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
    cPtr_typeMapBlockEpilogueInstruction * ptr_ = (cPtr_typeMapBlockEpilogueInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMapBlockEpilogueInstruction (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeReaderCallInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeReaderCallInExpression::cPtr_typeReaderCallInExpression (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2)
:mExpressionValue (argument_0),
mReaderName (argument_1),
mExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeReaderCallInExpression::isBuilt (void) const {
  return mExpressionValue.isBuilt () &&
       mReaderName.isBuilt () &&
       mExpressionList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeReaderCallInExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeReaderCallInExpression * GGS_typeReaderCallInExpression::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
    cPtr_typeReaderCallInExpression * ptr_ = (cPtr_typeReaderCallInExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeReaderCallInExpression (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeAndOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAndOperation::cPtr_typeAndOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeAndOperation::isBuilt (void) const {
  return mLeftExpression.isBuilt () &&
       mRightExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAndOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeAndOperation * GGS_typeAndOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeAndOperation * ptr_ = (cPtr_typeAndOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeAndOperation (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeOrOperation'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOrOperation::cPtr_typeOrOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeOrOperation::isBuilt (void) const {
  return mLeftExpression.isBuilt () &&
       mRightExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOrOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeOrOperation * GGS_typeOrOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeOrOperation * ptr_ = (cPtr_typeOrOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeOrOperation (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeConcatOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConcatOperation::cPtr_typeConcatOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeConcatOperation::isBuilt (void) const {
  return mLeftExpression.isBuilt () &&
       mRightExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConcatOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeConcatOperation * GGS_typeConcatOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeConcatOperation * ptr_ = (cPtr_typeConcatOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeConcatOperation (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeTrueBool'                            *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeTrueBool::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeTrueBool'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeTrueBool * GGS_typeTrueBool::
    constructor_new () {
    cPtr_typeTrueBool * ptr_ = (cPtr_typeTrueBool *) NULL ;
    macroMyNew (ptr_, cPtr_typeTrueBool ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFalseBool'                            *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeFalseBool::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFalseBool'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFalseBool * GGS_typeFalseBool::
    constructor_new () {
    cPtr_typeFalseBool * ptr_ = (cPtr_typeFalseBool *) NULL ;
    macroMyNew (ptr_, cPtr_typeFalseBool ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeLiteralStringExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralStringExpression::cPtr_typeLiteralStringExpression (const GGS_lstring & argument_0)
:mLiteralString (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralStringExpression::isBuilt (void) const {
  return mLiteralString.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralStringExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeLiteralStringExpression * GGS_typeLiteralStringExpression::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeLiteralStringExpression * ptr_ = (cPtr_typeLiteralStringExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralStringExpression (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralUIntExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralUIntExpression::cPtr_typeLiteralUIntExpression (const GGS_luint & argument_0)
:mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralUIntExpression::isBuilt (void) const {
  return mLiteralInt.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralUIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeLiteralUIntExpression * GGS_typeLiteralUIntExpression::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_typeLiteralUIntExpression * ptr_ = (cPtr_typeLiteralUIntExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralUIntExpression (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralSIntExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralSIntExpression::cPtr_typeLiteralSIntExpression (const GGS_lsint & argument_0)
:mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralSIntExpression::isBuilt (void) const {
  return mLiteralInt.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralSIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeLiteralSIntExpression * GGS_typeLiteralSIntExpression::
    constructor_new (const GGS_lsint & argument_0) {
    cPtr_typeLiteralSIntExpression * ptr_ = (cPtr_typeLiteralSIntExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralSIntExpression (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralCharExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralCharExpression::cPtr_typeLiteralCharExpression (const GGS_lchar & argument_0)
:mLiteralChar (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralCharExpression::isBuilt (void) const {
  return mLiteralChar.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralCharExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeLiteralCharExpression * GGS_typeLiteralCharExpression::
    constructor_new (const GGS_lchar & argument_0) {
    cPtr_typeLiteralCharExpression * ptr_ = (cPtr_typeLiteralCharExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralCharExpression (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeHereExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeHereExpression::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeHereExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeHereExpression * GGS_typeHereExpression::
    constructor_new () {
    cPtr_typeHereExpression * ptr_ = (cPtr_typeHereExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeHereExpression ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeConstructorExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConstructorExpression::cPtr_typeConstructorExpression (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2)
:mClassName (argument_0),
mClassMethodName (argument_1),
mExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeConstructorExpression::isBuilt (void) const {
  return mClassName.isBuilt () &&
       mClassMethodName.isBuilt () &&
       mExpressionList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeConstructorExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeConstructorExpression * GGS_typeConstructorExpression::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
    cPtr_typeConstructorExpression * ptr_ = (cPtr_typeConstructorExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeConstructorExpression (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeTestComplement'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTestComplement::cPtr_typeTestComplement (const GGS_typeExpression & argument_0)
:mTest (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeTestComplement::isBuilt (void) const {
  return mTest.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeTestComplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeTestComplement * GGS_typeTestComplement::
    constructor_new (const GGS_typeExpression & argument_0) {
    cPtr_typeTestComplement * ptr_ = (cPtr_typeTestComplement *) NULL ;
    macroMyNew (ptr_, cPtr_typeTestComplement (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeBoolOption'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeBoolOption::cPtr_typeBoolOption (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1)
:mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeBoolOption::isBuilt (void) const {
  return mOptionComponentName.isBuilt () &&
       mOptionName.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeBoolOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeBoolOption * GGS_typeBoolOption::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
    cPtr_typeBoolOption * ptr_ = (cPtr_typeBoolOption *) NULL ;
    macroMyNew (ptr_, cPtr_typeBoolOption (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeUIntOption'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUIntOption::cPtr_typeUIntOption (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1)
:mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeUIntOption::isBuilt (void) const {
  return mOptionComponentName.isBuilt () &&
       mOptionName.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUIntOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeUIntOption * GGS_typeUIntOption::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
    cPtr_typeUIntOption * ptr_ = (cPtr_typeUIntOption *) NULL ;
    macroMyNew (ptr_, cPtr_typeUIntOption (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeVarInExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVarInExpression::cPtr_typeVarInExpression (const GGS_typeCplusPlusName & argument_0)
:mCppVarName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeVarInExpression::isBuilt (void) const {
  return mCppVarName.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeVarInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeVarInExpression * GGS_typeVarInExpression::
    constructor_new (const GGS_typeCplusPlusName & argument_0) {
    cPtr_typeVarInExpression * ptr_ = (cPtr_typeVarInExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeVarInExpression (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeJokerInExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJokerInExpression::cPtr_typeJokerInExpression (const GGS_location & argument_0)
:mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeJokerInExpression::isBuilt (void) const {
  return mLocation.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeJokerInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeJokerInExpression * GGS_typeJokerInExpression::
    constructor_new (const GGS_location & argument_0) {
    cPtr_typeJokerInExpression * ptr_ = (cPtr_typeJokerInExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeJokerInExpression (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEqualTest'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEqualTest::cPtr_typeEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeEqualTest::isBuilt (void) const {
  return mLeftExpression.isBuilt () &&
       mRightExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeEqualTest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEqualTest * GGS_typeEqualTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeEqualTest * ptr_ = (cPtr_typeEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeEqualTest (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeNonEqualTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonEqualTest::cPtr_typeNonEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeNonEqualTest::isBuilt (void) const {
  return mLeftExpression.isBuilt () &&
       mRightExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeNonEqualTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeNonEqualTest * GGS_typeNonEqualTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeNonEqualTest * ptr_ = (cPtr_typeNonEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeNonEqualTest (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeStrictInfTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictInfTest::cPtr_typeStrictInfTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeStrictInfTest::isBuilt (void) const {
  return mLeftExpression.isBuilt () &&
       mRightExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictInfTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeStrictInfTest * GGS_typeStrictInfTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeStrictInfTest * ptr_ = (cPtr_typeStrictInfTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeStrictInfTest (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeInfOrEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInfOrEqualTest::cPtr_typeInfOrEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeInfOrEqualTest::isBuilt (void) const {
  return mLeftExpression.isBuilt () &&
       mRightExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeInfOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInfOrEqualTest * GGS_typeInfOrEqualTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeInfOrEqualTest * ptr_ = (cPtr_typeInfOrEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeInfOrEqualTest (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeStrictSupTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictSupTest::cPtr_typeStrictSupTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeStrictSupTest::isBuilt (void) const {
  return mLeftExpression.isBuilt () &&
       mRightExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictSupTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeStrictSupTest * GGS_typeStrictSupTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeStrictSupTest * ptr_ = (cPtr_typeStrictSupTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeStrictSupTest (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeSupOrEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSupOrEqualTest::cPtr_typeSupOrEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeSupOrEqualTest::isBuilt (void) const {
  return mLeftExpression.isBuilt () &&
       mRightExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeSupOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeSupOrEqualTest * GGS_typeSupOrEqualTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeSupOrEqualTest * ptr_ = (cPtr_typeSupOrEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeSupOrEqualTest (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeTextTableCall'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTextTableCall::cPtr_typeTextTableCall (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2)
:mExpression (argument_0),
aNomMethodeTest (argument_1),
aNomCppClef (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeTextTableCall::isBuilt (void) const {
  return mExpression.isBuilt () &&
       aNomMethodeTest.isBuilt () &&
       aNomCppClef.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeTextTableCall'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeTextTableCall * GGS_typeTextTableCall::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2) {
    cPtr_typeTextTableCall * ptr_ = (cPtr_typeTextTableCall *) NULL ;
    macroMyNew (ptr_, cPtr_typeTextTableCall (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_assignmentInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_assignmentInstruction::cPtr_C_assignmentInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1)
:mTargetVarCppName (argument_0),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_assignmentInstruction::isBuilt (void) const {
  return mTargetVarCppName.isBuilt () &&
       mSourceExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_assignmentInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_assignmentInstruction * GGS_C_assignmentInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_C_assignmentInstruction * ptr_ = (cPtr_C_assignmentInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_assignmentInstruction (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'C_declarationInstructionWithAssignment'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_declarationInstructionWithAssignment::cPtr_C_declarationInstructionWithAssignment (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2)
:mVariableType (argument_0),
mTargetVarCppName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_declarationInstructionWithAssignment::isBuilt (void) const {
  return mVariableType.isBuilt () &&
       mTargetVarCppName.isBuilt () &&
       mSourceExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_declarationInstructionWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_declarationInstructionWithAssignment * GGS_C_declarationInstructionWithAssignment::
    constructor_new (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2) {
    cPtr_C_declarationInstructionWithAssignment * ptr_ = (cPtr_C_declarationInstructionWithAssignment *) NULL ;
    macroMyNew (ptr_, cPtr_C_declarationInstructionWithAssignment (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//        Class element of list 'L_expression_instructionsList_list'         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::element_type::
element_type (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionsList & argument_1) {
  mNextItem = (element_type *) NULL ;
  mIFexpression = argument_0 ;
  mInstructionsList = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class list 'L_expression_instructionsList_list'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list
::GGS_L_expression_instructionsList_list (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::~GGS_L_expression_instructionsList_list (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::GGS_L_expression_instructionsList_list (const GGS_L_expression_instructionsList_list & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list
::operator = (const GGS_L_expression_instructionsList_list & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
internalAppendItem (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionsList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
addAssign_operation (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionsList & argument_1) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mIFexpression,
                                p->mInstructionsList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_L_expression_instructionsList_list::
constructor_empty (void) {
  GGS_L_expression_instructionsList_list result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_if_instruction'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_if_instruction::cPtr_C_if_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionsList & argument_1)
:mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_if_instruction::isBuilt (void) const {
  return mIFbranchesList.isBuilt () &&
       mElseInstructionsList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_if_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_if_instruction * GGS_C_if_instruction::
    constructor_new (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionsList & argument_1) {
    cPtr_C_if_instruction * ptr_ = (cPtr_C_if_instruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_if_instruction (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableRoutinesAimplementer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableRoutinesAimplementer & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableRoutinesAimplementer::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableRoutinesAimplementer *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeTableRoutinesAimplementer * info = (e_typeTableRoutinesAimplementer *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeTableRoutinesAimplementer::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_typeTableRoutinesAimplementer::element_type::stringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::constructor_empty (void) {
  GGS_typeTableRoutinesAimplementer result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableRoutinesAimplementer::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
     insulateMap () ;
    e_typeTableRoutinesAimplementer info  ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void insertKey_typeTableRoutinesAimplementer (C_Lexique & lexique_var_,
                                GGS_typeTableRoutinesAimplementer & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the routine '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableAttributsSemantiques'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableAttributsSemantiques & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableAttributsSemantiques::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableAttributsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeTableAttributsSemantiques * info = (e_typeTableAttributsSemantiques *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeTableAttributsSemantiques::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_typeTableAttributsSemantiques::element_type::stringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::constructor_empty (void) {
  GGS_typeTableAttributsSemantiques result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableAttributsSemantiques::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_typeCplusPlusName &  inParameter0,
               const GGS_AC_galgasType &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()
                 && inParameter1.isBuilt ()) {
     insulateMap () ;
    e_typeTableAttributsSemantiques info  ;
    info.aNomCppAttribut = inParameter0 ;
    info.mAttributType = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_typeCplusPlusName   * outParameter0,
               GGS_AC_galgasType   * outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.aNomCppAttribut ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = node->mInfo.mAttributType ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeTableAttributsSemantiques (C_Lexique & inLexique,
                                GGS_typeTableAttributsSemantiques & ioMap,
                                const GGS_lstring & inKey,
                                GGS_typeCplusPlusName   * outParameter0,
                                GGS_AC_galgasType   * outParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the attribute '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outParameter1,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeTableAttributsSemantiques (C_Lexique & lexique_var_,
                                GGS_typeTableAttributsSemantiques & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_typeCplusPlusName & inParameter0,
                                const GGS_AC_galgasType & inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the attribute '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       inParameter1,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class for enumeration 'localConstantBuildStyleEnum'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator == (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator != (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator <= (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator >= (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator < (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localConstantBuildStyleEnum::
operator > (const GGS_localConstantBuildStyleEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "buildMapWithLocalConstants"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildMapWithLocalConstants (C_Lexique & lexique_var_,
                                GGS_L_nameWithType   var_cas_inLocalDeclarationsList,
                                GGS_typeListeAttributsSemantiques   var_cas_inSemanticAttributsList,
                                GGS_typeVariablesMap  & var_cas_ioVariablesMap,
                                GGS_location   var_cas_inLocation,
                                GGS_localConstantBuildStyleEnum  var_cas_inLocalConstantStyle,
                                GGS_bool  var_cas_inEllipsisFound) {
  GGS_bool var_cas_mapStyle ;
  var_cas_mapStyle = (var_cas_inLocalConstantStyle) != (GGS_localConstantBuildStyleEnum::constructor_listStyle ()) ;
  GGS_bool var_cas_first ;
  var_cas_first = GGS_bool (true, true) ;
  GGS_L_nameWithType::element_type * operand_27828 = var_cas_inLocalDeclarationsList.firstObject () ;
  GGS_typeListeAttributsSemantiques::element_type * operand_27917 = var_cas_inSemanticAttributsList.firstObject () ;
  while ((operand_27828 != NULL)
      && (operand_27917 != NULL)) {
    macroValidPointer (operand_27828) ;
    macroValidPointer (operand_27917) ;
    if (((operand_27828->mName.reader_value ()) != (GGS_string (true, ""))).isBuiltAndTrue ()) {
      GGS_string var_cas_typeName ;
      if (operand_27917->mAttributType.isBuilt ()) {
        operand_27917->mAttributType ()->methode_getTypeName (lexique_var_, var_cas_typeName) ;
      }
      if (((operand_27828->mType.reader_value ()) == (var_cas_typeName)).isBuiltAndTrue ()) {
        GGS_typeCplusPlusName  var_cas_cppName ;
        if (((((var_cas_inLocalConstantStyle) == (GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle ())) && (var_cas_first))).isBuiltAndTrue ()) {
          var_cas_cppName = GGS_typeKeyName::constructor_new (var_cas_inLocation) ;
        }else{
          var_cas_cppName = GGS_typeOperandName::constructor_new (operand_27917->aNomAttribut, var_cas_inLocation, var_cas_mapStyle) ;
        }
        insertUsedConstInArgument_typeVariablesMap (lexique_var_,
                                        var_cas_ioVariablesMap,
                                        operand_27828->mName,
                                        operand_27917->mAttributType,
                                        var_cas_cppName,
                                        NULL) ;
      }else{
          operand_27828->mType.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I have found the '@")) + (operand_27828->mType.reader_value ()))) + (GGS_string (true, "' type, I was expected the '@")))) + (var_cas_typeName))) + (GGS_string (true, "' type")))) ;
      }
    }
    var_cas_first = GGS_bool (true, false) ;
    operand_27828 = operand_27828->nextObject () ;
    operand_27917 = operand_27917->nextObject () ;
  }
  if (((((var_cas_inLocalDeclarationsList.reader_length ()) < (var_cas_inSemanticAttributsList.reader_length ())) && ((! var_cas_inEllipsisFound)))).isBuiltAndTrue ()) {
      GGS_location (lexique_var_).reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "one or more parameters missing: found ")) + (var_cas_inLocalDeclarationsList.reader_length ().reader_string ()))) + (GGS_string (true, " effective parameters, while ")))) + (var_cas_inSemanticAttributsList.reader_length ().reader_string ()))) + (GGS_string (true, " are needed")))) ;
  }else if (((var_cas_inLocalDeclarationsList.reader_length ()) > (var_cas_inSemanticAttributsList.reader_length ())).isBuiltAndTrue ()) {
      GGS_location (lexique_var_).reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "too much parameters: found ")) + (var_cas_inLocalDeclarationsList.reader_length ().reader_string ()))) + (GGS_string (true, " effective parameters, while ")))) + (var_cas_inSemanticAttributsList.reader_length ().reader_string ()))) + (GGS_string (true, " are needed")))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "checkAssignmentTypesCompatibility"        *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkAssignmentTypesCompatibility (C_Lexique & lexique_var_,
                                GGS_AC_galgasType   var_cas_targetType,
                                GGS_AC_galgasType   var_cas_sourceType,
                                GGS_location   var_cas_inErrorLocation) {
  if (var_cas_targetType.isBuilt () && var_cas_sourceType.isBuilt ()) {
    cPtr_AC_galgasType * ptr_29944 = var_cas_targetType () ;
    cPtr_AC_galgasType * ptr_29958 = var_cas_sourceType () ;
    cPtr_typeGalgas_uint * operand_29944 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_29944) ;
    cPtr_typeGalgas_uint * operand_29958 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_29958) ;
    if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
    }else{
      cPtr_typeGalgas_sint * operand_29944 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_29944) ;
      cPtr_typeGalgas_sint * operand_29958 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_29958) ;
      if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
      }else{
        cPtr_typeGalgas_char * operand_29944 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_29944) ;
        cPtr_typeGalgas_char * operand_29958 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_29958) ;
        if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
        }else{
          cPtr_typeGalgas_string * operand_29944 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_29944) ;
          cPtr_typeGalgas_string * operand_29958 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_29958) ;
          if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
          }else{
            cPtr_typeGalgas_bool * operand_29944 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_29944) ;
            cPtr_typeGalgas_bool * operand_29958 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_29958) ;
            if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
            }else{
              cPtr_typeGalgas_double * operand_29944 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_29944) ;
              cPtr_typeGalgas_double * operand_29958 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_29958) ;
              if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
              }else{
                cPtr_typeGalgas_ldouble * operand_29944 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_29944) ;
                cPtr_typeGalgas_ldouble * operand_29958 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_29958) ;
                if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
                }else{
                  cPtr_typeGalgas_location * operand_29944 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_29944) ;
                  cPtr_typeGalgas_location * operand_29958 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_29958) ;
                  if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
                  }else{
                    cPtr_typeGalgas_lchar * operand_29944 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_29944) ;
                    cPtr_typeGalgas_lchar * operand_29958 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_29958) ;
                    if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
                    }else{
                      cPtr_typeGalgas_luint * operand_29944 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_29944) ;
                      cPtr_typeGalgas_luint * operand_29958 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_29958) ;
                      if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
                      }else{
                        cPtr_typeGalgas_lsint * operand_29944 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_29944) ;
                        cPtr_typeGalgas_lsint * operand_29958 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_29958) ;
                        if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
                        }else{
                          cPtr_typeGalgas_lstring * operand_29944 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_29944) ;
                          cPtr_typeGalgas_lstring * operand_29958 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_29958) ;
                          if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
                          }else{
                            cPtr_typeGalgas_lbool * operand_29944 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_29944) ;
                            cPtr_typeGalgas_lbool * operand_29958 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_29958) ;
                            if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
                            }else{
                              cPtr_typeGalgasUndefinedExternType * operand_29944 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_29944) ;
                              cPtr_typeGalgasUndefinedExternType * operand_29958 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_29958) ;
                              if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
                                if (((operand_29944->mGalgasClassName.reader_value ()) != (operand_29958->mGalgasClassName.reader_value ())).isBuiltAndTrue ()) {
                                    var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting an extern variable of extern '")) + (operand_29944->mGalgasClassName.reader_value ()))) + (GGS_string (true, "' type variable, and I got an extern '")))) + (operand_29958->mGalgasClassName.reader_value ()))) + (GGS_string (true, "' type variable")))) ;
                                }
                              }else{
                                cPtr_typeGalgasUndefinedListType * operand_29944 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_29944) ;
                                cPtr_typeGalgasUndefinedListType * operand_29958 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_29958) ;
                                if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
                                  if (((operand_29944->mListTypeName.reader_value ()) != (operand_29958->mListTypeName.reader_value ())).isBuiltAndTrue ()) {
                                      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting a '")) + (operand_29944->mListTypeName.reader_value ()))) + (GGS_string (true, "' list type variable, and I got a '")))) + (operand_29958->mListTypeName.reader_value ()))) + (GGS_string (true, "' list type variable")))) ;
                                  }
                                }else{
                                  cPtr_typeGalgasClassType * operand_29944 = dynamic_cast <cPtr_typeGalgasClassType *> (ptr_29944) ;
                                  cPtr_typeGalgasClassType * operand_29958 = dynamic_cast <cPtr_typeGalgasClassType *> (ptr_29958) ;
                                  if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
                                    if (((operand_29944->mClassTypeName.reader_value ()) == (operand_29958->mClassTypeName.reader_value ())).isBuiltAndTrue ()) {
                                    }else if (((! operand_29958->mAncestorClassesMap.reader_hasKey (operand_29944->mClassTypeName))).isBuiltAndTrue ()) {
                                        var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "The '")) + (operand_29958->mClassTypeName.reader_value ()))) + (GGS_string (true, "' does not inherit from '")))) + (operand_29958->mClassTypeName.reader_value ()))) + (GGS_string (true, "' class")))) ;
                                    }
                                  }else{
                                    cPtr_typeGalgasUndefinedClassType * operand_29944 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_29944) ;
                                    cPtr_typeGalgasUndefinedClassType * operand_29958 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_29958) ;
                                    if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
                                      if (((operand_29944->mClassTypeName.reader_value ()) != (operand_29958->mClassTypeName.reader_value ())).isBuiltAndTrue ()) {
                                          var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting a '")) + (operand_29944->mClassTypeName.reader_value ()))) + (GGS_string (true, "' class type variable, and I got a '")))) + (operand_29958->mClassTypeName.reader_value ()))) + (GGS_string (true, "' class type variable")))) ;
                                      }
                                    }else{
                                      cPtr_typeGalgasUndefinedMapType * operand_29944 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_29944) ;
                                      cPtr_typeGalgasUndefinedMapType * operand_29958 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_29958) ;
                                      if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
                                        if (((operand_29944->mMapTypeName.reader_value ()) != (operand_29958->mMapTypeName.reader_value ())).isBuiltAndTrue ()) {
                                            var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting a '")) + (operand_29944->mMapTypeName.reader_value ()))) + (GGS_string (true, "' map type variable, and I got a '")))) + (operand_29958->mMapTypeName.reader_value ()))) + (GGS_string (true, "' map type variable")))) ;
                                        }
                                      }else{
                                        cPtr_typeGalgas_enum * operand_29944 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_29944) ;
                                        cPtr_typeGalgas_enum * operand_29958 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_29958) ;
                                        if ((operand_29944 != NULL) && (operand_29958 != NULL)) {
                                          if (((operand_29944->mEnumTypeName.reader_value ()) != (operand_29958->mEnumTypeName.reader_value ())).isBuiltAndTrue ()) {
                                              var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting an enum variable of  '")) + (operand_29944->mEnumTypeName.reader_value ()))) + (GGS_string (true, "' type variable, and I got an enum '")))) + (operand_29958->mEnumTypeName.reader_value ()))) + (GGS_string (true, "' type variable")))) ;
                                          }
                                        }else{
                                            var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((var_cas_targetType.reader_messageGalgasType ()) + (GGS_string (true, " cannot be assigned from ")))) + (var_cas_sourceType.reader_messageGalgasType ()))) ;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "verifierCompatibiliteTypes"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteTypes (C_Lexique & lexique_var_,
                                GGS_typeSemanticsTypesList   var_cas_t1,
                                GGS_typeListeAttributsSemantiques   var_cas_t2,
                                const GGS_location  & var_cas_inErrorLocation) {
  if (((var_cas_t1.reader_length ()) < (var_cas_t2.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "one or more identifiers missing")) ;
  }else if (((var_cas_t1.reader_length ()) > (var_cas_t2.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "too much identifiers")) ;
  }else{
    GGS_typeSemanticsTypesList::element_type * operand_34321 = var_cas_t1.firstObject () ;
    GGS_typeListeAttributsSemantiques::element_type * operand_34406 = var_cas_t2.firstObject () ;
    while ((operand_34321 != NULL)
        && (operand_34406 != NULL)) {
      macroValidPointer (operand_34321) ;
      macroValidPointer (operand_34406) ;
      ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  operand_34321->mType,  operand_34406->mAttributType,  operand_34321->mGalgasVariableName.reader_location ()) ;
      operand_34321 = operand_34321->nextObject () ;
      operand_34406 = operand_34406->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Implementation of routine "verifierCompatibiliteArgEffectifsSignature"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteArgEffectifsSignature (C_Lexique & lexique_var_,
                                GGS_L_signature   var_cas_signatureReference,
                                GGS_L_actualParametersSignature   var_cas_inEffectiveArgumentsSignature,
                                const GGS_location  & var_cas_inErrorLocation,
                                GGS_typeInstructionsList  & var_cas_ioInstructionsList,
                                GGS_typeExpressionList  & var_cas_ioExpressionList) {
  if (((var_cas_signatureReference.reader_length ()) > (var_cas_inEffectiveArgumentsSignature.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "one or more arguments missing")) ;
  }else if (((var_cas_signatureReference.reader_length ()) < (var_cas_inEffectiveArgumentsSignature.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "too much arguments")) ;
  }else{
    GGS_L_signature::element_type * operand_35639 = var_cas_signatureReference.firstObject () ;
    GGS_L_actualParametersSignature::element_type * operand_35768 = var_cas_inEffectiveArgumentsSignature.firstObject () ;
    while ((operand_35639 != NULL)
        && (operand_35768 != NULL)) {
      macroValidPointer (operand_35639) ;
      macroValidPointer (operand_35768) ;
      if (operand_35639->mFormalArgumentPassingMode.isBuilt () && operand_35768->mFormalArgumentPassingMode.isBuilt ()) {
        if ((operand_35639->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentConstantIn) && (operand_35768->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOut)) {
          ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  operand_35639->mType,  operand_35768->mType,  var_cas_inErrorLocation) ;
        }else{
          if ((operand_35639->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentIn) && (operand_35768->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOut)) {
            ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  operand_35639->mType,  operand_35768->mType,  var_cas_inErrorLocation) ;
          }else{
            if ((operand_35639->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentInOut) && (operand_35768->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOutIn)) {
              ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  operand_35639->mType,  operand_35768->mType,  var_cas_inErrorLocation) ;
            }else{
              if ((operand_35639->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentOut) && (operand_35768->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterIn)) {
                if (operand_35768->mType.isBuilt ()) {
                  if (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (operand_35768->mType.getPtr ()) != NULL) {
                  }else{ // Else part
                    ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  operand_35639->mType,  operand_35768->mType,  var_cas_inErrorLocation) ;
                  }
                }
              }else{
                  var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((operand_35768->mFormalArgumentPassingMode.reader_actualArgumentMessage ()) + (GGS_string (true, " is not compatible with ")))) + (operand_35639->mFormalArgumentPassingMode.reader_formalArgumentMessage ()))) ;
              }
            }
          }
        }
      }
      operand_35639 = operand_35639->nextObject () ;
      operand_35768 = operand_35768->nextObject () ;
    }
    GGS_typeExpressionList  var_cas_expressionList ;
    var_cas_expressionList = var_cas_ioExpressionList ;
    var_cas_ioExpressionList = GGS_typeExpressionList::constructor_empty () ;
    GGS_L_signature::element_type * operand_37025 = var_cas_signatureReference.firstObject () ;
    GGS_typeExpressionList::element_type * operand_37093 = var_cas_expressionList.firstObject () ;
    while ((operand_37025 != NULL)
        && (operand_37093 != NULL)) {
      macroValidPointer (operand_37025) ;
      macroValidPointer (operand_37093) ;
      if (operand_37093->mExpression.isBuilt ()) {
        if (dynamic_cast <cPtr_typeJokerInExpression *> (operand_37093->mExpression.getPtr ()) != NULL) {
          cPtr_typeJokerInExpression * operand_37178 = dynamic_cast <cPtr_typeJokerInExpression *> (operand_37093->mExpression.getPtr ()) ;
          macroValidPointer (operand_37178) ; 
          GGS_typeCplusPlusName  var_cas_cppVarName ;
          var_cas_cppVarName = GGS_typeLocationAutomaticName::constructor_new (operand_37178->mLocation) ;
          GGS_typeExpression  var_cas_e ;
          var_cas_e = GGS_typeVarInExpression::constructor_new (var_cas_cppVarName) ;
          var_cas_ioExpressionList.addAssign_operation (var_cas_e) ;
          GGS_typeInstruction  var_cas_i ;
          var_cas_i = GGS_typeInstructionDeclarationVarLocale::constructor_new (var_cas_cppVarName, operand_37025->mType) ;
          var_cas_ioInstructionsList.addAssign_operation (var_cas_i) ;
        }else{ // Else part
          var_cas_ioExpressionList.addAssign_operation (operand_37093->mExpression) ;
        }
      }
      operand_37025 = operand_37025->nextObject () ;
      operand_37093 = operand_37093->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'typeJoker'                              *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeJoker::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::
methode_verifierType (C_Lexique & /* lexique_var_ */,
                                GGS_AC_galgasType  /* var_cas_typeArgumentFormel */,
                                GGS_lstring & /* var_cas_nomAttributSource */,
                                GGS_L_assignedVariables & /* var_cas_listeAffectations */,
                                GGS_typeCplusPlusNameList & var_cas_outAllVariablesList) {
  GGS_typeCplusPlusName  var_cas_nullName ;
  var_cas_nullName = GGS_typeNullName::constructor_new () ;
  var_cas_outAllVariablesList.addAssign_operation (var_cas_nullName) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeJoker'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeJoker * GGS_typeJoker::
    constructor_new () {
    cPtr_typeJoker * ptr_ = (cPtr_typeJoker *) NULL ;
    macroMyNew (ptr_, cPtr_typeJoker ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEntiteDest'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteDest::cPtr_typeEntiteDest (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2)
:aTypeVarDest (argument_0),
mCppName (argument_1),
aPositionVariableCible (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteDest::isBuilt (void) const {
  return aTypeVarDest.isBuilt () &&
       mCppName.isBuilt () &&
       aPositionVariableCible.isBuilt () ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::
methode_verifierType (C_Lexique & lexique_var_,
                                GGS_AC_galgasType  var_cas_typeArgumentFormel,
                                GGS_lstring & var_cas_nomAttributSource,
                                GGS_L_assignedVariables & var_cas_listeAffectations,
                                GGS_typeCplusPlusNameList & var_cas_outAllVariablesList) {
  GGS_location  var_cas_positionErreur ;
  var_cas_positionErreur = aPositionVariableCible ;
  ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  aTypeVarDest,  var_cas_typeArgumentFormel,  var_cas_positionErreur) ;
  var_cas_listeAffectations.addAssign_operation (mCppName, var_cas_nomAttributSource) ;
  var_cas_outAllVariablesList.addAssign_operation (mCppName) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteDest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEntiteDest * GGS_typeEntiteDest::
    constructor_new (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2) {
    cPtr_typeEntiteDest * ptr_ = (cPtr_typeEntiteDest *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteDest (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeEntiteNonTerminal'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteNonTerminal::cPtr_typeEntiteNonTerminal (const GGS_M_nonterminalSymbolAlts & argument_0)
:mAltParametersMap (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteNonTerminal::isBuilt (void) const {
  return mAltParametersMap.isBuilt () ;
}


const char * cPtr_typeEntiteNonTerminal::message_messageTypeEntite (void) const {
  return "a nonterminal symbol" ;
}

const char * cPtr_typeEntiteNonTerminal::static_string_message_messageTypeEntite (void) {
  return "a nonterminal symbol" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEntiteNonTerminal'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEntiteNonTerminal * GGS_typeEntiteNonTerminal::
    constructor_new (const GGS_M_nonterminalSymbolAlts & argument_0) {
    cPtr_typeEntiteNonTerminal * ptr_ = (cPtr_typeEntiteNonTerminal *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteNonTerminal (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_grammarInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarInstruction::cPtr_C_grammarInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_lstring & argument_3)
:mSourceFileCppName (argument_0),
mGrammarName (argument_1),
mExpressionsList (argument_2),
mAltSymbol (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_grammarInstruction::isBuilt (void) const {
  return mSourceFileCppName.isBuilt () &&
       mGrammarName.isBuilt () &&
       mExpressionsList.isBuilt () &&
       mAltSymbol.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_grammarInstruction * GGS_C_grammarInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_lstring & argument_3) {
    cPtr_C_grammarInstruction * ptr_ = (cPtr_C_grammarInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_grammarInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeAppendInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAppendInstruction::cPtr_typeAppendInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1)
:mTargetVarCppName (argument_0),
mSourceExpressions (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeAppendInstruction::isBuilt (void) const {
  return mTargetVarCppName.isBuilt () &&
       mSourceExpressions.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeAppendInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeAppendInstruction * GGS_typeAppendInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1) {
    cPtr_typeAppendInstruction * ptr_ = (cPtr_typeAppendInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeAppendInstruction (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeIncrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeIncrementInstruction::cPtr_typeIncrementInstruction (const GGS_typeCplusPlusName & argument_0)
:mTargetVarCppName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeIncrementInstruction::isBuilt (void) const {
  return mTargetVarCppName.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeIncrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeIncrementInstruction * GGS_typeIncrementInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0) {
    cPtr_typeIncrementInstruction * ptr_ = (cPtr_typeIncrementInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeIncrementInstruction (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'typeAppendInstructionWithAssignment'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAppendInstructionWithAssignment::cPtr_typeAppendInstructionWithAssignment (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_typeCplusPlusName & argument_2)
:mTargetVarCppName (argument_0),
mSourceExpressions (argument_1),
m_luint_TargetVarCppName (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeAppendInstructionWithAssignment::isBuilt (void) const {
  return mTargetVarCppName.isBuilt () &&
       mSourceExpressions.isBuilt () &&
       m_luint_TargetVarCppName.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeAppendInstructionWithAssignment'           *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeAppendInstructionWithAssignment * GGS_typeAppendInstructionWithAssignment::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_typeCplusPlusName & argument_2) {
    cPtr_typeAppendInstructionWithAssignment * ptr_ = (cPtr_typeAppendInstructionWithAssignment *) NULL ;
    macroMyNew (ptr_, cPtr_typeAppendInstructionWithAssignment (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeInstructionAppelActionExterne'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelActionExterne::cPtr_typeInstructionAppelActionExterne (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_signature & argument_2)
:aNomAction (argument_0),
mExpressionsList (argument_1),
aListeTypesParametresFormels (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionAppelActionExterne::isBuilt (void) const {
  return aNomAction.isBuilt () &&
       mExpressionsList.isBuilt () &&
       aListeTypesParametresFormels.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelActionExterne'            *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInstructionAppelActionExterne * GGS_typeInstructionAppelActionExterne::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_signature & argument_2) {
    cPtr_typeInstructionAppelActionExterne * ptr_ = (cPtr_typeInstructionAppelActionExterne *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionAppelActionExterne (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//           Class element of list 'L_matchInstructionCasesList'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::element_type::
element_type (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
  mNextItem = (element_type *) NULL ;
  mCase1_name = argument_0 ;
  mCase2_name = argument_1 ;
  mInstructionsList = argument_2 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class list 'L_matchInstructionCasesList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList
::GGS_L_matchInstructionCasesList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::~GGS_L_matchInstructionCasesList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::GGS_L_matchInstructionCasesList (const GGS_L_matchInstructionCasesList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList
::operator = (const GGS_L_matchInstructionCasesList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()
                 && argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCase1_name,
                                p->mCase2_name,
                                p->mInstructionsList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_L_matchInstructionCasesList::
constructor_empty (void) {
  GGS_L_matchInstructionCasesList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeMatchInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMatchInstruction::cPtr_typeMatchInstruction (const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionsList & argument_9)
:aIndicatif1 (argument_0),
aIndicatif2 (argument_1),
aNomCppVariable1 (argument_2),
aNomCppVariable2 (argument_3),
aNomTypeBase1 (argument_4),
aNomTypeBase2 (argument_5),
mOperand1_isEnumeration (argument_6),
mOperand2_isEnumeration (argument_7),
aListeCas (argument_8),
mElseInstructionsList (argument_9) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeMatchInstruction::isBuilt (void) const {
  return aIndicatif1.isBuilt () &&
       aIndicatif2.isBuilt () &&
       aNomCppVariable1.isBuilt () &&
       aNomCppVariable2.isBuilt () &&
       aNomTypeBase1.isBuilt () &&
       aNomTypeBase2.isBuilt () &&
       mOperand1_isEnumeration.isBuilt () &&
       mOperand2_isEnumeration.isBuilt () &&
       aListeCas.isBuilt () &&
       mElseInstructionsList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMatchInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeMatchInstruction * GGS_typeMatchInstruction::
    constructor_new (const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionsList & argument_9) {
    cPtr_typeMatchInstruction * ptr_ = (cPtr_typeMatchInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMatchInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Class element of list 'foreachEnumerationList'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::element_type::
element_type (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) {
  mNextItem = (element_type *) NULL ;
  mCppEnumeratedVariableName = argument_0 ;
  mLocationOffset = argument_1 ;
  mCppTypeName = argument_2 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class list 'foreachEnumerationList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachEnumerationList
::GGS_foreachEnumerationList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::~GGS_foreachEnumerationList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::GGS_foreachEnumerationList (const GGS_foreachEnumerationList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList
::operator = (const GGS_foreachEnumerationList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
internalAppendItem (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()
                 && argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCppEnumeratedVariableName,
                                p->mLocationOffset,
                                p->mCppTypeName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_foreachEnumerationList::
constructor_empty (void) {
  GGS_foreachEnumerationList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeForeachInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeForeachInstruction::cPtr_typeForeachInstruction (const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeInstructionsList & argument_2)
:mForeachEnumerationList (argument_0),
mWhileExpression (argument_1),
mInstructionsList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeForeachInstruction::isBuilt (void) const {
  return mForeachEnumerationList.isBuilt () &&
       mWhileExpression.isBuilt () &&
       mInstructionsList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeForeachInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeForeachInstruction * GGS_typeForeachInstruction::
    constructor_new (const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
    cPtr_typeForeachInstruction * ptr_ = (cPtr_typeForeachInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeForeachInstruction (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeSimpleExtractInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSimpleExtractInstruction::cPtr_typeSimpleExtractInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4)
:aNomVariable (argument_0),
aNomClasse (argument_1),
aListeAffectationParametresEffectifs (argument_2),
mErrorLocationExpression (argument_3),
aNomMessage (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeSimpleExtractInstruction::isBuilt (void) const {
  return aNomVariable.isBuilt () &&
       aNomClasse.isBuilt () &&
       aListeAffectationParametresEffectifs.isBuilt () &&
       mErrorLocationExpression.isBuilt () &&
       aNomMessage.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeSimpleExtractInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeSimpleExtractInstruction * GGS_typeSimpleExtractInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4) {
    cPtr_typeSimpleExtractInstruction * ptr_ = (cPtr_typeSimpleExtractInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeSimpleExtractInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//          Class element of list 'typeStructuredExtractCasesList'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::element_type::
element_type (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionsList & argument_2,
                                const GGS_bool& argument_3) {
  mNextItem = (element_type *) NULL ;
  mClassName = argument_0 ;
  mResultVarID = argument_1 ;
  mInstructionsList = argument_2 ;
  mNoUsedParameter = argument_3 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class list 'typeStructuredExtractCasesList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList
::GGS_typeStructuredExtractCasesList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::~GGS_typeStructuredExtractCasesList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::GGS_typeStructuredExtractCasesList (const GGS_typeStructuredExtractCasesList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList
::operator = (const GGS_typeStructuredExtractCasesList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionsList & argument_2,
                                const GGS_bool& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionsList & argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()
                 && argument_2.isBuilt ()
                 && argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mClassName,
                                p->mResultVarID,
                                p->mInstructionsList,
                                p->mNoUsedParameter) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractCasesList::
constructor_empty (void) {
  GGS_typeStructuredExtractCasesList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'typeStructuredExtractInstructionWithElse'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStructuredExtractInstructionWithElse::cPtr_typeStructuredExtractInstructionWithElse (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionsList & argument_2)
:mVariableName (argument_0),
mCasesList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeStructuredExtractInstructionWithElse::isBuilt (void) const {
  return mVariableName.isBuilt () &&
       mCasesList.isBuilt () &&
       mElseInstructionList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_typeStructuredExtractInstructionWithElse'         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeStructuredExtractInstructionWithElse * GGS_typeStructuredExtractInstructionWithElse::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
    cPtr_typeStructuredExtractInstructionWithElse * ptr_ = (cPtr_typeStructuredExtractInstructionWithElse *) NULL ;
    macroMyNew (ptr_, cPtr_typeStructuredExtractInstructionWithElse (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeRoutineCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineCallInstruction::cPtr_typeRoutineCallInstruction (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1)
:aNomRoutine (argument_0),
mExpressionsList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeRoutineCallInstruction::isBuilt (void) const {
  return aNomRoutine.isBuilt () &&
       mExpressionsList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeRoutineCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeRoutineCallInstruction * GGS_typeRoutineCallInstruction::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1) {
    cPtr_typeRoutineCallInstruction * ptr_ = (cPtr_typeRoutineCallInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeRoutineCallInstruction (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeDropInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDropInstruction::cPtr_typeDropInstruction (const GGS_typeCplusPlusName & argument_0)
:aVariableConsommee (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeDropInstruction::isBuilt (void) const {
  return aVariableConsommee.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDropInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDropInstruction * GGS_typeDropInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0) {
    cPtr_typeDropInstruction * ptr_ = (cPtr_typeDropInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeDropInstruction (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableNomRoutinesDeclarees'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableNomRoutinesDeclarees & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableNomRoutinesDeclarees::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableNomRoutinesDeclarees *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeTableNomRoutinesDeclarees * info = (e_typeTableNomRoutinesDeclarees *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeTableNomRoutinesDeclarees::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_typeTableNomRoutinesDeclarees::element_type::stringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::constructor_empty (void) {
  GGS_typeTableNomRoutinesDeclarees result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableNomRoutinesDeclarees::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
     insulateMap () ;
    e_typeTableNomRoutinesDeclarees info  ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void insertKey_typeTableNomRoutinesDeclarees (C_Lexique & lexique_var_,
                                GGS_typeTableNomRoutinesDeclarees & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the routine '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeEntityToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEntityToGenerate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (void) {
  mPointer = (cPtr_typeEntityToGenerate *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (const GGS_typeEntityToGenerate & inOperand) {
  mPointer = (cPtr_typeEntityToGenerate *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
~GGS_typeEntityToGenerate (void) {
  macroDetachPointer (mPointer, cPtr_typeEntityToGenerate) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate::
operator = (const GGS_typeEntityToGenerate & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeEntityToGenerate::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate::
operator = (cPtr_typeEntityToGenerate * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (cPtr_typeEntityToGenerate * inSource) {
  mPointer = (cPtr_typeEntityToGenerate *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeEntityToGenerate * GGS_typeEntityToGenerate
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeEntityToGenerate) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeExternTypeToGenerate'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExternTypeToGenerate::cPtr_typeExternTypeToGenerate (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1)
:mName (argument_0),
mCppClassName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeExternTypeToGenerate::isBuilt (void) const {
  return mName.isBuilt () &&
       mCppClassName.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeExternTypeToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeExternTypeToGenerate * GGS_typeExternTypeToGenerate::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
    cPtr_typeExternTypeToGenerate * ptr_ = (cPtr_typeExternTypeToGenerate *) NULL ;
    macroMyNew (ptr_, cPtr_typeExternTypeToGenerate (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'setTypeToGenerate'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_setTypeToGenerate::cPtr_setTypeToGenerate (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1)
:mSetTypeName (argument_0),
mEnumElementTypeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_setTypeToGenerate::isBuilt (void) const {
  return mSetTypeName.isBuilt () &&
       mEnumElementTypeName.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_setTypeToGenerate'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_setTypeToGenerate * GGS_setTypeToGenerate::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
    cPtr_setTypeToGenerate * ptr_ = (cPtr_setTypeToGenerate *) NULL ;
    macroMyNew (ptr_, cPtr_setTypeToGenerate (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeRoutineAengendrer'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineAengendrer::cPtr_typeRoutineAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionsList & argument_2)
:aNomRoutine (argument_0),
aListeTypeEtNomsArguments (argument_1),
mInstructionsList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeRoutineAengendrer::isBuilt (void) const {
  return aNomRoutine.isBuilt () &&
       aListeTypeEtNomsArguments.isBuilt () &&
       mInstructionsList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRoutineAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeRoutineAengendrer * GGS_typeRoutineAengendrer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
    cPtr_typeRoutineAengendrer * ptr_ = (cPtr_typeRoutineAengendrer *) NULL ;
    macroMyNew (ptr_, cPtr_typeRoutineAengendrer (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_listTypeToImplement'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_listTypeToImplement::cPtr_C_listTypeToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2)
:aNomListe (argument_0),
mNonExternAttributesList (argument_1),
mExternAttributesList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_listTypeToImplement::isBuilt (void) const {
  return aNomListe.isBuilt () &&
       mNonExternAttributesList.isBuilt () &&
       mExternAttributesList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_listTypeToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_listTypeToImplement * GGS_C_listTypeToImplement::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2) {
    cPtr_C_listTypeToImplement * ptr_ = (cPtr_C_listTypeToImplement *) NULL ;
    macroMyNew (ptr_, cPtr_C_listTypeToImplement (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeDefinitionTableAimplementer'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefinitionTableAimplementer::cPtr_typeDefinitionTableAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_typeTableMethodesInsererChercher & argument_4,
                                const GGS_typeTableMethodesInsererChercher & argument_5,
                                const GGS_typeTableBlocsDeTable & argument_6,
                                const GGS_lstring & argument_7)
:aNomTable (argument_0),
mNonExternAttributesList (argument_1),
mExternAttributesList (argument_2),
aNomClasseGenerique (argument_3),
aTableMethodesInserer (argument_4),
aTableMethodesChercher (argument_5),
aTableMethodesSurcharger (argument_6),
mKeyTypeName (argument_7) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeDefinitionTableAimplementer::isBuilt (void) const {
  return aNomTable.isBuilt () &&
       mNonExternAttributesList.isBuilt () &&
       mExternAttributesList.isBuilt () &&
       aNomClasseGenerique.isBuilt () &&
       aTableMethodesInserer.isBuilt () &&
       aTableMethodesChercher.isBuilt () &&
       aTableMethodesSurcharger.isBuilt () &&
       mKeyTypeName.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeDefinitionTableAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDefinitionTableAimplementer * GGS_typeDefinitionTableAimplementer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_typeTableMethodesInsererChercher & argument_4,
                                const GGS_typeTableMethodesInsererChercher & argument_5,
                                const GGS_typeTableBlocsDeTable & argument_6,
                                const GGS_lstring & argument_7) {
    cPtr_typeDefinitionTableAimplementer * ptr_ = (cPtr_typeDefinitionTableAimplementer *) NULL ;
    macroMyNew (ptr_, cPtr_typeDefinitionTableAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'stateMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_stateMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_stateMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_stateMap::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_stateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_stateMap * info = (e_stateMap *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_stateMap::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_stateMap::element_type::stringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stateMap GGS_stateMap::constructor_empty (void) {
  GGS_stateMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_stateMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_stateMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_stateMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
     insulateMap () ;
    e_stateMap info  ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_stateMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_stateMap (C_Lexique & inLexique,
                                GGS_stateMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' state is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_stateMap (C_Lexique & lexique_var_,
                                GGS_stateMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' state is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_mapToImplement'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_mapToImplement::cPtr_C_mapToImplement (const GGS_stateMap & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_L_nameWithType & argument_3,
                                const GGS_typeTableMethodesInsererChercher & argument_4,
                                const GGS_typeTableMethodesInsererChercher & argument_5,
                                const GGS_lstring & argument_6)
:mStateMap (argument_0),
aNomTable (argument_1),
mNonExternAttributesList (argument_2),
mExternAttributesList (argument_3),
aTableMethodesInserer (argument_4),
aTableMethodesChercher (argument_5),
mKeyTypeName (argument_6) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_mapToImplement::isBuilt (void) const {
  return mStateMap.isBuilt () &&
       aNomTable.isBuilt () &&
       mNonExternAttributesList.isBuilt () &&
       mExternAttributesList.isBuilt () &&
       aTableMethodesInserer.isBuilt () &&
       aTableMethodesChercher.isBuilt () &&
       mKeyTypeName.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_mapToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_mapToImplement * GGS_C_mapToImplement::
    constructor_new (const GGS_stateMap & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_L_nameWithType & argument_3,
                                const GGS_typeTableMethodesInsererChercher & argument_4,
                                const GGS_typeTableMethodesInsererChercher & argument_5,
                                const GGS_lstring & argument_6) {
    cPtr_C_mapToImplement * ptr_ = (cPtr_C_mapToImplement *) NULL ;
    macroMyNew (ptr_, cPtr_C_mapToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeDefClasseAbstraiteAimplementer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefClasseAbstraiteAimplementer::cPtr_typeDefClasseAbstraiteAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_typeTableMethodesAimplementer & argument_4,
                                const GGS_typeListeAttributsSemantiques & argument_5,
                                const GGS_L_nameWithType & argument_6,
                                const GGS_typeSuperClassesMap & argument_7,
                                const GGS_typeClassMessagesMap & argument_8)
:aNomClasse (argument_0),
aListeTousAttributsNonExternes (argument_1),
aTableToutesMethodes (argument_2),
mGenerateIncludeHeader (argument_3),
mMethodsMap (argument_4),
aListeAttributsCourants (argument_5),
aListeExternesCourants (argument_6),
mAncestorClassesMap (argument_7),
mMessagesMap (argument_8) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeDefClasseAbstraiteAimplementer::isBuilt (void) const {
  return aNomClasse.isBuilt () &&
       aListeTousAttributsNonExternes.isBuilt () &&
       aTableToutesMethodes.isBuilt () &&
       mGenerateIncludeHeader.isBuilt () &&
       mMethodsMap.isBuilt () &&
       aListeAttributsCourants.isBuilt () &&
       aListeExternesCourants.isBuilt () &&
       mAncestorClassesMap.isBuilt () &&
       mMessagesMap.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeDefClasseAbstraiteAimplementer'            *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDefClasseAbstraiteAimplementer * GGS_typeDefClasseAbstraiteAimplementer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_typeTableMethodesAimplementer & argument_4,
                                const GGS_typeListeAttributsSemantiques & argument_5,
                                const GGS_L_nameWithType & argument_6,
                                const GGS_typeSuperClassesMap & argument_7,
                                const GGS_typeClassMessagesMap & argument_8) {
    cPtr_typeDefClasseAbstraiteAimplementer * ptr_ = (cPtr_typeDefClasseAbstraiteAimplementer *) NULL ;
    macroMyNew (ptr_, cPtr_typeDefClasseAbstraiteAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'typeDefClasseNonAbstraiteAimplementer'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefClasseNonAbstraiteAimplementer::cPtr_typeDefClasseNonAbstraiteAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7,
                                const GGS_bool& argument_8)
:aNomClasse (argument_0),
aListeTousAttributsNonExternes (argument_1),
aTableToutesMethodes (argument_2),
mMethodsMap (argument_3),
aListeAttributsCourants (argument_4),
aListeExternesCourants (argument_5),
mAncestorClassesMap (argument_6),
mMessagesMap (argument_7),
mGenerateIncludeHeader (argument_8) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeDefClasseNonAbstraiteAimplementer::isBuilt (void) const {
  return aNomClasse.isBuilt () &&
       aListeTousAttributsNonExternes.isBuilt () &&
       aTableToutesMethodes.isBuilt () &&
       mMethodsMap.isBuilt () &&
       aListeAttributsCourants.isBuilt () &&
       aListeExternesCourants.isBuilt () &&
       mAncestorClassesMap.isBuilt () &&
       mMessagesMap.isBuilt () &&
       mGenerateIncludeHeader.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_typeDefClasseNonAbstraiteAimplementer'          *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDefClasseNonAbstraiteAimplementer * GGS_typeDefClasseNonAbstraiteAimplementer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7,
                                const GGS_bool& argument_8) {
    cPtr_typeDefClasseNonAbstraiteAimplementer * ptr_ = (cPtr_typeDefClasseNonAbstraiteAimplementer *) NULL ;
    macroMyNew (ptr_, cPtr_typeDefClasseNonAbstraiteAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeEntiteActionExterne'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteActionExterne::cPtr_typeEntiteActionExterne (const GGS_L_signature & argument_0)
:aSignature (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteActionExterne::isBuilt (void) const {
  return aSignature.isBuilt () ;
}


const char * cPtr_typeEntiteActionExterne::message_messageTypeEntite (void) const {
  return "an external action" ;
}

const char * cPtr_typeEntiteActionExterne::static_string_message_messageTypeEntite (void) {
  return "an external action" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeEntiteActionExterne'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEntiteActionExterne * GGS_typeEntiteActionExterne::
    constructor_new (const GGS_L_signature & argument_0) {
    cPtr_typeEntiteActionExterne * ptr_ = (cPtr_typeEntiteActionExterne *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteActionExterne (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeActionExterneAengendrer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeActionExterneAengendrer::cPtr_typeActionExterneAengendrer (const GGS_lstring & argument_0,
                                const GGS_L_signature & argument_1)
:aNomAction (argument_0),
aSignature (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeActionExterneAengendrer::isBuilt (void) const {
  return aNomAction.isBuilt () &&
       aSignature.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeActionExterneAengendrer'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeActionExterneAengendrer * GGS_typeActionExterneAengendrer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_L_signature & argument_1) {
    cPtr_typeActionExterneAengendrer * ptr_ = (cPtr_typeActionExterneAengendrer *) NULL ;
    macroMyNew (ptr_, cPtr_typeActionExterneAengendrer (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//            Class element of list 'typeEntitiesToGenerateList'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::element_type::
element_type (const GGS_typeEntityToGenerate & argument_0) {
  mNextItem = (element_type *) NULL ;
  mEntityToGenerate = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class list 'typeEntitiesToGenerateList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList
::GGS_typeEntitiesToGenerateList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::~GGS_typeEntitiesToGenerateList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::GGS_typeEntitiesToGenerateList (const GGS_typeEntitiesToGenerateList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList
::operator = (const GGS_typeEntitiesToGenerateList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
internalAppendItem (const GGS_typeEntityToGenerate & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
addAssign_operation (const GGS_typeEntityToGenerate & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mEntityToGenerate) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList  GGS_typeEntitiesToGenerateList::
constructor_empty (void) {
  GGS_typeEntitiesToGenerateList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "enterBuiltinTypes"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterBuiltinTypes (C_Lexique & lexique_var_,
                                GGS_M_semanticsEntitiesForUse  & var_cas_ioComponentSemanticsEntitiesMap) {
  var_cas_ioComponentSemanticsEntitiesMap = GGS_M_semanticsEntitiesForUse::constructor_empty () ;
  GGS_lstring  var_cas_name ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "lstring"), GGS_location (lexique_var_)) ;
  GGS_AC_galgasType  var_cas_t ;
  var_cas_t = GGS_typeGalgas_lstring::constructor_new () ;
  GGS_AC_semanticsEntity  var_cas_e ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  insertKey_M_semanticsEntitiesForUse (lexique_var_,
                                  var_cas_ioComponentSemanticsEntitiesMap,
                                  var_cas_name,
                                  var_cas_e,
                                  NULL) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "lbool"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_lbool::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  insertKey_M_semanticsEntitiesForUse (lexique_var_,
                                  var_cas_ioComponentSemanticsEntitiesMap,
                                  var_cas_name,
                                  var_cas_e,
                                  NULL) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "luint"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_luint::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  insertKey_M_semanticsEntitiesForUse (lexique_var_,
                                  var_cas_ioComponentSemanticsEntitiesMap,
                                  var_cas_name,
                                  var_cas_e,
                                  NULL) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "lsint"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_lsint::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  insertKey_M_semanticsEntitiesForUse (lexique_var_,
                                  var_cas_ioComponentSemanticsEntitiesMap,
                                  var_cas_name,
                                  var_cas_e,
                                  NULL) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "ldouble"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_ldouble::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  insertKey_M_semanticsEntitiesForUse (lexique_var_,
                                  var_cas_ioComponentSemanticsEntitiesMap,
                                  var_cas_name,
                                  var_cas_e,
                                  NULL) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "lchar"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_lchar::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  insertKey_M_semanticsEntitiesForUse (lexique_var_,
                                  var_cas_ioComponentSemanticsEntitiesMap,
                                  var_cas_name,
                                  var_cas_e,
                                  NULL) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "location"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_location::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  insertKey_M_semanticsEntitiesForUse (lexique_var_,
                                  var_cas_ioComponentSemanticsEntitiesMap,
                                  var_cas_name,
                                  var_cas_e,
                                  NULL) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "uint"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_uint::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  insertKey_M_semanticsEntitiesForUse (lexique_var_,
                                  var_cas_ioComponentSemanticsEntitiesMap,
                                  var_cas_name,
                                  var_cas_e,
                                  NULL) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "sint"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_sint::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  insertKey_M_semanticsEntitiesForUse (lexique_var_,
                                  var_cas_ioComponentSemanticsEntitiesMap,
                                  var_cas_name,
                                  var_cas_e,
                                  NULL) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "char"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_char::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  insertKey_M_semanticsEntitiesForUse (lexique_var_,
                                  var_cas_ioComponentSemanticsEntitiesMap,
                                  var_cas_name,
                                  var_cas_e,
                                  NULL) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "string"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_string::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  insertKey_M_semanticsEntitiesForUse (lexique_var_,
                                  var_cas_ioComponentSemanticsEntitiesMap,
                                  var_cas_name,
                                  var_cas_e,
                                  NULL) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "bool"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_bool::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  insertKey_M_semanticsEntitiesForUse (lexique_var_,
                                  var_cas_ioComponentSemanticsEntitiesMap,
                                  var_cas_name,
                                  var_cas_e,
                                  NULL) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "double"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_double::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  insertKey_M_semanticsEntitiesForUse (lexique_var_,
                                  var_cas_ioComponentSemanticsEntitiesMap,
                                  var_cas_name,
                                  var_cas_e,
                                  NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map 'typeEnumCstMessageStringMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumCstMessageStringMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumCstMessageStringMap::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeEnumCstMessageStringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeEnumCstMessageStringMap * info = (e_typeEnumCstMessageStringMap *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeEnumCstMessageStringMap::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_typeEnumCstMessageStringMap::element_type::stringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::constructor_empty (void) {
  GGS_typeEnumCstMessageStringMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumCstMessageStringMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_typeEnumCstMessageStringMap info  ;
    info.mMessageString = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_lstring   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mMessageString ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeEnumCstMessageStringMap (C_Lexique & inLexique,
                                GGS_typeEnumCstMessageStringMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_lstring   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the message for '",
                                   "",
                                   "' constant is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeEnumCstMessageStringMap (C_Lexique & lexique_var_,
                                GGS_typeEnumCstMessageStringMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the message for '",
                                   "",
                                   "' constant is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'enumGalgasType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumGalgasType::cPtr_enumGalgasType (const GGS_lstring & argument_0,
                                const GGS_typeEnumConstantesMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2)
:mEnumTypeName (argument_0),
mConstantMap (argument_1),
mEnumMessageMap (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumGalgasType::isBuilt (void) const {
  return mEnumTypeName.isBuilt () &&
       mConstantMap.isBuilt () &&
       mEnumMessageMap.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_enumGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_enumGalgasType * GGS_enumGalgasType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeEnumConstantesMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2) {
    cPtr_enumGalgasType * ptr_ = (cPtr_enumGalgasType *) NULL ;
    macroMyNew (ptr_, cPtr_enumGalgasType (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*

