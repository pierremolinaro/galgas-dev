//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semantics_semantics.cpp'                       *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                     october 27th, 2006, at 9h56'41"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semantics_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "semantics_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeCplusPlusName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCplusPlusName::
cPtr_typeCplusPlusName (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCplusPlusName::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeCplusPlusName:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCplusPlusName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (const GGS_typeCplusPlusName & inOperand) {
  mPointer = (cPtr_typeCplusPlusName *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
~GGS_typeCplusPlusName (void) {
  macroDetachPointer (mPointer, cPtr_typeCplusPlusName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName::
operator = (const GGS_typeCplusPlusName & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCplusPlusName * GGS_typeCplusPlusName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCplusPlusName) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCplusPlusName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeCplusPlusName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeDirectName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectName::cPtr_typeDirectName (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectName::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeDirectName:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeDirectName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDirectName::
GGS_typeDirectName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectName GGS_typeDirectName::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeDirectName * _ptr = (cPtr_typeDirectName *) NULL ;
  macroMyNew (_ptr, cPtr_typeDirectName (argument_0 COMMA_THERE)) ;
  GGS_typeDirectName result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectName * GGS_typeDirectName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDirectName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDirectName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDirectName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeCppThisName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCppThisName::cPtr_typeCppThisName (LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCppThisName::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << " ->@typeCppThisName:" ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeCppThisName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCppThisName::
GGS_typeCppThisName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCppThisName GGS_typeCppThisName::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeCppThisName * _ptr = (cPtr_typeCppThisName *) NULL ;
  macroMyNew (_ptr, cPtr_typeCppThisName (THERE)) ;
  GGS_typeCppThisName result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCppThisName * GGS_typeCppThisName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCppThisName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCppThisName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeCppThisName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeCppThisName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeCppInheritedName'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCppInheritedName::cPtr_typeCppInheritedName (LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCppInheritedName::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << " ->@typeCppInheritedName:" ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCppInheritedName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCppInheritedName::
GGS_typeCppInheritedName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCppInheritedName GGS_typeCppInheritedName::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeCppInheritedName * _ptr = (cPtr_typeCppInheritedName *) NULL ;
  macroMyNew (_ptr, cPtr_typeCppInheritedName (THERE)) ;
  GGS_typeCppInheritedName result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCppInheritedName * GGS_typeCppInheritedName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCppInheritedName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCppInheritedName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeCppInheritedName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeCppInheritedName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeAutomaticName'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAutomaticName::cPtr_typeAutomaticName (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAutomaticName::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeAutomaticName:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAutomaticName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAutomaticName::
GGS_typeAutomaticName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeAutomaticName GGS_typeAutomaticName::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeAutomaticName * _ptr = (cPtr_typeAutomaticName *) NULL ;
  macroMyNew (_ptr, cPtr_typeAutomaticName (argument_0 COMMA_THERE)) ;
  GGS_typeAutomaticName result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAutomaticName * GGS_typeAutomaticName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAutomaticName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAutomaticName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeAutomaticName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeAutomaticName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLocationAutomaticName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLocationAutomaticName::cPtr_typeLocationAutomaticName (const GGS_location & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLocationAutomaticName::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeLocationAutomaticName:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLocationAutomaticName'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLocationAutomaticName::
GGS_typeLocationAutomaticName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLocationAutomaticName GGS_typeLocationAutomaticName::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_location & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeLocationAutomaticName * _ptr = (cPtr_typeLocationAutomaticName *) NULL ;
  macroMyNew (_ptr, cPtr_typeLocationAutomaticName (argument_0 COMMA_THERE)) ;
  GGS_typeLocationAutomaticName result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLocationAutomaticName * GGS_typeLocationAutomaticName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLocationAutomaticName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLocationAutomaticName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeLocationAutomaticName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLocationAutomaticName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeOperandName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOperandName::cPtr_typeOperandName (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mName (argument_0),
mLocationOffset (argument_1),
mFieldKind (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeOperandName::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeOperandName:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLocationOffset.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mFieldKind.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOperandName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeOperandName::
GGS_typeOperandName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeOperandName GGS_typeOperandName::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_location & argument_1,
                 const GGS_bool& argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeOperandName * _ptr = (cPtr_typeOperandName *) NULL ;
  macroMyNew (_ptr, cPtr_typeOperandName (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeOperandName result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOperandName * GGS_typeOperandName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOperandName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeOperandName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeOperandName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeOperandName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeKeyName'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeKeyName::cPtr_typeKeyName (const GGS_location & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mLocationOffset (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeKeyName::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeKeyName:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLocationOffset.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeKeyName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeKeyName::
GGS_typeKeyName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeKeyName GGS_typeKeyName::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_location & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeKeyName * _ptr = (cPtr_typeKeyName *) NULL ;
  macroMyNew (_ptr, cPtr_typeKeyName (argument_0 COMMA_THERE)) ;
  GGS_typeKeyName result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeKeyName * GGS_typeKeyName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeKeyName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeKeyName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeKeyName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeKeyName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeNullName'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNullName::cPtr_typeNullName (LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeNullName::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << " ->@typeNullName:" ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeNullName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeNullName::
GGS_typeNullName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeNullName GGS_typeNullName::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeNullName * _ptr = (cPtr_typeNullName *) NULL ;
  macroMyNew (_ptr, cPtr_typeNullName (THERE)) ;
  GGS_typeNullName result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNullName * GGS_typeNullName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNullName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeNullName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeNullName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeNullName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@typeCplusPlusNameList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeCplusPlusNameList::
elementOf_GGS_typeCplusPlusNameList (const GGS_typeCplusPlusName & argument_0):
mCppName (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeCplusPlusNameList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeCplusPlusNameList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::GGS_typeCplusPlusNameList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::
GGS_typeCplusPlusNameList (const GGS_typeCplusPlusNameList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_typeCplusPlusNameList::
operator = (const GGS_typeCplusPlusNameList & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_internalAppendValues (const GGS_typeCplusPlusName & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_internalPrependValues (const GGS_typeCplusPlusName & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList GGS_typeCplusPlusNameList::
operator + (const GGS_typeCplusPlusNameList & inOperand) const {
  GGS_typeCplusPlusNameList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeCplusPlusNameList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->mCppName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCppName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeCplusPlusNameList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeCplusPlusNameList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeCplusPlusNameList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeCplusPlusName & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeCplusPlusNameList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCplusPlusNameList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeCplusPlusNameList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
method_first (C_Lexique & _inLexique,
              GGS_typeCplusPlusName & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppName ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
method_last (C_Lexique & _inLexique,
             GGS_typeCplusPlusName & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppName ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
method_popFirst (C_Lexique & _inLexique,
                 GGS_typeCplusPlusName & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
method_popLast (C_Lexique & _inLexique,
                GGS_typeCplusPlusName & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExpression::
cPtr_typeExpression (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeExpression::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (const GGS_typeExpression & inOperand) {
  mPointer = (cPtr_typeExpression *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
~GGS_typeExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpression::
operator = (const GGS_typeExpression & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeExpression * GGS_typeExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeExpression::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeExpression) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'typeClassMessagesMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeClassMessagesMap::
elementOf_GGS_typeClassMessagesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeClassMessagesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeClassMessagesMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassMessagesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeClassMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeClassMessagesMap * info = (e_typeClassMessagesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeClassMessagesMap info  ;
    info.mMessage = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the message '%K' is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the message '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeClassMessagesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassMessagesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeClassMessagesMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeClassMessagesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeSemanticsTypesList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSemanticsTypesList::
elementOf_GGS_typeSemanticsTypesList (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1):
mType (argument_0),
mGalgasVariableName (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSemanticsTypesList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGalgasVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeSemanticsTypesList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::GGS_typeSemanticsTypesList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::
GGS_typeSemanticsTypesList (const GGS_typeSemanticsTypesList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_typeSemanticsTypesList::
operator = (const GGS_typeSemanticsTypesList & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList GGS_typeSemanticsTypesList::
operator + (const GGS_typeSemanticsTypesList & inOperand) const {
  GGS_typeSemanticsTypesList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeSemanticsTypesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_lstring  p_1 = p->mGalgasVariableName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mGalgasVariableName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList  GGS_typeSemanticsTypesList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticsTypesList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList  GGS_typeSemanticsTypesList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_AC_galgasType & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticsTypesList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSemanticsTypesList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeSemanticsTypesList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
method_first (C_Lexique & _inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mGalgasVariableName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
method_last (C_Lexique & _inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mGalgasVariableName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
method_popFirst (C_Lexique & _inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mGalgasVariableName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
method_popLast (C_Lexique & _inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mGalgasVariableName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map element 'e_typeVariablesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cGalgasVariablesMap.hh"

//---------------------------------------------------------------------------*

template class cGalgasVariablesMap <e_typeVariablesMap> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Map 'typeVariablesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariablesMap GGS_typeVariablesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeVariablesMap t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadOnlyAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadOnlyAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outIndex._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForDestructiveReadAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive read mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForDestructiveReadAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive read mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outIndex._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadWriteAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadWriteAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outIndex._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForWriteAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForWriteAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outIndex._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertListOfEntitiesLocalVariable (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertListOfEntitiesLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertListOfEntitiesLocalVariableGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertListOfEntitiesLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertSingleEntityLocalVariable (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertSingleEntityLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertSingleEntityLocalVariableGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertSingleEntityLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertEntityAttributeLocalVariable (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertEntityAttributeLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertEntityAttributeLocalVariableGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertEntityAttributeLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUnusedInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUnusedInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUnusedInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertConstInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertConstInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUsedConstInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUsedConstInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUsedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUnusedConstInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUnusedConstInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUnusedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertLocalVariable (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertLocalVariableGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertOutProperty (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertOutProperty (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertOutPropertyGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertOutProperty (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertInOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertInOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUsedInOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUsedInOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUsedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUnusedInOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_insertUnusedInOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUnusedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariablesMap::
reader_description (C_Lexique & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<map @typeVariablesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_assignedVariables'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_assignedVariables::
elementOf_GGS_L_assignedVariables (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1):
aNomVariableCible (argument_0),
aNomAttributSource (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_assignedVariables::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aNomVariableCible.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aNomAttributSource.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@L_assignedVariables'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_assignedVariables::GGS_L_assignedVariables (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables::
GGS_L_assignedVariables (const GGS_L_assignedVariables & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_L_assignedVariables::
operator = (const GGS_L_assignedVariables & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_internalAppendValues (const GGS_typeCplusPlusName & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_internalPrependValues (const GGS_typeCplusPlusName & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables GGS_L_assignedVariables::
operator + (const GGS_L_assignedVariables & inOperand) const {
  GGS_L_assignedVariables result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_assignedVariables * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->aNomVariableCible ;
          GGS_lstring  p_1 = p->aNomAttributSource ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->aNomVariableCible,
                                _p->aNomAttributSource) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_L_assignedVariables::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_assignedVariables result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_L_assignedVariables::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeCplusPlusName & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_assignedVariables result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_assignedVariables::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_assignedVariables", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
method_first (C_Lexique & _inLexique,
              GGS_typeCplusPlusName & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aNomVariableCible ;
    _out_1 = _p->aNomAttributSource ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
method_last (C_Lexique & _inLexique,
             GGS_typeCplusPlusName & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aNomVariableCible ;
    _out_1 = _p->aNomAttributSource ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
method_popFirst (C_Lexique & _inLexique,
                 GGS_typeCplusPlusName & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aNomVariableCible ;
    _out_1 = _p->aNomAttributSource ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
method_popLast (C_Lexique & _inLexique,
                GGS_typeCplusPlusName & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aNomVariableCible ;
    _out_1 = _p->aNomAttributSource ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeCible'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCible::
cPtr_typeCible (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCible::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeCible:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeCible'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (const GGS_typeCible & inOperand) {
  mPointer = (cPtr_typeCible *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
~GGS_typeCible (void) {
  macroDetachPointer (mPointer, cPtr_typeCible) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCible::
operator = (const GGS_typeCible & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCible * GGS_typeCible::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeCible::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCible) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCible::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeCible" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@typeListeCibles'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCibles::
elementOf_GGS_typeListeCibles (const GGS_typeCible & argument_0):
aCible (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeCibles::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aCible.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCibles'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeCibles::GGS_typeListeCibles (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles::
GGS_typeListeCibles (const GGS_typeListeCibles & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_typeListeCibles::
operator = (const GGS_typeListeCibles & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_internalAppendValues (const GGS_typeCible & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_internalPrependValues (const GGS_typeCible & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_addAssign_operation (const GGS_typeCible & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles GGS_typeListeCibles::
operator + (const GGS_typeListeCibles & inOperand) const {
  GGS_typeListeCibles result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeCibles * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCible  p_0 = p->aCible ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeCible & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->aCible) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles  GGS_typeListeCibles::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeCibles result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles  GGS_typeListeCibles::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeCible & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeCibles result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeCibles::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeCibles", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
method_first (C_Lexique & _inLexique,
              GGS_typeCible & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aCible ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
method_last (C_Lexique & _inLexique,
             GGS_typeCible & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aCible ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
method_popFirst (C_Lexique & _inLexique,
                 GGS_typeCible & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aCible ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
method_popLast (C_Lexique & _inLexique,
                GGS_typeCible & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aCible ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeListeTypesEtNomsArgMethode'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeTypesEtNomsArgMethode::
elementOf_GGS_typeListeTypesEtNomsArgMethode (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3):
mType (argument_0),
mFormalArgumentPassingMode (argument_1),
mCppName (argument_2),
mModeIn (argument_3) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeTypesEtNomsArgMethode::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mModeIn.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeTypesEtNomsArgMethode'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::GGS_typeListeTypesEtNomsArgMethode (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::
GGS_typeListeTypesEtNomsArgMethode (const GGS_typeListeTypesEtNomsArgMethode & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_typeListeTypesEtNomsArgMethode::
operator = (const GGS_typeListeTypesEtNomsArgMethode & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_formalArgumentPassingMode& argument_1,
                    const GGS_typeCplusPlusName & argument_2,
                    const GGS_bool& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_formalArgumentPassingMode& argument_1,
                    const GGS_typeCplusPlusName & argument_2,
                    const GGS_bool& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
_addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode GGS_typeListeTypesEtNomsArgMethode::
operator + (const GGS_typeListeTypesEtNomsArgMethode & inOperand) const {
  GGS_typeListeTypesEtNomsArgMethode result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeTypesEtNomsArgMethode * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_formalArgumentPassingMode p_1 = p->mFormalArgumentPassingMode ;
          GGS_typeCplusPlusName  p_2 = p->mCppName ;
          GGS_bool p_3 = p->mModeIn ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_formalArgumentPassingMode& argument_1,
                     const GGS_typeCplusPlusName & argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mFormalArgumentPassingMode,
                                _p->mCppName,
                                _p->mModeIn) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_typeListeTypesEtNomsArgMethode::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeTypesEtNomsArgMethode result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_typeListeTypesEtNomsArgMethode::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_AC_galgasType & argument_0,
                           const GGS_formalArgumentPassingMode& argument_1,
                           const GGS_typeCplusPlusName & argument_2,
                           const GGS_bool& argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeTypesEtNomsArgMethode result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeTypesEtNomsArgMethode::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeTypesEtNomsArgMethode", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
method_first (C_Lexique & _inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_formalArgumentPassingMode& _out_1,
              GGS_typeCplusPlusName & _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _out_2 = _p->mCppName ;
    _out_3 = _p->mModeIn ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
method_last (C_Lexique & _inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_formalArgumentPassingMode& _out_1,
             GGS_typeCplusPlusName & _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _out_2 = _p->mCppName ;
    _out_3 = _p->mModeIn ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
method_popFirst (C_Lexique & _inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_formalArgumentPassingMode& _out_1,
                 GGS_typeCplusPlusName & _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _out_2 = _p->mCppName ;
    _out_3 = _p->mModeIn ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
method_popLast (C_Lexique & _inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_formalArgumentPassingMode& _out_1,
                GGS_typeCplusPlusName & _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _out_2 = _p->mCppName ;
    _out_3 = _p->mModeIn ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstruction::
cPtr_typeInstruction (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstruction::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (const GGS_typeInstruction & inOperand) {
  mPointer = (cPtr_typeInstruction *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
~GGS_typeInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstruction::
operator = (const GGS_typeInstruction & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstruction * GGS_typeInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeInstruction::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeInstruction) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeInstructionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeInstructionList::
elementOf_GGS_typeInstructionList (const GGS_typeInstruction & argument_0):
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeInstructionList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@typeInstructionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionList::GGS_typeInstructionList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList::
GGS_typeInstructionList (const GGS_typeInstructionList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_typeInstructionList::
operator = (const GGS_typeInstructionList & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
_internalAppendValues (const GGS_typeInstruction & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
_internalPrependValues (const GGS_typeInstruction & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
_addAssign_operation (const GGS_typeInstruction & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList GGS_typeInstructionList::
operator + (const GGS_typeInstructionList & inOperand) const {
  GGS_typeInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeInstructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeInstruction  p_0 = p->mInstruction ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeInstruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeInstructionList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeInstructionList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeInstruction & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeInstructionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
method_first (C_Lexique & _inLexique,
              GGS_typeInstruction & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
method_last (C_Lexique & _inLexique,
             GGS_typeInstruction & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
method_popFirst (C_Lexique & _inLexique,
                 GGS_typeInstruction & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
method_popLast (C_Lexique & _inLexique,
                GGS_typeInstruction & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_nameWithType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_nameWithType::
elementOf_GGS_L_nameWithType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1):
mType (argument_0),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_nameWithType::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_nameWithType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_nameWithType::GGS_L_nameWithType (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType::
GGS_L_nameWithType (const GGS_L_nameWithType & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_L_nameWithType::
operator = (const GGS_L_nameWithType & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType GGS_L_nameWithType::
operator + (const GGS_L_nameWithType & inOperand) const {
  GGS_L_nameWithType result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_nameWithType * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mType ;
          GGS_lstring  p_1 = p->mName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType  GGS_L_nameWithType::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_nameWithType result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType  GGS_L_nameWithType::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_nameWithType result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_nameWithType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_nameWithType", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
method_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
method_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//           class map element 'e_typeTableMethodesAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cTableMethodesAimplementer.hh"

//---------------------------------------------------------------------------*

template class cTableMethodesAimplementer <e_typeTableMethodesAimplementer> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map 'typeTableMethodesAimplementer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableMethodesAimplementer GGS_typeTableMethodesAimplementer::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodesAimplementer t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::method_insertAbstract (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  insertAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::method_insertAbstractGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  const sint32 index = insertAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::method_insertNotAbstract (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  insertNotAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::method_insertNotAbstractGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  const sint32 index = insertNotAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMethodesAimplementer::
reader_description (C_Lexique & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<map @typeTableMethodesAimplementer " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeExpressionList::
elementOf_GGS_typeExpressionList (const GGS_typeExpression & argument_0):
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeExpressionList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@typeExpressionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExpressionList::GGS_typeExpressionList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList::
GGS_typeExpressionList (const GGS_typeExpressionList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_typeExpressionList::
operator = (const GGS_typeExpressionList & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_internalAppendValues (const GGS_typeExpression & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_internalPrependValues (const GGS_typeExpression & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_addAssign_operation (const GGS_typeExpression & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList GGS_typeExpressionList::
operator + (const GGS_typeExpressionList & inOperand) const {
  GGS_typeExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeExpressionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeExpression  p_0 = p->mExpression ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeExpression & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeExpressionList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeExpressionList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeExpression & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeExpressionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeExpressionList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
method_first (C_Lexique & _inLexique,
              GGS_typeExpression & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mExpression ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
method_last (C_Lexique & _inLexique,
             GGS_typeExpression & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mExpression ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
method_popFirst (C_Lexique & _inLexique,
                 GGS_typeExpression & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mExpression ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
method_popLast (C_Lexique & _inLexique,
                GGS_typeExpression & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mExpression ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@varToDropList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_varToDropList::
elementOf_GGS_varToDropList (const GGS_typeCplusPlusName & argument_0):
mVarToDrop (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_varToDropList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVarToDrop.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@varToDropList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_varToDropList::GGS_varToDropList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_varToDropList::
GGS_varToDropList (const GGS_varToDropList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_varToDropList::
operator = (const GGS_varToDropList & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_varToDropList::
_internalAppendValues (const GGS_typeCplusPlusName & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
_internalPrependValues (const GGS_typeCplusPlusName & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
_addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList GGS_varToDropList::
operator + (const GGS_varToDropList & inOperand) const {
  GGS_varToDropList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_varToDropList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->mVarToDrop ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mVarToDrop) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_varToDropList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_varToDropList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_varToDropList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeCplusPlusName & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_varToDropList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_varToDropList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@varToDropList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
method_first (C_Lexique & _inLexique,
              GGS_typeCplusPlusName & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVarToDrop ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
method_last (C_Lexique & _inLexique,
             GGS_typeCplusPlusName & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVarToDrop ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
method_popFirst (C_Lexique & _inLexique,
                 GGS_typeCplusPlusName & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVarToDrop ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
method_popLast (C_Lexique & _inLexique,
                GGS_typeCplusPlusName & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVarToDrop ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeErrorInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeErrorInstruction::cPtr_typeErrorInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_varToDropList & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mErrorLocationExpression (argument_0),
mErrorMessageExpression (argument_1),
mLocation (argument_2),
mVarToDropList (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_typeErrorInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeErrorInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mErrorMessageExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mVarToDropList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeErrorInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeErrorInstruction::
GGS_typeErrorInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeErrorInstruction GGS_typeErrorInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2,
                 const GGS_varToDropList & argument_3 COMMA_LOCATION_ARGS) {
  cPtr_typeErrorInstruction * _ptr = (cPtr_typeErrorInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeErrorInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  GGS_typeErrorInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeErrorInstruction * GGS_typeErrorInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeErrorInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeErrorInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeErrorInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeWarningInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeWarningInstruction::cPtr_typeWarningInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mWarningLocationExpression (argument_0),
mWarningMessageExpression (argument_1),
mLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeWarningInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeWarningInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mWarningLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mWarningMessageExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeWarningInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeWarningInstruction::
GGS_typeWarningInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeWarningInstruction GGS_typeWarningInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeWarningInstruction * _ptr = (cPtr_typeWarningInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeWarningInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeWarningInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeWarningInstruction * GGS_typeWarningInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeWarningInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeWarningInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeWarningInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeMessageInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMessageInstruction::cPtr_typeMessageInstruction (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mMessageExpression (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMessageInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeMessageInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mMessageExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeMessageInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMessageInstruction::
GGS_typeMessageInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeMessageInstruction GGS_typeMessageInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeMessageInstruction * _ptr = (cPtr_typeMessageInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeMessageInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeMessageInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMessageInstruction * GGS_typeMessageInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMessageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMessageInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeMessageInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeMessageInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeReaderCallInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeReaderCallInstruction::cPtr_typeReaderCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aNomMethodeSimple (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeReaderCallInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeReaderCallInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomCppVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomMethodeSimple.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeReaderCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeReaderCallInstruction::
GGS_typeReaderCallInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeReaderCallInstruction GGS_typeReaderCallInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeReaderCallInstruction * _ptr = (cPtr_typeReaderCallInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeReaderCallInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeReaderCallInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeReaderCallInstruction * GGS_typeReaderCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeReaderCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeReaderCallInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeReaderCallInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeModifierCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModifierCallInstruction::cPtr_typeModifierCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aNomMethodeSimple (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeModifierCallInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeModifierCallInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomCppVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomMethodeSimple.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeModifierCallInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction::
GGS_typeModifierCallInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction GGS_typeModifierCallInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeModifierCallInstruction * _ptr = (cPtr_typeModifierCallInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeModifierCallInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeModifierCallInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeModifierCallInstruction * GGS_typeModifierCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeModifierCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeModifierCallInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeModifierCallInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeInstructionAppelMethodeListe'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelMethodeListe::cPtr_typeInstructionAppelMethodeListe (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppAttribut (argument_0),
aMethodeDeListe (argument_1),
aListeNomsCppArguments (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelMethodeListe::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeInstructionAppelMethodeListe:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomCppAttribut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aMethodeDeListe.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aListeNomsCppArguments.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelMethodeListe'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe::
GGS_typeInstructionAppelMethodeListe (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe GGS_typeInstructionAppelMethodeListe::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeCplusPlusNameList & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeInstructionAppelMethodeListe * _ptr = (cPtr_typeInstructionAppelMethodeListe *) NULL ;
  macroMyNew (_ptr, cPtr_typeInstructionAppelMethodeListe (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeInstructionAppelMethodeListe result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelMethodeListe * GGS_typeInstructionAppelMethodeListe::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionAppelMethodeListe *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionAppelMethodeListe::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionAppelMethodeListe" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'typeInstructionDeclarationVarLocale'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionDeclarationVarLocale::cPtr_typeInstructionDeclarationVarLocale (const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aTypeVariable (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionDeclarationVarLocale::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeInstructionDeclarationVarLocale:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomCppVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aTypeVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeInstructionDeclarationVarLocale'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale::
GGS_typeInstructionDeclarationVarLocale (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale GGS_typeInstructionDeclarationVarLocale::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_AC_galgasType & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeInstructionDeclarationVarLocale * _ptr = (cPtr_typeInstructionDeclarationVarLocale *) NULL ;
  macroMyNew (_ptr, cPtr_typeInstructionDeclarationVarLocale (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeInstructionDeclarationVarLocale result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionDeclarationVarLocale * GGS_typeInstructionDeclarationVarLocale::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionDeclarationVarLocale *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionDeclarationVarLocale::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionDeclarationVarLocale" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeMapBlockPrologueInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockPrologueInstruction::cPtr_typeMapBlockPrologueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mPrologueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMapBlockPrologueInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeMapBlockPrologueInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomVariableTable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomMethodeBloc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mPrologueExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockPrologueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction::
GGS_typeMapBlockPrologueInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction GGS_typeMapBlockPrologueInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeMapBlockPrologueInstruction * _ptr = (cPtr_typeMapBlockPrologueInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeMapBlockPrologueInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeMapBlockPrologueInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMapBlockPrologueInstruction * GGS_typeMapBlockPrologueInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMapBlockPrologueInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeMapBlockPrologueInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeMapBlockPrologueInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeMapBlockEpilogueInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockEpilogueInstruction::cPtr_typeMapBlockEpilogueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mEpilogueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMapBlockEpilogueInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeMapBlockEpilogueInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomVariableTable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomMethodeBloc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mEpilogueExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockEpilogueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction::
GGS_typeMapBlockEpilogueInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction GGS_typeMapBlockEpilogueInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeMapBlockEpilogueInstruction * _ptr = (cPtr_typeMapBlockEpilogueInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeMapBlockEpilogueInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeMapBlockEpilogueInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMapBlockEpilogueInstruction * GGS_typeMapBlockEpilogueInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMapBlockEpilogueInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeMapBlockEpilogueInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeMapBlockEpilogueInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeReaderCallInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeReaderCallInExpression::cPtr_typeReaderCallInExpression (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_location & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpressionValue (argument_0),
mReaderName (argument_1),
mExpressionList (argument_2),
mInstructionLocation (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_typeReaderCallInExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeReaderCallInExpression:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExpressionValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mReaderName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeReaderCallInExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression::
GGS_typeReaderCallInExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression GGS_typeReaderCallInExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2,
                 const GGS_location & argument_3 COMMA_LOCATION_ARGS) {
  cPtr_typeReaderCallInExpression * _ptr = (cPtr_typeReaderCallInExpression *) NULL ;
  macroMyNew (_ptr, cPtr_typeReaderCallInExpression (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  GGS_typeReaderCallInExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeReaderCallInExpression * GGS_typeReaderCallInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeReaderCallInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeReaderCallInExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeReaderCallInExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeAndOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAndOperation::cPtr_typeAndOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAndOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeAndOperation:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAndOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAndOperation::
GGS_typeAndOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeAndOperation GGS_typeAndOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeAndOperation * _ptr = (cPtr_typeAndOperation *) NULL ;
  macroMyNew (_ptr, cPtr_typeAndOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeAndOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAndOperation * GGS_typeAndOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAndOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeAndOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeAndOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeOrOperation'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOrOperation::cPtr_typeOrOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeOrOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeOrOperation:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOrOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeOrOperation::
GGS_typeOrOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeOrOperation GGS_typeOrOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeOrOperation * _ptr = (cPtr_typeOrOperation *) NULL ;
  macroMyNew (_ptr, cPtr_typeOrOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeOrOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOrOperation * GGS_typeOrOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeOrOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeOrOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeOrOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeXorOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeXorOperation::cPtr_typeXorOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeXorOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeXorOperation:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeXorOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeXorOperation::
GGS_typeXorOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeXorOperation GGS_typeXorOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeXorOperation * _ptr = (cPtr_typeXorOperation *) NULL ;
  macroMyNew (_ptr, cPtr_typeXorOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeXorOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeXorOperation * GGS_typeXorOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeXorOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeXorOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeXorOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeConcatOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConcatOperation::cPtr_typeConcatOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeConcatOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeConcatOperation:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConcatOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeConcatOperation::
GGS_typeConcatOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeConcatOperation GGS_typeConcatOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeConcatOperation * _ptr = (cPtr_typeConcatOperation *) NULL ;
  macroMyNew (_ptr, cPtr_typeConcatOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeConcatOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConcatOperation * GGS_typeConcatOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeConcatOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeConcatOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeConcatOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeTrueBool'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTrueBool::cPtr_typeTrueBool (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeTrueBool::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << " ->@typeTrueBool:" ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeTrueBool'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTrueBool::
GGS_typeTrueBool (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeTrueBool GGS_typeTrueBool::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeTrueBool * _ptr = (cPtr_typeTrueBool *) NULL ;
  macroMyNew (_ptr, cPtr_typeTrueBool (THERE)) ;
  GGS_typeTrueBool result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTrueBool * GGS_typeTrueBool::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTrueBool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeTrueBool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeTrueBool::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeTrueBool" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFalseBool'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFalseBool::cPtr_typeFalseBool (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFalseBool::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << " ->@typeFalseBool:" ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFalseBool'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFalseBool::
GGS_typeFalseBool (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFalseBool GGS_typeFalseBool::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeFalseBool * _ptr = (cPtr_typeFalseBool *) NULL ;
  macroMyNew (_ptr, cPtr_typeFalseBool (THERE)) ;
  GGS_typeFalseBool result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFalseBool * GGS_typeFalseBool::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFalseBool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFalseBool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeFalseBool::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFalseBool" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeLiteralStringExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralStringExpression::cPtr_typeLiteralStringExpression (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralString (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralStringExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeLiteralStringExpression:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLiteralString.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralStringExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression::
GGS_typeLiteralStringExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression GGS_typeLiteralStringExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeLiteralStringExpression * _ptr = (cPtr_typeLiteralStringExpression *) NULL ;
  macroMyNew (_ptr, cPtr_typeLiteralStringExpression (argument_0 COMMA_THERE)) ;
  GGS_typeLiteralStringExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralStringExpression * GGS_typeLiteralStringExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralStringExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralStringExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeLiteralStringExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLiteralStringExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralUIntExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralUIntExpression::cPtr_typeLiteralUIntExpression (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralUIntExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeLiteralUIntExpression:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLiteralInt.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralUIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression::
GGS_typeLiteralUIntExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression GGS_typeLiteralUIntExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeLiteralUIntExpression * _ptr = (cPtr_typeLiteralUIntExpression *) NULL ;
  macroMyNew (_ptr, cPtr_typeLiteralUIntExpression (argument_0 COMMA_THERE)) ;
  GGS_typeLiteralUIntExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralUIntExpression * GGS_typeLiteralUIntExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralUIntExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeLiteralUIntExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLiteralUIntExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralSIntExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralSIntExpression::cPtr_typeLiteralSIntExpression (const GGS_lsint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralSIntExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeLiteralSIntExpression:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLiteralInt.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralSIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression::
GGS_typeLiteralSIntExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression GGS_typeLiteralSIntExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lsint & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeLiteralSIntExpression * _ptr = (cPtr_typeLiteralSIntExpression *) NULL ;
  macroMyNew (_ptr, cPtr_typeLiteralSIntExpression (argument_0 COMMA_THERE)) ;
  GGS_typeLiteralSIntExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralSIntExpression * GGS_typeLiteralSIntExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralSIntExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeLiteralSIntExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLiteralSIntExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeLiteralUInt64Expression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralUInt64Expression::cPtr_typeLiteralUInt64Expression (const GGS_luint64 & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralUInt64Expression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeLiteralUInt64Expression:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLiteralInt.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralUInt64Expression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression::
GGS_typeLiteralUInt64Expression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression GGS_typeLiteralUInt64Expression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint64 & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeLiteralUInt64Expression * _ptr = (cPtr_typeLiteralUInt64Expression *) NULL ;
  macroMyNew (_ptr, cPtr_typeLiteralUInt64Expression (argument_0 COMMA_THERE)) ;
  GGS_typeLiteralUInt64Expression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralUInt64Expression * GGS_typeLiteralUInt64Expression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralUInt64Expression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeLiteralUInt64Expression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLiteralUInt64Expression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeLiteralSInt64Expression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralSInt64Expression::cPtr_typeLiteralSInt64Expression (const GGS_lsint64 & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralSInt64Expression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeLiteralSInt64Expression:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLiteralInt.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralSInt64Expression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression::
GGS_typeLiteralSInt64Expression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression GGS_typeLiteralSInt64Expression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lsint64 & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeLiteralSInt64Expression * _ptr = (cPtr_typeLiteralSInt64Expression *) NULL ;
  macroMyNew (_ptr, cPtr_typeLiteralSInt64Expression (argument_0 COMMA_THERE)) ;
  GGS_typeLiteralSInt64Expression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralSInt64Expression * GGS_typeLiteralSInt64Expression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralSInt64Expression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeLiteralSInt64Expression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLiteralSInt64Expression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralCharExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralCharExpression::cPtr_typeLiteralCharExpression (const GGS_lchar & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralChar (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralCharExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeLiteralCharExpression:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLiteralChar.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralCharExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression::
GGS_typeLiteralCharExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression GGS_typeLiteralCharExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lchar & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeLiteralCharExpression * _ptr = (cPtr_typeLiteralCharExpression *) NULL ;
  macroMyNew (_ptr, cPtr_typeLiteralCharExpression (argument_0 COMMA_THERE)) ;
  GGS_typeLiteralCharExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralCharExpression * GGS_typeLiteralCharExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralCharExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralCharExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeLiteralCharExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLiteralCharExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeLiteralDoubleExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralDoubleExpression::cPtr_typeLiteralDoubleExpression (const GGS_ldouble & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralDouble (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralDoubleExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeLiteralDoubleExpression:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLiteralDouble.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralDoubleExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression::
GGS_typeLiteralDoubleExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression GGS_typeLiteralDoubleExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_ldouble & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeLiteralDoubleExpression * _ptr = (cPtr_typeLiteralDoubleExpression *) NULL ;
  macroMyNew (_ptr, cPtr_typeLiteralDoubleExpression (argument_0 COMMA_THERE)) ;
  GGS_typeLiteralDoubleExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralDoubleExpression * GGS_typeLiteralDoubleExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralDoubleExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralDoubleExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeLiteralDoubleExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLiteralDoubleExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeHereExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeHereExpression::cPtr_typeHereExpression (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeHereExpression::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << " ->@typeHereExpression:" ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeHereExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeHereExpression::
GGS_typeHereExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeHereExpression GGS_typeHereExpression::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeHereExpression * _ptr = (cPtr_typeHereExpression *) NULL ;
  macroMyNew (_ptr, cPtr_typeHereExpression (THERE)) ;
  GGS_typeHereExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeHereExpression * GGS_typeHereExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeHereExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeHereExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeHereExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeHereExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeConstructorExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConstructorExpression::cPtr_typeConstructorExpression (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mClassName (argument_0),
mClassMethodName (argument_1),
mExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeConstructorExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeConstructorExpression:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mClassMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeConstructorExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeConstructorExpression::
GGS_typeConstructorExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeConstructorExpression GGS_typeConstructorExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeConstructorExpression * _ptr = (cPtr_typeConstructorExpression *) NULL ;
  macroMyNew (_ptr, cPtr_typeConstructorExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeConstructorExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConstructorExpression * GGS_typeConstructorExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeConstructorExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeConstructorExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeConstructorExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeTestComplement'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTestComplement::cPtr_typeTestComplement (const GGS_typeExpression & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeTestComplement::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeTestComplement:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeTestComplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTestComplement::
GGS_typeTestComplement (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeTestComplement GGS_typeTestComplement::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeTestComplement * _ptr = (cPtr_typeTestComplement *) NULL ;
  macroMyNew (_ptr, cPtr_typeTestComplement (argument_0 COMMA_THERE)) ;
  GGS_typeTestComplement result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTestComplement * GGS_typeTestComplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTestComplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeTestComplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeTestComplement::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeTestComplement" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeLogicalNegate'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLogicalNegate::cPtr_typeLogicalNegate (const GGS_typeExpression & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLogicalNegate::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeLogicalNegate:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeLogicalNegate'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLogicalNegate::
GGS_typeLogicalNegate (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLogicalNegate GGS_typeLogicalNegate::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeLogicalNegate * _ptr = (cPtr_typeLogicalNegate *) NULL ;
  macroMyNew (_ptr, cPtr_typeLogicalNegate (argument_0 COMMA_THERE)) ;
  GGS_typeLogicalNegate result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLogicalNegate * GGS_typeLogicalNegate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogicalNegate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLogicalNegate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeLogicalNegate::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLogicalNegate" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeBoolOption'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeBoolOption::cPtr_typeBoolOption (const GGS_string& argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeBoolOption::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeBoolOption:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mOptionComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mOptionName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeBoolOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeBoolOption::
GGS_typeBoolOption (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeBoolOption GGS_typeBoolOption::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeBoolOption * _ptr = (cPtr_typeBoolOption *) NULL ;
  macroMyNew (_ptr, cPtr_typeBoolOption (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeBoolOption result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeBoolOption * GGS_typeBoolOption::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeBoolOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeBoolOption *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeBoolOption::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeBoolOption" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeUIntOption'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUIntOption::cPtr_typeUIntOption (const GGS_string& argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUIntOption::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeUIntOption:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mOptionComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mOptionName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUIntOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUIntOption::
GGS_typeUIntOption (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeUIntOption GGS_typeUIntOption::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeUIntOption * _ptr = (cPtr_typeUIntOption *) NULL ;
  macroMyNew (_ptr, cPtr_typeUIntOption (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeUIntOption result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUIntOption * GGS_typeUIntOption::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUIntOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUIntOption *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeUIntOption::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeUIntOption" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeStringOption'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStringOption::cPtr_typeStringOption (const GGS_string& argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeStringOption::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeStringOption:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mOptionComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mOptionName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStringOption'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStringOption::
GGS_typeStringOption (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeStringOption GGS_typeStringOption::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeStringOption * _ptr = (cPtr_typeStringOption *) NULL ;
  macroMyNew (_ptr, cPtr_typeStringOption (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeStringOption result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStringOption * GGS_typeStringOption::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStringOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStringOption *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeStringOption::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeStringOption" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeVarInExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVarInExpression::cPtr_typeVarInExpression (const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mCppVarName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeVarInExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeVarInExpression:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mCppVarName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeVarInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVarInExpression::
GGS_typeVarInExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeVarInExpression GGS_typeVarInExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeVarInExpression * _ptr = (cPtr_typeVarInExpression *) NULL ;
  macroMyNew (_ptr, cPtr_typeVarInExpression (argument_0 COMMA_THERE)) ;
  GGS_typeVarInExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeVarInExpression * GGS_typeVarInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeVarInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeVarInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeVarInExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeVarInExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeJokerInExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJokerInExpression::cPtr_typeJokerInExpression (const GGS_location & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeJokerInExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeJokerInExpression:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeJokerInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeJokerInExpression::
GGS_typeJokerInExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeJokerInExpression GGS_typeJokerInExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_location & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeJokerInExpression * _ptr = (cPtr_typeJokerInExpression *) NULL ;
  macroMyNew (_ptr, cPtr_typeJokerInExpression (argument_0 COMMA_THERE)) ;
  GGS_typeJokerInExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeJokerInExpression * GGS_typeJokerInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeJokerInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeJokerInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeJokerInExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeJokerInExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeAddOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAddOperation::cPtr_typeAddOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAddOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeAddOperation:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAddOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAddOperation::
GGS_typeAddOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeAddOperation GGS_typeAddOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeAddOperation * _ptr = (cPtr_typeAddOperation *) NULL ;
  macroMyNew (_ptr, cPtr_typeAddOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeAddOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAddOperation * GGS_typeAddOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAddOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeAddOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeAddOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeSubOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSubOperation::cPtr_typeSubOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeSubOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeSubOperation:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeSubOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSubOperation::
GGS_typeSubOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeSubOperation GGS_typeSubOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeSubOperation * _ptr = (cPtr_typeSubOperation *) NULL ;
  macroMyNew (_ptr, cPtr_typeSubOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeSubOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSubOperation * GGS_typeSubOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeSubOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeSubOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeSubOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeMultiplyOperation'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMultiplyOperation::cPtr_typeMultiplyOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMultiplyOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeMultiplyOperation:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMultiplyOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation::
GGS_typeMultiplyOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation GGS_typeMultiplyOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeMultiplyOperation * _ptr = (cPtr_typeMultiplyOperation *) NULL ;
  macroMyNew (_ptr, cPtr_typeMultiplyOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeMultiplyOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMultiplyOperation * GGS_typeMultiplyOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMultiplyOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeMultiplyOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeMultiplyOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeDivideOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDivideOperation::cPtr_typeDivideOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDivideOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeDivideOperation:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDivideOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDivideOperation::
GGS_typeDivideOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDivideOperation GGS_typeDivideOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeDivideOperation * _ptr = (cPtr_typeDivideOperation *) NULL ;
  macroMyNew (_ptr, cPtr_typeDivideOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeDivideOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDivideOperation * GGS_typeDivideOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDivideOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDivideOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDivideOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeModuloOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModuloOperation::cPtr_typeModuloOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeModuloOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeModuloOperation:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeModuloOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeModuloOperation::
GGS_typeModuloOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeModuloOperation GGS_typeModuloOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeModuloOperation * _ptr = (cPtr_typeModuloOperation *) NULL ;
  macroMyNew (_ptr, cPtr_typeModuloOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeModuloOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeModuloOperation * GGS_typeModuloOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeModuloOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeModuloOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeModuloOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeUnaryMinusOperation'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUnaryMinusOperation::cPtr_typeUnaryMinusOperation (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUnaryMinusOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeUnaryMinusOperation:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeUnaryMinusOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation::
GGS_typeUnaryMinusOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation GGS_typeUnaryMinusOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeUnaryMinusOperation * _ptr = (cPtr_typeUnaryMinusOperation *) NULL ;
  macroMyNew (_ptr, cPtr_typeUnaryMinusOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeUnaryMinusOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUnaryMinusOperation * GGS_typeUnaryMinusOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUnaryMinusOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUnaryMinusOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeUnaryMinusOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeUnaryMinusOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEqualTest'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEqualTest::cPtr_typeEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeEqualTest::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeEqualTest:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeEqualTest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEqualTest::
GGS_typeEqualTest (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEqualTest GGS_typeEqualTest::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeEqualTest * _ptr = (cPtr_typeEqualTest *) NULL ;
  macroMyNew (_ptr, cPtr_typeEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeEqualTest result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEqualTest * GGS_typeEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeEqualTest::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeEqualTest" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeNonEqualTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonEqualTest::cPtr_typeNonEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeNonEqualTest::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeNonEqualTest:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeNonEqualTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeNonEqualTest::
GGS_typeNonEqualTest (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeNonEqualTest GGS_typeNonEqualTest::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeNonEqualTest * _ptr = (cPtr_typeNonEqualTest *) NULL ;
  macroMyNew (_ptr, cPtr_typeNonEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeNonEqualTest result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNonEqualTest * GGS_typeNonEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeNonEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeNonEqualTest::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeNonEqualTest" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeStrictInfTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictInfTest::cPtr_typeStrictInfTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeStrictInfTest::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeStrictInfTest:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictInfTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStrictInfTest::
GGS_typeStrictInfTest (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictInfTest GGS_typeStrictInfTest::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeStrictInfTest * _ptr = (cPtr_typeStrictInfTest *) NULL ;
  macroMyNew (_ptr, cPtr_typeStrictInfTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeStrictInfTest result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStrictInfTest * GGS_typeStrictInfTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStrictInfTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeStrictInfTest::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeStrictInfTest" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeInfOrEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInfOrEqualTest::cPtr_typeInfOrEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInfOrEqualTest::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeInfOrEqualTest:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeInfOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest::
GGS_typeInfOrEqualTest (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest GGS_typeInfOrEqualTest::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeInfOrEqualTest * _ptr = (cPtr_typeInfOrEqualTest *) NULL ;
  macroMyNew (_ptr, cPtr_typeInfOrEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeInfOrEqualTest result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInfOrEqualTest * GGS_typeInfOrEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInfOrEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeInfOrEqualTest::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInfOrEqualTest" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeStrictSupTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictSupTest::cPtr_typeStrictSupTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeStrictSupTest::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeStrictSupTest:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictSupTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStrictSupTest::
GGS_typeStrictSupTest (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictSupTest GGS_typeStrictSupTest::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeStrictSupTest * _ptr = (cPtr_typeStrictSupTest *) NULL ;
  macroMyNew (_ptr, cPtr_typeStrictSupTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeStrictSupTest result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStrictSupTest * GGS_typeStrictSupTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStrictSupTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeStrictSupTest::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeStrictSupTest" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeSupOrEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSupOrEqualTest::cPtr_typeSupOrEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeSupOrEqualTest::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeSupOrEqualTest:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeSupOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest::
GGS_typeSupOrEqualTest (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest GGS_typeSupOrEqualTest::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeSupOrEqualTest * _ptr = (cPtr_typeSupOrEqualTest *) NULL ;
  macroMyNew (_ptr, cPtr_typeSupOrEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeSupOrEqualTest result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSupOrEqualTest * GGS_typeSupOrEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeSupOrEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeSupOrEqualTest::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeSupOrEqualTest" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeLeftShiftOperation'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLeftShiftOperation::cPtr_typeLeftShiftOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLeftShiftOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeLeftShiftOperation:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeLeftShiftOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation::
GGS_typeLeftShiftOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation GGS_typeLeftShiftOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeLeftShiftOperation * _ptr = (cPtr_typeLeftShiftOperation *) NULL ;
  macroMyNew (_ptr, cPtr_typeLeftShiftOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeLeftShiftOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLeftShiftOperation * GGS_typeLeftShiftOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLeftShiftOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeLeftShiftOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLeftShiftOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeRightShiftOperation'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRightShiftOperation::cPtr_typeRightShiftOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeRightShiftOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeRightShiftOperation:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeRightShiftOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation::
GGS_typeRightShiftOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation GGS_typeRightShiftOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeRightShiftOperation * _ptr = (cPtr_typeRightShiftOperation *) NULL ;
  macroMyNew (_ptr, cPtr_typeRightShiftOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeRightShiftOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRightShiftOperation * GGS_typeRightShiftOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRightShiftOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeRightShiftOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeRightShiftOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeTextTableCall'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTextTableCall::cPtr_typeTextTableCall (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0),
aNomMethodeTest (argument_1),
aNomCppClef (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeTextTableCall::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeTextTableCall:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomMethodeTest.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomCppClef.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeTextTableCall'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTextTableCall::
GGS_typeTextTableCall (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeTextTableCall GGS_typeTextTableCall::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeCplusPlusName & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeTextTableCall * _ptr = (cPtr_typeTextTableCall *) NULL ;
  macroMyNew (_ptr, cPtr_typeTextTableCall (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeTextTableCall result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTextTableCall * GGS_typeTextTableCall::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeTextTableCall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeTextTableCall::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeTextTableCall" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_assignmentInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_assignmentInstruction::cPtr_C_assignmentInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_assignmentInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_assignmentInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_assignmentInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction::
GGS_C_assignmentInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction GGS_C_assignmentInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_assignmentInstruction * _ptr = (cPtr_C_assignmentInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_C_assignmentInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_assignmentInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_assignmentInstruction * GGS_C_assignmentInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_assignmentInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_assignmentInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_assignmentInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'C_declarationInstructionWithAssignment'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_declarationInstructionWithAssignment::cPtr_C_declarationInstructionWithAssignment (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariableType (argument_0),
mTargetVarCppName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_C_declarationInstructionWithAssignment::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_declarationInstructionWithAssignment:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mVariableType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_declarationInstructionWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment::
GGS_C_declarationInstructionWithAssignment (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment GGS_C_declarationInstructionWithAssignment::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_typeExpression & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_C_declarationInstructionWithAssignment * _ptr = (cPtr_C_declarationInstructionWithAssignment *) NULL ;
  macroMyNew (_ptr, cPtr_C_declarationInstructionWithAssignment (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_C_declarationInstructionWithAssignment result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_declarationInstructionWithAssignment * GGS_C_declarationInstructionWithAssignment::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_declarationInstructionWithAssignment *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_declarationInstructionWithAssignment::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_declarationInstructionWithAssignment" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_while_instruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_while_instruction::cPtr_C_while_instruction (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_typeInstructionList & argument_3,
                                const GGS_location & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariantExpression (argument_0),
mInstructionList1 (argument_1),
mWhileExpression (argument_2),
mInstructionList2 (argument_3),
mLocation (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_C_while_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_while_instruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mVariantExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionList1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mWhileExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionList2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_while_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_while_instruction::
GGS_C_while_instruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_while_instruction GGS_C_while_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeInstructionList & argument_1,
                 const GGS_typeExpression & argument_2,
                 const GGS_typeInstructionList & argument_3,
                 const GGS_location & argument_4 COMMA_LOCATION_ARGS) {
  cPtr_C_while_instruction * _ptr = (cPtr_C_while_instruction *) NULL ;
  macroMyNew (_ptr, cPtr_C_while_instruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  GGS_C_while_instruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_while_instruction * GGS_C_while_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_while_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_while_instruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_while_instruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@L_expression_instructionsList_list'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_expression_instructionsList_list::
elementOf_GGS_L_expression_instructionsList_list (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1):
mIFexpression (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_expression_instructionsList_list::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFexpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@L_expression_instructionsList_list'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::GGS_L_expression_instructionsList_list (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::
GGS_L_expression_instructionsList_list (const GGS_L_expression_instructionsList_list & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_L_expression_instructionsList_list::
operator = (const GGS_L_expression_instructionsList_list & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_internalAppendValues (const GGS_typeExpression & argument_0,
                    const GGS_typeInstructionList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_internalPrependValues (const GGS_typeExpression & argument_0,
                    const GGS_typeInstructionList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_addAssign_operation (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list GGS_L_expression_instructionsList_list::
operator + (const GGS_L_expression_instructionsList_list & inOperand) const {
  GGS_L_expression_instructionsList_list result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_expression_instructionsList_list * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeExpression  p_0 = p->mIFexpression ;
          GGS_typeInstructionList  p_1 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeExpression & argument_0,
                     const GGS_typeInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mIFexpression,
                                _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_L_expression_instructionsList_list::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_expression_instructionsList_list result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_L_expression_instructionsList_list::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeExpression & argument_0,
                           const GGS_typeInstructionList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_expression_instructionsList_list result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_expression_instructionsList_list::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_expression_instructionsList_list", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
method_first (C_Lexique & _inLexique,
              GGS_typeExpression & _out_0,
              GGS_typeInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
method_last (C_Lexique & _inLexique,
             GGS_typeExpression & _out_0,
             GGS_typeInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
method_popFirst (C_Lexique & _inLexique,
                 GGS_typeExpression & _out_0,
                 GGS_typeInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
method_popLast (C_Lexique & _inLexique,
                GGS_typeExpression & _out_0,
                GGS_typeInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_if_instruction'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_if_instruction::cPtr_C_if_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_if_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_if_instruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mIFbranchesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mElseInstructionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_if_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_if_instruction::
GGS_C_if_instruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_if_instruction GGS_C_if_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_L_expression_instructionsList_list & argument_0,
                 const GGS_typeInstructionList & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_if_instruction * _ptr = (cPtr_C_if_instruction *) NULL ;
  macroMyNew (_ptr, cPtr_C_if_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_if_instruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_if_instruction * GGS_C_if_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_if_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_if_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_if_instruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_if_instruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_switchBranchlist'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_switchBranchlist::
elementOf_GGS_L_switchBranchlist (const GGS_stringset & argument_0,
                                const GGS_typeInstructionList & argument_1):
mConstantSet (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_switchBranchlist::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantSet.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@L_switchBranchlist'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_switchBranchlist::GGS_L_switchBranchlist (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist::
GGS_L_switchBranchlist (const GGS_L_switchBranchlist & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_L_switchBranchlist::
operator = (const GGS_L_switchBranchlist & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_internalAppendValues (const GGS_stringset & argument_0,
                    const GGS_typeInstructionList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_internalPrependValues (const GGS_stringset & argument_0,
                    const GGS_typeInstructionList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_addAssign_operation (const GGS_stringset & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist GGS_L_switchBranchlist::
operator + (const GGS_L_switchBranchlist & inOperand) const {
  GGS_L_switchBranchlist result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_switchBranchlist * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_stringset  p_0 = p->mConstantSet ;
          GGS_typeInstructionList  p_1 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_stringset & argument_0,
                     const GGS_typeInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mConstantSet,
                                _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist  GGS_L_switchBranchlist::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_switchBranchlist result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist  GGS_L_switchBranchlist::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_stringset & argument_0,
                           const GGS_typeInstructionList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_switchBranchlist result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_switchBranchlist::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_switchBranchlist", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
method_first (C_Lexique & _inLexique,
              GGS_stringset & _out_0,
              GGS_typeInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantSet ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
method_last (C_Lexique & _inLexique,
             GGS_stringset & _out_0,
             GGS_typeInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantSet ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
method_popFirst (C_Lexique & _inLexique,
                 GGS_stringset & _out_0,
                 GGS_typeInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantSet ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
method_popLast (C_Lexique & _inLexique,
                GGS_stringset & _out_0,
                GGS_typeInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantSet ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_switch_instruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_switch_instruction::cPtr_C_switch_instruction (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_switchBranchlist & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mSwitchExpression (argument_0),
mEnumTypeName (argument_1),
mBranchList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_C_switch_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_switch_instruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mSwitchExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_switch_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_switch_instruction::
GGS_C_switch_instruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_switch_instruction GGS_C_switch_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_L_switchBranchlist & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_C_switch_instruction * _ptr = (cPtr_C_switch_instruction *) NULL ;
  macroMyNew (_ptr, cPtr_C_switch_instruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_C_switch_instruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_switch_instruction * GGS_C_switch_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_switch_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_switch_instruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_switch_instruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableRoutinesAimplementer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableRoutinesAimplementer::
elementOf_GGS_typeTableRoutinesAimplementer (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableRoutinesAimplementer & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableRoutinesAimplementer::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableRoutinesAimplementer::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableRoutinesAimplementer *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableRoutinesAimplementer * info = (e_typeTableRoutinesAimplementer *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableRoutinesAimplementer info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the routine '%K' is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableRoutinesAimplementer & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableRoutinesAimplementer result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableRoutinesAimplementer::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableRoutinesAimplementer " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableAttributsSemantiques'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableAttributsSemantiques::
elementOf_GGS_typeTableAttributsSemantiques (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableAttributsSemantiques & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableAttributsSemantiques::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aNomCppAttribut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAttributType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableAttributsSemantiques::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableAttributsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableAttributsSemantiques * info = (e_typeTableAttributsSemantiques *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeCplusPlusName &  inParameter0,
               const GGS_AC_galgasType &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableAttributsSemantiques info  ;
    info.aNomCppAttribut = inParameter0 ;
    info.mAttributType = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeCplusPlusName   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aNomCppAttribut ;
    outParameter1 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeCplusPlusName   & outParameter0,
                                GGS_AC_galgasType   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the attribute '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeCplusPlusName & inParameter0,
                                const GGS_AC_galgasType & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the attribute '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableAttributsSemantiques & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableAttributsSemantiques result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableAttributsSemantiques::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableAttributsSemantiques " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "buildMapWithLocalConstants"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildMapWithLocalConstants (C_Lexique & _inLexique,
                                GGS_L_nameWithType   var_cas_inLocalDeclarationsList,
                                GGS_typeListeAttributsSemantiques   var_cas_inSemanticAttributsList,
                                GGS_typeVariablesMap  & var_cas_ioVariablesMap,
                                GGS_location   var_cas_inLocation,
                                GGS_localConstantBuildStyleEnum  var_cas_inLocalConstantStyle,
                                GGS_bool  var_cas_inEllipsisFound COMMA_UNUSED_LOCATION_ARGS) {
  GGS_bool var_cas_mapStyle ;
  var_cas_mapStyle = (var_cas_inLocalConstantStyle) != (GGS_localConstantBuildStyleEnum::constructor_listStyle (_inLexique COMMA_HERE)) ;
  GGS_bool var_cas_firstOne ;
  var_cas_firstOne = GGS_bool (true, true) ;
  GGS_L_nameWithType::element_type * operand_31352 = var_cas_inLocalDeclarationsList.firstObject () ;
  GGS_typeListeAttributsSemantiques::element_type * operand_31437 = var_cas_inSemanticAttributsList.firstObject () ;
  while ((operand_31352 != NULL)
      && (operand_31437 != NULL)) {
    macroValidPointer (operand_31352) ;
    macroValidPointer (operand_31437) ;
    if (((operand_31352->mName.reader_string (_inLexique SOURCE_FILE_AT_LINE (769))) != (GGS_string (true, ""))).isBuiltAndTrue ()) {
      GGS_string var_cas_typeName ;
      if (operand_31437->mAttributType._isBuilt ()) {
        operand_31437->mAttributType (HERE)->method_getTypeName (_inLexique, var_cas_typeName SOURCE_FILE_AT_LINE (771)) ;
      }
      if (((operand_31352->mType.reader_string (_inLexique SOURCE_FILE_AT_LINE (772))) == (var_cas_typeName)).isBuiltAndTrue ()) {
        GGS_typeCplusPlusName  var_cas_cppName ;
        if (((((var_cas_inLocalConstantStyle) == (GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (_inLexique COMMA_HERE))) & (var_cas_firstOne))).isBuiltAndTrue ()) {
          var_cas_cppName = GGS_typeKeyName::constructor_new (_inLexique, var_cas_inLocation COMMA_HERE) ;
        }else{
          var_cas_cppName = GGS_typeOperandName::constructor_new (_inLexique, operand_31437->aNomAttribut, var_cas_inLocation, var_cas_mapStyle COMMA_HERE) ;
        }
        var_cas_ioVariablesMap.method_insertUsedConstInArgument (_inLexique, operand_31352->mName, operand_31437->mAttributType, var_cas_cppName SOURCE_FILE_AT_LINE (779)) ;
      }else{
        operand_31352->mType.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I have found the '@")) + (operand_31352->mType.reader_string (_inLexique SOURCE_FILE_AT_LINE (781))))) + (GGS_string (true, "' type, I was expected the '@")))) + (var_cas_typeName))) + (GGS_string (true, "' type"))) SOURCE_FILE_AT_LINE (783)) ;
      }
    }
    var_cas_firstOne = GGS_bool (true, false) ;
    operand_31352 = operand_31352->nextObject () ;
    operand_31437 = operand_31437->nextObject () ;
  }
  if (((((var_cas_inLocalDeclarationsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (788))) < (var_cas_inSemanticAttributsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (788)))) & ((! (var_cas_inEllipsisFound))))).isBuiltAndTrue ()) {
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "one or more parameters missing: found ")) + (var_cas_inLocalDeclarationsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (790)).reader_string (_inLexique SOURCE_FILE_AT_LINE (790))))) + (GGS_string (true, " effective parameters, while ")))) + (var_cas_inSemanticAttributsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (791)).reader_string (_inLexique SOURCE_FILE_AT_LINE (791))))) + (GGS_string (true, " are needed"))) SOURCE_FILE_AT_LINE (792)) ;
  }else if (((var_cas_inLocalDeclarationsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (792))) > (var_cas_inSemanticAttributsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (792)))).isBuiltAndTrue ()) {
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "too much parameters: found ")) + (var_cas_inLocalDeclarationsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (794)).reader_string (_inLexique SOURCE_FILE_AT_LINE (794))))) + (GGS_string (true, " effective parameters, while ")))) + (var_cas_inSemanticAttributsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (795)).reader_string (_inLexique SOURCE_FILE_AT_LINE (795))))) + (GGS_string (true, " are needed"))) SOURCE_FILE_AT_LINE (796)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "verifierCompatibiliteTypes"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteTypes (C_Lexique & _inLexique,
                                const GGS_typeSemanticsTypesList  & var_cas_t1,
                                const GGS_typeListeAttributsSemantiques  & var_cas_t2,
                                const GGS_location  & var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_t1.reader_length (_inLexique SOURCE_FILE_AT_LINE (811))) < (var_cas_t2.reader_length (_inLexique SOURCE_FILE_AT_LINE (811)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more identifiers missing") SOURCE_FILE_AT_LINE (813)) ;
  }else if (((var_cas_t1.reader_length (_inLexique SOURCE_FILE_AT_LINE (813))) > (var_cas_t2.reader_length (_inLexique SOURCE_FILE_AT_LINE (813)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "too much identifiers") SOURCE_FILE_AT_LINE (815)) ;
  }else{
    GGS_typeSemanticsTypesList::element_type * operand_33743 = var_cas_t1.firstObject () ;
    GGS_typeListeAttributsSemantiques::element_type * operand_33824 = var_cas_t2.firstObject () ;
    while ((operand_33743 != NULL)
        && (operand_33824 != NULL)) {
      macroValidPointer (operand_33743) ;
      macroValidPointer (operand_33824) ;
      ::routine_checkAssignmentTypesCompatibility (_inLexique,  operand_33743->mType,  operand_33824->mAttributType,  operand_33743->mGalgasVariableName.reader_location (_inLexique SOURCE_FILE_AT_LINE (821)),  GGS_bool (true, false) SOURCE_FILE_AT_LINE (819)) ;
      operand_33743 = operand_33743->nextObject () ;
      operand_33824 = operand_33824->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Implementation of routine "verifierCompatibiliteArgEffectifsSignature"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteArgEffectifsSignature (C_Lexique & _inLexique,
                                const GGS_L_EXsignature  & var_cas_signatureReference,
                                const GGS_L_actualParametersSignature  & var_cas_inEffectiveArgumentsSignature,
                                const GGS_location  & var_cas_inErrorLocation,
                                GGS_typeInstructionList  & var_cas_ioInstructionsList,
                                GGS_typeExpressionList  & var_cas_ioExpressionList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_signatureReference.reader_length (_inLexique SOURCE_FILE_AT_LINE (841))) > (var_cas_inEffectiveArgumentsSignature.reader_length (_inLexique SOURCE_FILE_AT_LINE (841)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more arguments missing") SOURCE_FILE_AT_LINE (843)) ;
  }else if (((var_cas_signatureReference.reader_length (_inLexique SOURCE_FILE_AT_LINE (843))) < (var_cas_inEffectiveArgumentsSignature.reader_length (_inLexique SOURCE_FILE_AT_LINE (843)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "too much arguments") SOURCE_FILE_AT_LINE (845)) ;
  }else{
    GGS_L_EXsignature::element_type * operand_35097 = var_cas_signatureReference.firstObject () ;
    GGS_L_actualParametersSignature::element_type * operand_35222 = var_cas_inEffectiveArgumentsSignature.firstObject () ;
    while ((operand_35097 != NULL)
        && (operand_35222 != NULL)) {
      macroValidPointer (operand_35097) ;
      macroValidPointer (operand_35222) ;
      if (operand_35097->mFormalArgumentPassingMode._isBuilt () && operand_35222->mFormalArgumentPassingMode._isBuilt ()) {
        if ((operand_35097->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentConstantIn) && (operand_35222->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOut)) {
          ::routine_checkAssignmentTypesCompatibility (_inLexique,  operand_35097->mType,  operand_35222->mType,  var_cas_inErrorLocation,  GGS_bool (true, true) SOURCE_FILE_AT_LINE (851)) ;
        }else{
          if ((operand_35097->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentIn) && (operand_35222->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOut)) {
            ::routine_checkAssignmentTypesCompatibility (_inLexique,  operand_35097->mType,  operand_35222->mType,  var_cas_inErrorLocation,  GGS_bool (true, true) SOURCE_FILE_AT_LINE (853)) ;
          }else{
            if ((operand_35097->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentInOut) && (operand_35222->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOutIn)) {
              ::routine_checkAssignmentTypesCompatibility (_inLexique,  operand_35097->mType,  operand_35222->mType,  var_cas_inErrorLocation,  GGS_bool (true, false) SOURCE_FILE_AT_LINE (855)) ;
            }else{
              if ((operand_35097->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentOut) && (operand_35222->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterIn)) {
                if (operand_35222->mType._isBuilt ()) {
                  if (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (operand_35222->mType.getPtr ()) != NULL) {
                  }else{ // Else part
                    ::routine_checkAssignmentTypesCompatibility (_inLexique,  operand_35097->mType,  operand_35222->mType,  var_cas_inErrorLocation,  GGS_bool (true, false) SOURCE_FILE_AT_LINE (860)) ;
                  }
                }
              }else{
                var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((operand_35222->mFormalArgumentPassingMode.reader_actualArgumentMessage (_inLexique SOURCE_FILE_AT_LINE (863))) + (GGS_string (true, " is not compatible with ")))) + (operand_35097->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique SOURCE_FILE_AT_LINE (864)))) SOURCE_FILE_AT_LINE (865)) ;
              }
            }
          }
        }
      }
      operand_35097 = operand_35097->nextObject () ;
      operand_35222 = operand_35222->nextObject () ;
    }
    GGS_typeExpressionList  var_cas_expressionList ;
    var_cas_expressionList = var_cas_ioExpressionList ;
    var_cas_ioExpressionList = GGS_typeExpressionList::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_L_EXsignature::element_type * operand_36489 = var_cas_signatureReference.firstObject () ;
    GGS_typeExpressionList::element_type * operand_36553 = var_cas_expressionList.firstObject () ;
    while ((operand_36489 != NULL)
        && (operand_36553 != NULL)) {
      macroValidPointer (operand_36489) ;
      macroValidPointer (operand_36553) ;
      if (operand_36553->mExpression._isBuilt ()) {
        if (dynamic_cast <cPtr_typeJokerInExpression *> (operand_36553->mExpression.getPtr ()) != NULL) {
          cPtr_typeJokerInExpression * operand_36636 = dynamic_cast <cPtr_typeJokerInExpression *> (operand_36553->mExpression.getPtr ()) ;
          macroValidPointer (operand_36636) ; 
          GGS_typeCplusPlusName  var_cas_cppVarName ;
          var_cas_cppVarName = GGS_typeLocationAutomaticName::constructor_new (_inLexique, operand_36636->mLocation COMMA_HERE) ;
          GGS_typeExpression  var_cas_e ;
          var_cas_e = GGS_typeVarInExpression::constructor_new (_inLexique, var_cas_cppVarName COMMA_HERE) ;
          var_cas_ioExpressionList._addAssign_operation (var_cas_e) ;
          GGS_typeInstruction  var_cas_i ;
          var_cas_i = GGS_typeInstructionDeclarationVarLocale::constructor_new (_inLexique, var_cas_cppVarName, operand_36489->mType COMMA_HERE) ;
          var_cas_ioInstructionsList._addAssign_operation (var_cas_i) ;
        }else{ // Else part
          var_cas_ioExpressionList._addAssign_operation (operand_36553->mExpression) ;
        }
      }
      operand_36489 = operand_36489->nextObject () ;
      operand_36553 = operand_36553->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'typeJoker'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJoker::cPtr_typeJoker (LOCATION_ARGS)
:cPtr_typeCible (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::
method_verifierType (C_Lexique & _inLexique,
                                GGS_AC_galgasType  /* var_cas_typeArgumentFormel */,
                                GGS_lstring & /* var_cas_nomAttributSource */,
                                GGS_L_assignedVariables & /* var_cas_listeAffectations */,
                                GGS_typeCplusPlusNameList & var_cas_outAllVariablesList COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeCplusPlusName  var_cas_nullName ;
  var_cas_nullName = GGS_typeNullName::constructor_new (_inLexique COMMA_HERE) ;
  var_cas_outAllVariablesList._addAssign_operation (var_cas_nullName) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << " ->@typeJoker:" ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeJoker'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeJoker::
GGS_typeJoker (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeJoker GGS_typeJoker::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeJoker * _ptr = (cPtr_typeJoker *) NULL ;
  macroMyNew (_ptr, cPtr_typeJoker (THERE)) ;
  GGS_typeJoker result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeJoker * GGS_typeJoker::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeJoker *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeJoker *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeJoker::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeJoker" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEntiteDest'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteDest::cPtr_typeEntiteDest (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeCible (THERE),
aTypeVarDest (argument_0),
mCppName (argument_1),
aPositionVariableCible (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::
method_verifierType (C_Lexique & _inLexique,
                                GGS_AC_galgasType  var_cas_typeArgumentFormel,
                                GGS_lstring & var_cas_nomAttributSource,
                                GGS_L_assignedVariables & var_cas_listeAffectations,
                                GGS_typeCplusPlusNameList & var_cas_ioAllVariablesList COMMA_UNUSED_LOCATION_ARGS) {
  ::routine_checkAssignmentTypesCompatibility (_inLexique,  aTypeVarDest,  var_cas_typeArgumentFormel,  aPositionVariableCible,  GGS_bool (true, false) SOURCE_FILE_AT_LINE (919)) ;
  var_cas_listeAffectations._addAssign_operation (mCppName, var_cas_nomAttributSource) ;
  var_cas_ioAllVariablesList._addAssign_operation (mCppName) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeEntiteDest:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aTypeVarDest.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aPositionVariableCible.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteDest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntiteDest::
GGS_typeEntiteDest (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteDest GGS_typeEntiteDest::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeEntiteDest * _ptr = (cPtr_typeEntiteDest *) NULL ;
  macroMyNew (_ptr, cPtr_typeEntiteDest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeEntiteDest result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteDest * GGS_typeEntiteDest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteDest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteDest::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeEntiteDest" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map 'M_nonTerminalSymbolForSyntax'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonTerminalSymbolForSyntax::
elementOf_GGS_M_nonTerminalSymbolForSyntax (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonTerminalSymbolForSyntax & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonTerminalSymbolForSyntax::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAltParametersMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonTerminalSymbolForSyntax::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolForSyntax *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonTerminalSymbolForSyntax * info = (e_M_nonTerminalSymbolForSyntax *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAlts &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_nonTerminalSymbolForSyntax info  ;
    info.mAltParametersMap = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAlts   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAltParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' non terminal symbol is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' non terminal symbol is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_nonTerminalSymbolForSyntax & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonTerminalSymbolForSyntax result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonTerminalSymbolForSyntax::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_nonTerminalSymbolForSyntax " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_grammarInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarInstruction::cPtr_C_grammarInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_lstring & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mSourceFileCppName (argument_0),
mGrammarName (argument_1),
mExpressionsList (argument_2),
mAltSymbol (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_C_grammarInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_grammarInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mSourceFileCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mGrammarName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mAltSymbol.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_grammarInstruction::
GGS_C_grammarInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarInstruction GGS_C_grammarInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2,
                 const GGS_lstring & argument_3 COMMA_LOCATION_ARGS) {
  cPtr_C_grammarInstruction * _ptr = (cPtr_C_grammarInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_C_grammarInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  GGS_C_grammarInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_grammarInstruction * GGS_C_grammarInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_grammarInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_grammarInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_grammarInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeAppendInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAppendInstruction::cPtr_typeAppendInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mSourceExpressions (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAppendInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeAppendInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mSourceExpressions.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeAppendInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAppendInstruction::
GGS_typeAppendInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeAppendInstruction GGS_typeAppendInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeAppendInstruction * _ptr = (cPtr_typeAppendInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeAppendInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeAppendInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAppendInstruction * GGS_typeAppendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAppendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeAppendInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeAppendInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeRemoveInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRemoveInstruction::cPtr_typeRemoveInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mSourceExpressions (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeRemoveInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeRemoveInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mSourceExpressions.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRemoveInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRemoveInstruction::
GGS_typeRemoveInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeRemoveInstruction GGS_typeRemoveInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeRemoveInstruction * _ptr = (cPtr_typeRemoveInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeRemoveInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeRemoveInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRemoveInstruction * GGS_typeRemoveInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRemoveInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRemoveInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeRemoveInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeRemoveInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeIncrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeIncrementInstruction::cPtr_typeIncrementInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeIncrementInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeIncrementInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeIncrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction::
GGS_typeIncrementInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction GGS_typeIncrementInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeIncrementInstruction * _ptr = (cPtr_typeIncrementInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeIncrementInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeIncrementInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeIncrementInstruction * GGS_typeIncrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeIncrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeIncrementInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeIncrementInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeDecrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDecrementInstruction::cPtr_typeDecrementInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDecrementInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeDecrementInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDecrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction::
GGS_typeDecrementInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction GGS_typeDecrementInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeDecrementInstruction * _ptr = (cPtr_typeDecrementInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeDecrementInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeDecrementInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDecrementInstruction * GGS_typeDecrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDecrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDecrementInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDecrementInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeInstructionAppelActionExterne'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelActionExterne::cPtr_typeInstructionAppelActionExterne (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_EXsignature & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomAction (argument_0),
mExpressionsList (argument_1),
aListeTypesParametresFormels (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelActionExterne::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeInstructionAppelActionExterne:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomAction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aListeTypesParametresFormels.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelActionExterne'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionAppelActionExterne::
GGS_typeInstructionAppelActionExterne (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelActionExterne GGS_typeInstructionAppelActionExterne::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpressionList & argument_1,
                 const GGS_L_EXsignature & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeInstructionAppelActionExterne * _ptr = (cPtr_typeInstructionAppelActionExterne *) NULL ;
  macroMyNew (_ptr, cPtr_typeInstructionAppelActionExterne (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeInstructionAppelActionExterne result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelActionExterne * GGS_typeInstructionAppelActionExterne::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionAppelActionExterne *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionAppelActionExterne::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionAppelActionExterne" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_matchInstructionCasesList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_matchInstructionCasesList::
elementOf_GGS_L_matchInstructionCasesList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2):
mCase1_name (argument_0),
mCase2_name (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_matchInstructionCasesList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCase1_name.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCase2_name.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@L_matchInstructionCasesList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::GGS_L_matchInstructionCasesList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::
GGS_L_matchInstructionCasesList (const GGS_L_matchInstructionCasesList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_L_matchInstructionCasesList::
operator = (const GGS_L_matchInstructionCasesList & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList GGS_L_matchInstructionCasesList::
operator + (const GGS_L_matchInstructionCasesList & inOperand) const {
  GGS_L_matchInstructionCasesList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_matchInstructionCasesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCase1_name ;
          GGS_lstring  p_1 = p->mCase2_name ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_typeInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCase1_name,
                                _p->mCase2_name,
                                _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_L_matchInstructionCasesList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_matchInstructionCasesList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_L_matchInstructionCasesList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_typeInstructionList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_matchInstructionCasesList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_matchInstructionCasesList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_matchInstructionCasesList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_typeInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCase1_name ;
    _out_1 = _p->mCase2_name ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_typeInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCase1_name ;
    _out_1 = _p->mCase2_name ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
method_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_typeInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCase1_name ;
    _out_1 = _p->mCase2_name ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
method_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_typeInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCase1_name ;
    _out_1 = _p->mCase2_name ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeMatchInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMatchInstruction::cPtr_typeMatchInstruction (const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionList & argument_9 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aIndicatif1 (argument_0),
aIndicatif2 (argument_1),
aNomCppVariable1 (argument_2),
aNomCppVariable2 (argument_3),
aNomTypeBase1 (argument_4),
aNomTypeBase2 (argument_5),
mOperand1_isEnumeration (argument_6),
mOperand2_isEnumeration (argument_7),
aListeCas (argument_8),
mElseInstructionsList (argument_9) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMatchInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeMatchInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aIndicatif1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aIndicatif2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomCppVariable1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomCppVariable2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomTypeBase1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomTypeBase2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mOperand1_isEnumeration.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mOperand2_isEnumeration.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aListeCas.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mElseInstructionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMatchInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMatchInstruction::
GGS_typeMatchInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeMatchInstruction GGS_typeMatchInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_location & argument_1,
                 const GGS_typeCplusPlusName & argument_2,
                 const GGS_typeCplusPlusName & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_lstring & argument_5,
                 const GGS_bool& argument_6,
                 const GGS_bool& argument_7,
                 const GGS_L_matchInstructionCasesList & argument_8,
                 const GGS_typeInstructionList & argument_9 COMMA_LOCATION_ARGS) {
  cPtr_typeMatchInstruction * _ptr = (cPtr_typeMatchInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeMatchInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9 COMMA_THERE)) ;
  GGS_typeMatchInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMatchInstruction * GGS_typeMatchInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMatchInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeMatchInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeMatchInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@foreachEnumerationList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachEnumerationList::
elementOf_GGS_foreachEnumerationList (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2):
mCppEnumeratedVariableName (argument_0),
mLocationOffset (argument_1),
mCppTypeName (argument_2) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachEnumerationList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppEnumeratedVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationOffset.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@foreachEnumerationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::GGS_foreachEnumerationList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::
GGS_foreachEnumerationList (const GGS_foreachEnumerationList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_foreachEnumerationList::
operator = (const GGS_foreachEnumerationList & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_internalAppendValues (const GGS_typeCplusPlusName & argument_0,
                    const GGS_location & argument_1,
                    const GGS_string& argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_internalPrependValues (const GGS_typeCplusPlusName & argument_0,
                    const GGS_location & argument_1,
                    const GGS_string& argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList GGS_foreachEnumerationList::
operator + (const GGS_foreachEnumerationList & inOperand) const {
  GGS_foreachEnumerationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_foreachEnumerationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->mCppEnumeratedVariableName ;
          GGS_location  p_1 = p->mLocationOffset ;
          GGS_string p_2 = p->mCppTypeName ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0,
                     const GGS_location & argument_1,
                     const GGS_string& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCppEnumeratedVariableName,
                                _p->mLocationOffset,
                                _p->mCppTypeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_foreachEnumerationList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_foreachEnumerationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_foreachEnumerationList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeCplusPlusName & argument_0,
                           const GGS_location & argument_1,
                           const GGS_string& argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_foreachEnumerationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachEnumerationList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@foreachEnumerationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
method_first (C_Lexique & _inLexique,
              GGS_typeCplusPlusName & _out_0,
              GGS_location & _out_1,
              GGS_string& _out_2
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppEnumeratedVariableName ;
    _out_1 = _p->mLocationOffset ;
    _out_2 = _p->mCppTypeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
method_last (C_Lexique & _inLexique,
             GGS_typeCplusPlusName & _out_0,
             GGS_location & _out_1,
             GGS_string& _out_2
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppEnumeratedVariableName ;
    _out_1 = _p->mLocationOffset ;
    _out_2 = _p->mCppTypeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
method_popFirst (C_Lexique & _inLexique,
                 GGS_typeCplusPlusName & _out_0,
                 GGS_location & _out_1,
                 GGS_string& _out_2
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppEnumeratedVariableName ;
    _out_1 = _p->mLocationOffset ;
    _out_2 = _p->mCppTypeName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
method_popLast (C_Lexique & _inLexique,
                GGS_typeCplusPlusName & _out_0,
                GGS_location & _out_1,
                GGS_string& _out_2
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppEnumeratedVariableName ;
    _out_1 = _p->mLocationOffset ;
    _out_2 = _p->mCppTypeName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeForeachInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeForeachInstruction::cPtr_typeForeachInstruction (const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mForeachEnumerationList (argument_0),
mWhileExpression (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeForeachInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeForeachInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mForeachEnumerationList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mWhileExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeForeachInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeForeachInstruction::
GGS_typeForeachInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeForeachInstruction GGS_typeForeachInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_foreachEnumerationList & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeForeachInstruction * _ptr = (cPtr_typeForeachInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeForeachInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeForeachInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeForeachInstruction * GGS_typeForeachInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeForeachInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeForeachInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeForeachInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeSimpleExtractInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSimpleExtractInstruction::cPtr_typeSimpleExtractInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariable (argument_0),
aNomClasse (argument_1),
aListeAffectationParametresEffectifs (argument_2),
mErrorLocationExpression (argument_3),
aNomMessage (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_typeSimpleExtractInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeSimpleExtractInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomClasse.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aListeAffectationParametresEffectifs.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeSimpleExtractInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSimpleExtractInstruction::
GGS_typeSimpleExtractInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeSimpleExtractInstruction GGS_typeSimpleExtractInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_L_assignedVariables & argument_2,
                 const GGS_typeExpression & argument_3,
                 const GGS_lstring & argument_4 COMMA_LOCATION_ARGS) {
  cPtr_typeSimpleExtractInstruction * _ptr = (cPtr_typeSimpleExtractInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeSimpleExtractInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  GGS_typeSimpleExtractInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSimpleExtractInstruction * GGS_typeSimpleExtractInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeSimpleExtractInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeSimpleExtractInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeSimpleExtractInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeStructuredExtractCasesList'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeStructuredExtractCasesList::
elementOf_GGS_typeStructuredExtractCasesList (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3):
mClassName (argument_0),
mResultVarID (argument_1),
mInstructionList (argument_2),
mNoUsedParameter (argument_3) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeStructuredExtractCasesList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mResultVarID.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNoUsedParameter.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeStructuredExtractCasesList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::GGS_typeStructuredExtractCasesList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::
GGS_typeStructuredExtractCasesList (const GGS_typeStructuredExtractCasesList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_typeStructuredExtractCasesList::
operator = (const GGS_typeStructuredExtractCasesList & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_location & argument_1,
                    const GGS_typeInstructionList & argument_2,
                    const GGS_bool& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_location & argument_1,
                    const GGS_typeInstructionList & argument_2,
                    const GGS_bool& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList GGS_typeStructuredExtractCasesList::
operator + (const GGS_typeStructuredExtractCasesList & inOperand) const {
  GGS_typeStructuredExtractCasesList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeStructuredExtractCasesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mClassName ;
          GGS_location  p_1 = p->mResultVarID ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          GGS_bool p_3 = p->mNoUsedParameter ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_location & argument_1,
                     const GGS_typeInstructionList & argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mClassName,
                                _p->mResultVarID,
                                _p->mInstructionList,
                                _p->mNoUsedParameter) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractCasesList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeStructuredExtractCasesList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractCasesList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_location & argument_1,
                           const GGS_typeInstructionList & argument_2,
                           const GGS_bool& argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeStructuredExtractCasesList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStructuredExtractCasesList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeStructuredExtractCasesList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0,
              GGS_location & _out_1,
              GGS_typeInstructionList & _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mClassName ;
    _out_1 = _p->mResultVarID ;
    _out_2 = _p->mInstructionList ;
    _out_3 = _p->mNoUsedParameter ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0,
             GGS_location & _out_1,
             GGS_typeInstructionList & _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mClassName ;
    _out_1 = _p->mResultVarID ;
    _out_2 = _p->mInstructionList ;
    _out_3 = _p->mNoUsedParameter ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
method_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_location & _out_1,
                 GGS_typeInstructionList & _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mClassName ;
    _out_1 = _p->mResultVarID ;
    _out_2 = _p->mInstructionList ;
    _out_3 = _p->mNoUsedParameter ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
method_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0,
                GGS_location & _out_1,
                GGS_typeInstructionList & _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mClassName ;
    _out_1 = _p->mResultVarID ;
    _out_2 = _p->mInstructionList ;
    _out_3 = _p->mNoUsedParameter ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'typeStructuredExtractInstructionWithElse'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStructuredExtractInstructionWithElse::cPtr_typeStructuredExtractInstructionWithElse (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariableName (argument_0),
mCasesList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeStructuredExtractInstructionWithElse::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeStructuredExtractInstructionWithElse:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mCasesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_typeStructuredExtractInstructionWithElse'         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse::
GGS_typeStructuredExtractInstructionWithElse (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse GGS_typeStructuredExtractInstructionWithElse::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_typeStructuredExtractCasesList & argument_1,
                 const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeStructuredExtractInstructionWithElse * _ptr = (cPtr_typeStructuredExtractInstructionWithElse *) NULL ;
  macroMyNew (_ptr, cPtr_typeStructuredExtractInstructionWithElse (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeStructuredExtractInstructionWithElse result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStructuredExtractInstructionWithElse * GGS_typeStructuredExtractInstructionWithElse::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStructuredExtractInstructionWithElse *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeStructuredExtractInstructionWithElse::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeStructuredExtractInstructionWithElse" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeRoutineCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineCallInstruction::cPtr_typeRoutineCallInstruction (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomRoutine (argument_0),
mExpressionsList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineCallInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeRoutineCallInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomRoutine.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeRoutineCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction::
GGS_typeRoutineCallInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction GGS_typeRoutineCallInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeRoutineCallInstruction * _ptr = (cPtr_typeRoutineCallInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeRoutineCallInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeRoutineCallInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineCallInstruction * GGS_typeRoutineCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRoutineCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeRoutineCallInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeRoutineCallInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeLogInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLogInstruction::cPtr_typeLogInstruction (const GGS_lstring & argument_0,
                                const GGS_typeCplusPlusName & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mGalgasVariableName (argument_0),
mLoggedVariable (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLogInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeLogInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mGalgasVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mLoggedVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeLogInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLogInstruction::
GGS_typeLogInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLogInstruction GGS_typeLogInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeCplusPlusName & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeLogInstruction * _ptr = (cPtr_typeLogInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeLogInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeLogInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLogInstruction * GGS_typeLogInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLogInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeLogInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLogInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeDropInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDropInstruction::cPtr_typeDropInstruction (const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aVariableConsommee (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDropInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeDropInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aVariableConsommee.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDropInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDropInstruction::
GGS_typeDropInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDropInstruction GGS_typeDropInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeDropInstruction * _ptr = (cPtr_typeDropInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_typeDropInstruction (argument_0 COMMA_THERE)) ;
  GGS_typeDropInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDropInstruction * GGS_typeDropInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDropInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDropInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDropInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableNomRoutinesDeclarees'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableNomRoutinesDeclarees::
elementOf_GGS_typeTableNomRoutinesDeclarees (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableNomRoutinesDeclarees & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableNomRoutinesDeclarees::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableNomRoutinesDeclarees::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableNomRoutinesDeclarees *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableNomRoutinesDeclarees * info = (e_typeTableNomRoutinesDeclarees *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableNomRoutinesDeclarees info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the routine '%K' is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableNomRoutinesDeclarees & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableNomRoutinesDeclarees result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableNomRoutinesDeclarees::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableNomRoutinesDeclarees " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeEntityToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntityToGenerate::
cPtr_typeEntityToGenerate (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeEntityToGenerate::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeEntityToGenerate:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEntityToGenerate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (const GGS_typeEntityToGenerate & inOperand) {
  mPointer = (cPtr_typeEntityToGenerate *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
~GGS_typeEntityToGenerate (void) {
  macroDetachPointer (mPointer, cPtr_typeEntityToGenerate) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate::
operator = (const GGS_typeEntityToGenerate & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntityToGenerate * GGS_typeEntityToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeEntityToGenerate) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntityToGenerate::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeEntityToGenerate" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeExternTypeToGenerate'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExternTypeToGenerate::cPtr_typeExternTypeToGenerate (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mGalgasName (argument_0),
mCppClassName (argument_1),
mIncludePath (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeExternTypeToGenerate::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeExternTypeToGenerate:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mGalgasName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mCppClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mIncludePath.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeExternTypeToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate::
GGS_typeExternTypeToGenerate (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate GGS_typeExternTypeToGenerate::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeExternTypeToGenerate * _ptr = (cPtr_typeExternTypeToGenerate *) NULL ;
  macroMyNew (_ptr, cPtr_typeExternTypeToGenerate (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeExternTypeToGenerate result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeExternTypeToGenerate * GGS_typeExternTypeToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExternTypeToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeExternTypeToGenerate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeExternTypeToGenerate::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeExternTypeToGenerate" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeRoutineAengendrer'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineAengendrer::cPtr_typeRoutineAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomRoutine (argument_0),
aListeTypeEtNomsArguments (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineAengendrer::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeRoutineAengendrer:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomRoutine.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aListeTypeEtNomsArguments.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRoutineAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer::
GGS_typeRoutineAengendrer (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer GGS_typeRoutineAengendrer::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                 const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeRoutineAengendrer * _ptr = (cPtr_typeRoutineAengendrer *) NULL ;
  macroMyNew (_ptr, cPtr_typeRoutineAengendrer (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeRoutineAengendrer result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineAengendrer * GGS_typeRoutineAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRoutineAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeRoutineAengendrer::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeRoutineAengendrer" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_listTypeToImplement'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_listTypeToImplement::cPtr_C_listTypeToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomListe (argument_0),
mNonExternAttributesList (argument_1),
mExternAttributesList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_C_listTypeToImplement::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_listTypeToImplement:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomListe.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_listTypeToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement::
GGS_C_listTypeToImplement (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement GGS_C_listTypeToImplement::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_L_nameWithType & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_C_listTypeToImplement * _ptr = (cPtr_C_listTypeToImplement *) NULL ;
  macroMyNew (_ptr, cPtr_C_listTypeToImplement (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_C_listTypeToImplement result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_listTypeToImplement * GGS_C_listTypeToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_listTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_listTypeToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_listTypeToImplement::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_listTypeToImplement" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeDefinitionTableAimplementer'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefinitionTableAimplementer::cPtr_typeDefinitionTableAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_insertOrSearchMethodList & argument_5,
                                const GGS_typeTableBlocsDeTable & argument_6 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomTable (argument_0),
mNonExternAttributesList (argument_1),
mExternAttributesList (argument_2),
aNomClasseGenerique (argument_3),
mInsertMethodList (argument_4),
mSearchMethodList (argument_5),
aTableMethodesSurcharger (argument_6) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDefinitionTableAimplementer::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeDefinitionTableAimplementer:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomTable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomClasseGenerique.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInsertMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mSearchMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aTableMethodesSurcharger.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeDefinitionTableAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer::
GGS_typeDefinitionTableAimplementer (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer GGS_typeDefinitionTableAimplementer::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_L_nameWithType & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_insertOrSearchMethodList & argument_4,
                 const GGS_insertOrSearchMethodList & argument_5,
                 const GGS_typeTableBlocsDeTable & argument_6 COMMA_LOCATION_ARGS) {
  cPtr_typeDefinitionTableAimplementer * _ptr = (cPtr_typeDefinitionTableAimplementer *) NULL ;
  macroMyNew (_ptr, cPtr_typeDefinitionTableAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  GGS_typeDefinitionTableAimplementer result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefinitionTableAimplementer * GGS_typeDefinitionTableAimplementer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDefinitionTableAimplementer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDefinitionTableAimplementer::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDefinitionTableAimplementer" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_mapToImplement'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_mapToImplement::cPtr_C_mapToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_insertOrSearchMethodList & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomTable (argument_0),
mNonExternAttributesList (argument_1),
mExternAttributesList (argument_2),
mInsertMethodList (argument_3),
mSearchMethodList (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_C_mapToImplement::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_mapToImplement:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomTable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInsertMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mSearchMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_mapToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_mapToImplement::
GGS_C_mapToImplement (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_mapToImplement GGS_C_mapToImplement::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_L_nameWithType & argument_2,
                 const GGS_insertOrSearchMethodList & argument_3,
                 const GGS_insertOrSearchMethodList & argument_4 COMMA_LOCATION_ARGS) {
  cPtr_C_mapToImplement * _ptr = (cPtr_C_mapToImplement *) NULL ;
  macroMyNew (_ptr, cPtr_C_mapToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  GGS_C_mapToImplement result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_mapToImplement * GGS_C_mapToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_mapToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_mapToImplement::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_mapToImplement" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_classToImplement'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_classToImplement::cPtr_C_classToImplement (const GGS_lstring & argument_0,
                                const GGS_typeSuperClassesMap & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mClassName (argument_0),
mAncestorClassesMap (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_classToImplement::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_classToImplement:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mAncestorClassesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_classToImplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_classToImplement::
GGS_C_classToImplement (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_classToImplement GGS_C_classToImplement::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeSuperClassesMap & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_classToImplement * _ptr = (cPtr_C_classToImplement *) NULL ;
  macroMyNew (_ptr, cPtr_C_classToImplement (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_classToImplement result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_classToImplement * GGS_C_classToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_classToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_classToImplement::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_classToImplement" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeDefClasseAbstraiteAimplementer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefClasseAbstraiteAimplementer::cPtr_typeDefClasseAbstraiteAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomClasse (argument_0),
aListeTousAttributsNonExternes (argument_1),
aTableToutesMethodes (argument_2),
mMethodsMap (argument_3),
aListeAttributsCourants (argument_4),
aListeExternesCourants (argument_5),
mAncestorClassesMap (argument_6),
mMessagesMap (argument_7) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDefClasseAbstraiteAimplementer::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeDefClasseAbstraiteAimplementer:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomClasse.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aListeTousAttributsNonExternes.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aTableToutesMethodes.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mMethodsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aListeAttributsCourants.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aListeExternesCourants.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mAncestorClassesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mMessagesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeDefClasseAbstraiteAimplementer'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDefClasseAbstraiteAimplementer::
GGS_typeDefClasseAbstraiteAimplementer (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDefClasseAbstraiteAimplementer GGS_typeDefClasseAbstraiteAimplementer::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_typeTableMethodes & argument_2,
                 const GGS_typeTableMethodesAimplementer & argument_3,
                 const GGS_typeListeAttributsSemantiques & argument_4,
                 const GGS_L_nameWithType & argument_5,
                 const GGS_typeSuperClassesMap & argument_6,
                 const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS) {
  cPtr_typeDefClasseAbstraiteAimplementer * _ptr = (cPtr_typeDefClasseAbstraiteAimplementer *) NULL ;
  macroMyNew (_ptr, cPtr_typeDefClasseAbstraiteAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  GGS_typeDefClasseAbstraiteAimplementer result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefClasseAbstraiteAimplementer * GGS_typeDefClasseAbstraiteAimplementer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefClasseAbstraiteAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDefClasseAbstraiteAimplementer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDefClasseAbstraiteAimplementer::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDefClasseAbstraiteAimplementer" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'typeDefClasseNonAbstraiteAimplementer'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefClasseNonAbstraiteAimplementer::cPtr_typeDefClasseNonAbstraiteAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomClasse (argument_0),
aListeTousAttributsNonExternes (argument_1),
aTableToutesMethodes (argument_2),
mMethodsMap (argument_3),
aListeAttributsCourants (argument_4),
aListeExternesCourants (argument_5),
mAncestorClassesMap (argument_6),
mMessagesMap (argument_7) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDefClasseNonAbstraiteAimplementer::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeDefClasseNonAbstraiteAimplementer:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomClasse.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aListeTousAttributsNonExternes.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aTableToutesMethodes.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mMethodsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aListeAttributsCourants.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aListeExternesCourants.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mAncestorClassesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mMessagesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_typeDefClasseNonAbstraiteAimplementer'          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDefClasseNonAbstraiteAimplementer::
GGS_typeDefClasseNonAbstraiteAimplementer (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDefClasseNonAbstraiteAimplementer GGS_typeDefClasseNonAbstraiteAimplementer::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_typeTableMethodes & argument_2,
                 const GGS_typeTableMethodesAimplementer & argument_3,
                 const GGS_typeListeAttributsSemantiques & argument_4,
                 const GGS_L_nameWithType & argument_5,
                 const GGS_typeSuperClassesMap & argument_6,
                 const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS) {
  cPtr_typeDefClasseNonAbstraiteAimplementer * _ptr = (cPtr_typeDefClasseNonAbstraiteAimplementer *) NULL ;
  macroMyNew (_ptr, cPtr_typeDefClasseNonAbstraiteAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  GGS_typeDefClasseNonAbstraiteAimplementer result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefClasseNonAbstraiteAimplementer * GGS_typeDefClasseNonAbstraiteAimplementer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefClasseNonAbstraiteAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDefClasseNonAbstraiteAimplementer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDefClasseNonAbstraiteAimplementer::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDefClasseNonAbstraiteAimplementer" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeEntiteActionExterne'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteActionExterne::cPtr_typeEntiteActionExterne (const GGS_L_EXsignature & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aSignature (argument_0) {
}


const char * cPtr_typeEntiteActionExterne::message_messageTypeEntite (void) const {
  return "an external action" ;
}

const char * cPtr_typeEntiteActionExterne::static_string_message_messageTypeEntite (void) {
  return "an external action" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteActionExterne::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeEntiteActionExterne:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeEntiteActionExterne'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntiteActionExterne::
GGS_typeEntiteActionExterne (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteActionExterne GGS_typeEntiteActionExterne::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_L_EXsignature & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeEntiteActionExterne * _ptr = (cPtr_typeEntiteActionExterne *) NULL ;
  macroMyNew (_ptr, cPtr_typeEntiteActionExterne (argument_0 COMMA_THERE)) ;
  GGS_typeEntiteActionExterne result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteActionExterne * GGS_typeEntiteActionExterne::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteActionExterne *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteActionExterne::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeEntiteActionExterne" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeActionExterneAengendrer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeActionExterneAengendrer::cPtr_typeActionExterneAengendrer (const GGS_lstring & argument_0,
                                const GGS_L_EXsignature & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomAction (argument_0),
aSignature (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeActionExterneAengendrer::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeActionExterneAengendrer:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomAction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeActionExterneAengendrer'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeActionExterneAengendrer::
GGS_typeActionExterneAengendrer (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeActionExterneAengendrer GGS_typeActionExterneAengendrer::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_L_EXsignature & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeActionExterneAengendrer * _ptr = (cPtr_typeActionExterneAengendrer *) NULL ;
  macroMyNew (_ptr, cPtr_typeActionExterneAengendrer (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeActionExterneAengendrer result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeActionExterneAengendrer * GGS_typeActionExterneAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeActionExterneAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeActionExterneAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeActionExterneAengendrer::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeActionExterneAengendrer" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@typeEntitiesToGenerateList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEntitiesToGenerateList::
elementOf_GGS_typeEntitiesToGenerateList (const GGS_typeEntityToGenerate & argument_0):
mEntityToGenerate (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEntitiesToGenerateList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntityToGenerate.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@typeEntitiesToGenerateList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::GGS_typeEntitiesToGenerateList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::
GGS_typeEntitiesToGenerateList (const GGS_typeEntitiesToGenerateList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

/*void GGS_typeEntitiesToGenerateList::
operator = (const GGS_typeEntitiesToGenerateList & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}*/

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_internalAppendValues (const GGS_typeEntityToGenerate & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_internalPrependValues (const GGS_typeEntityToGenerate & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_addAssign_operation (const GGS_typeEntityToGenerate & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList GGS_typeEntitiesToGenerateList::
operator + (const GGS_typeEntitiesToGenerateList & inOperand) const {
  GGS_typeEntitiesToGenerateList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeEntitiesToGenerateList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeEntityToGenerate  p_0 = p->mEntityToGenerate ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeEntityToGenerate & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEntityToGenerate) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList  GGS_typeEntitiesToGenerateList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEntitiesToGenerateList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList  GGS_typeEntitiesToGenerateList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeEntityToGenerate & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEntitiesToGenerateList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntitiesToGenerateList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeEntitiesToGenerateList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
method_first (C_Lexique & _inLexique,
              GGS_typeEntityToGenerate & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityToGenerate ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
method_last (C_Lexique & _inLexique,
             GGS_typeEntityToGenerate & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityToGenerate ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
method_popFirst (C_Lexique & _inLexique,
                 GGS_typeEntityToGenerate & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityToGenerate ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
method_popLast (C_Lexique & _inLexique,
                GGS_typeEntityToGenerate & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityToGenerate ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "enterBuiltinTypes"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterBuiltinTypes (C_Lexique & _inLexique,
                                GGS_M_semanticsEntitiesForUse  & var_cas_ioComponentSemanticsEntitiesMap COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_ioComponentSemanticsEntitiesMap = GGS_M_semanticsEntitiesForUse::constructor_emptyMap (_inLexique COMMA_HERE) ;
  GGS_AC_semanticsEntity  var_cas_e ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_lstring::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lstring"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1293)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_lbool::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lbool"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1296)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_luint::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "luint"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1299)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_lsint::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lsint"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1302)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_luint64::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "luint64"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1305)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_lsint64::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lsint64"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1308)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_ldouble::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "ldouble"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1311)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_lchar::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lchar"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1314)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_location::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "location"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1317)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_uint::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "uint"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1320)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_sint::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "sint"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1323)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_uint64::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "uint64"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1326)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_sint64::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "sint64"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1329)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_char::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "char"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1332)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_string::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "string"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1335)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_bool::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "bool"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1338)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_double::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "double"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1341)) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (_inLexique, GGS_typeGalgas_stringset::constructor_new (_inLexique COMMA_HERE) COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.method_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "stringset"), GGS_location (_inLexique) COMMA_HERE), var_cas_e SOURCE_FILE_AT_LINE (1344)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map 'typeEnumCstMessageStringMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumCstMessageStringMap::
elementOf_GGS_typeEnumCstMessageStringMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumCstMessageStringMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEnumCstMessageStringMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMessageString.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumCstMessageStringMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeEnumCstMessageStringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumCstMessageStringMap * info = (e_typeEnumCstMessageStringMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeEnumCstMessageStringMap info  ;
    info.mMessageString = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessageString ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the message for '%K' constant is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the message for '%K' constant is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeEnumCstMessageStringMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumCstMessageStringMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEnumCstMessageStringMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeEnumCstMessageStringMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'enumGalgasType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumGalgasType::cPtr_enumGalgasType (const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mEnumTypeName (argument_0),
mConstantMap (argument_1),
mEnumMessageMap (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_enumGalgasType::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@enumGalgasType:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mConstantMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mEnumMessageMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_enumGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumGalgasType::
GGS_enumGalgasType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_enumGalgasType GGS_enumGalgasType::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_enumConstantMap & argument_1,
                 const GGS_typeEnumMessageMap & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_enumGalgasType * _ptr = (cPtr_enumGalgasType *) NULL ;
  macroMyNew (_ptr, cPtr_enumGalgasType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_enumGalgasType result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumGalgasType * GGS_enumGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_enumGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_enumGalgasType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @enumGalgasType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map 'representativeEntityMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_representativeEntityMap::
elementOf_GGS_representativeEntityMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_representativeEntityMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_representativeEntityMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mRepresentativeEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSuperEntitySet.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_representativeEntityMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_representativeEntityMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_representativeEntityMap * info = (e_representativeEntityMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_representativeEntityMap GGS_representativeEntityMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_representativeEntityMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_representativeEntityMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_representativeEntityMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               const GGS_stringset &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_representativeEntityMap info  ;
    info.mRepresentativeEntityName = inParameter0 ;
    info.mSuperEntitySet = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_representativeEntityMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_stringset   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mRepresentativeEntityName ;
    outParameter1 = node->mInfo.mSuperEntitySet ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_representativeEntityMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_stringset   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "internal error: the '%K' entity is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_representativeEntityMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_stringset & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "internal error: the '%K' entity has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_representativeEntityMap GGS_representativeEntityMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_representativeEntityMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_representativeEntityMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_representativeEntityMap GGS_representativeEntityMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_representativeEntityMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_representativeEntityMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @representativeEntityMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class map 'callInstructionSharedPropertySignatureMap'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_callInstructionSharedPropertySignatureMap::
elementOf_GGS_callInstructionSharedPropertySignatureMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_callInstructionSharedPropertySignatureMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_callInstructionSharedPropertySignatureMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mEffectiveArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSignatureLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_callInstructionSharedPropertySignatureMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_callInstructionSharedPropertySignatureMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_callInstructionSharedPropertySignatureMap * info = (e_callInstructionSharedPropertySignatureMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_callInstructionSharedPropertySignatureMap GGS_callInstructionSharedPropertySignatureMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_callInstructionSharedPropertySignatureMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_L_lstringList &  inParameter0,
               const GGS_location &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_callInstructionSharedPropertySignatureMap info  ;
    info.mEffectiveArgumentList = inParameter0 ;
    info.mSignatureLocation = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_lstringList   & outParameter0,
               GGS_location   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mEffectiveArgumentList ;
    outParameter1 = node->mInfo.mSignatureLocation ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_lstringList   & outParameter0,
                                GGS_location   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "internal error: the '%K' property is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_lstringList & inParameter0,
                                const GGS_location & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "internal error: the '%K' property has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_callInstructionSharedPropertySignatureMap GGS_callInstructionSharedPropertySignatureMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_callInstructionSharedPropertySignatureMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_callInstructionSharedPropertySignatureMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_callInstructionSharedPropertySignatureMap GGS_callInstructionSharedPropertySignatureMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_callInstructionSharedPropertySignatureMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_callInstructionSharedPropertySignatureMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @callInstructionSharedPropertySignatureMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map 'constraintInstructionListMap'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_constraintInstructionListMap::
elementOf_GGS_constraintInstructionListMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_constraintInstructionListMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constraintInstructionListMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.instructionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mCallInstructionSharedPropertySignatureMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constraintInstructionListMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_constraintInstructionListMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constraintInstructionListMap * info = (e_constraintInstructionListMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_constraintInstructionListMap GGS_constraintInstructionListMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constraintInstructionListMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constraintInstructionListMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_constraintInstructionListMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeInstructionList &  inParameter0,
               const GGS_callInstructionSharedPropertySignatureMap &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_constraintInstructionListMap info  ;
    info.instructionsList = inParameter0 ;
    info.mCallInstructionSharedPropertySignatureMap = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constraintInstructionListMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeInstructionList   & outParameter0,
               GGS_callInstructionSharedPropertySignatureMap   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.instructionsList ;
    outParameter1 = node->mInfo.mCallInstructionSharedPropertySignatureMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_constraintInstructionListMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeInstructionList   & outParameter0,
                                GGS_callInstructionSharedPropertySignatureMap   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the instruction list of '%K' constraint entity is not defined",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_constraintInstructionListMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeInstructionList & inParameter0,
                                const GGS_callInstructionSharedPropertySignatureMap & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the instruction list of '%K' entity constraint  is already defined in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_constraintInstructionListMap GGS_constraintInstructionListMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_constraintInstructionListMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constraintInstructionListMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constraintInstructionListMap GGS_constraintInstructionListMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constraintInstructionListMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constraintInstructionListMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @constraintInstructionListMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'callInstruction'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_callInstruction::cPtr_callInstruction (const GGS_lstring & argument_0,
                                const GGS_metamodelProperty & argument_1,
                                const GGS_L_lstringList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mCalledPropertyName (argument_0),
mProperty (argument_1),
mParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_callInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@callInstruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mCalledPropertyName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mProperty.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_callInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_callInstruction::
GGS_callInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_callInstruction GGS_callInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_metamodelProperty & argument_1,
                 const GGS_L_lstringList & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_callInstruction * _ptr = (cPtr_callInstruction *) NULL ;
  macroMyNew (_ptr, cPtr_callInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_callInstruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_callInstruction * GGS_callInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_callInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_callInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_callInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @callInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "displayConstraintDefinitionErrors"        *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_displayConstraintDefinitionErrors (C_Lexique & _inLexique,
                                GGS_stringset   var_cas_inFirstBranchconstraintDefinitionSet,
                                GGS_stringset   var_cas_inCurrentBranchconstraintDefinitionSet COMMA_UNUSED_LOCATION_ARGS) {
  GGS_stringset  var_cas_missingDefinition ;
  var_cas_missingDefinition = var_cas_inFirstBranchconstraintDefinitionSet._substract_operation (_inLexique, var_cas_inCurrentBranchconstraintDefinitionSet SOURCE_FILE_AT_LINE (1445)) ;
  GGS_stringset::element_type * operand_60782 = var_cas_missingDefinition.firstObject () ;
  while ((operand_60782 != NULL)) {
    macroValidPointer (operand_60782) ;
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "the '")) + (operand_60782->mKey))) + (GGS_string (true, "' property is initialized by first branch, but not by this one"))) SOURCE_FILE_AT_LINE (1448)) ;
    operand_60782 = operand_60782->nextObject () ;
  }
  GGS_stringset  var_cas_unexpectedDefinition ;
  var_cas_unexpectedDefinition = var_cas_inCurrentBranchconstraintDefinitionSet._substract_operation (_inLexique, var_cas_inFirstBranchconstraintDefinitionSet SOURCE_FILE_AT_LINE (1449)) ;
  GGS_stringset::element_type * operand_61077 = var_cas_unexpectedDefinition.firstObject () ;
  while ((operand_61077 != NULL)) {
    macroValidPointer (operand_61077) ;
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "the '")) + (operand_61077->mKey))) + (GGS_string (true, "' property is not initialized by first branch, but by this one"))) SOURCE_FILE_AT_LINE (1452)) ;
    operand_61077 = operand_61077->nextObject () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Implementation of routine "displayConstraintDefinitionErrorsNoElse"     *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_displayConstraintDefinitionErrorsNoElse (C_Lexique & _inLexique,
                                GGS_stringset   var_cas_inFirstBranchConstraintDefinitionSet,
                                GGS_stringset   var_cas_inInheritedConstraintDefinitionSet COMMA_UNUSED_LOCATION_ARGS) {
  GGS_stringset  var_cas_missingDefinition ;
  var_cas_missingDefinition = var_cas_inFirstBranchConstraintDefinitionSet._substract_operation (_inLexique, var_cas_inInheritedConstraintDefinitionSet SOURCE_FILE_AT_LINE (1461)) ;
  GGS_stringset::element_type * operand_61611 = var_cas_missingDefinition.firstObject () ;
  while ((operand_61611 != NULL)) {
    macroValidPointer (operand_61611) ;
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "the '")) + (operand_61611->mKey))) + (GGS_string (true, "' property is initialized by first branch, but there is no else branch"))) SOURCE_FILE_AT_LINE (1464)) ;
    operand_61611 = operand_61611->nextObject () ;
  }
}

//---------------------------------------------------------------------------*

